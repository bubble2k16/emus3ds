
;@ Cyclone 68000 Emulator v0.099 - Assembler Output

;@ Copyright (c) 2004,2011 FinalDave (emudave (at) gmail.com)
;@ Copyright (c) 2005-2011 GraÅ¾vydas "notaz" Ignotas (notasas (at) gmail.com)

;@ This code is licensed under the GNU General Public License version 2.0 and the MAME License.
;@ You can choose the license that has the most advantages for you.

;@ SVN repository can be found at http://code.google.com/p/cyclone68000/

  .text
  .align 4

  .global CycloneInitJT
  .global CycloneResetJT
  .global CycloneRun
  .global CycloneSetSr
  .global CycloneGetSr
  .global CycloneFlushIrq
  .global CyclonePack
  .global CycloneUnpack
  .global CycloneVer
  .global CycloneSetRealTAS_JT
  .global CycloneDoInterrupt
  .global CycloneDoTrace
  .global CycloneJumpTab
  .global Op____
  .global Op6002
  .global Op6602
  .global Op6702

CycloneVer: .long 0x0099

;@ --------------------------- Framework --------------------------
CycloneRun:
  stmdb sp!,{r4-r8,r10,r11,lr}
  mov r7,r0          ;@ r7 = Pointer to Cpu Context
                     ;@ r0-3 = Temporary registers
  ldrb r10,[r7,#0x46]    ;@ r10 = Flags (NZCV)
  ldr r6,[r7,#0x54]  ;@ r6 = Opcode Jump table (from reset)
  ldr r5,[r7,#0x5c]  ;@ r5 = Cycles
  ldr r4,[r7,#0x40]  ;@ r4 = Current PC + Memory Base
                     ;@ r8 = Current Opcode
  ldr r1,[r7,#0x44]  ;@ Get SR high T_S__III and irq level
  mov r10,r10,lsl #28;@ r10 = Flags 0xf0000000, cpsr format
                     ;@ r11 = Source value / Memory Base

  mov r2,#0
  str r2,[r7,#0x98]  ;@ clear custom CycloneEnd
;@ CheckInterrupt:
  movs r0,r1,lsr #24 ;@ Get IRQ level
  beq NoInts0
  cmp r0,#6 ;@ irq>6 ?
  andle r1,r1,#7 ;@ Get interrupt mask
  cmple r0,r1 ;@ irq<=6: Is irq<=mask ?
  bgt CycloneDoInterrupt
NoInts0:

;@ Check if our processor is in special state
;@ and jump to opcode handler if not
  ldr r0,[r7,#0x58] ;@ state_flags
  ldrh r8,[r4],#2 ;@ Fetch first opcode
  tst r0,#0x03 ;@ special state?
  ldreq pc,[r6,r8,asl #2] ;@ Jump to opcode handler

CycloneSpecial:
  tst r0,#2 ;@ tracing?
  bne CycloneDoTrace
;@ stopped or halted
  mov r5,#0
  str r5,[r7,#0x5C]  ;@ eat all cycles
  ldmia sp!,{r4-r8,r10,r11,pc} ;@ we are stopped, do nothing!


;@ We come back here after execution
CycloneEnd:
  sub r4,r4,#2
CycloneEndNoBack:
  ldr r1,[r7,#0x98]
  mov r10,r10,lsr #28
  tst r1,r1
  bxne r1            ;@ jump to alternative CycloneEnd
  str r4,[r7,#0x40]  ;@ Save Current PC + Memory Base
  str r5,[r7,#0x5c]  ;@ Save Cycles
  strb r10,[r7,#0x46] ;@ Save Flags (NZCV)
  ldmia sp!,{r4-r8,r10,r11,pc}
  .ltorg


CycloneInitJT:
;@ fix final jumptable entries
  add r0,r0,#0x10000*4
  ldr r1,[r0,#-3*4]
  str r1,[r0,#-2*4]
  str r1,[r0,#-1*4]
  bx lr

CycloneResetJT:
  stmfd sp!,{r7,lr}
  mov r7,r0
  str r1,[r7,#0x54] ;@ save CycloneJumpTab avoid literal pools
  mov r0,#0
  str r0,[r7,#0x58] ;@ state_flags
  str r0,[r7,#0x48] ;@ OSP
  mov r1,#0x27 ;@ Supervisor mode
  strb r1,[r7,#0x44] ;@ set SR high
  strb r0,[r7,#0x47] ;@ IRQ
  bl cyclone_read32 ;@ Call read32(r0) handler
  str r0,[r7,#0x3c] ;@ Stack pointer
  mov r0,#0
  str r0,[r7,#0x60] ;@ Membase
  mov r0,#4
  bl cyclone_read32 ;@ Call read32(r0) handler
  bl cyclone_checkpc ;@ Call checkpc()
  str r0,[r7,#0x40] ;@ PC + base
  ldmfd sp!,{r7,pc}

CycloneSetRealTAS_JT:
  tst r0,r0
  add r12,r1,#0x4a00*4
  add r12,r12,#0x00d0*4
  adr r2,CycloneOT_TAS_
  addeq r2,r2,#9*4
  ldr r0,[r2,#0*4] ;@ Op4ad0
  add r0,r0,r2
  mov r1,#8
setrtas_loop0: ;@ 4ad0-4ad7
  subs r1,r1,#1
  str r0,[r12],#4
  bne setrtas_loop0
  ldr r0,[r2,#1*4] ;@ Op4ad8
  add r0,r0,r2
  mov r1,#7
setrtas_loop1: ;@ 4ad8-4ade
  subs r1,r1,#1
  str r0,[r12],#4
  bne setrtas_loop1
  ldr r0,[r2,#2*4] ;@ Op4adf
  add r0,r0,r2
  str r0,[r12],#4
  ldr r0,[r2,#3*4] ;@ Op4ae0
  add r0,r0,r2
  mov r1,#7
setrtas_loop2: ;@ 4ae0-4ae6
  subs r1,r1,#1
  str r0,[r12],#4
  bne setrtas_loop2
  ldr r0,[r2,#4*4] ;@ Op4ae7
  add r0,r0,r2
  str r0,[r12],#4
  ldr r0,[r2,#5*4] ;@ Op4ae8
  add r0,r0,r2
  mov r1,#8
setrtas_loop3: ;@ 4ae8-4aef
  subs r1,r1,#1
  str r0,[r12],#4
  bne setrtas_loop3
  ldr r0,[r2,#6*4] ;@ Op4af0
  add r0,r0,r2
  mov r1,#8
setrtas_loop4: ;@ 4af0-4af7
  subs r1,r1,#1
  str r0,[r12],#4
  bne setrtas_loop4
  ldr r0,[r2,#7*4] ;@ Op4af8
  add r0,r0,r2
  str r0,[r12],#4
  ldr r0,[r2,#8*4] ;@ Op4af9
  add r0,r0,r2
  str r0,[r12],#4
  bx lr

CycloneOT_TAS_:
  .long Op4ad0_-CycloneOT_TAS_
  .long Op4ad8_-CycloneOT_TAS_
  .long Op4adf_-CycloneOT_TAS_
  .long Op4ae0_-CycloneOT_TAS_
  .long Op4ae7_-CycloneOT_TAS_
  .long Op4ae8_-CycloneOT_TAS_
  .long Op4af0_-CycloneOT_TAS_
  .long Op4af8_-CycloneOT_TAS_
  .long Op4af9_-CycloneOT_TAS_
CycloneOT_TAS:
  .long Op4ad0-CycloneOT_TAS
  .long Op4ad8-CycloneOT_TAS
  .long Op4adf-CycloneOT_TAS
  .long Op4ae0-CycloneOT_TAS
  .long Op4ae7-CycloneOT_TAS
  .long Op4ae8-CycloneOT_TAS
  .long Op4af0-CycloneOT_TAS
  .long Op4af8-CycloneOT_TAS
  .long Op4af9-CycloneOT_TAS

CycloneSetSr:
  mov r2,r1,lsr #8
  and r2,r2,#0xa7 ;@ only defined bits
  strb r2,[r0,#0x44] ;@ set SR high
  mov r2,r1,lsl #25
  str r2,[r0,#0x4c] ;@ the X flag
  bic r2,r1,#0xf3
  tst r1,#1
  orrne r2,r2,#2
  tst r1,#2
  orrne r2,r2,#1
  strb r2,[r0,#0x46] ;@ flags
  bx lr

CycloneGetSr:
  ldrb r1,[r0,#0x46] ;@ flags
  bic r2,r1,#0xf3
  tst r1,#1
  orrne r2,r2,#2
  tst r1,#2
  orrne r2,r2,#1
  ldr r1,[r0,#0x4c] ;@ the X flag
  tst r1,#0x20000000
  orrne r2,r2,#0x10
  ldrb r1,[r0,#0x44] ;@ the SR high
  orr r0,r2,r1,lsl #8
  bx lr

CyclonePack:
  stmfd sp!,{r4,r5,lr}
  mov r4,r0
  mov r5,r1
  mov r3,#16
;@ 0x00-0x3f: DA registers
c_pack_loop:
  ldr r1,[r0],#4
  subs r3,r3,#1
  str r1,[r5],#4
  bne c_pack_loop
;@ 0x40: PC
  ldr r0,[r4,#0x40] ;@ PC + Memory Base
  ldr r1,[r4,#0x60] ;@ Memory base
  sub r0,r0,r1
  str r0,[r5],#4
;@ 0x44: SR
  mov r0,r4
  bl CycloneGetSr
  strh r0,[r5],#2
;@ 0x46: IRQ level
  ldrb r0,[r4,#0x47]
  strb r0,[r5],#2
;@ 0x48: other SP
  ldr r0,[r4,#0x48]
  str r0,[r5],#4
;@ 0x4c: CPU state flags
  ldr r0,[r4,#0x58]
  str r0,[r5],#4
  ldmfd sp!,{r4,r5,pc}

CycloneUnpack:
  stmfd sp!,{r5,r7,lr}
  mov r7,r0
  movs r5,r1
  beq c_unpack_do_pc
  mov r3,#16
;@ 0x00-0x3f: DA registers
c_unpack_loop:
  ldr r1,[r5],#4
  subs r3,r3,#1
  str r1,[r0],#4
  bne c_unpack_loop
;@ 0x40: PC
  ldr r0,[r5],#4 ;@ PC
  str r0,[r7,#0x40] ;@ handle later
;@ 0x44: SR
  ldrh r1,[r5],#2
  mov r0,r7
  bl CycloneSetSr
;@ 0x46: IRQ level
  ldrb r0,[r5],#2
  strb r0,[r7,#0x47]
;@ 0x48: other SP
  ldr r0,[r5],#4
  str r0,[r7,#0x48]
;@ 0x4c: CPU state flags
  ldr r0,[r5],#4
  str r0,[r7,#0x58]
c_unpack_do_pc:
  ldr r0,[r7,#0x40] ;@ unbased PC
  mov r1,#0
  str r1,[r7,#0x60] ;@ Memory base
  bl cyclone_checkpc ;@ Call checkpc()
  str r0,[r7,#0x40] ;@ PC + Memory Base
  ldmfd sp!,{r5,r7,pc}

CycloneFlushIrq:
  ldr r1,[r0,#0x44]  ;@ Get SR high T_S__III and irq level
  mov r2,r1,lsr #24 ;@ Get IRQ level
  cmp r2,#6 ;@ irq>6 ?
  andle r1,r1,#7 ;@ Get interrupt mask
  cmple r2,r1 ;@ irq<=6: Is irq<=mask ?
  movle r0,#0
  bxle lr ;@ no ints

  stmdb sp!,{r4,r5,r7,r8,r10,r11,lr}
  mov r7,r0
  mov r0,r2
  ldrb r10,[r7,#0x46]  ;@ r10 = Flags (NZCV)
  mov r5,#0
  ldr r4,[r7,#0x40]    ;@ r4 = Current PC + Memory Base
  mov r10,r10,lsl #28  ;@ r10 = Flags 0xf0000000, cpsr format
  adr r2,CycloneFlushIrqEnd
  str r2,[r7,#0x98]  ;@ set custom CycloneEnd
  b CycloneDoInterrupt

CycloneFlushIrqEnd:
  rsb r0,r5,#0
  str r4,[r7,#0x40]   ;@ Save Current PC + Memory Base
  strb r10,[r7,#0x46] ;@ Save Flags (NZCV)
  ldmia sp!,{r4,r5,r7,r8,r10,r11,lr}
  bx lr


;@ DoInterrupt - r0=IRQ level
CycloneDoInterruptGoBack:
  sub r4,r4,#2
CycloneDoInterrupt:
  bic r8,r8,#0xff000000
  orr r8,r8,r0,lsl #29 ;@ abuse r8
  ldr r2,[r7,#0x58] ;@ state flags
  and r0,r0,#7
  orr r3,r0,#0x20 ;@ Supervisor mode + IRQ level
  bic r2,r2,#3 ;@ clear stopped and trace states
  orr r2,r2,#4 ;@ set activity bit: 'not processing instruction'
  str r2,[r7,#0x58]
  ldrb r6,[r7,#0x44] ;@ Get old SR high, abuse r6
  strb r3,[r7,#0x44] ;@ Put new SR high

  ldr r1,[r7,#0x60] ;@ Get Memory base
  ldr r11,[r7,#0x3c] ;@ Get A7
  tst r6,#0x20
;@ get our SP:
  ldreq r2,[r7,#0x48] ;@ ...or OSP as our stack pointer
  streq r11,[r7,#0x48]
  moveq r11,r2
;@ Push old PC onto stack
  sub r0,r11,#4 ;@ Predecremented A7
  sub r1,r4,r1 ;@ r1 = Old PC
  bl cyclone_write32 ;@ Call write32(r0,r1) handler
;@ Push old SR:
  ldr r0,[r7,#0x4c]   ;@ X bit
  mov r1,r10,lsr #28  ;@ ____NZCV
  eor r2,r1,r1,ror #1 ;@ Bit 0=C^V
  tst r2,#1           ;@ 1 if C!=V
  eorne r1,r1,#3      ;@ ____NZVC
  and r0,r0,#0x20000000
  orr r1,r1,r0,lsr #25 ;@ ___XNZVC
  orr r1,r1,r6,lsl #8 ;@ Include old SR high
  sub r0,r11,#6 ;@ Predecrement A7
  str r0,[r7,#0x3c] ;@ Save A7
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  mov r11,r8,lsr #29
  mov r0,r11
;@ call IrqCallback if it is defined
  ldr r3,[r7,#0x8c] ;@ IrqCallback
  add lr,pc,#4*3
  tst r3,r3
  streqb r3,[r7,#0x47] ;@ just clear IRQ if there is no callback
  mvneq r0,#0 ;@ and simulate -1 return
  bxne r3
;@ get IRQ vector address:
  cmn r0,#1 ;@ returned -1?
  addeq r0,r11,#0x18 ;@ use autovector then
  cmn r0,#2 ;@ returned -2?
  moveq r0,#0x18 ;@ use spurious interrupt then
  mov r0,r0,lsl #2 ;@ get vector address

  ldr r11,[r7,#0x60] ;@ Get Memory base
;@ Read IRQ Vector:
  bl cyclone_read32 ;@ Call read32(r0) handler
  tst r0,r0 ;@ uninitialized int vector?
  moveq r0,#0x3c
  bleq cyclone_read32 ;@ Call read32(r0) handler
  add lr,pc,#4
  add r0,r0,r11 ;@ r0 = Memory Base + New PC
  bl cyclone_checkpc ;@ Call checkpc()
  mov r4,r0

  tst r4,#1
  bne ExceptionAddressError_r_prg_r4
  ldr r6,[r7,#0x54]
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#44 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

Exception:
  ;@ Cause an Exception - Vector number in r0
  mov r11,lr ;@ Preserve ARM return address
  bic r8,r8,#0xff000000
  orr r8,r8,r0,lsl #24 ;@ abuse r8
  ldr r6,[r7,#0x44] ;@ Get old SR high, abuse r6
  ldr r2,[r7,#0x58] ;@ state flags
  and r3,r6,#0x27 ;@ clear trace and unused flags
  orr r3,r3,#0x20 ;@ set supervisor mode
  bic r2,r2,#3 ;@ clear stopped and trace states
  str r2,[r7,#0x58]
  strb r3,[r7,#0x44] ;@ Put new SR high

  ldr r0,[r7,#0x3c] ;@ Get A7
  tst r6,#0x20
;@ get our SP:
  ldreq r2,[r7,#0x48] ;@ ...or OSP as our stack pointer
  streq r0,[r7,#0x48]
  moveq r0,r2
;@ Push old PC onto stack
  ldr r1,[r7,#0x60] ;@ Get Memory base
  sub r0,r0,#4 ;@ Predecremented A7
  str r0,[r7,#0x3c] ;@ Save A7
  sub r1,r4,r1 ;@ r1 = Old PC
  bl cyclone_write32 ;@ Call write32(r0,r1) handler
;@ Push old SR:
  ldr r0,[r7,#0x4c]   ;@ X bit
  mov r1,r10,lsr #28  ;@ ____NZCV
  eor r2,r1,r1,ror #1 ;@ Bit 0=C^V
  tst r2,#1           ;@ 1 if C!=V
  eorne r1,r1,#3      ;@ ____NZVC
  and r0,r0,#0x20000000
  orr r1,r1,r0,lsr #25 ;@ ___XNZVC
  ldr r0,[r7,#0x3c] ;@ A7
  orr r1,r1,r6,lsl #8 ;@ Include SR high
  sub r0,r0,#2 ;@ Predecrement A7
  str r0,[r7,#0x3c] ;@ Save A7
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

;@ Read Exception Vector:
  mov r0,r8,lsr #24
  mov r0,r0,lsl #2
  bl cyclone_read32 ;@ Call read32(r0) handler
  ldr r3,[r7,#0x60] ;@ Get Memory base
  add lr,pc,#4
  add r0,r0,r3 ;@ r0 = Memory Base + New PC
  bl cyclone_checkpc ;@ Call checkpc()
  mov r4,r0

  tst r4,#1
  bne ExceptionAddressError_r_prg_r4
  ldr r6,[r7,#0x54]
  bx r11 ;@ Return

ExceptionAddressError_r_data:
  ldr r1,[r7,#0x44]
  mov r6,#0x11
  mov r11,r0
  tst r1,#0x20
  orrne r6,r6,#4
  b ExceptionAddressError

ExceptionAddressError_r_prg:
  ldr r1,[r7,#0x44]
  mov r6,#0x12
  mov r11,r0
  tst r1,#0x20
  orrne r6,r6,#4
  b ExceptionAddressError

ExceptionAddressError_w_data:
  ldr r1,[r7,#0x44]
  mov r6,#0x01
  mov r11,r0
  tst r1,#0x20
  orrne r6,r6,#4
  b ExceptionAddressError

ExceptionAddressError_r_prg_r4:
  ldr r1,[r7,#0x44]
  ldr r3,[r7,#0x60] ;@ Get Memory base
  mov r6,#0x12
  sub r11,r4,r3
  tst r1,#0x20
  orrne r6,r6,#4

ExceptionAddressError:
;@ r6 - info word (without instruction/not bit), r11 - faulting address
  ldrb r0,[r7,#0x44] ;@ Get old SR high
  ldr r2,[r7,#0x58] ;@ state flags
  and r3,r0,#0x27 ;@ clear trace and unused flags
  orr r3,r3,#0x20 ;@ set supervisor mode
  strb r3,[r7,#0x44] ;@ Put new SR high
  bic r2,r2,#3 ;@ clear stopped and trace states
  tst r2,#4
  orrne r6,r6,#8 ;@ complete info word
  orr r2,r2,#4 ;@ set activity bit: 'not processing instruction'
  str r2,[r7,#0x58]
  and r10,r10,#0xf0000000
  orr r10,r10,r0,lsl #4 ;@ some preparations for SR push

  ldr r0,[r7,#0x3c] ;@ Get A7
  tst r10,#0x200
;@ get our SP:
  ldreq r2,[r7,#0x48] ;@ ...or OSP as our stack pointer
  streq r0,[r7,#0x48]
  moveq r0,r2
;@ Push old PC onto stack
  ldr r1,[r7,#0x60] ;@ Get Memory base
  sub r0,r0,#4 ;@ Predecremented A7
  sub r1,r4,r1 ;@ r1 = Old PC
  str r0,[r7,#0x3c] ;@ Save A7
  bl cyclone_write32 ;@ Call write32(r0,r1) handler
;@ Push old SR:
  ldr r0,[r7,#0x4c]   ;@ X bit
  mov r1,r10,ror #28  ;@ ____NZCV
  eor r2,r1,r1,ror #1 ;@ Bit 0=C^V
  tst r2,#1           ;@ 1 if C!=V
  eorne r1,r1,#3      ;@ ____NZVC
  and r0,r0,#0x20000000
  orr r1,r1,r0,lsr #25 ;@ ___XNZVC
  ldr r0,[r7,#0x3c] ;@ A7
  and r10,r10,#0xf0000000
  sub r0,r0,#2 ;@ Predecrement A7
  str r0,[r7,#0x3c] ;@ Save A7
  bl cyclone_write16 ;@ Call write16(r0,r1) handler
;@ Push IR:
  ldr r0,[r7,#0x3c] ;@ A7
  mov r1,r8
  sub r0,r0,#2 ;@ Predecrement A7
  str r0,[r7,#0x3c] ;@ Save A7
  bl cyclone_write16 ;@ Call write16(r0,r1) handler
;@ Push address:
  ldr r0,[r7,#0x3c] ;@ A7
  mov r1,r11
  sub r0,r0,#4 ;@ Predecrement A7
  str r0,[r7,#0x3c] ;@ Save A7
  bl cyclone_write32 ;@ Call write32(r0,r1) handler
;@ Push info word:
  ldr r0,[r7,#0x3c] ;@ A7
  mov r1,r6
  sub r0,r0,#2 ;@ Predecrement A7
  str r0,[r7,#0x3c] ;@ Save A7
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

;@ Read Exception Vector:
  mov r0,#0x0c
  bl cyclone_read32 ;@ Call read32(r0) handler
  ldr r3,[r7,#0x60] ;@ Get Memory base
  add lr,pc,#4
  add r0,r0,r3 ;@ r0 = Memory Base + New PC
  bl cyclone_checkpc ;@ Call checkpc()
  mov r4,r0

  bic r4,r4,#1
  ldr r6,[r7,#0x54]
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#50 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

CycloneDoTraceWithChecks:
  ldr r0,[r7,#0x58]
  cmp r5,#0
  orr r0,r0,#2 ;@ go to trace mode
  str r0,[r7,#0x58]
  ble CycloneEnd
;@ CheckInterrupt:
  movs r0,r1,lsr #24 ;@ Get IRQ level
  beq CycloneDoTrace
  cmp r0,#6 ;@ irq>6 ?
  andle r1,r1,#7 ;@ Get interrupt mask
  cmple r0,r1 ;@ irq<=6: Is irq<=mask ?
  bgt CycloneDoInterruptGoBack

CycloneDoTrace:
  str r5,[r7,#0x9c] ;@ save cycles
  ldr r1,[r7,#0x98]
  mov r5,#0
  str r1,[r7,#0xa0]
  adr r0,TraceEnd
  str r0,[r7,#0x98] ;@ store TraceEnd as CycloneEnd hadler
  ldr pc,[r6,r8,asl #2] ;@ Jump to opcode handler

TraceEnd:
  ldr r2,[r7,#0x58]
  ldr r0,[r7,#0x9c] ;@ restore cycles
  ldr r1,[r7,#0xa0] ;@ old CycloneEnd handler
  mov r10,r10,lsl #28
  add r5,r0,r5
  str r1,[r7,#0x98]
;@ still tracing?
  tst r2,#2
  beq TraceDisabled
;@ trace exception
  ldr r1,[r7,#0x58]
  mov r0,#9
  orr r1,r1,#4 ;@ set activity bit: 'not processing instruction'
  str r1,[r7,#0x58]
  bl Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#34 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

TraceDisabled:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  cmp r5,#0
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------------------------- Opcodes ---------------------------
Op____: ;@ Called if an opcode is not recognised
  ldr r1,[r7,#0x58]
  sub r4,r4,#2
  orr r1,r1,#4 ;@ set activity bit: 'not processing instruction'
  str r1,[r7,#0x58]
  str r4,[r7,#0x40] ;@ Save PC
  mov r1,r10,lsr #28
  strb r1,[r7,#0x46] ;@ Save Flags (NZCV)
  str r5,[r7,#0x5c] ;@ Save Cycles
  ldr r11,[r7,#0x94] ;@ UnrecognizedCallback
  tst r11,r11
  movne lr,pc
  movne pc,r11 ;@ call UnrecognizedCallback if it is defined
  ldrb r10,[r7,#0x46] ;@ r10 = Load Flags (NZCV)
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldr r4,[r7,#0x40] ;@ Load PC
  mov r10,r10,lsl #28
  tst r0,r0
  moveq r0,#4
  bleq Exception

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#34 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

Op__al: ;@ Unrecognised a-line opcode
  sub r4,r4,#2
  str r4,[r7,#0x40] ;@ Save PC
  mov r1,r10,lsr #28
  strb r1,[r7,#0x46] ;@ Save Flags (NZCV)
  str r5,[r7,#0x5c] ;@ Save Cycles
  ldr r11,[r7,#0x94] ;@ UnrecognizedCallback
  tst r11,r11
  movne lr,pc
  movne pc,r11 ;@ call UnrecognizedCallback if it is defined
  ldrb r10,[r7,#0x46] ;@ r10 = Load Flags (NZCV)
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldr r4,[r7,#0x40] ;@ Load PC
  mov r10,r10,lsl #28
  tst r0,r0
  moveq r0,#0x0a
  bleq Exception

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

Op__fl: ;@ Unrecognised f-line opcode
  sub r4,r4,#2
  str r4,[r7,#0x40] ;@ Save PC
  mov r1,r10,lsr #28
  strb r1,[r7,#0x46] ;@ Save Flags (NZCV)
  str r5,[r7,#0x5c] ;@ Save Cycles
  ldr r11,[r7,#0x94] ;@ UnrecognizedCallback
  tst r11,r11
  movne lr,pc
  movne pc,r11 ;@ call UnrecognizedCallback if it is defined
  ldrb r10,[r7,#0x46] ;@ r10 = Load Flags (NZCV)
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldr r4,[r7,#0x40] ;@ Load PC
  mov r10,r10,lsl #28
  tst r0,r0
  moveq r0,#0x0b
  bleq Exception

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6702] beq 4 uses Op6702 ----------
Op6702:
  tst r10,#0x40000000 ;@ eq: Z
  beq BccDontBranch8

  mov r11,r8,asl #24 ;@ Shift 8-bit signed offset up...

;@ Branch taken - Add on r0 to PC
  add r4,r4,r11,asr #24 ;@ r4 = New PC

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

BccDontBranch8:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6602] bne 4 uses Op6602 ----------
Op6602:
  tst r10,#0x40000000 ;@ ne: !Z
  bne BccDontBranch8

  mov r11,r8,asl #24 ;@ Shift 8-bit signed offset up...

;@ Branch taken - Add on r0 to PC
  add r4,r4,r11,asr #24 ;@ r4 = New PC

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [51c8] dbra d0, 3335 uses Op51c8 ----------
Op51c8:
;@ Decrement Dn.w
  and r1,r8,#0x0007
  mov r1,r1,lsl #2
  ldrsh r0,[r7,r1]
  strb r8,[r7,#0x45] ;@ not polling
  sub r0,r0,#1
  strh r0,[r7,r1]

;@ Check if Dn.w is -1
  cmn r0,#1
  beq DbraMin1

;@ Get Branch offset:
  ldrsh r0,[r4]
  add r0,r4,r0 ;@ r0 = New PC
  bl cyclone_checkpc ;@ Call checkpc()
  mov r4,r0
  tst r4,#1 ;@ address error?
  bne ExceptionAddressError_r_prg_r4
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ Dn.w is -1:
DbraMin1:
  add r4,r4,#2 ;@ Skip branch offset

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4a38] tst.b $3333.w uses Op4a38 ----------
Op4a38:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  bl cyclone_read8 ;@ Call read8(r0) handler
  movs r0,r0,asl #24

  and r10,r0,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d040] add.w d0, d0 uses Opd040 ----------
Opd040:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r0:
  ldr r0,[r7,r0,lsl #2]

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
  mov r11,r11,lsr #7
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11]

;@ Do arithmetic:
  mov r0,r0,asl #16
  adds r1,r0,r1,asl #16
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: r1 into register[r11]:
  strh r1,[r7,r11]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4a79] tst.w $33333333.l uses Op4a79 ----------
Op4a79:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  bl cyclone_read16 ;@ Call read16(r0) handler
  movs r0,r0,asl #16

  and r10,r0,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0240] andi.w #$3333, d0 uses Op0240 ----------
Op0240:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
  mov r11,r11,lsl #2
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11]

  mov r10,r10,asl #16
;@ Do arithmetic:
  ands r1,r10,r0,asl #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: r1 into register[r11]:
  mov r1,r1,lsr #16
  strh r1,[r7,r11]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2038] move.l $3333.w, d0 uses Op2038 ----------
Op2038:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r1:
  bl cyclone_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b0b8] cmp.l $3333.w, d0 uses Opb0b8 ----------
Opb0b8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get EA into r11 and value into r0:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  rsbs r1,r0,r1
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6002] bra 4 uses Op6002 ----------
Op6002:
  mov r11,r8,asl #24 ;@ Shift 8-bit signed offset up...

;@ Branch taken - Add on r0 to PC
  add r4,r4,r11,asr #24 ;@ r4 = New PC

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [30c0] move.w d0, (a0)+ uses Op30c0 ----------
Op30c0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x000f
  mov r1,r1,lsl #2
;@ EaRead : Read register[r1] into r1:
  ldrh r1,[r7,r1]

  movs r2,r1,lsl #16
  and r10,r2,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3028] move.w ($3333,a0), d0 uses Op3028 ----------
Op3028:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  bl cyclone_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,lsr #16
  strh r1,[r7,r0]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0c40] cmpi.w #$3333, d0 uses Op0c40 ----------
Op0c40:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r0:
  ldr r0,[r7,r0,lsl #2]

  mov r10,r10,asl #16
;@ Do arithmetic:
  rsbs r1,r10,r0,asl #16 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0c79] cmpi.w #$3333, $33333333.l uses Op0c79 ----------
Op0c79:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  bl cyclone_read16 ;@ Call read16(r0) handler

  mov r10,r10,asl #16
;@ Do arithmetic:
  rsbs r1,r10,r0,asl #16 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4e75] rts uses Op4e75 ----------
Op4e75:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Pop PC:
  ldr r0,[r7,#0x3c]
  add r1,r0,#4 ;@ Postincrement A7
  str r1,[r7,#0x3c] ;@ Save A7
  bl cyclone_read32 ;@ Call read32(r0) handler
  ldr r1,[r7,#0x60] ;@ Get Memory base
  add r0,r0,r1 ;@ Memory Base+PC

  bl cyclone_checkpc ;@ Call checkpc()
  mov r4,r0
  tst r4,#1 ;@ address error?
  bne ExceptionAddressError_r_prg_r4
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4e71] nop uses Op4e71 ----------
Op4e71:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3000] move.w d0, d0 uses Op3000 ----------
Op3000:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x000f
  mov r1,r1,lsl #2
;@ EaRead : Read register[r1] into r1:
  ldrh r1,[r7,r1]

  movs r2,r1,lsl #16
  and r10,r2,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaWrite: r1 into register[r0]:
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0839] btst #$33, $33333333.l uses Op0839 ----------
Op0839:
  str r5,[r7,#0x5c] ;@ Save Cycles


;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  mov r11,#1
  bic r10,r10,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7    ;@ mem - do mod 8
  mov r11,r11,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  bl cyclone_read8 ;@ Call read8(r0) handler

  tst r0,r11 ;@ Do arithmetic
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [7000] moveq #$0, d0 uses Op7000 ----------
Op7000:
  movs r0,r8,asl #24
  and r1,r8,#0x0e00
  mov r0,r0,asr #24 ;@ Sign extended Quick value
  and r10,r0,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV
  str r0,[r7,r1,lsr #7] ;@ Store into Dn

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3040] movea.w d0, a0 uses Op3040 ----------
Op3040:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x000f
  mov r1,r1,lsl #2
;@ EaRead : Read register[r1] into r1:
  ldrsh r1,[r7,r1]

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x1e00
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0838] btst #$33, $3333.w uses Op0838 ----------
Op0838:
  str r5,[r7,#0x5c] ;@ Save Cycles


;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  mov r11,#1
  bic r10,r10,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7    ;@ mem - do mod 8
  mov r11,r11,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  bl cyclone_read8 ;@ Call read8(r0) handler

  tst r0,r11 ;@ Do arithmetic
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4a39] tst.b $33333333.l uses Op4a39 ----------
Op4a39:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  bl cyclone_read8 ;@ Call read8(r0) handler
  movs r0,r0,asl #24

  and r10,r0,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [33d8] move.w (a0)+, $33333333.l uses Op33d8 ----------
Op33d8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r1:
  bl cyclone_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov r1,r1,lsr #16
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6700] beq 3335 uses Op6700 ----------
Op6700:
  str r5,[r7,#0x5c] ;@ Save Cycles

  tst r10,#0x40000000 ;@ eq: Z
  beq BccDontBranch16

  ldrsh r11,[r4] ;@ Fetch Branch offset
;@ Branch taken - Add on r0 to PC
  add r0,r4,r11 ;@ New PC
  bl cyclone_checkpc ;@ Call checkpc()
  mov r4,r0
  tst r4,#1 ;@ address error?
  bne ExceptionAddressError_r_prg_r4

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

BccDontBranch16:
  add r4,r4,#2
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b038] cmp.b $3333.w, d0 uses Opb038 ----------
Opb038:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get EA into r11 and value into r0:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  bl cyclone_read8 ;@ Call read8(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #24

;@ Do arithmetic:
  rsbs r1,r0,r1,asl #24
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3039] move.w $33333333.l, d0 uses Op3039 ----------
Op3039:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r1:
  bl cyclone_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,lsr #16
  strh r1,[r7,r0]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4840] swap d0 uses Op4840 ----------
Op4840:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

  movs r1,r0,ror #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV
;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6102] bsr 4 uses Op6102 ----------
Op6102:
  mov r11,r8,asl #24 ;@ Shift 8-bit signed offset up...

;@ Branch taken - Add on r0 to PC
;@ Bsr - remember old PC
  ldr r12,[r7,#0x60] ;@ Get Memory base
  ldr r2,[r7,#0x3c]
  sub r1,r4,r12 ;@ r1 = Old PC

;@ Push r1 onto stack
  sub r0,r2,#4 ;@ Predecrement A7
  str r0,[r7,#0x3c] ;@ Save A7
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  add r4,r4,r11,asr #24 ;@ r4 = New PC

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6100] bsr 3335 uses Op6100 ----------
Op6100:
  str r5,[r7,#0x5c] ;@ Save Cycles

  ldrsh r11,[r4] ;@ Fetch Branch offset
;@ Branch taken - Add on r0 to PC
;@ Bsr - remember old PC
  ldr r12,[r7,#0x60] ;@ Get Memory base
  ldr r2,[r7,#0x3c]
  sub r1,r4,r12 ;@ r1 = Old PC
  add r1,r1,#2

;@ Push r1 onto stack
  sub r0,r2,#4 ;@ Predecrement A7
  str r0,[r7,#0x3c] ;@ Save A7
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  add r0,r4,r11 ;@ New PC
  bl cyclone_checkpc ;@ Call checkpc()
  mov r4,r0
  tst r4,#1 ;@ address error?
  bne ExceptionAddressError_r_prg_r4

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5e40] addq.w #7, d0 uses Op5e40 ----------
Op5e40:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
  mov r11,r11,lsl #2
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11]

  and r2,r8,#0x0e00 ;@ Get quick value

  mov r0,r0,asl #16

  adds r1,r0,r2,lsl #7
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: r1 into register[r11]:
  mov r1,r1,lsr #16
  strh r1,[r7,r11]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1039] move.b $33333333.l, d0 uses Op1039 ----------
Op1039:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r1:
  bl cyclone_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,lsr #24
  strb r1,[r7,r0,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [20c0] move.l d0, (a0)+ uses Op20c0 ----------
Op20c0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x000f
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsl #2]
  tst r1,r1

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1018] move.b (a0)+, d0 uses Op1018 ----------
Op1018:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r1:
  bl cyclone_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,lsr #24
  strb r1,[r7,r0,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [30d0] move.w (a0), (a0)+ uses Op30d0 ----------
Op30d0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r1:
  bl cyclone_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov r1,r1,lsr #16
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3080] move.w d0, (a0) uses Op3080 ----------
Op3080:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x000f
  mov r1,r1,lsl #2
;@ EaRead : Read register[r1] into r1:
  ldrh r1,[r7,r1]

  movs r2,r1,lsl #16
  and r10,r2,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3018] move.w (a0)+, d0 uses Op3018 ----------
Op3018:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r1:
  bl cyclone_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,lsr #16
  strh r1,[r7,r0]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c040] and.w d0, d0 uses Opc040 ----------
Opc040:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r0:
  ldr r0,[r7,r0,lsl #2]

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
  mov r11,r11,lsr #7
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11]

;@ Do arithmetic:
  mov r0,r0,asl #16
  ands r1,r0,r1,asl #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: r1 into register[r11]:
  strh r1,[r7,r11]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3180] move.w d0, ($33,a0,d3.w*2) uses Op3180 ----------
Op3180:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x000f
  mov r1,r1,lsl #2
;@ EaRead : Read register[r1] into r1:
  ldrh r1,[r7,r1]

  movs r2,r1,lsl #16
  and r10,r2,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x1e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1198] move.b (a0)+, ($33,a0,d3.w*2) uses Op1198 ----------
Op1198:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r1:
  bl cyclone_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x1e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov r1,r1,lsr #24
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6502] bcs 4 uses Op6502 ----------
Op6502:
  tst r10,#0x20000000 ;@ cs: C
  beq BccDontBranch8

  mov r11,r8,asl #24 ;@ Shift 8-bit signed offset up...

;@ Branch taken - Add on r0 to PC
  add r4,r4,r11,asr #24 ;@ r4 = New PC

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6500] bcs 3335 uses Op6500 ----------
Op6500:
  str r5,[r7,#0x5c] ;@ Save Cycles

  tst r10,#0x20000000 ;@ cs: C
  beq BccDontBranch16

  ldrsh r11,[r4] ;@ Fetch Branch offset
;@ Branch taken - Add on r0 to PC
  add r0,r4,r11 ;@ New PC
  bl cyclone_checkpc ;@ Call checkpc()
  mov r4,r0
  tst r4,#1 ;@ address error?
  bne ExceptionAddressError_r_prg_r4

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6402] bcc 4 uses Op6402 ----------
Op6402:
  tst r10,#0x20000000 ;@ cc: !C
  bne BccDontBranch8

  mov r11,r8,asl #24 ;@ Shift 8-bit signed offset up...

;@ Branch taken - Add on r0 to PC
  add r4,r4,r11,asr #24 ;@ r4 = New PC

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6a02] bpl 4 uses Op6a02 ----------
Op6a02:
  tst r10,r10 ;@ pl: !N
  bmi BccDontBranch8

  mov r11,r8,asl #24 ;@ Shift 8-bit signed offset up...

;@ Branch taken - Add on r0 to PC
  add r4,r4,r11,asr #24 ;@ r4 = New PC

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [41f0] lea ($33,a0,d3.w*2), a0 uses Op41f0 ----------
Op41f0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r1:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r1,r2,r3 ;@ r1=Disp+An+Rn
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4a28] tst.b ($3333,a0) uses Op4a28 ----------
Op4a28:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  bl cyclone_read8 ;@ Call read8(r0) handler
  movs r0,r0,asl #24

  and r10,r0,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0828] btst #$33, ($3333,a0) uses Op0828 ----------
Op0828:
  str r5,[r7,#0x5c] ;@ Save Cycles


;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  mov r11,#1
  bic r10,r10,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7    ;@ mem - do mod 8
  mov r11,r11,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  bl cyclone_read8 ;@ Call read8(r0) handler

  tst r0,r11 ;@ Do arithmetic
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0640] addi.w #$3333, d0 uses Op0640 ----------
Op0640:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
  mov r11,r11,lsl #2
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11]

  mov r10,r10,asl #16
;@ Do arithmetic:
  adds r1,r10,r0,asl #16 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: r1 into register[r11]:
  mov r1,r1,lsr #16
  strh r1,[r7,r11]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [10c0] move.b d0, (a0)+ uses Op10c0 ----------
Op10c0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x000f
;@ EaRead : Read register[r1] into r1:
  ldrb r1,[r7,r1,lsl #2]

  movs r2,r1,lsl #24
  and r10,r2,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [10d8] move.b (a0)+, (a0)+ uses Op10d8 ----------
Op10d8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r1:
  bl cyclone_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov r1,r1,lsr #24
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0000] ori.b #$33, d0 uses Op0000 ----------
Op0000:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

  mov r10,r10,asl #24
;@ Do arithmetic:
  orrs r1,r10,r0,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: r1 into register[r11]:
  mov r1,r1,lsr #24
  strb r1,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0010] ori.b #$33, (a0) uses Op0010 ----------
Op0010:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  orrs r1,r10,r0,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  mov r1,r1,lsr #24
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0018] ori.b #$33, (a0)+ uses Op0018 ----------
Op0018:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  orrs r1,r10,r0,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  mov r1,r1,lsr #24
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [001f] ori.b #$33, (a7)+ uses Op001f ----------
Op001f:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '(a7)+' into r11:
  ldr r11,[r7,#0x3c] ;@ A7
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  orrs r1,r10,r0,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '(a7)+' (address in r11):
  mov r1,r1,lsr #24
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0020] ori.b #$33, -(a0) uses Op0020 ----------
Op0020:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#1 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  orrs r1,r10,r0,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r1,r1,lsr #24
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0027] ori.b #$33, -(a7) uses Op0027 ----------
Op0027:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '-(a7)' into r11:
  ldr r11,[r7,#0x3c] ;@ A7
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  orrs r1,r10,r0,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '-(a7)' (address in r11):
  mov r1,r1,lsr #24
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0028] ori.b #$33, ($3333,a0) uses Op0028 ----------
Op0028:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  orrs r1,r10,r0,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  mov r1,r1,lsr #24
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0030] ori.b #$33, ($33,a0,d3.w*2) uses Op0030 ----------
Op0030:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  orrs r1,r10,r0,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  mov r1,r1,lsr #24
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0038] ori.b #$33, $3333.w uses Op0038 ----------
Op0038:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  orrs r1,r10,r0,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  mov r1,r1,lsr #24
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0039] ori.b #$33, $33333333.l uses Op0039 ----------
Op0039:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  orrs r1,r10,r0,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  mov r1,r1,lsr #24
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [003c] ori.b #$33, ccr uses Op003c ----------
Op003c:
;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  ldr r2,[r7,#0x4c]   ;@ Load old X bit
  orr r10,r10,r0,lsl #28
  orr r2,r2,r0,lsl #25 ;@ X bit
  str r2,[r7,#0x4c]   ;@ Save X bit

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0040] ori.w #$3333, d0 uses Op0040 ----------
Op0040:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
  mov r11,r11,lsl #2
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11]

  mov r10,r10,asl #16
;@ Do arithmetic:
  orrs r1,r10,r0,asl #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: r1 into register[r11]:
  mov r1,r1,lsr #16
  strh r1,[r7,r11]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0050] ori.w #$3333, (a0) uses Op0050 ----------
Op0050:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler

  mov r10,r10,asl #16
;@ Do arithmetic:
  orrs r1,r10,r0,asl #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  mov r1,r1,lsr #16
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0058] ori.w #$3333, (a0)+ uses Op0058 ----------
Op0058:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler

  mov r10,r10,asl #16
;@ Do arithmetic:
  orrs r1,r10,r0,asl #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  mov r1,r1,lsr #16
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0060] ori.w #$3333, -(a0) uses Op0060 ----------
Op0060:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler

  mov r10,r10,asl #16
;@ Do arithmetic:
  orrs r1,r10,r0,asl #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r1,r1,lsr #16
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0068] ori.w #$3333, ($3333,a0) uses Op0068 ----------
Op0068:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler

  mov r10,r10,asl #16
;@ Do arithmetic:
  orrs r1,r10,r0,asl #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  mov r1,r1,lsr #16
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0070] ori.w #$3333, ($33,a0,d3.w*2) uses Op0070 ----------
Op0070:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler

  mov r10,r10,asl #16
;@ Do arithmetic:
  orrs r1,r10,r0,asl #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  mov r1,r1,lsr #16
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0078] ori.w #$3333, $3333.w uses Op0078 ----------
Op0078:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler

  mov r10,r10,asl #16
;@ Do arithmetic:
  orrs r1,r10,r0,asl #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  mov r1,r1,lsr #16
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0079] ori.w #$3333, $33333333.l uses Op0079 ----------
Op0079:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler

  mov r10,r10,asl #16
;@ Do arithmetic:
  orrs r1,r10,r0,asl #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  mov r1,r1,lsr #16
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [007c] ori.w #$3333, sr uses Op007c ----------
Op007c:
  ldr r11,[r7,#0x44] ;@ Get SR high
  tst r11,#0x20 ;@ Check we are in supervisor mode
  beq WrongPrivilegeMode ;@ No

;@ EaCalc : Get '#$3333' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r0) into r0:

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  ldr r2,[r7,#0x4c]   ;@ Load old X bit
  orr r10,r10,r0,lsl #28
  orr r2,r2,r0,lsl #25 ;@ X bit
  orr r1,r11,r0,lsr #8
  and r1,r1,#0xa7 ;@ mask-out unused bits
  str r2,[r7,#0x4c]   ;@ Save X bit
  strb r1,[r7,#0x44]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  ldr r1,[r7,#0x44]
  subs r5,r5,#20 ;@ Subtract cycles
;@ CheckTrace:
  tst r1,#0x80
  bne CycloneDoTraceWithChecks
  cmp r5,#0
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0080] ori.l #$33333333, d0 uses Op0080 ----------
Op0080:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

;@ Do arithmetic:
  orrs r1,r10,r0
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0090] ori.l #$33333333, (a0) uses Op0090 ----------
Op0090:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ Do arithmetic:
  orrs r1,r10,r0
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  mov r0,r11
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0098] ori.l #$33333333, (a0)+ uses Op0098 ----------
Op0098:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ Do arithmetic:
  orrs r1,r10,r0
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  mov r0,r11
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [00a0] ori.l #$33333333, -(a0) uses Op00a0 ----------
Op00a0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#4 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ Do arithmetic:
  orrs r1,r10,r0
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r0,r11
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#30 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [00a8] ori.l #$33333333, ($3333,a0) uses Op00a8 ----------
Op00a8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ Do arithmetic:
  orrs r1,r10,r0
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  mov r0,r11
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#32 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [00b0] ori.l #$33333333, ($33,a0,d3.w*2) uses Op00b0 ----------
Op00b0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ Do arithmetic:
  orrs r1,r10,r0
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  mov r0,r11
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#34 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [00b8] ori.l #$33333333, $3333.w uses Op00b8 ----------
Op00b8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ Do arithmetic:
  orrs r1,r10,r0
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  mov r0,r11
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#32 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [00b9] ori.l #$33333333, $33333333.l uses Op00b9 ----------
Op00b9:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ Do arithmetic:
  orrs r1,r10,r0
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  mov r0,r11
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#36 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0100] btst d0, d0 uses Op0100 ----------
Op0100:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r11:
  ldr r11,[r7,r11,lsr #7]

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r0:
  ldr r0,[r7,r0,lsl #2]

  and r11,r11,#31 ;@ reg - do mod 32

  mov r1,#1
  tst r0,r1,lsl r11 ;@ Do arithmetic
  bicne r10,r10,#0x40000000
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0108] movep.w ($3333,a0), d0 uses Op0108 ----------
Op0108:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r6:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r6,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r6) into r11:
  mov r0,r6
  bl cyclone_read8 ;@ Call read8(r0) handler
  mov r11,r0,asl #24

  add r0,r6,#2
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  bl cyclone_read8 ;@ Call read8(r0) handler
  mov r1,r0,asl #24

  orr r1,r11,r1,lsr #8 ;@ second byte
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,lsr #16
  strh r1,[r7,r0]

  ldr r6,[r7,#0x54]
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0110] btst d0, (a0) uses Op0110 ----------
Op0110:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r11:
  ldr r11,[r7,r11,lsr #7]

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  bl cyclone_read8 ;@ Call read8(r0) handler

  and r11,r11,#7  ;@ mem - do mod 8

  mov r1,#1
  tst r0,r1,lsl r11 ;@ Do arithmetic
  bicne r10,r10,#0x40000000
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0118] btst d0, (a0)+ uses Op0118 ----------
Op0118:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r11:
  ldr r11,[r7,r11,lsr #7]

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  bl cyclone_read8 ;@ Call read8(r0) handler

  and r11,r11,#7  ;@ mem - do mod 8

  mov r1,#1
  tst r0,r1,lsl r11 ;@ Do arithmetic
  bicne r10,r10,#0x40000000
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [011f] btst d0, (a7)+ uses Op011f ----------
Op011f:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r11:
  ldr r11,[r7,r11,lsr #7]

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r0) into r0:
  bl cyclone_read8 ;@ Call read8(r0) handler

  and r11,r11,#7  ;@ mem - do mod 8

  mov r1,#1
  tst r0,r1,lsl r11 ;@ Do arithmetic
  bicne r10,r10,#0x40000000
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0120] btst d0, -(a0) uses Op0120 ----------
Op0120:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r11:
  ldr r11,[r7,r11,lsr #7]

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  bl cyclone_read8 ;@ Call read8(r0) handler

  and r11,r11,#7  ;@ mem - do mod 8

  mov r1,#1
  tst r0,r1,lsl r11 ;@ Do arithmetic
  bicne r10,r10,#0x40000000
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0127] btst d0, -(a7) uses Op0127 ----------
Op0127:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r11:
  ldr r11,[r7,r11,lsr #7]

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r0) into r0:
  bl cyclone_read8 ;@ Call read8(r0) handler

  and r11,r11,#7  ;@ mem - do mod 8

  mov r1,#1
  tst r0,r1,lsl r11 ;@ Do arithmetic
  bicne r10,r10,#0x40000000
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0128] btst d0, ($3333,a0) uses Op0128 ----------
Op0128:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r11:
  ldr r11,[r7,r11,lsr #7]

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  bl cyclone_read8 ;@ Call read8(r0) handler

  and r11,r11,#7  ;@ mem - do mod 8

  mov r1,#1
  tst r0,r1,lsl r11 ;@ Do arithmetic
  bicne r10,r10,#0x40000000
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0130] btst d0, ($33,a0,d3.w*2) uses Op0130 ----------
Op0130:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r11:
  ldr r11,[r7,r11,lsr #7]

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  bl cyclone_read8 ;@ Call read8(r0) handler

  and r11,r11,#7  ;@ mem - do mod 8

  mov r1,#1
  tst r0,r1,lsl r11 ;@ Do arithmetic
  bicne r10,r10,#0x40000000
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0138] btst d0, $3333.w uses Op0138 ----------
Op0138:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r11:
  ldr r11,[r7,r11,lsr #7]

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  bl cyclone_read8 ;@ Call read8(r0) handler

  and r11,r11,#7  ;@ mem - do mod 8

  mov r1,#1
  tst r0,r1,lsl r11 ;@ Do arithmetic
  bicne r10,r10,#0x40000000
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0139] btst d0, $33333333.l uses Op0139 ----------
Op0139:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r11:
  ldr r11,[r7,r11,lsr #7]

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  bl cyclone_read8 ;@ Call read8(r0) handler

  and r11,r11,#7  ;@ mem - do mod 8

  mov r1,#1
  tst r0,r1,lsl r11 ;@ Do arithmetic
  bicne r10,r10,#0x40000000
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [013a] btst d0, ($3333,pc); =3335 uses Op013a ----------
Op013a:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r11:
  ldr r11,[r7,r11,lsr #7]

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r2,r0 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r0:
  bl cyclone_fetch8 ;@ Call fetch8(r0) handler

  and r11,r11,#7  ;@ mem - do mod 8

  mov r1,#1
  tst r0,r1,lsl r11 ;@ Do arithmetic
  bicne r10,r10,#0x40000000
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [013b] btst d0, ($33,pc,d3.w*2); =35 uses Op013b ----------
Op013b:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r11:
  ldr r11,[r7,r11,lsr #7]

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r0:
  bl cyclone_fetch8 ;@ Call fetch8(r0) handler

  and r11,r11,#7  ;@ mem - do mod 8

  mov r1,#1
  tst r0,r1,lsl r11 ;@ Do arithmetic
  bicne r10,r10,#0x40000000
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [013c] btst d0, #$33 uses Op013c ----------
Op013c:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r11:
  ldr r11,[r7,r11,lsr #7]

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  and r11,r11,#7  ;@ mem - do mod 8

  mov r1,#1
  tst r0,r1,lsl r11 ;@ Do arithmetic
  bicne r10,r10,#0x40000000
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0140] bchg d0, d0 uses Op0140 ----------
Op0140:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r11:
  ldr r11,[r7,r11,lsr #7]

;@ EaCalc : Get register index into r8:
  and r8,r8,#0x000f
;@ EaRead : Read register[r8] into r0:
  ldr r0,[r7,r8,lsl #2]

  and r11,r11,#31 ;@ reg - do mod 32

  mov r1,#1
  tst r0,r1,lsl r11 ;@ Do arithmetic
  bicne r10,r10,#0x40000000
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  eor r1,r0,r1,lsl r11 ;@ Toggle bit

;@ EaWrite: r1 into register[r8]:
  str r1,[r7,r8,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0148] movep.l ($3333,a0), d0 uses Op0148 ----------
Op0148:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r6:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r6,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r6) into r11:
  mov r0,r6
  bl cyclone_read8 ;@ Call read8(r0) handler
  mov r11,r0,asl #24

  add r0,r6,#2
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  bl cyclone_read8 ;@ Call read8(r0) handler
  mov r1,r0,asl #24

  orr r11,r11,r1,lsr #8 ;@ second byte
  add r0,r6,#4
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  bl cyclone_read8 ;@ Call read8(r0) handler
  mov r1,r0,asl #24

  orr r11,r11,r1,lsr #16 ;@ third byte
  add r0,r6,#6
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  bl cyclone_read8 ;@ Call read8(r0) handler
  mov r1,r0,asl #24

  orr r1,r11,r1,lsr #24 ;@ fourth byte
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldr r6,[r7,#0x54]
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0150] bchg d0, (a0) uses Op0150 ----------
Op0150:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r11:
  ldr r11,[r7,r11,lsr #7]

;@ EaCalc : Get '(a0)' into r8:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r8,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r8) into r0:
  mov r0,r8
  bl cyclone_read8 ;@ Call read8(r0) handler

  and r11,r11,#7  ;@ mem - do mod 8

  mov r1,#1
  tst r0,r1,lsl r11 ;@ Do arithmetic
  bicne r10,r10,#0x40000000
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  eor r1,r0,r1,lsl r11 ;@ Toggle bit

;@ EaWrite: Write r1 into '(a0)' (address in r8):
  and r1,r1,#0xff
  mov r0,r8
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0158] bchg d0, (a0)+ uses Op0158 ----------
Op0158:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r11:
  ldr r11,[r7,r11,lsr #7]

;@ EaCalc : Get '(a0)+' into r8:
  and r2,r8,#0x000f
  ldr r8,[r7,r2,lsl #2]
  add r3,r8,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r8) into r0:
  mov r0,r8
  bl cyclone_read8 ;@ Call read8(r0) handler

  and r11,r11,#7  ;@ mem - do mod 8

  mov r1,#1
  tst r0,r1,lsl r11 ;@ Do arithmetic
  bicne r10,r10,#0x40000000
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  eor r1,r0,r1,lsl r11 ;@ Toggle bit

;@ EaWrite: Write r1 into '(a0)+' (address in r8):
  and r1,r1,#0xff
  mov r0,r8
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [015f] bchg d0, (a7)+ uses Op015f ----------
Op015f:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r11:
  ldr r11,[r7,r11,lsr #7]

;@ EaCalc : Get '(a7)+' into r8:
  ldr r8,[r7,#0x3c] ;@ A7
  add r3,r8,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r8) into r0:
  mov r0,r8
  bl cyclone_read8 ;@ Call read8(r0) handler

  and r11,r11,#7  ;@ mem - do mod 8

  mov r1,#1
  tst r0,r1,lsl r11 ;@ Do arithmetic
  bicne r10,r10,#0x40000000
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  eor r1,r0,r1,lsl r11 ;@ Toggle bit

;@ EaWrite: Write r1 into '(a7)+' (address in r8):
  and r1,r1,#0xff
  mov r0,r8
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0160] bchg d0, -(a0) uses Op0160 ----------
Op0160:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r11:
  ldr r11,[r7,r11,lsr #7]

;@ EaCalc : Get '-(a0)' into r8:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r8,[r7,r2,lsl #2]
  sub r8,r8,#1 ;@ Pre-decrement An
  str r8,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r8) into r0:
  mov r0,r8
  bl cyclone_read8 ;@ Call read8(r0) handler

  and r11,r11,#7  ;@ mem - do mod 8

  mov r1,#1
  tst r0,r1,lsl r11 ;@ Do arithmetic
  bicne r10,r10,#0x40000000
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  eor r1,r0,r1,lsl r11 ;@ Toggle bit

;@ EaWrite: Write r1 into '-(a0)' (address in r8):
  and r1,r1,#0xff
  mov r0,r8
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0167] bchg d0, -(a7) uses Op0167 ----------
Op0167:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r11:
  ldr r11,[r7,r11,lsr #7]

;@ EaCalc : Get '-(a7)' into r8:
  ldr r8,[r7,#0x3c] ;@ A7
  sub r8,r8,#2 ;@ Pre-decrement An
  str r8,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r8) into r0:
  mov r0,r8
  bl cyclone_read8 ;@ Call read8(r0) handler

  and r11,r11,#7  ;@ mem - do mod 8

  mov r1,#1
  tst r0,r1,lsl r11 ;@ Do arithmetic
  bicne r10,r10,#0x40000000
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  eor r1,r0,r1,lsl r11 ;@ Toggle bit

;@ EaWrite: Write r1 into '-(a7)' (address in r8):
  and r1,r1,#0xff
  mov r0,r8
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0168] bchg d0, ($3333,a0) uses Op0168 ----------
Op0168:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r11:
  ldr r11,[r7,r11,lsr #7]

;@ EaCalc : Get '($3333,a0)' into r8:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r8,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r8) into r0:
  mov r0,r8
  bl cyclone_read8 ;@ Call read8(r0) handler

  and r11,r11,#7  ;@ mem - do mod 8

  mov r1,#1
  tst r0,r1,lsl r11 ;@ Do arithmetic
  bicne r10,r10,#0x40000000
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  eor r1,r0,r1,lsl r11 ;@ Toggle bit

;@ EaWrite: Write r1 into '($3333,a0)' (address in r8):
  and r1,r1,#0xff
  mov r0,r8
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0170] bchg d0, ($33,a0,d3.w*2) uses Op0170 ----------
Op0170:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r11:
  ldr r11,[r7,r11,lsr #7]

;@ EaCalc : Get '($33,a0,d3.w*2)' into r8:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r8,r2,r3 ;@ r8=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r8) into r0:
  mov r0,r8
  bl cyclone_read8 ;@ Call read8(r0) handler

  and r11,r11,#7  ;@ mem - do mod 8

  mov r1,#1
  tst r0,r1,lsl r11 ;@ Do arithmetic
  bicne r10,r10,#0x40000000
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  eor r1,r0,r1,lsl r11 ;@ Toggle bit

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r8):
  and r1,r1,#0xff
  mov r0,r8
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0178] bchg d0, $3333.w uses Op0178 ----------
Op0178:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r11:
  ldr r11,[r7,r11,lsr #7]

;@ EaCalc : Get '$3333.w' into r8:
  ldrsh r8,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r8) into r0:
  mov r0,r8
  bl cyclone_read8 ;@ Call read8(r0) handler

  and r11,r11,#7  ;@ mem - do mod 8

  mov r1,#1
  tst r0,r1,lsl r11 ;@ Do arithmetic
  bicne r10,r10,#0x40000000
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  eor r1,r0,r1,lsl r11 ;@ Toggle bit

;@ EaWrite: Write r1 into '$3333.w' (address in r8):
  and r1,r1,#0xff
  mov r0,r8
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0179] bchg d0, $33333333.l uses Op0179 ----------
Op0179:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r11:
  ldr r11,[r7,r11,lsr #7]

;@ EaCalc : Get '$33333333.l' into r8:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r8,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r8) into r0:
  mov r0,r8
  bl cyclone_read8 ;@ Call read8(r0) handler

  and r11,r11,#7  ;@ mem - do mod 8

  mov r1,#1
  tst r0,r1,lsl r11 ;@ Do arithmetic
  bicne r10,r10,#0x40000000
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  eor r1,r0,r1,lsl r11 ;@ Toggle bit

;@ EaWrite: Write r1 into '$33333333.l' (address in r8):
  and r1,r1,#0xff
  mov r0,r8
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0180] bclr d0, d0 uses Op0180 ----------
Op0180:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r11:
  ldr r11,[r7,r11,lsr #7]

;@ EaCalc : Get register index into r8:
  and r8,r8,#0x000f
;@ EaRead : Read register[r8] into r0:
  ldr r0,[r7,r8,lsl #2]

  and r11,r11,#31 ;@ reg - do mod 32

  mov r1,#1
  tst r0,r1,lsl r11 ;@ Do arithmetic
  bicne r10,r10,#0x40000000
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  bic r1,r0,r1,lsl r11 ;@ Clear bit

;@ EaWrite: r1 into register[r8]:
  str r1,[r7,r8,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0188] movep.w d0, ($3333,a0) uses Op0188 ----------
Op0188:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r11:
  ldr r11,[r7,r11,lsr #7]

;@ EaCalc : Get '($3333,a0)' into r8:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r8,r0,r2 ;@ Add on offset
  mov r0,r8
  mov r1,r11,lsr #8 ;@ first or third byte
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  add r0,r8,#2
  and r1,r11,#0xff
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0190] bclr d0, (a0) uses Op0190 ----------
Op0190:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r11:
  ldr r11,[r7,r11,lsr #7]

;@ EaCalc : Get '(a0)' into r8:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r8,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r8) into r0:
  mov r0,r8
  bl cyclone_read8 ;@ Call read8(r0) handler

  and r11,r11,#7  ;@ mem - do mod 8

  mov r1,#1
  tst r0,r1,lsl r11 ;@ Do arithmetic
  bicne r10,r10,#0x40000000
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  bic r1,r0,r1,lsl r11 ;@ Clear bit

;@ EaWrite: Write r1 into '(a0)' (address in r8):
  and r1,r1,#0xff
  mov r0,r8
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0198] bclr d0, (a0)+ uses Op0198 ----------
Op0198:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r11:
  ldr r11,[r7,r11,lsr #7]

;@ EaCalc : Get '(a0)+' into r8:
  and r2,r8,#0x000f
  ldr r8,[r7,r2,lsl #2]
  add r3,r8,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r8) into r0:
  mov r0,r8
  bl cyclone_read8 ;@ Call read8(r0) handler

  and r11,r11,#7  ;@ mem - do mod 8

  mov r1,#1
  tst r0,r1,lsl r11 ;@ Do arithmetic
  bicne r10,r10,#0x40000000
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  bic r1,r0,r1,lsl r11 ;@ Clear bit

;@ EaWrite: Write r1 into '(a0)+' (address in r8):
  and r1,r1,#0xff
  mov r0,r8
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [019f] bclr d0, (a7)+ uses Op019f ----------
Op019f:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r11:
  ldr r11,[r7,r11,lsr #7]

;@ EaCalc : Get '(a7)+' into r8:
  ldr r8,[r7,#0x3c] ;@ A7
  add r3,r8,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r8) into r0:
  mov r0,r8
  bl cyclone_read8 ;@ Call read8(r0) handler

  and r11,r11,#7  ;@ mem - do mod 8

  mov r1,#1
  tst r0,r1,lsl r11 ;@ Do arithmetic
  bicne r10,r10,#0x40000000
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  bic r1,r0,r1,lsl r11 ;@ Clear bit

;@ EaWrite: Write r1 into '(a7)+' (address in r8):
  and r1,r1,#0xff
  mov r0,r8
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [01a0] bclr d0, -(a0) uses Op01a0 ----------
Op01a0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r11:
  ldr r11,[r7,r11,lsr #7]

;@ EaCalc : Get '-(a0)' into r8:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r8,[r7,r2,lsl #2]
  sub r8,r8,#1 ;@ Pre-decrement An
  str r8,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r8) into r0:
  mov r0,r8
  bl cyclone_read8 ;@ Call read8(r0) handler

  and r11,r11,#7  ;@ mem - do mod 8

  mov r1,#1
  tst r0,r1,lsl r11 ;@ Do arithmetic
  bicne r10,r10,#0x40000000
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  bic r1,r0,r1,lsl r11 ;@ Clear bit

;@ EaWrite: Write r1 into '-(a0)' (address in r8):
  and r1,r1,#0xff
  mov r0,r8
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [01a7] bclr d0, -(a7) uses Op01a7 ----------
Op01a7:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r11:
  ldr r11,[r7,r11,lsr #7]

;@ EaCalc : Get '-(a7)' into r8:
  ldr r8,[r7,#0x3c] ;@ A7
  sub r8,r8,#2 ;@ Pre-decrement An
  str r8,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r8) into r0:
  mov r0,r8
  bl cyclone_read8 ;@ Call read8(r0) handler

  and r11,r11,#7  ;@ mem - do mod 8

  mov r1,#1
  tst r0,r1,lsl r11 ;@ Do arithmetic
  bicne r10,r10,#0x40000000
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  bic r1,r0,r1,lsl r11 ;@ Clear bit

;@ EaWrite: Write r1 into '-(a7)' (address in r8):
  and r1,r1,#0xff
  mov r0,r8
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [01a8] bclr d0, ($3333,a0) uses Op01a8 ----------
Op01a8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r11:
  ldr r11,[r7,r11,lsr #7]

;@ EaCalc : Get '($3333,a0)' into r8:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r8,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r8) into r0:
  mov r0,r8
  bl cyclone_read8 ;@ Call read8(r0) handler

  and r11,r11,#7  ;@ mem - do mod 8

  mov r1,#1
  tst r0,r1,lsl r11 ;@ Do arithmetic
  bicne r10,r10,#0x40000000
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  bic r1,r0,r1,lsl r11 ;@ Clear bit

;@ EaWrite: Write r1 into '($3333,a0)' (address in r8):
  and r1,r1,#0xff
  mov r0,r8
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [01b0] bclr d0, ($33,a0,d3.w*2) uses Op01b0 ----------
Op01b0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r11:
  ldr r11,[r7,r11,lsr #7]

;@ EaCalc : Get '($33,a0,d3.w*2)' into r8:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r8,r2,r3 ;@ r8=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r8) into r0:
  mov r0,r8
  bl cyclone_read8 ;@ Call read8(r0) handler

  and r11,r11,#7  ;@ mem - do mod 8

  mov r1,#1
  tst r0,r1,lsl r11 ;@ Do arithmetic
  bicne r10,r10,#0x40000000
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  bic r1,r0,r1,lsl r11 ;@ Clear bit

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r8):
  and r1,r1,#0xff
  mov r0,r8
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [01b8] bclr d0, $3333.w uses Op01b8 ----------
Op01b8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r11:
  ldr r11,[r7,r11,lsr #7]

;@ EaCalc : Get '$3333.w' into r8:
  ldrsh r8,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r8) into r0:
  mov r0,r8
  bl cyclone_read8 ;@ Call read8(r0) handler

  and r11,r11,#7  ;@ mem - do mod 8

  mov r1,#1
  tst r0,r1,lsl r11 ;@ Do arithmetic
  bicne r10,r10,#0x40000000
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  bic r1,r0,r1,lsl r11 ;@ Clear bit

;@ EaWrite: Write r1 into '$3333.w' (address in r8):
  and r1,r1,#0xff
  mov r0,r8
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [01b9] bclr d0, $33333333.l uses Op01b9 ----------
Op01b9:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r11:
  ldr r11,[r7,r11,lsr #7]

;@ EaCalc : Get '$33333333.l' into r8:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r8,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r8) into r0:
  mov r0,r8
  bl cyclone_read8 ;@ Call read8(r0) handler

  and r11,r11,#7  ;@ mem - do mod 8

  mov r1,#1
  tst r0,r1,lsl r11 ;@ Do arithmetic
  bicne r10,r10,#0x40000000
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  bic r1,r0,r1,lsl r11 ;@ Clear bit

;@ EaWrite: Write r1 into '$33333333.l' (address in r8):
  and r1,r1,#0xff
  mov r0,r8
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [01c0] bset d0, d0 uses Op01c0 ----------
Op01c0:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r11:
  ldr r11,[r7,r11,lsr #7]

;@ EaCalc : Get register index into r8:
  and r8,r8,#0x000f
;@ EaRead : Read register[r8] into r0:
  ldr r0,[r7,r8,lsl #2]

  and r11,r11,#31 ;@ reg - do mod 32

  mov r1,#1
  tst r0,r1,lsl r11 ;@ Do arithmetic
  bicne r10,r10,#0x40000000
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  orr r1,r0,r1,lsl r11 ;@ Set bit

;@ EaWrite: r1 into register[r8]:
  str r1,[r7,r8,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [01c8] movep.l d0, ($3333,a0) uses Op01c8 ----------
Op01c8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r11:
  ldr r11,[r7,r11,lsr #7]

;@ EaCalc : Get '($3333,a0)' into r8:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r8,r0,r2 ;@ Add on offset
  mov r1,r11,lsr #24 ;@ first byte
;@ EaWrite: Write r1 into '($3333,a0)' (address in r8):
  and r1,r1,#0xff
  mov r0,r8
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  add r0,r8,#2
  mov r1,r11,lsr #16 ;@ second byte
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  add r0,r8,#4
  mov r1,r11,lsr #8 ;@ first or third byte
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  add r0,r8,#6
  and r1,r11,#0xff
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [01d0] bset d0, (a0) uses Op01d0 ----------
Op01d0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r11:
  ldr r11,[r7,r11,lsr #7]

;@ EaCalc : Get '(a0)' into r8:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r8,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r8) into r0:
  mov r0,r8
  bl cyclone_read8 ;@ Call read8(r0) handler

  and r11,r11,#7  ;@ mem - do mod 8

  mov r1,#1
  tst r0,r1,lsl r11 ;@ Do arithmetic
  bicne r10,r10,#0x40000000
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  orr r1,r0,r1,lsl r11 ;@ Set bit

;@ EaWrite: Write r1 into '(a0)' (address in r8):
  and r1,r1,#0xff
  mov r0,r8
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [01d8] bset d0, (a0)+ uses Op01d8 ----------
Op01d8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r11:
  ldr r11,[r7,r11,lsr #7]

;@ EaCalc : Get '(a0)+' into r8:
  and r2,r8,#0x000f
  ldr r8,[r7,r2,lsl #2]
  add r3,r8,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r8) into r0:
  mov r0,r8
  bl cyclone_read8 ;@ Call read8(r0) handler

  and r11,r11,#7  ;@ mem - do mod 8

  mov r1,#1
  tst r0,r1,lsl r11 ;@ Do arithmetic
  bicne r10,r10,#0x40000000
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  orr r1,r0,r1,lsl r11 ;@ Set bit

;@ EaWrite: Write r1 into '(a0)+' (address in r8):
  and r1,r1,#0xff
  mov r0,r8
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [01df] bset d0, (a7)+ uses Op01df ----------
Op01df:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r11:
  ldr r11,[r7,r11,lsr #7]

;@ EaCalc : Get '(a7)+' into r8:
  ldr r8,[r7,#0x3c] ;@ A7
  add r3,r8,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r8) into r0:
  mov r0,r8
  bl cyclone_read8 ;@ Call read8(r0) handler

  and r11,r11,#7  ;@ mem - do mod 8

  mov r1,#1
  tst r0,r1,lsl r11 ;@ Do arithmetic
  bicne r10,r10,#0x40000000
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  orr r1,r0,r1,lsl r11 ;@ Set bit

;@ EaWrite: Write r1 into '(a7)+' (address in r8):
  and r1,r1,#0xff
  mov r0,r8
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [01e0] bset d0, -(a0) uses Op01e0 ----------
Op01e0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r11:
  ldr r11,[r7,r11,lsr #7]

;@ EaCalc : Get '-(a0)' into r8:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r8,[r7,r2,lsl #2]
  sub r8,r8,#1 ;@ Pre-decrement An
  str r8,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r8) into r0:
  mov r0,r8
  bl cyclone_read8 ;@ Call read8(r0) handler

  and r11,r11,#7  ;@ mem - do mod 8

  mov r1,#1
  tst r0,r1,lsl r11 ;@ Do arithmetic
  bicne r10,r10,#0x40000000
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  orr r1,r0,r1,lsl r11 ;@ Set bit

;@ EaWrite: Write r1 into '-(a0)' (address in r8):
  and r1,r1,#0xff
  mov r0,r8
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [01e7] bset d0, -(a7) uses Op01e7 ----------
Op01e7:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r11:
  ldr r11,[r7,r11,lsr #7]

;@ EaCalc : Get '-(a7)' into r8:
  ldr r8,[r7,#0x3c] ;@ A7
  sub r8,r8,#2 ;@ Pre-decrement An
  str r8,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r8) into r0:
  mov r0,r8
  bl cyclone_read8 ;@ Call read8(r0) handler

  and r11,r11,#7  ;@ mem - do mod 8

  mov r1,#1
  tst r0,r1,lsl r11 ;@ Do arithmetic
  bicne r10,r10,#0x40000000
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  orr r1,r0,r1,lsl r11 ;@ Set bit

;@ EaWrite: Write r1 into '-(a7)' (address in r8):
  and r1,r1,#0xff
  mov r0,r8
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [01e8] bset d0, ($3333,a0) uses Op01e8 ----------
Op01e8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r11:
  ldr r11,[r7,r11,lsr #7]

;@ EaCalc : Get '($3333,a0)' into r8:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r8,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r8) into r0:
  mov r0,r8
  bl cyclone_read8 ;@ Call read8(r0) handler

  and r11,r11,#7  ;@ mem - do mod 8

  mov r1,#1
  tst r0,r1,lsl r11 ;@ Do arithmetic
  bicne r10,r10,#0x40000000
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  orr r1,r0,r1,lsl r11 ;@ Set bit

;@ EaWrite: Write r1 into '($3333,a0)' (address in r8):
  and r1,r1,#0xff
  mov r0,r8
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [01f0] bset d0, ($33,a0,d3.w*2) uses Op01f0 ----------
Op01f0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r11:
  ldr r11,[r7,r11,lsr #7]

;@ EaCalc : Get '($33,a0,d3.w*2)' into r8:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r8,r2,r3 ;@ r8=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r8) into r0:
  mov r0,r8
  bl cyclone_read8 ;@ Call read8(r0) handler

  and r11,r11,#7  ;@ mem - do mod 8

  mov r1,#1
  tst r0,r1,lsl r11 ;@ Do arithmetic
  bicne r10,r10,#0x40000000
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  orr r1,r0,r1,lsl r11 ;@ Set bit

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r8):
  and r1,r1,#0xff
  mov r0,r8
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [01f8] bset d0, $3333.w uses Op01f8 ----------
Op01f8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r11:
  ldr r11,[r7,r11,lsr #7]

;@ EaCalc : Get '$3333.w' into r8:
  ldrsh r8,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r8) into r0:
  mov r0,r8
  bl cyclone_read8 ;@ Call read8(r0) handler

  and r11,r11,#7  ;@ mem - do mod 8

  mov r1,#1
  tst r0,r1,lsl r11 ;@ Do arithmetic
  bicne r10,r10,#0x40000000
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  orr r1,r0,r1,lsl r11 ;@ Set bit

;@ EaWrite: Write r1 into '$3333.w' (address in r8):
  and r1,r1,#0xff
  mov r0,r8
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [01f9] bset d0, $33333333.l uses Op01f9 ----------
Op01f9:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r11:
  ldr r11,[r7,r11,lsr #7]

;@ EaCalc : Get '$33333333.l' into r8:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r8,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r8) into r0:
  mov r0,r8
  bl cyclone_read8 ;@ Call read8(r0) handler

  and r11,r11,#7  ;@ mem - do mod 8

  mov r1,#1
  tst r0,r1,lsl r11 ;@ Do arithmetic
  bicne r10,r10,#0x40000000
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  orr r1,r0,r1,lsl r11 ;@ Set bit

;@ EaWrite: Write r1 into '$33333333.l' (address in r8):
  and r1,r1,#0xff
  mov r0,r8
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0200] andi.b #$33, d0 uses Op0200 ----------
Op0200:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

  mov r10,r10,asl #24
;@ Do arithmetic:
  ands r1,r10,r0,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: r1 into register[r11]:
  mov r1,r1,lsr #24
  strb r1,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0210] andi.b #$33, (a0) uses Op0210 ----------
Op0210:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  ands r1,r10,r0,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  mov r1,r1,lsr #24
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0218] andi.b #$33, (a0)+ uses Op0218 ----------
Op0218:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  ands r1,r10,r0,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  mov r1,r1,lsr #24
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [021f] andi.b #$33, (a7)+ uses Op021f ----------
Op021f:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '(a7)+' into r11:
  ldr r11,[r7,#0x3c] ;@ A7
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  ands r1,r10,r0,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '(a7)+' (address in r11):
  mov r1,r1,lsr #24
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0220] andi.b #$33, -(a0) uses Op0220 ----------
Op0220:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#1 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  ands r1,r10,r0,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r1,r1,lsr #24
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0227] andi.b #$33, -(a7) uses Op0227 ----------
Op0227:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '-(a7)' into r11:
  ldr r11,[r7,#0x3c] ;@ A7
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  ands r1,r10,r0,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '-(a7)' (address in r11):
  mov r1,r1,lsr #24
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0228] andi.b #$33, ($3333,a0) uses Op0228 ----------
Op0228:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  ands r1,r10,r0,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  mov r1,r1,lsr #24
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0230] andi.b #$33, ($33,a0,d3.w*2) uses Op0230 ----------
Op0230:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  ands r1,r10,r0,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  mov r1,r1,lsr #24
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0238] andi.b #$33, $3333.w uses Op0238 ----------
Op0238:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  ands r1,r10,r0,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  mov r1,r1,lsr #24
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0239] andi.b #$33, $33333333.l uses Op0239 ----------
Op0239:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  ands r1,r10,r0,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  mov r1,r1,lsr #24
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [023c] andi.b #$33, ccr uses Op023c ----------
Op023c:
;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  ldr r2,[r7,#0x4c]   ;@ Load old X bit
  and r10,r10,r0,lsl #28
  and r2,r2,r0,lsl #25 ;@ X bit
  str r2,[r7,#0x4c]   ;@ Save X bit

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0250] andi.w #$3333, (a0) uses Op0250 ----------
Op0250:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler

  mov r10,r10,asl #16
;@ Do arithmetic:
  ands r1,r10,r0,asl #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  mov r1,r1,lsr #16
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0258] andi.w #$3333, (a0)+ uses Op0258 ----------
Op0258:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler

  mov r10,r10,asl #16
;@ Do arithmetic:
  ands r1,r10,r0,asl #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  mov r1,r1,lsr #16
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0260] andi.w #$3333, -(a0) uses Op0260 ----------
Op0260:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler

  mov r10,r10,asl #16
;@ Do arithmetic:
  ands r1,r10,r0,asl #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r1,r1,lsr #16
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0268] andi.w #$3333, ($3333,a0) uses Op0268 ----------
Op0268:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler

  mov r10,r10,asl #16
;@ Do arithmetic:
  ands r1,r10,r0,asl #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  mov r1,r1,lsr #16
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0270] andi.w #$3333, ($33,a0,d3.w*2) uses Op0270 ----------
Op0270:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler

  mov r10,r10,asl #16
;@ Do arithmetic:
  ands r1,r10,r0,asl #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  mov r1,r1,lsr #16
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0278] andi.w #$3333, $3333.w uses Op0278 ----------
Op0278:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler

  mov r10,r10,asl #16
;@ Do arithmetic:
  ands r1,r10,r0,asl #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  mov r1,r1,lsr #16
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0279] andi.w #$3333, $33333333.l uses Op0279 ----------
Op0279:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler

  mov r10,r10,asl #16
;@ Do arithmetic:
  ands r1,r10,r0,asl #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  mov r1,r1,lsr #16
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [027c] andi.w #$3333, sr uses Op027c ----------
Op027c:
  ldr r11,[r7,#0x44] ;@ Get SR high
  tst r11,#0x20 ;@ Check we are in supervisor mode
  beq WrongPrivilegeMode ;@ No

;@ EaCalc : Get '#$3333' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r0) into r0:

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  ldr r2,[r7,#0x4c]   ;@ Load old X bit
  and r10,r10,r0,lsl #28
  and r2,r2,r0,lsl #25 ;@ X bit
  and r1,r11,r0,lsr #8
  str r2,[r7,#0x4c]   ;@ Save X bit
  strb r1,[r7,#0x44]

;@ A7 <-> OSP?
  eor r0,r1,r11
  tst r0,#0x20
  beq no_sp_swap027c
 ;@ swap OSP and A7:
  ldr r11,[r7,#0x3C] ;@ Get A7
  ldr r0, [r7,#0x48] ;@ Get OSP
  str r11,[r7,#0x48]
  str r0, [r7,#0x3C]
no_sp_swap027c:

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ble CycloneEnd
;@ CheckInterrupt:
  ldr r1,[r7,#0x44]
  movs r0,r1,lsr #24 ;@ Get IRQ level
  ldreq pc,[r6,r8,asl #2] ;@ Jump to next opcode handler
  cmp r0,#6 ;@ irq>6 ?
  andle r1,r1,#7 ;@ Get interrupt mask
  cmple r0,r1 ;@ irq<=6: Is irq<=mask ?
  ldrle pc,[r6,r8,asl #2] ;@ Jump to next opcode handler
  b CycloneDoInterruptGoBack

;@ ---------- [0280] andi.l #$33333333, d0 uses Op0280 ----------
Op0280:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

;@ Do arithmetic:
  ands r1,r10,r0
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0290] andi.l #$33333333, (a0) uses Op0290 ----------
Op0290:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ Do arithmetic:
  ands r1,r10,r0
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  mov r0,r11
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0298] andi.l #$33333333, (a0)+ uses Op0298 ----------
Op0298:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ Do arithmetic:
  ands r1,r10,r0
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  mov r0,r11
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [02a0] andi.l #$33333333, -(a0) uses Op02a0 ----------
Op02a0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#4 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ Do arithmetic:
  ands r1,r10,r0
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r0,r11
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#30 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [02a8] andi.l #$33333333, ($3333,a0) uses Op02a8 ----------
Op02a8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ Do arithmetic:
  ands r1,r10,r0
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  mov r0,r11
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#32 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [02b0] andi.l #$33333333, ($33,a0,d3.w*2) uses Op02b0 ----------
Op02b0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ Do arithmetic:
  ands r1,r10,r0
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  mov r0,r11
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#34 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [02b8] andi.l #$33333333, $3333.w uses Op02b8 ----------
Op02b8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ Do arithmetic:
  ands r1,r10,r0
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  mov r0,r11
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#32 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [02b9] andi.l #$33333333, $33333333.l uses Op02b9 ----------
Op02b9:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ Do arithmetic:
  ands r1,r10,r0
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  mov r0,r11
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#36 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0400] subi.b #$33, d0 uses Op0400 ----------
Op0400:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

  mov r10,r10,asl #24
;@ Do arithmetic:
  rsbs r1,r10,r0,asl #24 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: r1 into register[r11]:
  mov r1,r1,lsr #24
  strb r1,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0410] subi.b #$33, (a0) uses Op0410 ----------
Op0410:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  rsbs r1,r10,r0,asl #24 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  mov r1,r1,lsr #24
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0418] subi.b #$33, (a0)+ uses Op0418 ----------
Op0418:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  rsbs r1,r10,r0,asl #24 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  mov r1,r1,lsr #24
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [041f] subi.b #$33, (a7)+ uses Op041f ----------
Op041f:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '(a7)+' into r11:
  ldr r11,[r7,#0x3c] ;@ A7
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  rsbs r1,r10,r0,asl #24 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '(a7)+' (address in r11):
  mov r1,r1,lsr #24
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0420] subi.b #$33, -(a0) uses Op0420 ----------
Op0420:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#1 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  rsbs r1,r10,r0,asl #24 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r1,r1,lsr #24
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0427] subi.b #$33, -(a7) uses Op0427 ----------
Op0427:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '-(a7)' into r11:
  ldr r11,[r7,#0x3c] ;@ A7
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  rsbs r1,r10,r0,asl #24 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '-(a7)' (address in r11):
  mov r1,r1,lsr #24
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0428] subi.b #$33, ($3333,a0) uses Op0428 ----------
Op0428:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  rsbs r1,r10,r0,asl #24 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  mov r1,r1,lsr #24
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0430] subi.b #$33, ($33,a0,d3.w*2) uses Op0430 ----------
Op0430:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  rsbs r1,r10,r0,asl #24 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  mov r1,r1,lsr #24
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0438] subi.b #$33, $3333.w uses Op0438 ----------
Op0438:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  rsbs r1,r10,r0,asl #24 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  mov r1,r1,lsr #24
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0439] subi.b #$33, $33333333.l uses Op0439 ----------
Op0439:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  rsbs r1,r10,r0,asl #24 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  mov r1,r1,lsr #24
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0440] subi.w #$3333, d0 uses Op0440 ----------
Op0440:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
  mov r11,r11,lsl #2
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11]

  mov r10,r10,asl #16
;@ Do arithmetic:
  rsbs r1,r10,r0,asl #16 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: r1 into register[r11]:
  mov r1,r1,lsr #16
  strh r1,[r7,r11]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0450] subi.w #$3333, (a0) uses Op0450 ----------
Op0450:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler

  mov r10,r10,asl #16
;@ Do arithmetic:
  rsbs r1,r10,r0,asl #16 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  mov r1,r1,lsr #16
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0458] subi.w #$3333, (a0)+ uses Op0458 ----------
Op0458:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler

  mov r10,r10,asl #16
;@ Do arithmetic:
  rsbs r1,r10,r0,asl #16 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  mov r1,r1,lsr #16
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0460] subi.w #$3333, -(a0) uses Op0460 ----------
Op0460:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler

  mov r10,r10,asl #16
;@ Do arithmetic:
  rsbs r1,r10,r0,asl #16 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r1,r1,lsr #16
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0468] subi.w #$3333, ($3333,a0) uses Op0468 ----------
Op0468:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler

  mov r10,r10,asl #16
;@ Do arithmetic:
  rsbs r1,r10,r0,asl #16 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  mov r1,r1,lsr #16
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0470] subi.w #$3333, ($33,a0,d3.w*2) uses Op0470 ----------
Op0470:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler

  mov r10,r10,asl #16
;@ Do arithmetic:
  rsbs r1,r10,r0,asl #16 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  mov r1,r1,lsr #16
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0478] subi.w #$3333, $3333.w uses Op0478 ----------
Op0478:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler

  mov r10,r10,asl #16
;@ Do arithmetic:
  rsbs r1,r10,r0,asl #16 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  mov r1,r1,lsr #16
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0479] subi.w #$3333, $33333333.l uses Op0479 ----------
Op0479:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler

  mov r10,r10,asl #16
;@ Do arithmetic:
  rsbs r1,r10,r0,asl #16 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  mov r1,r1,lsr #16
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0480] subi.l #$33333333, d0 uses Op0480 ----------
Op0480:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

;@ Do arithmetic:
  rsbs r1,r10,r0 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0490] subi.l #$33333333, (a0) uses Op0490 ----------
Op0490:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ Do arithmetic:
  rsbs r1,r10,r0 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  mov r0,r11
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0498] subi.l #$33333333, (a0)+ uses Op0498 ----------
Op0498:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ Do arithmetic:
  rsbs r1,r10,r0 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  mov r0,r11
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [04a0] subi.l #$33333333, -(a0) uses Op04a0 ----------
Op04a0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#4 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ Do arithmetic:
  rsbs r1,r10,r0 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r0,r11
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#30 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [04a8] subi.l #$33333333, ($3333,a0) uses Op04a8 ----------
Op04a8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ Do arithmetic:
  rsbs r1,r10,r0 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  mov r0,r11
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#32 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [04b0] subi.l #$33333333, ($33,a0,d3.w*2) uses Op04b0 ----------
Op04b0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ Do arithmetic:
  rsbs r1,r10,r0 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  mov r0,r11
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#34 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [04b8] subi.l #$33333333, $3333.w uses Op04b8 ----------
Op04b8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ Do arithmetic:
  rsbs r1,r10,r0 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  mov r0,r11
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#32 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [04b9] subi.l #$33333333, $33333333.l uses Op04b9 ----------
Op04b9:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ Do arithmetic:
  rsbs r1,r10,r0 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  mov r0,r11
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#36 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0600] addi.b #$33, d0 uses Op0600 ----------
Op0600:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

  mov r10,r10,asl #24
;@ Do arithmetic:
  adds r1,r10,r0,asl #24 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: r1 into register[r11]:
  mov r1,r1,lsr #24
  strb r1,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0610] addi.b #$33, (a0) uses Op0610 ----------
Op0610:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  adds r1,r10,r0,asl #24 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  mov r1,r1,lsr #24
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0618] addi.b #$33, (a0)+ uses Op0618 ----------
Op0618:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  adds r1,r10,r0,asl #24 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  mov r1,r1,lsr #24
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [061f] addi.b #$33, (a7)+ uses Op061f ----------
Op061f:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '(a7)+' into r11:
  ldr r11,[r7,#0x3c] ;@ A7
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  adds r1,r10,r0,asl #24 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '(a7)+' (address in r11):
  mov r1,r1,lsr #24
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0620] addi.b #$33, -(a0) uses Op0620 ----------
Op0620:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#1 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  adds r1,r10,r0,asl #24 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r1,r1,lsr #24
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0627] addi.b #$33, -(a7) uses Op0627 ----------
Op0627:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '-(a7)' into r11:
  ldr r11,[r7,#0x3c] ;@ A7
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  adds r1,r10,r0,asl #24 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '-(a7)' (address in r11):
  mov r1,r1,lsr #24
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0628] addi.b #$33, ($3333,a0) uses Op0628 ----------
Op0628:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  adds r1,r10,r0,asl #24 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  mov r1,r1,lsr #24
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0630] addi.b #$33, ($33,a0,d3.w*2) uses Op0630 ----------
Op0630:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  adds r1,r10,r0,asl #24 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  mov r1,r1,lsr #24
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0638] addi.b #$33, $3333.w uses Op0638 ----------
Op0638:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  adds r1,r10,r0,asl #24 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  mov r1,r1,lsr #24
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0639] addi.b #$33, $33333333.l uses Op0639 ----------
Op0639:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  adds r1,r10,r0,asl #24 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  mov r1,r1,lsr #24
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0650] addi.w #$3333, (a0) uses Op0650 ----------
Op0650:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler

  mov r10,r10,asl #16
;@ Do arithmetic:
  adds r1,r10,r0,asl #16 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  mov r1,r1,lsr #16
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0658] addi.w #$3333, (a0)+ uses Op0658 ----------
Op0658:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler

  mov r10,r10,asl #16
;@ Do arithmetic:
  adds r1,r10,r0,asl #16 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  mov r1,r1,lsr #16
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0660] addi.w #$3333, -(a0) uses Op0660 ----------
Op0660:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler

  mov r10,r10,asl #16
;@ Do arithmetic:
  adds r1,r10,r0,asl #16 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r1,r1,lsr #16
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0668] addi.w #$3333, ($3333,a0) uses Op0668 ----------
Op0668:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler

  mov r10,r10,asl #16
;@ Do arithmetic:
  adds r1,r10,r0,asl #16 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  mov r1,r1,lsr #16
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0670] addi.w #$3333, ($33,a0,d3.w*2) uses Op0670 ----------
Op0670:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler

  mov r10,r10,asl #16
;@ Do arithmetic:
  adds r1,r10,r0,asl #16 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  mov r1,r1,lsr #16
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0678] addi.w #$3333, $3333.w uses Op0678 ----------
Op0678:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler

  mov r10,r10,asl #16
;@ Do arithmetic:
  adds r1,r10,r0,asl #16 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  mov r1,r1,lsr #16
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0679] addi.w #$3333, $33333333.l uses Op0679 ----------
Op0679:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler

  mov r10,r10,asl #16
;@ Do arithmetic:
  adds r1,r10,r0,asl #16 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  mov r1,r1,lsr #16
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0680] addi.l #$33333333, d0 uses Op0680 ----------
Op0680:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

;@ Do arithmetic:
  adds r1,r10,r0 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0690] addi.l #$33333333, (a0) uses Op0690 ----------
Op0690:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ Do arithmetic:
  adds r1,r10,r0 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  mov r0,r11
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0698] addi.l #$33333333, (a0)+ uses Op0698 ----------
Op0698:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ Do arithmetic:
  adds r1,r10,r0 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  mov r0,r11
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [06a0] addi.l #$33333333, -(a0) uses Op06a0 ----------
Op06a0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#4 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ Do arithmetic:
  adds r1,r10,r0 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r0,r11
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#30 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [06a8] addi.l #$33333333, ($3333,a0) uses Op06a8 ----------
Op06a8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ Do arithmetic:
  adds r1,r10,r0 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  mov r0,r11
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#32 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [06b0] addi.l #$33333333, ($33,a0,d3.w*2) uses Op06b0 ----------
Op06b0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ Do arithmetic:
  adds r1,r10,r0 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  mov r0,r11
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#34 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [06b8] addi.l #$33333333, $3333.w uses Op06b8 ----------
Op06b8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ Do arithmetic:
  adds r1,r10,r0 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  mov r0,r11
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#32 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [06b9] addi.l #$33333333, $33333333.l uses Op06b9 ----------
Op06b9:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ Do arithmetic:
  adds r1,r10,r0 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  mov r0,r11
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#36 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0800] btst #$33, d0 uses Op0800 ----------
Op0800:

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  mov r11,#1
  bic r10,r10,#0x40000000 ;@ Blank Z flag
  and r0,r0,#0x1F ;@ reg - do mod 32
  mov r11,r11,lsl r0 ;@ Make bit mask

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r0:
  ldr r0,[r7,r0,lsl #2]

  tst r0,r11 ;@ Do arithmetic
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0810] btst #$33, (a0) uses Op0810 ----------
Op0810:
  str r5,[r7,#0x5c] ;@ Save Cycles


;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  mov r11,#1
  bic r10,r10,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7    ;@ mem - do mod 8
  mov r11,r11,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  bl cyclone_read8 ;@ Call read8(r0) handler

  tst r0,r11 ;@ Do arithmetic
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0818] btst #$33, (a0)+ uses Op0818 ----------
Op0818:
  str r5,[r7,#0x5c] ;@ Save Cycles


;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  mov r11,#1
  bic r10,r10,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7    ;@ mem - do mod 8
  mov r11,r11,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  bl cyclone_read8 ;@ Call read8(r0) handler

  tst r0,r11 ;@ Do arithmetic
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [081f] btst #$33, (a7)+ uses Op081f ----------
Op081f:
  str r5,[r7,#0x5c] ;@ Save Cycles


;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  mov r11,#1
  bic r10,r10,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7    ;@ mem - do mod 8
  mov r11,r11,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r0) into r0:
  bl cyclone_read8 ;@ Call read8(r0) handler

  tst r0,r11 ;@ Do arithmetic
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0820] btst #$33, -(a0) uses Op0820 ----------
Op0820:
  str r5,[r7,#0x5c] ;@ Save Cycles


;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  mov r11,#1
  bic r10,r10,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7    ;@ mem - do mod 8
  mov r11,r11,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  bl cyclone_read8 ;@ Call read8(r0) handler

  tst r0,r11 ;@ Do arithmetic
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0827] btst #$33, -(a7) uses Op0827 ----------
Op0827:
  str r5,[r7,#0x5c] ;@ Save Cycles


;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  mov r11,#1
  bic r10,r10,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7    ;@ mem - do mod 8
  mov r11,r11,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r0) into r0:
  bl cyclone_read8 ;@ Call read8(r0) handler

  tst r0,r11 ;@ Do arithmetic
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0830] btst #$33, ($33,a0,d3.w*2) uses Op0830 ----------
Op0830:
  str r5,[r7,#0x5c] ;@ Save Cycles


;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  mov r11,#1
  bic r10,r10,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7    ;@ mem - do mod 8
  mov r11,r11,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  bl cyclone_read8 ;@ Call read8(r0) handler

  tst r0,r11 ;@ Do arithmetic
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [083a] btst #$33, ($3333,pc); =3337 uses Op083a ----------
Op083a:
  str r5,[r7,#0x5c] ;@ Save Cycles


;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  mov r11,#1
  bic r10,r10,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7    ;@ mem - do mod 8
  mov r11,r11,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r2,r0 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r0:
  bl cyclone_fetch8 ;@ Call fetch8(r0) handler

  tst r0,r11 ;@ Do arithmetic
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [083b] btst #$33, ($33,pc,d3.w*2); =37 uses Op083b ----------
Op083b:
  str r5,[r7,#0x5c] ;@ Save Cycles


;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  mov r11,#1
  bic r10,r10,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7    ;@ mem - do mod 8
  mov r11,r11,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r0:
  bl cyclone_fetch8 ;@ Call fetch8(r0) handler

  tst r0,r11 ;@ Do arithmetic
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0840] bchg #$33, d0 uses Op0840 ----------
Op0840:

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  mov r11,#1
  bic r10,r10,#0x40000000 ;@ Blank Z flag
  and r0,r0,#0x1F ;@ reg - do mod 32
  mov r11,r11,lsl r0 ;@ Make bit mask

;@ EaCalc : Get register index into r8:
  and r8,r8,#0x000f
;@ EaRead : Read register[r8] into r0:
  ldr r0,[r7,r8,lsl #2]

  tst r0,r11 ;@ Do arithmetic
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  eor r1,r0,r11 ;@ Toggle bit

;@ EaWrite: r1 into register[r8]:
  str r1,[r7,r8,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0850] bchg #$33, (a0) uses Op0850 ----------
Op0850:
  str r5,[r7,#0x5c] ;@ Save Cycles


;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  mov r11,#1
  bic r10,r10,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7    ;@ mem - do mod 8
  mov r11,r11,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '(a0)' into r8:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r8,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r8) into r0:
  mov r0,r8
  bl cyclone_read8 ;@ Call read8(r0) handler

  tst r0,r11 ;@ Do arithmetic
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  eor r1,r0,r11 ;@ Toggle bit

;@ EaWrite: Write r1 into '(a0)' (address in r8):
  and r1,r1,#0xff
  mov r0,r8
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0858] bchg #$33, (a0)+ uses Op0858 ----------
Op0858:
  str r5,[r7,#0x5c] ;@ Save Cycles


;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  mov r11,#1
  bic r10,r10,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7    ;@ mem - do mod 8
  mov r11,r11,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '(a0)+' into r8:
  and r2,r8,#0x000f
  ldr r8,[r7,r2,lsl #2]
  add r3,r8,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r8) into r0:
  mov r0,r8
  bl cyclone_read8 ;@ Call read8(r0) handler

  tst r0,r11 ;@ Do arithmetic
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  eor r1,r0,r11 ;@ Toggle bit

;@ EaWrite: Write r1 into '(a0)+' (address in r8):
  and r1,r1,#0xff
  mov r0,r8
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [085f] bchg #$33, (a7)+ uses Op085f ----------
Op085f:
  str r5,[r7,#0x5c] ;@ Save Cycles


;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  mov r11,#1
  bic r10,r10,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7    ;@ mem - do mod 8
  mov r11,r11,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '(a7)+' into r8:
  ldr r8,[r7,#0x3c] ;@ A7
  add r3,r8,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r8) into r0:
  mov r0,r8
  bl cyclone_read8 ;@ Call read8(r0) handler

  tst r0,r11 ;@ Do arithmetic
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  eor r1,r0,r11 ;@ Toggle bit

;@ EaWrite: Write r1 into '(a7)+' (address in r8):
  and r1,r1,#0xff
  mov r0,r8
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0860] bchg #$33, -(a0) uses Op0860 ----------
Op0860:
  str r5,[r7,#0x5c] ;@ Save Cycles


;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  mov r11,#1
  bic r10,r10,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7    ;@ mem - do mod 8
  mov r11,r11,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '-(a0)' into r8:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r8,[r7,r2,lsl #2]
  sub r8,r8,#1 ;@ Pre-decrement An
  str r8,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r8) into r0:
  mov r0,r8
  bl cyclone_read8 ;@ Call read8(r0) handler

  tst r0,r11 ;@ Do arithmetic
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  eor r1,r0,r11 ;@ Toggle bit

;@ EaWrite: Write r1 into '-(a0)' (address in r8):
  and r1,r1,#0xff
  mov r0,r8
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0867] bchg #$33, -(a7) uses Op0867 ----------
Op0867:
  str r5,[r7,#0x5c] ;@ Save Cycles


;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  mov r11,#1
  bic r10,r10,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7    ;@ mem - do mod 8
  mov r11,r11,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '-(a7)' into r8:
  ldr r8,[r7,#0x3c] ;@ A7
  sub r8,r8,#2 ;@ Pre-decrement An
  str r8,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r8) into r0:
  mov r0,r8
  bl cyclone_read8 ;@ Call read8(r0) handler

  tst r0,r11 ;@ Do arithmetic
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  eor r1,r0,r11 ;@ Toggle bit

;@ EaWrite: Write r1 into '-(a7)' (address in r8):
  and r1,r1,#0xff
  mov r0,r8
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0868] bchg #$33, ($3333,a0) uses Op0868 ----------
Op0868:
  str r5,[r7,#0x5c] ;@ Save Cycles


;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  mov r11,#1
  bic r10,r10,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7    ;@ mem - do mod 8
  mov r11,r11,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '($3333,a0)' into r8:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r8,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r8) into r0:
  mov r0,r8
  bl cyclone_read8 ;@ Call read8(r0) handler

  tst r0,r11 ;@ Do arithmetic
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  eor r1,r0,r11 ;@ Toggle bit

;@ EaWrite: Write r1 into '($3333,a0)' (address in r8):
  and r1,r1,#0xff
  mov r0,r8
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0870] bchg #$33, ($33,a0,d3.w*2) uses Op0870 ----------
Op0870:
  str r5,[r7,#0x5c] ;@ Save Cycles


;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  mov r11,#1
  bic r10,r10,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7    ;@ mem - do mod 8
  mov r11,r11,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '($33,a0,d3.w*2)' into r8:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r8,r2,r3 ;@ r8=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r8) into r0:
  mov r0,r8
  bl cyclone_read8 ;@ Call read8(r0) handler

  tst r0,r11 ;@ Do arithmetic
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  eor r1,r0,r11 ;@ Toggle bit

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r8):
  and r1,r1,#0xff
  mov r0,r8
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0878] bchg #$33, $3333.w uses Op0878 ----------
Op0878:
  str r5,[r7,#0x5c] ;@ Save Cycles


;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  mov r11,#1
  bic r10,r10,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7    ;@ mem - do mod 8
  mov r11,r11,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '$3333.w' into r8:
  ldrsh r8,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r8) into r0:
  mov r0,r8
  bl cyclone_read8 ;@ Call read8(r0) handler

  tst r0,r11 ;@ Do arithmetic
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  eor r1,r0,r11 ;@ Toggle bit

;@ EaWrite: Write r1 into '$3333.w' (address in r8):
  and r1,r1,#0xff
  mov r0,r8
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0879] bchg #$33, $33333333.l uses Op0879 ----------
Op0879:
  str r5,[r7,#0x5c] ;@ Save Cycles


;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  mov r11,#1
  bic r10,r10,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7    ;@ mem - do mod 8
  mov r11,r11,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '$33333333.l' into r8:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r8,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r8) into r0:
  mov r0,r8
  bl cyclone_read8 ;@ Call read8(r0) handler

  tst r0,r11 ;@ Do arithmetic
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  eor r1,r0,r11 ;@ Toggle bit

;@ EaWrite: Write r1 into '$33333333.l' (address in r8):
  and r1,r1,#0xff
  mov r0,r8
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0880] bclr #$33, d0 uses Op0880 ----------
Op0880:

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  mov r11,#1
  bic r10,r10,#0x40000000 ;@ Blank Z flag
  and r0,r0,#0x1F ;@ reg - do mod 32
  mov r11,r11,lsl r0 ;@ Make bit mask

;@ EaCalc : Get register index into r8:
  and r8,r8,#0x000f
;@ EaRead : Read register[r8] into r0:
  ldr r0,[r7,r8,lsl #2]

  tst r0,r11 ;@ Do arithmetic
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  bic r1,r0,r11 ;@ Clear bit

;@ EaWrite: r1 into register[r8]:
  str r1,[r7,r8,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0890] bclr #$33, (a0) uses Op0890 ----------
Op0890:
  str r5,[r7,#0x5c] ;@ Save Cycles


;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  mov r11,#1
  bic r10,r10,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7    ;@ mem - do mod 8
  mov r11,r11,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '(a0)' into r8:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r8,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r8) into r0:
  mov r0,r8
  bl cyclone_read8 ;@ Call read8(r0) handler

  tst r0,r11 ;@ Do arithmetic
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  bic r1,r0,r11 ;@ Clear bit

;@ EaWrite: Write r1 into '(a0)' (address in r8):
  and r1,r1,#0xff
  mov r0,r8
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0898] bclr #$33, (a0)+ uses Op0898 ----------
Op0898:
  str r5,[r7,#0x5c] ;@ Save Cycles


;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  mov r11,#1
  bic r10,r10,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7    ;@ mem - do mod 8
  mov r11,r11,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '(a0)+' into r8:
  and r2,r8,#0x000f
  ldr r8,[r7,r2,lsl #2]
  add r3,r8,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r8) into r0:
  mov r0,r8
  bl cyclone_read8 ;@ Call read8(r0) handler

  tst r0,r11 ;@ Do arithmetic
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  bic r1,r0,r11 ;@ Clear bit

;@ EaWrite: Write r1 into '(a0)+' (address in r8):
  and r1,r1,#0xff
  mov r0,r8
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [089f] bclr #$33, (a7)+ uses Op089f ----------
Op089f:
  str r5,[r7,#0x5c] ;@ Save Cycles


;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  mov r11,#1
  bic r10,r10,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7    ;@ mem - do mod 8
  mov r11,r11,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '(a7)+' into r8:
  ldr r8,[r7,#0x3c] ;@ A7
  add r3,r8,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r8) into r0:
  mov r0,r8
  bl cyclone_read8 ;@ Call read8(r0) handler

  tst r0,r11 ;@ Do arithmetic
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  bic r1,r0,r11 ;@ Clear bit

;@ EaWrite: Write r1 into '(a7)+' (address in r8):
  and r1,r1,#0xff
  mov r0,r8
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [08a0] bclr #$33, -(a0) uses Op08a0 ----------
Op08a0:
  str r5,[r7,#0x5c] ;@ Save Cycles


;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  mov r11,#1
  bic r10,r10,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7    ;@ mem - do mod 8
  mov r11,r11,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '-(a0)' into r8:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r8,[r7,r2,lsl #2]
  sub r8,r8,#1 ;@ Pre-decrement An
  str r8,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r8) into r0:
  mov r0,r8
  bl cyclone_read8 ;@ Call read8(r0) handler

  tst r0,r11 ;@ Do arithmetic
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  bic r1,r0,r11 ;@ Clear bit

;@ EaWrite: Write r1 into '-(a0)' (address in r8):
  and r1,r1,#0xff
  mov r0,r8
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [08a7] bclr #$33, -(a7) uses Op08a7 ----------
Op08a7:
  str r5,[r7,#0x5c] ;@ Save Cycles


;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  mov r11,#1
  bic r10,r10,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7    ;@ mem - do mod 8
  mov r11,r11,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '-(a7)' into r8:
  ldr r8,[r7,#0x3c] ;@ A7
  sub r8,r8,#2 ;@ Pre-decrement An
  str r8,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r8) into r0:
  mov r0,r8
  bl cyclone_read8 ;@ Call read8(r0) handler

  tst r0,r11 ;@ Do arithmetic
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  bic r1,r0,r11 ;@ Clear bit

;@ EaWrite: Write r1 into '-(a7)' (address in r8):
  and r1,r1,#0xff
  mov r0,r8
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [08a8] bclr #$33, ($3333,a0) uses Op08a8 ----------
Op08a8:
  str r5,[r7,#0x5c] ;@ Save Cycles


;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  mov r11,#1
  bic r10,r10,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7    ;@ mem - do mod 8
  mov r11,r11,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '($3333,a0)' into r8:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r8,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r8) into r0:
  mov r0,r8
  bl cyclone_read8 ;@ Call read8(r0) handler

  tst r0,r11 ;@ Do arithmetic
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  bic r1,r0,r11 ;@ Clear bit

;@ EaWrite: Write r1 into '($3333,a0)' (address in r8):
  and r1,r1,#0xff
  mov r0,r8
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [08b0] bclr #$33, ($33,a0,d3.w*2) uses Op08b0 ----------
Op08b0:
  str r5,[r7,#0x5c] ;@ Save Cycles


;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  mov r11,#1
  bic r10,r10,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7    ;@ mem - do mod 8
  mov r11,r11,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '($33,a0,d3.w*2)' into r8:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r8,r2,r3 ;@ r8=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r8) into r0:
  mov r0,r8
  bl cyclone_read8 ;@ Call read8(r0) handler

  tst r0,r11 ;@ Do arithmetic
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  bic r1,r0,r11 ;@ Clear bit

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r8):
  and r1,r1,#0xff
  mov r0,r8
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [08b8] bclr #$33, $3333.w uses Op08b8 ----------
Op08b8:
  str r5,[r7,#0x5c] ;@ Save Cycles


;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  mov r11,#1
  bic r10,r10,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7    ;@ mem - do mod 8
  mov r11,r11,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '$3333.w' into r8:
  ldrsh r8,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r8) into r0:
  mov r0,r8
  bl cyclone_read8 ;@ Call read8(r0) handler

  tst r0,r11 ;@ Do arithmetic
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  bic r1,r0,r11 ;@ Clear bit

;@ EaWrite: Write r1 into '$3333.w' (address in r8):
  and r1,r1,#0xff
  mov r0,r8
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [08b9] bclr #$33, $33333333.l uses Op08b9 ----------
Op08b9:
  str r5,[r7,#0x5c] ;@ Save Cycles


;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  mov r11,#1
  bic r10,r10,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7    ;@ mem - do mod 8
  mov r11,r11,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '$33333333.l' into r8:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r8,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r8) into r0:
  mov r0,r8
  bl cyclone_read8 ;@ Call read8(r0) handler

  tst r0,r11 ;@ Do arithmetic
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  bic r1,r0,r11 ;@ Clear bit

;@ EaWrite: Write r1 into '$33333333.l' (address in r8):
  and r1,r1,#0xff
  mov r0,r8
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [08c0] bset #$33, d0 uses Op08c0 ----------
Op08c0:

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  mov r11,#1
  bic r10,r10,#0x40000000 ;@ Blank Z flag
  and r0,r0,#0x1F ;@ reg - do mod 32
  mov r11,r11,lsl r0 ;@ Make bit mask

;@ EaCalc : Get register index into r8:
  and r8,r8,#0x000f
;@ EaRead : Read register[r8] into r0:
  ldr r0,[r7,r8,lsl #2]

  tst r0,r11 ;@ Do arithmetic
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  orr r1,r0,r11 ;@ Set bit

;@ EaWrite: r1 into register[r8]:
  str r1,[r7,r8,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [08d0] bset #$33, (a0) uses Op08d0 ----------
Op08d0:
  str r5,[r7,#0x5c] ;@ Save Cycles


;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  mov r11,#1
  bic r10,r10,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7    ;@ mem - do mod 8
  mov r11,r11,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '(a0)' into r8:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r8,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r8) into r0:
  mov r0,r8
  bl cyclone_read8 ;@ Call read8(r0) handler

  tst r0,r11 ;@ Do arithmetic
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  orr r1,r0,r11 ;@ Set bit

;@ EaWrite: Write r1 into '(a0)' (address in r8):
  and r1,r1,#0xff
  mov r0,r8
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [08d8] bset #$33, (a0)+ uses Op08d8 ----------
Op08d8:
  str r5,[r7,#0x5c] ;@ Save Cycles


;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  mov r11,#1
  bic r10,r10,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7    ;@ mem - do mod 8
  mov r11,r11,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '(a0)+' into r8:
  and r2,r8,#0x000f
  ldr r8,[r7,r2,lsl #2]
  add r3,r8,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r8) into r0:
  mov r0,r8
  bl cyclone_read8 ;@ Call read8(r0) handler

  tst r0,r11 ;@ Do arithmetic
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  orr r1,r0,r11 ;@ Set bit

;@ EaWrite: Write r1 into '(a0)+' (address in r8):
  and r1,r1,#0xff
  mov r0,r8
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [08df] bset #$33, (a7)+ uses Op08df ----------
Op08df:
  str r5,[r7,#0x5c] ;@ Save Cycles


;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  mov r11,#1
  bic r10,r10,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7    ;@ mem - do mod 8
  mov r11,r11,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '(a7)+' into r8:
  ldr r8,[r7,#0x3c] ;@ A7
  add r3,r8,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r8) into r0:
  mov r0,r8
  bl cyclone_read8 ;@ Call read8(r0) handler

  tst r0,r11 ;@ Do arithmetic
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  orr r1,r0,r11 ;@ Set bit

;@ EaWrite: Write r1 into '(a7)+' (address in r8):
  and r1,r1,#0xff
  mov r0,r8
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [08e0] bset #$33, -(a0) uses Op08e0 ----------
Op08e0:
  str r5,[r7,#0x5c] ;@ Save Cycles


;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  mov r11,#1
  bic r10,r10,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7    ;@ mem - do mod 8
  mov r11,r11,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '-(a0)' into r8:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r8,[r7,r2,lsl #2]
  sub r8,r8,#1 ;@ Pre-decrement An
  str r8,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r8) into r0:
  mov r0,r8
  bl cyclone_read8 ;@ Call read8(r0) handler

  tst r0,r11 ;@ Do arithmetic
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  orr r1,r0,r11 ;@ Set bit

;@ EaWrite: Write r1 into '-(a0)' (address in r8):
  and r1,r1,#0xff
  mov r0,r8
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [08e7] bset #$33, -(a7) uses Op08e7 ----------
Op08e7:
  str r5,[r7,#0x5c] ;@ Save Cycles


;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  mov r11,#1
  bic r10,r10,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7    ;@ mem - do mod 8
  mov r11,r11,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '-(a7)' into r8:
  ldr r8,[r7,#0x3c] ;@ A7
  sub r8,r8,#2 ;@ Pre-decrement An
  str r8,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r8) into r0:
  mov r0,r8
  bl cyclone_read8 ;@ Call read8(r0) handler

  tst r0,r11 ;@ Do arithmetic
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  orr r1,r0,r11 ;@ Set bit

;@ EaWrite: Write r1 into '-(a7)' (address in r8):
  and r1,r1,#0xff
  mov r0,r8
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [08e8] bset #$33, ($3333,a0) uses Op08e8 ----------
Op08e8:
  str r5,[r7,#0x5c] ;@ Save Cycles


;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  mov r11,#1
  bic r10,r10,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7    ;@ mem - do mod 8
  mov r11,r11,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '($3333,a0)' into r8:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r8,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r8) into r0:
  mov r0,r8
  bl cyclone_read8 ;@ Call read8(r0) handler

  tst r0,r11 ;@ Do arithmetic
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  orr r1,r0,r11 ;@ Set bit

;@ EaWrite: Write r1 into '($3333,a0)' (address in r8):
  and r1,r1,#0xff
  mov r0,r8
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [08f0] bset #$33, ($33,a0,d3.w*2) uses Op08f0 ----------
Op08f0:
  str r5,[r7,#0x5c] ;@ Save Cycles


;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  mov r11,#1
  bic r10,r10,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7    ;@ mem - do mod 8
  mov r11,r11,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '($33,a0,d3.w*2)' into r8:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r8,r2,r3 ;@ r8=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r8) into r0:
  mov r0,r8
  bl cyclone_read8 ;@ Call read8(r0) handler

  tst r0,r11 ;@ Do arithmetic
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  orr r1,r0,r11 ;@ Set bit

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r8):
  and r1,r1,#0xff
  mov r0,r8
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [08f8] bset #$33, $3333.w uses Op08f8 ----------
Op08f8:
  str r5,[r7,#0x5c] ;@ Save Cycles


;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  mov r11,#1
  bic r10,r10,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7    ;@ mem - do mod 8
  mov r11,r11,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '$3333.w' into r8:
  ldrsh r8,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r8) into r0:
  mov r0,r8
  bl cyclone_read8 ;@ Call read8(r0) handler

  tst r0,r11 ;@ Do arithmetic
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  orr r1,r0,r11 ;@ Set bit

;@ EaWrite: Write r1 into '$3333.w' (address in r8):
  and r1,r1,#0xff
  mov r0,r8
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [08f9] bset #$33, $33333333.l uses Op08f9 ----------
Op08f9:
  str r5,[r7,#0x5c] ;@ Save Cycles


;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  mov r11,#1
  bic r10,r10,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7    ;@ mem - do mod 8
  mov r11,r11,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '$33333333.l' into r8:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r8,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r8) into r0:
  mov r0,r8
  bl cyclone_read8 ;@ Call read8(r0) handler

  tst r0,r11 ;@ Do arithmetic
  orreq r10,r10,#0x40000000 ;@ Get Z flag

  orr r1,r0,r11 ;@ Set bit

;@ EaWrite: Write r1 into '$33333333.l' (address in r8):
  and r1,r1,#0xff
  mov r0,r8
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0a00] eori.b #$33, d0 uses Op0a00 ----------
Op0a00:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

  mov r10,r10,asl #24
;@ Do arithmetic:
  eors r1,r10,r0,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: r1 into register[r11]:
  mov r1,r1,lsr #24
  strb r1,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0a10] eori.b #$33, (a0) uses Op0a10 ----------
Op0a10:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  eors r1,r10,r0,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  mov r1,r1,lsr #24
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0a18] eori.b #$33, (a0)+ uses Op0a18 ----------
Op0a18:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  eors r1,r10,r0,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  mov r1,r1,lsr #24
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0a1f] eori.b #$33, (a7)+ uses Op0a1f ----------
Op0a1f:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '(a7)+' into r11:
  ldr r11,[r7,#0x3c] ;@ A7
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  eors r1,r10,r0,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '(a7)+' (address in r11):
  mov r1,r1,lsr #24
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0a20] eori.b #$33, -(a0) uses Op0a20 ----------
Op0a20:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#1 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  eors r1,r10,r0,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r1,r1,lsr #24
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0a27] eori.b #$33, -(a7) uses Op0a27 ----------
Op0a27:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '-(a7)' into r11:
  ldr r11,[r7,#0x3c] ;@ A7
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  eors r1,r10,r0,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '-(a7)' (address in r11):
  mov r1,r1,lsr #24
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0a28] eori.b #$33, ($3333,a0) uses Op0a28 ----------
Op0a28:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  eors r1,r10,r0,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  mov r1,r1,lsr #24
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0a30] eori.b #$33, ($33,a0,d3.w*2) uses Op0a30 ----------
Op0a30:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  eors r1,r10,r0,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  mov r1,r1,lsr #24
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0a38] eori.b #$33, $3333.w uses Op0a38 ----------
Op0a38:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  eors r1,r10,r0,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  mov r1,r1,lsr #24
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0a39] eori.b #$33, $33333333.l uses Op0a39 ----------
Op0a39:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  eors r1,r10,r0,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  mov r1,r1,lsr #24
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0a3c] eori.b #$33, ccr uses Op0a3c ----------
Op0a3c:
;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  ldr r2,[r7,#0x4c]   ;@ Load old X bit
  eor r10,r10,r0,lsl #28
  eor r2,r2,r0,lsl #25 ;@ X bit
  str r2,[r7,#0x4c]   ;@ Save X bit

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0a40] eori.w #$3333, d0 uses Op0a40 ----------
Op0a40:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
  mov r11,r11,lsl #2
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11]

  mov r10,r10,asl #16
;@ Do arithmetic:
  eors r1,r10,r0,asl #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: r1 into register[r11]:
  mov r1,r1,lsr #16
  strh r1,[r7,r11]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0a50] eori.w #$3333, (a0) uses Op0a50 ----------
Op0a50:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler

  mov r10,r10,asl #16
;@ Do arithmetic:
  eors r1,r10,r0,asl #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  mov r1,r1,lsr #16
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0a58] eori.w #$3333, (a0)+ uses Op0a58 ----------
Op0a58:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler

  mov r10,r10,asl #16
;@ Do arithmetic:
  eors r1,r10,r0,asl #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  mov r1,r1,lsr #16
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0a60] eori.w #$3333, -(a0) uses Op0a60 ----------
Op0a60:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler

  mov r10,r10,asl #16
;@ Do arithmetic:
  eors r1,r10,r0,asl #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r1,r1,lsr #16
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0a68] eori.w #$3333, ($3333,a0) uses Op0a68 ----------
Op0a68:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler

  mov r10,r10,asl #16
;@ Do arithmetic:
  eors r1,r10,r0,asl #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  mov r1,r1,lsr #16
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0a70] eori.w #$3333, ($33,a0,d3.w*2) uses Op0a70 ----------
Op0a70:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler

  mov r10,r10,asl #16
;@ Do arithmetic:
  eors r1,r10,r0,asl #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  mov r1,r1,lsr #16
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0a78] eori.w #$3333, $3333.w uses Op0a78 ----------
Op0a78:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler

  mov r10,r10,asl #16
;@ Do arithmetic:
  eors r1,r10,r0,asl #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  mov r1,r1,lsr #16
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0a79] eori.w #$3333, $33333333.l uses Op0a79 ----------
Op0a79:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler

  mov r10,r10,asl #16
;@ Do arithmetic:
  eors r1,r10,r0,asl #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  mov r1,r1,lsr #16
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0a7c] eori.w #$3333, sr uses Op0a7c ----------
Op0a7c:
  ldr r11,[r7,#0x44] ;@ Get SR high
  tst r11,#0x20 ;@ Check we are in supervisor mode
  beq WrongPrivilegeMode ;@ No

;@ EaCalc : Get '#$3333' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r0) into r0:

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  ldr r2,[r7,#0x4c]   ;@ Load old X bit
  eor r10,r10,r0,lsl #28
  eor r2,r2,r0,lsl #25 ;@ X bit
  eor r1,r11,r0,lsr #8
  and r1,r1,#0xa7 ;@ mask-out unused bits
  str r2,[r7,#0x4c]   ;@ Save X bit
  strb r1,[r7,#0x44]

;@ A7 <-> OSP?
  eor r0,r1,r11
  tst r0,#0x20
  beq no_sp_swap0a7c
 ;@ swap OSP and A7:
  ldr r11,[r7,#0x3C] ;@ Get A7
  ldr r0, [r7,#0x48] ;@ Get OSP
  str r11,[r7,#0x48]
  str r0, [r7,#0x3C]
no_sp_swap0a7c:

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  ldr r1,[r7,#0x44]
  subs r5,r5,#20 ;@ Subtract cycles
;@ CheckTrace:
  tst r1,#0x80
  bne CycloneDoTraceWithChecks
  cmp r5,#0
  ble CycloneEnd
;@ CheckInterrupt:
  movs r0,r1,lsr #24 ;@ Get IRQ level
  ldreq pc,[r6,r8,asl #2] ;@ Jump to next opcode handler
  cmp r0,#6 ;@ irq>6 ?
  andle r1,r1,#7 ;@ Get interrupt mask
  cmple r0,r1 ;@ irq<=6: Is irq<=mask ?
  ldrle pc,[r6,r8,asl #2] ;@ Jump to next opcode handler
  b CycloneDoInterruptGoBack

;@ ---------- [0a80] eori.l #$33333333, d0 uses Op0a80 ----------
Op0a80:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

;@ Do arithmetic:
  eors r1,r10,r0
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0a90] eori.l #$33333333, (a0) uses Op0a90 ----------
Op0a90:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ Do arithmetic:
  eors r1,r10,r0
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  mov r0,r11
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0a98] eori.l #$33333333, (a0)+ uses Op0a98 ----------
Op0a98:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ Do arithmetic:
  eors r1,r10,r0
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  mov r0,r11
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0aa0] eori.l #$33333333, -(a0) uses Op0aa0 ----------
Op0aa0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#4 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ Do arithmetic:
  eors r1,r10,r0
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r0,r11
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#30 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0aa8] eori.l #$33333333, ($3333,a0) uses Op0aa8 ----------
Op0aa8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ Do arithmetic:
  eors r1,r10,r0
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  mov r0,r11
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#32 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0ab0] eori.l #$33333333, ($33,a0,d3.w*2) uses Op0ab0 ----------
Op0ab0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ Do arithmetic:
  eors r1,r10,r0
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  mov r0,r11
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#34 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0ab8] eori.l #$33333333, $3333.w uses Op0ab8 ----------
Op0ab8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ Do arithmetic:
  eors r1,r10,r0
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  mov r0,r11
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#32 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0ab9] eori.l #$33333333, $33333333.l uses Op0ab9 ----------
Op0ab9:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ Do arithmetic:
  eors r1,r10,r0
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  mov r0,r11
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#36 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0c00] cmpi.b #$33, d0 uses Op0c00 ----------
Op0c00:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r0:
  ldr r0,[r7,r0,lsl #2]

  mov r10,r10,asl #24
;@ Do arithmetic:
  rsbs r1,r10,r0,asl #24 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0c10] cmpi.b #$33, (a0) uses Op0c10 ----------
Op0c10:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  bl cyclone_read8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  rsbs r1,r10,r0,asl #24 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0c18] cmpi.b #$33, (a0)+ uses Op0c18 ----------
Op0c18:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  bl cyclone_read8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  rsbs r1,r10,r0,asl #24 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0c1f] cmpi.b #$33, (a7)+ uses Op0c1f ----------
Op0c1f:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r0) into r0:
  bl cyclone_read8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  rsbs r1,r10,r0,asl #24 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0c20] cmpi.b #$33, -(a0) uses Op0c20 ----------
Op0c20:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  bl cyclone_read8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  rsbs r1,r10,r0,asl #24 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0c27] cmpi.b #$33, -(a7) uses Op0c27 ----------
Op0c27:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r0) into r0:
  bl cyclone_read8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  rsbs r1,r10,r0,asl #24 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0c28] cmpi.b #$33, ($3333,a0) uses Op0c28 ----------
Op0c28:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  bl cyclone_read8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  rsbs r1,r10,r0,asl #24 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0c30] cmpi.b #$33, ($33,a0,d3.w*2) uses Op0c30 ----------
Op0c30:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  bl cyclone_read8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  rsbs r1,r10,r0,asl #24 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0c38] cmpi.b #$33, $3333.w uses Op0c38 ----------
Op0c38:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  bl cyclone_read8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  rsbs r1,r10,r0,asl #24 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0c39] cmpi.b #$33, $33333333.l uses Op0c39 ----------
Op0c39:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  bl cyclone_read8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  rsbs r1,r10,r0,asl #24 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0c50] cmpi.w #$3333, (a0) uses Op0c50 ----------
Op0c50:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  bl cyclone_read16 ;@ Call read16(r0) handler

  mov r10,r10,asl #16
;@ Do arithmetic:
  rsbs r1,r10,r0,asl #16 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0c58] cmpi.w #$3333, (a0)+ uses Op0c58 ----------
Op0c58:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  bl cyclone_read16 ;@ Call read16(r0) handler

  mov r10,r10,asl #16
;@ Do arithmetic:
  rsbs r1,r10,r0,asl #16 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0c60] cmpi.w #$3333, -(a0) uses Op0c60 ----------
Op0c60:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  bl cyclone_read16 ;@ Call read16(r0) handler

  mov r10,r10,asl #16
;@ Do arithmetic:
  rsbs r1,r10,r0,asl #16 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0c68] cmpi.w #$3333, ($3333,a0) uses Op0c68 ----------
Op0c68:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  bl cyclone_read16 ;@ Call read16(r0) handler

  mov r10,r10,asl #16
;@ Do arithmetic:
  rsbs r1,r10,r0,asl #16 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0c70] cmpi.w #$3333, ($33,a0,d3.w*2) uses Op0c70 ----------
Op0c70:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  bl cyclone_read16 ;@ Call read16(r0) handler

  mov r10,r10,asl #16
;@ Do arithmetic:
  rsbs r1,r10,r0,asl #16 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0c78] cmpi.w #$3333, $3333.w uses Op0c78 ----------
Op0c78:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  bl cyclone_read16 ;@ Call read16(r0) handler

  mov r10,r10,asl #16
;@ Do arithmetic:
  rsbs r1,r10,r0,asl #16 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0c80] cmpi.l #$33333333, d0 uses Op0c80 ----------
Op0c80:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r0:
  ldr r0,[r7,r0,lsl #2]

;@ Do arithmetic:
  rsbs r1,r10,r0 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0c90] cmpi.l #$33333333, (a0) uses Op0c90 ----------
Op0c90:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ Do arithmetic:
  rsbs r1,r10,r0 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0c98] cmpi.l #$33333333, (a0)+ uses Op0c98 ----------
Op0c98:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ Do arithmetic:
  rsbs r1,r10,r0 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0ca0] cmpi.l #$33333333, -(a0) uses Op0ca0 ----------
Op0ca0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ Do arithmetic:
  rsbs r1,r10,r0 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0ca8] cmpi.l #$33333333, ($3333,a0) uses Op0ca8 ----------
Op0ca8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ Do arithmetic:
  rsbs r1,r10,r0 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0cb0] cmpi.l #$33333333, ($33,a0,d3.w*2) uses Op0cb0 ----------
Op0cb0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ Do arithmetic:
  rsbs r1,r10,r0 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0cb8] cmpi.l #$33333333, $3333.w uses Op0cb8 ----------
Op0cb8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ Do arithmetic:
  rsbs r1,r10,r0 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [0cb9] cmpi.l #$33333333, $33333333.l uses Op0cb9 ----------
Op0cb9:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ Do arithmetic:
  rsbs r1,r10,r0 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1000] move.b d0, d0 uses Op1000 ----------
Op1000:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x000f
;@ EaRead : Read register[r1] into r1:
  ldrb r1,[r7,r1,lsl #2]

  movs r2,r1,lsl #24
  and r10,r2,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaWrite: r1 into register[r0]:
  strb r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1010] move.b (a0), d0 uses Op1010 ----------
Op1010:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r1:
  bl cyclone_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,lsr #24
  strb r1,[r7,r0,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [101f] move.b (a7)+, d0 uses Op101f ----------
Op101f:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r0) into r1:
  bl cyclone_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,lsr #24
  strb r1,[r7,r0,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1020] move.b -(a0), d0 uses Op1020 ----------
Op1020:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r1:
  bl cyclone_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,lsr #24
  strb r1,[r7,r0,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1027] move.b -(a7), d0 uses Op1027 ----------
Op1027:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r0) into r1:
  bl cyclone_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,lsr #24
  strb r1,[r7,r0,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1028] move.b ($3333,a0), d0 uses Op1028 ----------
Op1028:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  bl cyclone_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,lsr #24
  strb r1,[r7,r0,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1030] move.b ($33,a0,d3.w*2), d0 uses Op1030 ----------
Op1030:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r1:
  bl cyclone_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,lsr #24
  strb r1,[r7,r0,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1038] move.b $3333.w, d0 uses Op1038 ----------
Op1038:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r1:
  bl cyclone_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,lsr #24
  strb r1,[r7,r0,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [103a] move.b ($3333,pc), d0; =3335 uses Op103a ----------
Op103a:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r2,r0 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r1:
  bl cyclone_fetch8 ;@ Call fetch8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,lsr #24
  strb r1,[r7,r0,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [103b] move.b ($33,pc,d3.w*2), d0; =35 uses Op103b ----------
Op103b:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r1:
  bl cyclone_fetch8 ;@ Call fetch8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,lsr #24
  strb r1,[r7,r0,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [103c] move.b #$33, d0 uses Op103c ----------
Op103c:
;@ EaCalc : Get '#$33' into r1:
  ldrsb r1,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r1) into r1:
  movs r1,r1,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,lsr #24
  strb r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1080] move.b d0, (a0) uses Op1080 ----------
Op1080:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x000f
;@ EaRead : Read register[r1] into r1:
  ldrb r1,[r7,r1,lsl #2]

  movs r2,r1,lsl #24
  and r10,r2,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1090] move.b (a0), (a0) uses Op1090 ----------
Op1090:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r1:
  bl cyclone_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov r1,r1,lsr #24
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1098] move.b (a0)+, (a0) uses Op1098 ----------
Op1098:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r1:
  bl cyclone_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov r1,r1,lsr #24
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [109f] move.b (a7)+, (a0) uses Op109f ----------
Op109f:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r0) into r1:
  bl cyclone_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov r1,r1,lsr #24
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [10a0] move.b -(a0), (a0) uses Op10a0 ----------
Op10a0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r1:
  bl cyclone_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov r1,r1,lsr #24
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [10a7] move.b -(a7), (a0) uses Op10a7 ----------
Op10a7:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r0) into r1:
  bl cyclone_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov r1,r1,lsr #24
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [10a8] move.b ($3333,a0), (a0) uses Op10a8 ----------
Op10a8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  bl cyclone_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov r1,r1,lsr #24
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [10b0] move.b ($33,a0,d3.w*2), (a0) uses Op10b0 ----------
Op10b0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r1:
  bl cyclone_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov r1,r1,lsr #24
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [10b8] move.b $3333.w, (a0) uses Op10b8 ----------
Op10b8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r1:
  bl cyclone_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov r1,r1,lsr #24
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [10b9] move.b $33333333.l, (a0) uses Op10b9 ----------
Op10b9:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r1:
  bl cyclone_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov r1,r1,lsr #24
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [10ba] move.b ($3333,pc), (a0); =3335 uses Op10ba ----------
Op10ba:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r2,r0 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r1:
  bl cyclone_fetch8 ;@ Call fetch8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov r1,r1,lsr #24
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [10bb] move.b ($33,pc,d3.w*2), (a0); =35 uses Op10bb ----------
Op10bb:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r1:
  bl cyclone_fetch8 ;@ Call fetch8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov r1,r1,lsr #24
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [10bc] move.b #$33, (a0) uses Op10bc ----------
Op10bc:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33' into r1:
  ldrsb r1,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r1) into r1:
  movs r1,r1,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov r1,r1,lsr #24
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [10d0] move.b (a0), (a0)+ uses Op10d0 ----------
Op10d0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r1:
  bl cyclone_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov r1,r1,lsr #24
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [10df] move.b (a7)+, (a0)+ uses Op10df ----------
Op10df:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r0) into r1:
  bl cyclone_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov r1,r1,lsr #24
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [10e0] move.b -(a0), (a0)+ uses Op10e0 ----------
Op10e0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r1:
  bl cyclone_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov r1,r1,lsr #24
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [10e7] move.b -(a7), (a0)+ uses Op10e7 ----------
Op10e7:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r0) into r1:
  bl cyclone_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov r1,r1,lsr #24
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [10e8] move.b ($3333,a0), (a0)+ uses Op10e8 ----------
Op10e8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  bl cyclone_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov r1,r1,lsr #24
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [10f0] move.b ($33,a0,d3.w*2), (a0)+ uses Op10f0 ----------
Op10f0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r1:
  bl cyclone_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov r1,r1,lsr #24
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [10f8] move.b $3333.w, (a0)+ uses Op10f8 ----------
Op10f8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r1:
  bl cyclone_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov r1,r1,lsr #24
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [10f9] move.b $33333333.l, (a0)+ uses Op10f9 ----------
Op10f9:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r1:
  bl cyclone_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov r1,r1,lsr #24
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [10fa] move.b ($3333,pc), (a0)+; =3335 uses Op10fa ----------
Op10fa:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r2,r0 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r1:
  bl cyclone_fetch8 ;@ Call fetch8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov r1,r1,lsr #24
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [10fb] move.b ($33,pc,d3.w*2), (a0)+; =35 uses Op10fb ----------
Op10fb:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r1:
  bl cyclone_fetch8 ;@ Call fetch8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov r1,r1,lsr #24
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [10fc] move.b #$33, (a0)+ uses Op10fc ----------
Op10fc:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33' into r1:
  ldrsb r1,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r1) into r1:
  movs r1,r1,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov r1,r1,lsr #24
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1100] move.b d0, -(a0) uses Op1100 ----------
Op1100:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x000f
;@ EaRead : Read register[r1] into r1:
  ldrb r1,[r7,r1,lsl #2]

  movs r2,r1,lsl #24
  and r10,r2,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1110] move.b (a0), -(a0) uses Op1110 ----------
Op1110:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r1:
  bl cyclone_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov r1,r1,lsr #24
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1118] move.b (a0)+, -(a0) uses Op1118 ----------
Op1118:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r1:
  bl cyclone_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov r1,r1,lsr #24
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [111f] move.b (a7)+, -(a0) uses Op111f ----------
Op111f:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r0) into r1:
  bl cyclone_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov r1,r1,lsr #24
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1120] move.b -(a0), -(a0) uses Op1120 ----------
Op1120:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r1:
  bl cyclone_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov r1,r1,lsr #24
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1127] move.b -(a7), -(a0) uses Op1127 ----------
Op1127:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r0) into r1:
  bl cyclone_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov r1,r1,lsr #24
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1128] move.b ($3333,a0), -(a0) uses Op1128 ----------
Op1128:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  bl cyclone_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov r1,r1,lsr #24
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1130] move.b ($33,a0,d3.w*2), -(a0) uses Op1130 ----------
Op1130:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r1:
  bl cyclone_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov r1,r1,lsr #24
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1138] move.b $3333.w, -(a0) uses Op1138 ----------
Op1138:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r1:
  bl cyclone_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov r1,r1,lsr #24
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1139] move.b $33333333.l, -(a0) uses Op1139 ----------
Op1139:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r1:
  bl cyclone_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov r1,r1,lsr #24
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [113a] move.b ($3333,pc), -(a0); =3335 uses Op113a ----------
Op113a:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r2,r0 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r1:
  bl cyclone_fetch8 ;@ Call fetch8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov r1,r1,lsr #24
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [113b] move.b ($33,pc,d3.w*2), -(a0); =35 uses Op113b ----------
Op113b:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r1:
  bl cyclone_fetch8 ;@ Call fetch8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov r1,r1,lsr #24
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [113c] move.b #$33, -(a0) uses Op113c ----------
Op113c:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33' into r1:
  ldrsb r1,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r1) into r1:
  movs r1,r1,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov r1,r1,lsr #24
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1140] move.b d0, ($3333,a0) uses Op1140 ----------
Op1140:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x000f
;@ EaRead : Read register[r1] into r1:
  ldrb r1,[r7,r1,lsl #2]

  movs r2,r1,lsl #24
  and r10,r2,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x1e00
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1150] move.b (a0), ($3333,a0) uses Op1150 ----------
Op1150:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r1:
  bl cyclone_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x1e00
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov r1,r1,lsr #24
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1158] move.b (a0)+, ($3333,a0) uses Op1158 ----------
Op1158:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r1:
  bl cyclone_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x1e00
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov r1,r1,lsr #24
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [115f] move.b (a7)+, ($3333,a0) uses Op115f ----------
Op115f:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r0) into r1:
  bl cyclone_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x1e00
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov r1,r1,lsr #24
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1160] move.b -(a0), ($3333,a0) uses Op1160 ----------
Op1160:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r1:
  bl cyclone_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x1e00
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov r1,r1,lsr #24
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1167] move.b -(a7), ($3333,a0) uses Op1167 ----------
Op1167:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r0) into r1:
  bl cyclone_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x1e00
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov r1,r1,lsr #24
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1168] move.b ($3333,a0), ($3333,a0) uses Op1168 ----------
Op1168:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  bl cyclone_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x1e00
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov r1,r1,lsr #24
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1170] move.b ($33,a0,d3.w*2), ($3333,a0) uses Op1170 ----------
Op1170:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r1:
  bl cyclone_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x1e00
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov r1,r1,lsr #24
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1178] move.b $3333.w, ($3333,a0) uses Op1178 ----------
Op1178:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r1:
  bl cyclone_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x1e00
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov r1,r1,lsr #24
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1179] move.b $33333333.l, ($3333,a0) uses Op1179 ----------
Op1179:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r1:
  bl cyclone_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x1e00
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov r1,r1,lsr #24
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [117a] move.b ($3333,pc), ($3333,a0); =3335 uses Op117a ----------
Op117a:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r2,r0 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r1:
  bl cyclone_fetch8 ;@ Call fetch8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x1e00
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov r1,r1,lsr #24
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [117b] move.b ($33,pc,d3.w*2), ($3333,a0); =35 uses Op117b ----------
Op117b:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r1:
  bl cyclone_fetch8 ;@ Call fetch8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x1e00
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov r1,r1,lsr #24
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [117c] move.b #$33, ($3333,a0) uses Op117c ----------
Op117c:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33' into r1:
  ldrsb r1,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r1) into r1:
  movs r1,r1,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x1e00
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov r1,r1,lsr #24
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1180] move.b d0, ($33,a0,d3.w*2) uses Op1180 ----------
Op1180:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x000f
;@ EaRead : Read register[r1] into r1:
  ldrb r1,[r7,r1,lsl #2]

  movs r2,r1,lsl #24
  and r10,r2,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x1e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1190] move.b (a0), ($33,a0,d3.w*2) uses Op1190 ----------
Op1190:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r1:
  bl cyclone_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x1e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov r1,r1,lsr #24
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [119f] move.b (a7)+, ($33,a0,d3.w*2) uses Op119f ----------
Op119f:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r0) into r1:
  bl cyclone_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x1e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov r1,r1,lsr #24
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [11a0] move.b -(a0), ($33,a0,d3.w*2) uses Op11a0 ----------
Op11a0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r1:
  bl cyclone_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x1e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov r1,r1,lsr #24
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [11a7] move.b -(a7), ($33,a0,d3.w*2) uses Op11a7 ----------
Op11a7:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r0) into r1:
  bl cyclone_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x1e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov r1,r1,lsr #24
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [11a8] move.b ($3333,a0), ($33,a0,d3.w*2) uses Op11a8 ----------
Op11a8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  bl cyclone_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x1e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov r1,r1,lsr #24
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [11b0] move.b ($33,a0,d3.w*2), ($33,a0,d3.w*2) uses Op11b0 ----------
Op11b0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r1:
  bl cyclone_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x1e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov r1,r1,lsr #24
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [11b8] move.b $3333.w, ($33,a0,d3.w*2) uses Op11b8 ----------
Op11b8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r1:
  bl cyclone_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x1e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov r1,r1,lsr #24
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [11b9] move.b $33333333.l, ($33,a0,d3.w*2) uses Op11b9 ----------
Op11b9:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r1:
  bl cyclone_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x1e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov r1,r1,lsr #24
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [11ba] move.b ($3333,pc), ($33,a0,d3.w*2); =3335 uses Op11ba ----------
Op11ba:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r2,r0 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r1:
  bl cyclone_fetch8 ;@ Call fetch8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x1e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov r1,r1,lsr #24
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [11bb] move.b ($33,pc,d3.w*2), ($33,a0,d3.w*2); =35 uses Op11bb ----------
Op11bb:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r1:
  bl cyclone_fetch8 ;@ Call fetch8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x1e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov r1,r1,lsr #24
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [11bc] move.b #$33, ($33,a0,d3.w*2) uses Op11bc ----------
Op11bc:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33' into r1:
  ldrsb r1,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r1) into r1:
  movs r1,r1,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x1e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov r1,r1,lsr #24
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [11c0] move.b d0, $3333.w uses Op11c0 ----------
Op11c0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x000f
;@ EaRead : Read register[r1] into r1:
  ldrb r1,[r7,r1,lsl #2]

  movs r2,r1,lsl #24
  and r10,r2,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [11d0] move.b (a0), $3333.w uses Op11d0 ----------
Op11d0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r1:
  bl cyclone_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov r1,r1,lsr #24
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [11d8] move.b (a0)+, $3333.w uses Op11d8 ----------
Op11d8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r1:
  bl cyclone_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov r1,r1,lsr #24
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [11df] move.b (a7)+, $3333.w uses Op11df ----------
Op11df:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r0) into r1:
  bl cyclone_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov r1,r1,lsr #24
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [11e0] move.b -(a0), $3333.w uses Op11e0 ----------
Op11e0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r1:
  bl cyclone_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov r1,r1,lsr #24
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [11e7] move.b -(a7), $3333.w uses Op11e7 ----------
Op11e7:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r0) into r1:
  bl cyclone_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov r1,r1,lsr #24
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [11e8] move.b ($3333,a0), $3333.w uses Op11e8 ----------
Op11e8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  bl cyclone_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov r1,r1,lsr #24
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [11f0] move.b ($33,a0,d3.w*2), $3333.w uses Op11f0 ----------
Op11f0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r1:
  bl cyclone_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov r1,r1,lsr #24
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [11f8] move.b $3333.w, $3333.w uses Op11f8 ----------
Op11f8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r1:
  bl cyclone_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov r1,r1,lsr #24
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [11f9] move.b $33333333.l, $3333.w uses Op11f9 ----------
Op11f9:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r1:
  bl cyclone_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov r1,r1,lsr #24
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [11fa] move.b ($3333,pc), $3333.w; =3335 uses Op11fa ----------
Op11fa:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r2,r0 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r1:
  bl cyclone_fetch8 ;@ Call fetch8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov r1,r1,lsr #24
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [11fb] move.b ($33,pc,d3.w*2), $3333.w; =35 uses Op11fb ----------
Op11fb:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r1:
  bl cyclone_fetch8 ;@ Call fetch8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov r1,r1,lsr #24
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [11fc] move.b #$33, $3333.w uses Op11fc ----------
Op11fc:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33' into r1:
  ldrsb r1,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r1) into r1:
  movs r1,r1,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov r1,r1,lsr #24
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [13c0] move.b d0, $33333333.l uses Op13c0 ----------
Op13c0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x000f
;@ EaRead : Read register[r1] into r1:
  ldrb r1,[r7,r1,lsl #2]

  movs r2,r1,lsl #24
  and r10,r2,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [13d0] move.b (a0), $33333333.l uses Op13d0 ----------
Op13d0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r1:
  bl cyclone_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov r1,r1,lsr #24
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [13d8] move.b (a0)+, $33333333.l uses Op13d8 ----------
Op13d8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r1:
  bl cyclone_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov r1,r1,lsr #24
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [13df] move.b (a7)+, $33333333.l uses Op13df ----------
Op13df:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r0) into r1:
  bl cyclone_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov r1,r1,lsr #24
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [13e0] move.b -(a0), $33333333.l uses Op13e0 ----------
Op13e0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r1:
  bl cyclone_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov r1,r1,lsr #24
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [13e7] move.b -(a7), $33333333.l uses Op13e7 ----------
Op13e7:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r0) into r1:
  bl cyclone_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov r1,r1,lsr #24
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [13e8] move.b ($3333,a0), $33333333.l uses Op13e8 ----------
Op13e8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  bl cyclone_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov r1,r1,lsr #24
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [13f0] move.b ($33,a0,d3.w*2), $33333333.l uses Op13f0 ----------
Op13f0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r1:
  bl cyclone_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov r1,r1,lsr #24
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [13f8] move.b $3333.w, $33333333.l uses Op13f8 ----------
Op13f8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r1:
  bl cyclone_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov r1,r1,lsr #24
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [13f9] move.b $33333333.l, $33333333.l uses Op13f9 ----------
Op13f9:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r1:
  bl cyclone_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov r1,r1,lsr #24
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [13fa] move.b ($3333,pc), $33333333.l; =3335 uses Op13fa ----------
Op13fa:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r2,r0 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r1:
  bl cyclone_fetch8 ;@ Call fetch8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov r1,r1,lsr #24
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [13fb] move.b ($33,pc,d3.w*2), $33333333.l; =35 uses Op13fb ----------
Op13fb:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r1:
  bl cyclone_fetch8 ;@ Call fetch8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov r1,r1,lsr #24
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [13fc] move.b #$33, $33333333.l uses Op13fc ----------
Op13fc:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33' into r1:
  ldrsb r1,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r1) into r1:
  movs r1,r1,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov r1,r1,lsr #24
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1ec0] move.b d0, (a7)+ uses Op1ec0 ----------
Op1ec0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x000f
;@ EaRead : Read register[r1] into r1:
  ldrb r1,[r7,r1,lsl #2]

  movs r2,r1,lsl #24
  and r10,r2,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1ed0] move.b (a0), (a7)+ uses Op1ed0 ----------
Op1ed0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r1:
  bl cyclone_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov r1,r1,lsr #24
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1ed8] move.b (a0)+, (a7)+ uses Op1ed8 ----------
Op1ed8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r1:
  bl cyclone_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov r1,r1,lsr #24
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1edf] move.b (a7)+, (a7)+ uses Op1edf ----------
Op1edf:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r0) into r1:
  bl cyclone_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov r1,r1,lsr #24
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1ee0] move.b -(a0), (a7)+ uses Op1ee0 ----------
Op1ee0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r1:
  bl cyclone_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov r1,r1,lsr #24
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1ee7] move.b -(a7), (a7)+ uses Op1ee7 ----------
Op1ee7:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r0) into r1:
  bl cyclone_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov r1,r1,lsr #24
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1ee8] move.b ($3333,a0), (a7)+ uses Op1ee8 ----------
Op1ee8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  bl cyclone_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov r1,r1,lsr #24
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1ef0] move.b ($33,a0,d3.w*2), (a7)+ uses Op1ef0 ----------
Op1ef0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r1:
  bl cyclone_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov r1,r1,lsr #24
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1ef8] move.b $3333.w, (a7)+ uses Op1ef8 ----------
Op1ef8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r1:
  bl cyclone_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov r1,r1,lsr #24
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1ef9] move.b $33333333.l, (a7)+ uses Op1ef9 ----------
Op1ef9:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r1:
  bl cyclone_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov r1,r1,lsr #24
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1efa] move.b ($3333,pc), (a7)+; =3335 uses Op1efa ----------
Op1efa:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r2,r0 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r1:
  bl cyclone_fetch8 ;@ Call fetch8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov r1,r1,lsr #24
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1efb] move.b ($33,pc,d3.w*2), (a7)+; =35 uses Op1efb ----------
Op1efb:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r1:
  bl cyclone_fetch8 ;@ Call fetch8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov r1,r1,lsr #24
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1efc] move.b #$33, (a7)+ uses Op1efc ----------
Op1efc:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33' into r1:
  ldrsb r1,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r1) into r1:
  movs r1,r1,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov r1,r1,lsr #24
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1f00] move.b d0, -(a7) uses Op1f00 ----------
Op1f00:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x000f
;@ EaRead : Read register[r1] into r1:
  ldrb r1,[r7,r1,lsl #2]

  movs r2,r1,lsl #24
  and r10,r2,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1f10] move.b (a0), -(a7) uses Op1f10 ----------
Op1f10:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r1:
  bl cyclone_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov r1,r1,lsr #24
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1f18] move.b (a0)+, -(a7) uses Op1f18 ----------
Op1f18:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r1:
  bl cyclone_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov r1,r1,lsr #24
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1f1f] move.b (a7)+, -(a7) uses Op1f1f ----------
Op1f1f:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r0) into r1:
  bl cyclone_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov r1,r1,lsr #24
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1f20] move.b -(a0), -(a7) uses Op1f20 ----------
Op1f20:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r1:
  bl cyclone_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov r1,r1,lsr #24
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1f27] move.b -(a7), -(a7) uses Op1f27 ----------
Op1f27:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r0) into r1:
  bl cyclone_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov r1,r1,lsr #24
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1f28] move.b ($3333,a0), -(a7) uses Op1f28 ----------
Op1f28:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  bl cyclone_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov r1,r1,lsr #24
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1f30] move.b ($33,a0,d3.w*2), -(a7) uses Op1f30 ----------
Op1f30:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r1:
  bl cyclone_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov r1,r1,lsr #24
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1f38] move.b $3333.w, -(a7) uses Op1f38 ----------
Op1f38:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r1:
  bl cyclone_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov r1,r1,lsr #24
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1f39] move.b $33333333.l, -(a7) uses Op1f39 ----------
Op1f39:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r1:
  bl cyclone_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov r1,r1,lsr #24
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1f3a] move.b ($3333,pc), -(a7); =3335 uses Op1f3a ----------
Op1f3a:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r2,r0 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r1:
  bl cyclone_fetch8 ;@ Call fetch8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov r1,r1,lsr #24
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1f3b] move.b ($33,pc,d3.w*2), -(a7); =35 uses Op1f3b ----------
Op1f3b:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r1:
  bl cyclone_fetch8 ;@ Call fetch8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov r1,r1,lsr #24
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [1f3c] move.b #$33, -(a7) uses Op1f3c ----------
Op1f3c:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33' into r1:
  ldrsb r1,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r1) into r1:
  movs r1,r1,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov r1,r1,lsr #24
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2000] move.l d0, d0 uses Op2000 ----------
Op2000:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x000f
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsl #2]
  tst r1,r1

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2010] move.l (a0), d0 uses Op2010 ----------
Op2010:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r1:
  bl cyclone_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2018] move.l (a0)+, d0 uses Op2018 ----------
Op2018:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r1:
  bl cyclone_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2020] move.l -(a0), d0 uses Op2020 ----------
Op2020:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r1:
  bl cyclone_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2028] move.l ($3333,a0), d0 uses Op2028 ----------
Op2028:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  bl cyclone_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2030] move.l ($33,a0,d3.w*2), d0 uses Op2030 ----------
Op2030:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r1:
  bl cyclone_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2039] move.l $33333333.l, d0 uses Op2039 ----------
Op2039:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r1:
  bl cyclone_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [203a] move.l ($3333,pc), d0; =3335 uses Op203a ----------
Op203a:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r2,r0 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r1:
  bl cyclone_fetch32 ;@ Call fetch32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [203b] move.l ($33,pc,d3.w*2), d0; =35 uses Op203b ----------
Op203b:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r1:
  bl cyclone_fetch32 ;@ Call fetch32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [203c] move.l #$33333333, d0 uses Op203c ----------
Op203c:
;@ EaCalc : Get '#$33333333' into r1:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r1,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r1) into r1:
  tst r1,r1

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2040] movea.l d0, a0 uses Op2040 ----------
Op2040:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x000f
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsl #2]

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2050] movea.l (a0), a0 uses Op2050 ----------
Op2050:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r1:
  bl cyclone_read32 ;@ Call read32(r0) handler
  mov r1,r0

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2058] movea.l (a0)+, a0 uses Op2058 ----------
Op2058:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r1:
  bl cyclone_read32 ;@ Call read32(r0) handler
  mov r1,r0

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2060] movea.l -(a0), a0 uses Op2060 ----------
Op2060:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r1:
  bl cyclone_read32 ;@ Call read32(r0) handler
  mov r1,r0

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2068] movea.l ($3333,a0), a0 uses Op2068 ----------
Op2068:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  bl cyclone_read32 ;@ Call read32(r0) handler
  mov r1,r0

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2070] movea.l ($33,a0,d3.w*2), a0 uses Op2070 ----------
Op2070:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r1:
  bl cyclone_read32 ;@ Call read32(r0) handler
  mov r1,r0

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2078] movea.l $3333.w, a0 uses Op2078 ----------
Op2078:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r1:
  bl cyclone_read32 ;@ Call read32(r0) handler
  mov r1,r0

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2079] movea.l $33333333.l, a0 uses Op2079 ----------
Op2079:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r1:
  bl cyclone_read32 ;@ Call read32(r0) handler
  mov r1,r0

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [207a] movea.l ($3333,pc), a0; =3335 uses Op207a ----------
Op207a:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r2,r0 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r1:
  bl cyclone_fetch32 ;@ Call fetch32(r0) handler
  mov r1,r0

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [207b] movea.l ($33,pc,d3.w*2), a0; =35 uses Op207b ----------
Op207b:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r1:
  bl cyclone_fetch32 ;@ Call fetch32(r0) handler
  mov r1,r0

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [207c] movea.l #$33333333, a0 uses Op207c ----------
Op207c:
;@ EaCalc : Get '#$33333333' into r1:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r1,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r1) into r1:

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2080] move.l d0, (a0) uses Op2080 ----------
Op2080:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x000f
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsl #2]
  tst r1,r1

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2090] move.l (a0), (a0) uses Op2090 ----------
Op2090:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r1:
  bl cyclone_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2098] move.l (a0)+, (a0) uses Op2098 ----------
Op2098:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r1:
  bl cyclone_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [20a0] move.l -(a0), (a0) uses Op20a0 ----------
Op20a0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r1:
  bl cyclone_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [20a8] move.l ($3333,a0), (a0) uses Op20a8 ----------
Op20a8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  bl cyclone_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [20b0] move.l ($33,a0,d3.w*2), (a0) uses Op20b0 ----------
Op20b0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r1:
  bl cyclone_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [20b8] move.l $3333.w, (a0) uses Op20b8 ----------
Op20b8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r1:
  bl cyclone_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [20b9] move.l $33333333.l, (a0) uses Op20b9 ----------
Op20b9:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r1:
  bl cyclone_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [20ba] move.l ($3333,pc), (a0); =3335 uses Op20ba ----------
Op20ba:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r2,r0 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r1:
  bl cyclone_fetch32 ;@ Call fetch32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [20bb] move.l ($33,pc,d3.w*2), (a0); =35 uses Op20bb ----------
Op20bb:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r1:
  bl cyclone_fetch32 ;@ Call fetch32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [20bc] move.l #$33333333, (a0) uses Op20bc ----------
Op20bc:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33333333' into r1:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r1,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r1) into r1:
  tst r1,r1

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [20d0] move.l (a0), (a0)+ uses Op20d0 ----------
Op20d0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r1:
  bl cyclone_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [20d8] move.l (a0)+, (a0)+ uses Op20d8 ----------
Op20d8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r1:
  bl cyclone_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [20e0] move.l -(a0), (a0)+ uses Op20e0 ----------
Op20e0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r1:
  bl cyclone_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [20e8] move.l ($3333,a0), (a0)+ uses Op20e8 ----------
Op20e8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  bl cyclone_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [20f0] move.l ($33,a0,d3.w*2), (a0)+ uses Op20f0 ----------
Op20f0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r1:
  bl cyclone_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [20f8] move.l $3333.w, (a0)+ uses Op20f8 ----------
Op20f8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r1:
  bl cyclone_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [20f9] move.l $33333333.l, (a0)+ uses Op20f9 ----------
Op20f9:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r1:
  bl cyclone_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [20fa] move.l ($3333,pc), (a0)+; =3335 uses Op20fa ----------
Op20fa:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r2,r0 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r1:
  bl cyclone_fetch32 ;@ Call fetch32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [20fb] move.l ($33,pc,d3.w*2), (a0)+; =35 uses Op20fb ----------
Op20fb:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r1:
  bl cyclone_fetch32 ;@ Call fetch32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [20fc] move.l #$33333333, (a0)+ uses Op20fc ----------
Op20fc:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33333333' into r1:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r1,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r1) into r1:
  tst r1,r1

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2100] move.l d0, -(a0) uses Op2100 ----------
Op2100:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x000f
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsl #2]
  tst r1,r1

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a0)' into r8:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r8,[r7,r2,lsr #7]
  sub r8,r8,#4 ;@ Pre-decrement An
  str r8,[r7,r2,lsr #7]
  mov r11,r1
  add r0,r8,#2
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  uxth r1,r1 ;@ zero extend
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

;@ EaWrite: Write r11 into '-(a0)' (address in r8):
  mov r1,r11,lsr #16
  mov r0,r8
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2110] move.l (a0), -(a0) uses Op2110 ----------
Op2110:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r1:
  bl cyclone_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a0)' into r8:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r8,[r7,r2,lsr #7]
  sub r8,r8,#4 ;@ Pre-decrement An
  str r8,[r7,r2,lsr #7]
  mov r11,r1
  add r0,r8,#2
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  uxth r1,r1 ;@ zero extend
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

;@ EaWrite: Write r11 into '-(a0)' (address in r8):
  mov r1,r11,lsr #16
  mov r0,r8
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2118] move.l (a0)+, -(a0) uses Op2118 ----------
Op2118:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r1:
  bl cyclone_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a0)' into r8:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r8,[r7,r2,lsr #7]
  sub r8,r8,#4 ;@ Pre-decrement An
  str r8,[r7,r2,lsr #7]
  mov r11,r1
  add r0,r8,#2
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  uxth r1,r1 ;@ zero extend
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

;@ EaWrite: Write r11 into '-(a0)' (address in r8):
  mov r1,r11,lsr #16
  mov r0,r8
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2120] move.l -(a0), -(a0) uses Op2120 ----------
Op2120:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r1:
  bl cyclone_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a0)' into r8:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r8,[r7,r2,lsr #7]
  sub r8,r8,#4 ;@ Pre-decrement An
  str r8,[r7,r2,lsr #7]
  mov r11,r1
  add r0,r8,#2
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  uxth r1,r1 ;@ zero extend
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

;@ EaWrite: Write r11 into '-(a0)' (address in r8):
  mov r1,r11,lsr #16
  mov r0,r8
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2128] move.l ($3333,a0), -(a0) uses Op2128 ----------
Op2128:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  bl cyclone_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a0)' into r8:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r8,[r7,r2,lsr #7]
  sub r8,r8,#4 ;@ Pre-decrement An
  str r8,[r7,r2,lsr #7]
  mov r11,r1
  add r0,r8,#2
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  uxth r1,r1 ;@ zero extend
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

;@ EaWrite: Write r11 into '-(a0)' (address in r8):
  mov r1,r11,lsr #16
  mov r0,r8
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2130] move.l ($33,a0,d3.w*2), -(a0) uses Op2130 ----------
Op2130:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r1:
  bl cyclone_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a0)' into r8:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r8,[r7,r2,lsr #7]
  sub r8,r8,#4 ;@ Pre-decrement An
  str r8,[r7,r2,lsr #7]
  mov r11,r1
  add r0,r8,#2
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  uxth r1,r1 ;@ zero extend
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

;@ EaWrite: Write r11 into '-(a0)' (address in r8):
  mov r1,r11,lsr #16
  mov r0,r8
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2138] move.l $3333.w, -(a0) uses Op2138 ----------
Op2138:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r1:
  bl cyclone_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a0)' into r8:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r8,[r7,r2,lsr #7]
  sub r8,r8,#4 ;@ Pre-decrement An
  str r8,[r7,r2,lsr #7]
  mov r11,r1
  add r0,r8,#2
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  uxth r1,r1 ;@ zero extend
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

;@ EaWrite: Write r11 into '-(a0)' (address in r8):
  mov r1,r11,lsr #16
  mov r0,r8
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2139] move.l $33333333.l, -(a0) uses Op2139 ----------
Op2139:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r1:
  bl cyclone_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a0)' into r8:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r8,[r7,r2,lsr #7]
  sub r8,r8,#4 ;@ Pre-decrement An
  str r8,[r7,r2,lsr #7]
  mov r11,r1
  add r0,r8,#2
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  uxth r1,r1 ;@ zero extend
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

;@ EaWrite: Write r11 into '-(a0)' (address in r8):
  mov r1,r11,lsr #16
  mov r0,r8
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [213a] move.l ($3333,pc), -(a0); =3335 uses Op213a ----------
Op213a:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r2,r0 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r1:
  bl cyclone_fetch32 ;@ Call fetch32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a0)' into r8:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r8,[r7,r2,lsr #7]
  sub r8,r8,#4 ;@ Pre-decrement An
  str r8,[r7,r2,lsr #7]
  mov r11,r1
  add r0,r8,#2
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  uxth r1,r1 ;@ zero extend
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

;@ EaWrite: Write r11 into '-(a0)' (address in r8):
  mov r1,r11,lsr #16
  mov r0,r8
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [213b] move.l ($33,pc,d3.w*2), -(a0); =35 uses Op213b ----------
Op213b:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r1:
  bl cyclone_fetch32 ;@ Call fetch32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a0)' into r8:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r8,[r7,r2,lsr #7]
  sub r8,r8,#4 ;@ Pre-decrement An
  str r8,[r7,r2,lsr #7]
  mov r11,r1
  add r0,r8,#2
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  uxth r1,r1 ;@ zero extend
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

;@ EaWrite: Write r11 into '-(a0)' (address in r8):
  mov r1,r11,lsr #16
  mov r0,r8
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [213c] move.l #$33333333, -(a0) uses Op213c ----------
Op213c:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33333333' into r1:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r1,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r1) into r1:
  tst r1,r1

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a0)' into r8:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r8,[r7,r2,lsr #7]
  sub r8,r8,#4 ;@ Pre-decrement An
  str r8,[r7,r2,lsr #7]
  mov r11,r1
  add r0,r8,#2
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  uxth r1,r1 ;@ zero extend
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

;@ EaWrite: Write r11 into '-(a0)' (address in r8):
  mov r1,r11,lsr #16
  mov r0,r8
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2140] move.l d0, ($3333,a0) uses Op2140 ----------
Op2140:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x000f
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsl #2]
  tst r1,r1

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2150] move.l (a0), ($3333,a0) uses Op2150 ----------
Op2150:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r1:
  bl cyclone_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2158] move.l (a0)+, ($3333,a0) uses Op2158 ----------
Op2158:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r1:
  bl cyclone_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2160] move.l -(a0), ($3333,a0) uses Op2160 ----------
Op2160:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r1:
  bl cyclone_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2168] move.l ($3333,a0), ($3333,a0) uses Op2168 ----------
Op2168:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  bl cyclone_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2170] move.l ($33,a0,d3.w*2), ($3333,a0) uses Op2170 ----------
Op2170:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r1:
  bl cyclone_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#30 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2178] move.l $3333.w, ($3333,a0) uses Op2178 ----------
Op2178:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r1:
  bl cyclone_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2179] move.l $33333333.l, ($3333,a0) uses Op2179 ----------
Op2179:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r1:
  bl cyclone_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#32 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [217a] move.l ($3333,pc), ($3333,a0); =3335 uses Op217a ----------
Op217a:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r2,r0 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r1:
  bl cyclone_fetch32 ;@ Call fetch32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [217b] move.l ($33,pc,d3.w*2), ($3333,a0); =35 uses Op217b ----------
Op217b:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r1:
  bl cyclone_fetch32 ;@ Call fetch32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#30 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [217c] move.l #$33333333, ($3333,a0) uses Op217c ----------
Op217c:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33333333' into r1:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r1,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r1) into r1:
  tst r1,r1

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2180] move.l d0, ($33,a0,d3.w*2) uses Op2180 ----------
Op2180:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x000f
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsl #2]
  tst r1,r1

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2190] move.l (a0), ($33,a0,d3.w*2) uses Op2190 ----------
Op2190:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r1:
  bl cyclone_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2198] move.l (a0)+, ($33,a0,d3.w*2) uses Op2198 ----------
Op2198:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r1:
  bl cyclone_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [21a0] move.l -(a0), ($33,a0,d3.w*2) uses Op21a0 ----------
Op21a0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r1:
  bl cyclone_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [21a8] move.l ($3333,a0), ($33,a0,d3.w*2) uses Op21a8 ----------
Op21a8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  bl cyclone_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#30 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [21b0] move.l ($33,a0,d3.w*2), ($33,a0,d3.w*2) uses Op21b0 ----------
Op21b0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r1:
  bl cyclone_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#32 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [21b8] move.l $3333.w, ($33,a0,d3.w*2) uses Op21b8 ----------
Op21b8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r1:
  bl cyclone_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#30 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [21b9] move.l $33333333.l, ($33,a0,d3.w*2) uses Op21b9 ----------
Op21b9:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r1:
  bl cyclone_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#34 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [21ba] move.l ($3333,pc), ($33,a0,d3.w*2); =3335 uses Op21ba ----------
Op21ba:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r2,r0 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r1:
  bl cyclone_fetch32 ;@ Call fetch32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#30 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [21bb] move.l ($33,pc,d3.w*2), ($33,a0,d3.w*2); =35 uses Op21bb ----------
Op21bb:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r1:
  bl cyclone_fetch32 ;@ Call fetch32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#32 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [21bc] move.l #$33333333, ($33,a0,d3.w*2) uses Op21bc ----------
Op21bc:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33333333' into r1:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r1,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r1) into r1:
  tst r1,r1

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [21c0] move.l d0, $3333.w uses Op21c0 ----------
Op21c0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x000f
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsl #2]
  tst r1,r1

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [21d0] move.l (a0), $3333.w uses Op21d0 ----------
Op21d0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r1:
  bl cyclone_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [21d8] move.l (a0)+, $3333.w uses Op21d8 ----------
Op21d8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r1:
  bl cyclone_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [21e0] move.l -(a0), $3333.w uses Op21e0 ----------
Op21e0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r1:
  bl cyclone_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [21e8] move.l ($3333,a0), $3333.w uses Op21e8 ----------
Op21e8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  bl cyclone_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [21f0] move.l ($33,a0,d3.w*2), $3333.w uses Op21f0 ----------
Op21f0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r1:
  bl cyclone_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#30 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [21f8] move.l $3333.w, $3333.w uses Op21f8 ----------
Op21f8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r1:
  bl cyclone_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [21f9] move.l $33333333.l, $3333.w uses Op21f9 ----------
Op21f9:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r1:
  bl cyclone_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#32 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [21fa] move.l ($3333,pc), $3333.w; =3335 uses Op21fa ----------
Op21fa:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r2,r0 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r1:
  bl cyclone_fetch32 ;@ Call fetch32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [21fb] move.l ($33,pc,d3.w*2), $3333.w; =35 uses Op21fb ----------
Op21fb:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r1:
  bl cyclone_fetch32 ;@ Call fetch32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#30 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [21fc] move.l #$33333333, $3333.w uses Op21fc ----------
Op21fc:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33333333' into r1:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r1,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r1) into r1:
  tst r1,r1

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [23c0] move.l d0, $33333333.l uses Op23c0 ----------
Op23c0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x000f
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsl #2]
  tst r1,r1

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [23d0] move.l (a0), $33333333.l uses Op23d0 ----------
Op23d0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r1:
  bl cyclone_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [23d8] move.l (a0)+, $33333333.l uses Op23d8 ----------
Op23d8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r1:
  bl cyclone_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [23e0] move.l -(a0), $33333333.l uses Op23e0 ----------
Op23e0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r1:
  bl cyclone_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#30 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [23e8] move.l ($3333,a0), $33333333.l uses Op23e8 ----------
Op23e8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  bl cyclone_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#32 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [23f0] move.l ($33,a0,d3.w*2), $33333333.l uses Op23f0 ----------
Op23f0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r1:
  bl cyclone_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#34 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [23f8] move.l $3333.w, $33333333.l uses Op23f8 ----------
Op23f8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r1:
  bl cyclone_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#32 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [23f9] move.l $33333333.l, $33333333.l uses Op23f9 ----------
Op23f9:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r1:
  bl cyclone_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#36 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [23fa] move.l ($3333,pc), $33333333.l; =3335 uses Op23fa ----------
Op23fa:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r2,r0 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r1:
  bl cyclone_fetch32 ;@ Call fetch32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#32 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [23fb] move.l ($33,pc,d3.w*2), $33333333.l; =35 uses Op23fb ----------
Op23fb:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r1:
  bl cyclone_fetch32 ;@ Call fetch32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#34 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [23fc] move.l #$33333333, $33333333.l uses Op23fc ----------
Op23fc:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33333333' into r1:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r1,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r1) into r1:
  tst r1,r1

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2ec0] move.l d0, (a7)+ uses Op2ec0 ----------
Op2ec0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x000f
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsl #2]
  tst r1,r1

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2ed0] move.l (a0), (a7)+ uses Op2ed0 ----------
Op2ed0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r1:
  bl cyclone_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2ed8] move.l (a0)+, (a7)+ uses Op2ed8 ----------
Op2ed8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r1:
  bl cyclone_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2ee0] move.l -(a0), (a7)+ uses Op2ee0 ----------
Op2ee0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r1:
  bl cyclone_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2ee8] move.l ($3333,a0), (a7)+ uses Op2ee8 ----------
Op2ee8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  bl cyclone_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2ef0] move.l ($33,a0,d3.w*2), (a7)+ uses Op2ef0 ----------
Op2ef0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r1:
  bl cyclone_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2ef8] move.l $3333.w, (a7)+ uses Op2ef8 ----------
Op2ef8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r1:
  bl cyclone_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2ef9] move.l $33333333.l, (a7)+ uses Op2ef9 ----------
Op2ef9:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r1:
  bl cyclone_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2efa] move.l ($3333,pc), (a7)+; =3335 uses Op2efa ----------
Op2efa:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r2,r0 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r1:
  bl cyclone_fetch32 ;@ Call fetch32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2efb] move.l ($33,pc,d3.w*2), (a7)+; =35 uses Op2efb ----------
Op2efb:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r1:
  bl cyclone_fetch32 ;@ Call fetch32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2efc] move.l #$33333333, (a7)+ uses Op2efc ----------
Op2efc:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33333333' into r1:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r1,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r1) into r1:
  tst r1,r1

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2f00] move.l d0, -(a7) uses Op2f00 ----------
Op2f00:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x000f
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsl #2]
  tst r1,r1

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a7)' into r8:
  ldr r8,[r7,#0x3c] ;@ A7
  sub r8,r8,#4 ;@ Pre-decrement An
  str r8,[r7,#0x3c] ;@ A7
  mov r11,r1
  add r0,r8,#2
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  uxth r1,r1 ;@ zero extend
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

;@ EaWrite: Write r11 into '-(a7)' (address in r8):
  mov r1,r11,lsr #16
  mov r0,r8
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2f10] move.l (a0), -(a7) uses Op2f10 ----------
Op2f10:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r1:
  bl cyclone_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a7)' into r8:
  ldr r8,[r7,#0x3c] ;@ A7
  sub r8,r8,#4 ;@ Pre-decrement An
  str r8,[r7,#0x3c] ;@ A7
  mov r11,r1
  add r0,r8,#2
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  uxth r1,r1 ;@ zero extend
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

;@ EaWrite: Write r11 into '-(a7)' (address in r8):
  mov r1,r11,lsr #16
  mov r0,r8
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2f18] move.l (a0)+, -(a7) uses Op2f18 ----------
Op2f18:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r1:
  bl cyclone_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a7)' into r8:
  ldr r8,[r7,#0x3c] ;@ A7
  sub r8,r8,#4 ;@ Pre-decrement An
  str r8,[r7,#0x3c] ;@ A7
  mov r11,r1
  add r0,r8,#2
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  uxth r1,r1 ;@ zero extend
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

;@ EaWrite: Write r11 into '-(a7)' (address in r8):
  mov r1,r11,lsr #16
  mov r0,r8
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2f20] move.l -(a0), -(a7) uses Op2f20 ----------
Op2f20:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r1:
  bl cyclone_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a7)' into r8:
  ldr r8,[r7,#0x3c] ;@ A7
  sub r8,r8,#4 ;@ Pre-decrement An
  str r8,[r7,#0x3c] ;@ A7
  mov r11,r1
  add r0,r8,#2
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  uxth r1,r1 ;@ zero extend
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

;@ EaWrite: Write r11 into '-(a7)' (address in r8):
  mov r1,r11,lsr #16
  mov r0,r8
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2f28] move.l ($3333,a0), -(a7) uses Op2f28 ----------
Op2f28:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  bl cyclone_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a7)' into r8:
  ldr r8,[r7,#0x3c] ;@ A7
  sub r8,r8,#4 ;@ Pre-decrement An
  str r8,[r7,#0x3c] ;@ A7
  mov r11,r1
  add r0,r8,#2
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  uxth r1,r1 ;@ zero extend
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

;@ EaWrite: Write r11 into '-(a7)' (address in r8):
  mov r1,r11,lsr #16
  mov r0,r8
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2f30] move.l ($33,a0,d3.w*2), -(a7) uses Op2f30 ----------
Op2f30:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r1:
  bl cyclone_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a7)' into r8:
  ldr r8,[r7,#0x3c] ;@ A7
  sub r8,r8,#4 ;@ Pre-decrement An
  str r8,[r7,#0x3c] ;@ A7
  mov r11,r1
  add r0,r8,#2
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  uxth r1,r1 ;@ zero extend
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

;@ EaWrite: Write r11 into '-(a7)' (address in r8):
  mov r1,r11,lsr #16
  mov r0,r8
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2f38] move.l $3333.w, -(a7) uses Op2f38 ----------
Op2f38:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r1:
  bl cyclone_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a7)' into r8:
  ldr r8,[r7,#0x3c] ;@ A7
  sub r8,r8,#4 ;@ Pre-decrement An
  str r8,[r7,#0x3c] ;@ A7
  mov r11,r1
  add r0,r8,#2
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  uxth r1,r1 ;@ zero extend
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

;@ EaWrite: Write r11 into '-(a7)' (address in r8):
  mov r1,r11,lsr #16
  mov r0,r8
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2f39] move.l $33333333.l, -(a7) uses Op2f39 ----------
Op2f39:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r1:
  bl cyclone_read32 ;@ Call read32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a7)' into r8:
  ldr r8,[r7,#0x3c] ;@ A7
  sub r8,r8,#4 ;@ Pre-decrement An
  str r8,[r7,#0x3c] ;@ A7
  mov r11,r1
  add r0,r8,#2
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  uxth r1,r1 ;@ zero extend
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

;@ EaWrite: Write r11 into '-(a7)' (address in r8):
  mov r1,r11,lsr #16
  mov r0,r8
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2f3a] move.l ($3333,pc), -(a7); =3335 uses Op2f3a ----------
Op2f3a:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r2,r0 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r1:
  bl cyclone_fetch32 ;@ Call fetch32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a7)' into r8:
  ldr r8,[r7,#0x3c] ;@ A7
  sub r8,r8,#4 ;@ Pre-decrement An
  str r8,[r7,#0x3c] ;@ A7
  mov r11,r1
  add r0,r8,#2
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  uxth r1,r1 ;@ zero extend
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

;@ EaWrite: Write r11 into '-(a7)' (address in r8):
  mov r1,r11,lsr #16
  mov r0,r8
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2f3b] move.l ($33,pc,d3.w*2), -(a7); =35 uses Op2f3b ----------
Op2f3b:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r1:
  bl cyclone_fetch32 ;@ Call fetch32(r0) handler
  movs r1,r0

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a7)' into r8:
  ldr r8,[r7,#0x3c] ;@ A7
  sub r8,r8,#4 ;@ Pre-decrement An
  str r8,[r7,#0x3c] ;@ A7
  mov r11,r1
  add r0,r8,#2
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  uxth r1,r1 ;@ zero extend
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

;@ EaWrite: Write r11 into '-(a7)' (address in r8):
  mov r1,r11,lsr #16
  mov r0,r8
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [2f3c] move.l #$33333333, -(a7) uses Op2f3c ----------
Op2f3c:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$33333333' into r1:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r1,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r1) into r1:
  tst r1,r1

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a7)' into r8:
  ldr r8,[r7,#0x3c] ;@ A7
  sub r8,r8,#4 ;@ Pre-decrement An
  str r8,[r7,#0x3c] ;@ A7
  mov r11,r1
  add r0,r8,#2
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  uxth r1,r1 ;@ zero extend
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

;@ EaWrite: Write r11 into '-(a7)' (address in r8):
  mov r1,r11,lsr #16
  mov r0,r8
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3010] move.w (a0), d0 uses Op3010 ----------
Op3010:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r1:
  bl cyclone_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,lsr #16
  strh r1,[r7,r0]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3020] move.w -(a0), d0 uses Op3020 ----------
Op3020:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r1:
  bl cyclone_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,lsr #16
  strh r1,[r7,r0]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3030] move.w ($33,a0,d3.w*2), d0 uses Op3030 ----------
Op3030:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r1:
  bl cyclone_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,lsr #16
  strh r1,[r7,r0]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3038] move.w $3333.w, d0 uses Op3038 ----------
Op3038:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r1:
  bl cyclone_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,lsr #16
  strh r1,[r7,r0]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [303a] move.w ($3333,pc), d0; =3335 uses Op303a ----------
Op303a:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r2,r0 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r1:
  bl cyclone_fetch16 ;@ Call fetch16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,lsr #16
  strh r1,[r7,r0]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [303b] move.w ($33,pc,d3.w*2), d0; =35 uses Op303b ----------
Op303b:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r1:
  bl cyclone_fetch16 ;@ Call fetch16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,lsr #16
  strh r1,[r7,r0]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [303c] move.w #$3333, d0 uses Op303c ----------
Op303c:
;@ EaCalc : Get '#$3333' into r1:
  ldrsh r1,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r1) into r1:
  movs r1,r1,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaWrite: r1 into register[r0]:
  mov r1,r1,lsr #16
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3050] movea.w (a0), a0 uses Op3050 ----------
Op3050:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r1:
  bl cyclone_read16 ;@ Call read16(r0) handler
  sxth r1,r0 ;@ sign extend

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x1e00
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3058] movea.w (a0)+, a0 uses Op3058 ----------
Op3058:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r1:
  bl cyclone_read16 ;@ Call read16(r0) handler
  sxth r1,r0 ;@ sign extend

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x1e00
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3060] movea.w -(a0), a0 uses Op3060 ----------
Op3060:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r1:
  bl cyclone_read16 ;@ Call read16(r0) handler
  sxth r1,r0 ;@ sign extend

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x1e00
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3068] movea.w ($3333,a0), a0 uses Op3068 ----------
Op3068:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  bl cyclone_read16 ;@ Call read16(r0) handler
  sxth r1,r0 ;@ sign extend

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x1e00
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3070] movea.w ($33,a0,d3.w*2), a0 uses Op3070 ----------
Op3070:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r1:
  bl cyclone_read16 ;@ Call read16(r0) handler
  sxth r1,r0 ;@ sign extend

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x1e00
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3078] movea.w $3333.w, a0 uses Op3078 ----------
Op3078:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r1:
  bl cyclone_read16 ;@ Call read16(r0) handler
  sxth r1,r0 ;@ sign extend

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x1e00
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3079] movea.w $33333333.l, a0 uses Op3079 ----------
Op3079:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r1:
  bl cyclone_read16 ;@ Call read16(r0) handler
  sxth r1,r0 ;@ sign extend

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x1e00
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [307a] movea.w ($3333,pc), a0; =3335 uses Op307a ----------
Op307a:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r2,r0 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r1:
  bl cyclone_fetch16 ;@ Call fetch16(r0) handler
  sxth r1,r0 ;@ sign extend

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x1e00
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [307b] movea.w ($33,pc,d3.w*2), a0; =35 uses Op307b ----------
Op307b:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r1:
  bl cyclone_fetch16 ;@ Call fetch16(r0) handler
  sxth r1,r0 ;@ sign extend

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x1e00
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [307c] movea.w #$3333, a0 uses Op307c ----------
Op307c:
;@ EaCalc : Get '#$3333' into r1:
  ldrsh r1,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r1) into r1:

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x1e00
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3090] move.w (a0), (a0) uses Op3090 ----------
Op3090:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r1:
  bl cyclone_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov r1,r1,lsr #16
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3098] move.w (a0)+, (a0) uses Op3098 ----------
Op3098:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r1:
  bl cyclone_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov r1,r1,lsr #16
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [30a0] move.w -(a0), (a0) uses Op30a0 ----------
Op30a0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r1:
  bl cyclone_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov r1,r1,lsr #16
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [30a8] move.w ($3333,a0), (a0) uses Op30a8 ----------
Op30a8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  bl cyclone_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov r1,r1,lsr #16
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [30b0] move.w ($33,a0,d3.w*2), (a0) uses Op30b0 ----------
Op30b0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r1:
  bl cyclone_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov r1,r1,lsr #16
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [30b8] move.w $3333.w, (a0) uses Op30b8 ----------
Op30b8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r1:
  bl cyclone_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov r1,r1,lsr #16
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [30b9] move.w $33333333.l, (a0) uses Op30b9 ----------
Op30b9:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r1:
  bl cyclone_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov r1,r1,lsr #16
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [30ba] move.w ($3333,pc), (a0); =3335 uses Op30ba ----------
Op30ba:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r2,r0 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r1:
  bl cyclone_fetch16 ;@ Call fetch16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov r1,r1,lsr #16
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [30bb] move.w ($33,pc,d3.w*2), (a0); =35 uses Op30bb ----------
Op30bb:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r1:
  bl cyclone_fetch16 ;@ Call fetch16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov r1,r1,lsr #16
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [30bc] move.w #$3333, (a0) uses Op30bc ----------
Op30bc:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$3333' into r1:
  ldrsh r1,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r1) into r1:
  movs r1,r1,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  mov r1,r1,lsr #16
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [30d8] move.w (a0)+, (a0)+ uses Op30d8 ----------
Op30d8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r1:
  bl cyclone_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov r1,r1,lsr #16
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [30e0] move.w -(a0), (a0)+ uses Op30e0 ----------
Op30e0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r1:
  bl cyclone_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov r1,r1,lsr #16
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [30e8] move.w ($3333,a0), (a0)+ uses Op30e8 ----------
Op30e8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  bl cyclone_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov r1,r1,lsr #16
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [30f0] move.w ($33,a0,d3.w*2), (a0)+ uses Op30f0 ----------
Op30f0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r1:
  bl cyclone_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov r1,r1,lsr #16
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [30f8] move.w $3333.w, (a0)+ uses Op30f8 ----------
Op30f8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r1:
  bl cyclone_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov r1,r1,lsr #16
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [30f9] move.w $33333333.l, (a0)+ uses Op30f9 ----------
Op30f9:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r1:
  bl cyclone_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov r1,r1,lsr #16
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [30fa] move.w ($3333,pc), (a0)+; =3335 uses Op30fa ----------
Op30fa:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r2,r0 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r1:
  bl cyclone_fetch16 ;@ Call fetch16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov r1,r1,lsr #16
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [30fb] move.w ($33,pc,d3.w*2), (a0)+; =35 uses Op30fb ----------
Op30fb:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r1:
  bl cyclone_fetch16 ;@ Call fetch16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov r1,r1,lsr #16
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [30fc] move.w #$3333, (a0)+ uses Op30fc ----------
Op30fc:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$3333' into r1:
  ldrsh r1,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r1) into r1:
  movs r1,r1,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  mov r1,r1,lsr #16
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3100] move.w d0, -(a0) uses Op3100 ----------
Op3100:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x000f
  mov r1,r1,lsl #2
;@ EaRead : Read register[r1] into r1:
  ldrh r1,[r7,r1]

  movs r2,r1,lsl #16
  and r10,r2,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3110] move.w (a0), -(a0) uses Op3110 ----------
Op3110:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r1:
  bl cyclone_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov r1,r1,lsr #16
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3118] move.w (a0)+, -(a0) uses Op3118 ----------
Op3118:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r1:
  bl cyclone_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov r1,r1,lsr #16
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3120] move.w -(a0), -(a0) uses Op3120 ----------
Op3120:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r1:
  bl cyclone_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov r1,r1,lsr #16
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3128] move.w ($3333,a0), -(a0) uses Op3128 ----------
Op3128:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  bl cyclone_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov r1,r1,lsr #16
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3130] move.w ($33,a0,d3.w*2), -(a0) uses Op3130 ----------
Op3130:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r1:
  bl cyclone_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov r1,r1,lsr #16
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3138] move.w $3333.w, -(a0) uses Op3138 ----------
Op3138:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r1:
  bl cyclone_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov r1,r1,lsr #16
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3139] move.w $33333333.l, -(a0) uses Op3139 ----------
Op3139:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r1:
  bl cyclone_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov r1,r1,lsr #16
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [313a] move.w ($3333,pc), -(a0); =3335 uses Op313a ----------
Op313a:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r2,r0 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r1:
  bl cyclone_fetch16 ;@ Call fetch16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov r1,r1,lsr #16
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [313b] move.w ($33,pc,d3.w*2), -(a0); =35 uses Op313b ----------
Op313b:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r1:
  bl cyclone_fetch16 ;@ Call fetch16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov r1,r1,lsr #16
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [313c] move.w #$3333, -(a0) uses Op313c ----------
Op313c:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$3333' into r1:
  ldrsh r1,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r1) into r1:
  movs r1,r1,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov r1,r1,lsr #16
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3140] move.w d0, ($3333,a0) uses Op3140 ----------
Op3140:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x000f
  mov r1,r1,lsl #2
;@ EaRead : Read register[r1] into r1:
  ldrh r1,[r7,r1]

  movs r2,r1,lsl #16
  and r10,r2,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x1e00
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3150] move.w (a0), ($3333,a0) uses Op3150 ----------
Op3150:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r1:
  bl cyclone_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x1e00
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov r1,r1,lsr #16
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3158] move.w (a0)+, ($3333,a0) uses Op3158 ----------
Op3158:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r1:
  bl cyclone_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x1e00
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov r1,r1,lsr #16
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3160] move.w -(a0), ($3333,a0) uses Op3160 ----------
Op3160:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r1:
  bl cyclone_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x1e00
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov r1,r1,lsr #16
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3168] move.w ($3333,a0), ($3333,a0) uses Op3168 ----------
Op3168:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  bl cyclone_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x1e00
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov r1,r1,lsr #16
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3170] move.w ($33,a0,d3.w*2), ($3333,a0) uses Op3170 ----------
Op3170:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r1:
  bl cyclone_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x1e00
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov r1,r1,lsr #16
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3178] move.w $3333.w, ($3333,a0) uses Op3178 ----------
Op3178:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r1:
  bl cyclone_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x1e00
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov r1,r1,lsr #16
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3179] move.w $33333333.l, ($3333,a0) uses Op3179 ----------
Op3179:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r1:
  bl cyclone_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x1e00
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov r1,r1,lsr #16
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [317a] move.w ($3333,pc), ($3333,a0); =3335 uses Op317a ----------
Op317a:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r2,r0 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r1:
  bl cyclone_fetch16 ;@ Call fetch16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x1e00
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov r1,r1,lsr #16
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [317b] move.w ($33,pc,d3.w*2), ($3333,a0); =35 uses Op317b ----------
Op317b:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r1:
  bl cyclone_fetch16 ;@ Call fetch16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x1e00
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov r1,r1,lsr #16
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [317c] move.w #$3333, ($3333,a0) uses Op317c ----------
Op317c:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$3333' into r1:
  ldrsh r1,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r1) into r1:
  movs r1,r1,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x1e00
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  mov r1,r1,lsr #16
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3190] move.w (a0), ($33,a0,d3.w*2) uses Op3190 ----------
Op3190:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r1:
  bl cyclone_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x1e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov r1,r1,lsr #16
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3198] move.w (a0)+, ($33,a0,d3.w*2) uses Op3198 ----------
Op3198:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r1:
  bl cyclone_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x1e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov r1,r1,lsr #16
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [31a0] move.w -(a0), ($33,a0,d3.w*2) uses Op31a0 ----------
Op31a0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r1:
  bl cyclone_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x1e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov r1,r1,lsr #16
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [31a8] move.w ($3333,a0), ($33,a0,d3.w*2) uses Op31a8 ----------
Op31a8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  bl cyclone_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x1e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov r1,r1,lsr #16
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [31b0] move.w ($33,a0,d3.w*2), ($33,a0,d3.w*2) uses Op31b0 ----------
Op31b0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r1:
  bl cyclone_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x1e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov r1,r1,lsr #16
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [31b8] move.w $3333.w, ($33,a0,d3.w*2) uses Op31b8 ----------
Op31b8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r1:
  bl cyclone_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x1e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov r1,r1,lsr #16
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [31b9] move.w $33333333.l, ($33,a0,d3.w*2) uses Op31b9 ----------
Op31b9:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r1:
  bl cyclone_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x1e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov r1,r1,lsr #16
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [31ba] move.w ($3333,pc), ($33,a0,d3.w*2); =3335 uses Op31ba ----------
Op31ba:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r2,r0 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r1:
  bl cyclone_fetch16 ;@ Call fetch16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x1e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov r1,r1,lsr #16
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [31bb] move.w ($33,pc,d3.w*2), ($33,a0,d3.w*2); =35 uses Op31bb ----------
Op31bb:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r1:
  bl cyclone_fetch16 ;@ Call fetch16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x1e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov r1,r1,lsr #16
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [31bc] move.w #$3333, ($33,a0,d3.w*2) uses Op31bc ----------
Op31bc:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$3333' into r1:
  ldrsh r1,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r1) into r1:
  movs r1,r1,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x1e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  mov r1,r1,lsr #16
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [31c0] move.w d0, $3333.w uses Op31c0 ----------
Op31c0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x000f
  mov r1,r1,lsl #2
;@ EaRead : Read register[r1] into r1:
  ldrh r1,[r7,r1]

  movs r2,r1,lsl #16
  and r10,r2,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [31d0] move.w (a0), $3333.w uses Op31d0 ----------
Op31d0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r1:
  bl cyclone_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov r1,r1,lsr #16
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [31d8] move.w (a0)+, $3333.w uses Op31d8 ----------
Op31d8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r1:
  bl cyclone_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov r1,r1,lsr #16
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [31e0] move.w -(a0), $3333.w uses Op31e0 ----------
Op31e0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r1:
  bl cyclone_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov r1,r1,lsr #16
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [31e8] move.w ($3333,a0), $3333.w uses Op31e8 ----------
Op31e8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  bl cyclone_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov r1,r1,lsr #16
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [31f0] move.w ($33,a0,d3.w*2), $3333.w uses Op31f0 ----------
Op31f0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r1:
  bl cyclone_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov r1,r1,lsr #16
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [31f8] move.w $3333.w, $3333.w uses Op31f8 ----------
Op31f8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r1:
  bl cyclone_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov r1,r1,lsr #16
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [31f9] move.w $33333333.l, $3333.w uses Op31f9 ----------
Op31f9:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r1:
  bl cyclone_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov r1,r1,lsr #16
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [31fa] move.w ($3333,pc), $3333.w; =3335 uses Op31fa ----------
Op31fa:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r2,r0 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r1:
  bl cyclone_fetch16 ;@ Call fetch16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov r1,r1,lsr #16
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [31fb] move.w ($33,pc,d3.w*2), $3333.w; =35 uses Op31fb ----------
Op31fb:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r1:
  bl cyclone_fetch16 ;@ Call fetch16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov r1,r1,lsr #16
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [31fc] move.w #$3333, $3333.w uses Op31fc ----------
Op31fc:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$3333' into r1:
  ldrsh r1,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r1) into r1:
  movs r1,r1,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  mov r1,r1,lsr #16
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [33c0] move.w d0, $33333333.l uses Op33c0 ----------
Op33c0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x000f
  mov r1,r1,lsl #2
;@ EaRead : Read register[r1] into r1:
  ldrh r1,[r7,r1]

  movs r2,r1,lsl #16
  and r10,r2,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [33d0] move.w (a0), $33333333.l uses Op33d0 ----------
Op33d0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r1:
  bl cyclone_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov r1,r1,lsr #16
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [33e0] move.w -(a0), $33333333.l uses Op33e0 ----------
Op33e0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r1:
  bl cyclone_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov r1,r1,lsr #16
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [33e8] move.w ($3333,a0), $33333333.l uses Op33e8 ----------
Op33e8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  bl cyclone_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov r1,r1,lsr #16
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [33f0] move.w ($33,a0,d3.w*2), $33333333.l uses Op33f0 ----------
Op33f0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r1:
  bl cyclone_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov r1,r1,lsr #16
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [33f8] move.w $3333.w, $33333333.l uses Op33f8 ----------
Op33f8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r1:
  bl cyclone_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov r1,r1,lsr #16
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [33f9] move.w $33333333.l, $33333333.l uses Op33f9 ----------
Op33f9:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r1:
  bl cyclone_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov r1,r1,lsr #16
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [33fa] move.w ($3333,pc), $33333333.l; =3335 uses Op33fa ----------
Op33fa:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r2,r0 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r1:
  bl cyclone_fetch16 ;@ Call fetch16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov r1,r1,lsr #16
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [33fb] move.w ($33,pc,d3.w*2), $33333333.l; =35 uses Op33fb ----------
Op33fb:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r1:
  bl cyclone_fetch16 ;@ Call fetch16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov r1,r1,lsr #16
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [33fc] move.w #$3333, $33333333.l uses Op33fc ----------
Op33fc:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$3333' into r1:
  ldrsh r1,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r1) into r1:
  movs r1,r1,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  mov r1,r1,lsr #16
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3ec0] move.w d0, (a7)+ uses Op3ec0 ----------
Op3ec0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x000f
  mov r1,r1,lsl #2
;@ EaRead : Read register[r1] into r1:
  ldrh r1,[r7,r1]

  movs r2,r1,lsl #16
  and r10,r2,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3ed0] move.w (a0), (a7)+ uses Op3ed0 ----------
Op3ed0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r1:
  bl cyclone_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov r1,r1,lsr #16
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3ed8] move.w (a0)+, (a7)+ uses Op3ed8 ----------
Op3ed8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r1:
  bl cyclone_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov r1,r1,lsr #16
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3ee0] move.w -(a0), (a7)+ uses Op3ee0 ----------
Op3ee0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r1:
  bl cyclone_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov r1,r1,lsr #16
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3ee8] move.w ($3333,a0), (a7)+ uses Op3ee8 ----------
Op3ee8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  bl cyclone_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov r1,r1,lsr #16
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3ef0] move.w ($33,a0,d3.w*2), (a7)+ uses Op3ef0 ----------
Op3ef0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r1:
  bl cyclone_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov r1,r1,lsr #16
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3ef8] move.w $3333.w, (a7)+ uses Op3ef8 ----------
Op3ef8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r1:
  bl cyclone_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov r1,r1,lsr #16
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3ef9] move.w $33333333.l, (a7)+ uses Op3ef9 ----------
Op3ef9:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r1:
  bl cyclone_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov r1,r1,lsr #16
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3efa] move.w ($3333,pc), (a7)+; =3335 uses Op3efa ----------
Op3efa:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r2,r0 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r1:
  bl cyclone_fetch16 ;@ Call fetch16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov r1,r1,lsr #16
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3efb] move.w ($33,pc,d3.w*2), (a7)+; =35 uses Op3efb ----------
Op3efb:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r1:
  bl cyclone_fetch16 ;@ Call fetch16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov r1,r1,lsr #16
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3efc] move.w #$3333, (a7)+ uses Op3efc ----------
Op3efc:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$3333' into r1:
  ldrsh r1,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r1) into r1:
  movs r1,r1,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  mov r1,r1,lsr #16
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3f00] move.w d0, -(a7) uses Op3f00 ----------
Op3f00:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x000f
  mov r1,r1,lsl #2
;@ EaRead : Read register[r1] into r1:
  ldrh r1,[r7,r1]

  movs r2,r1,lsl #16
  and r10,r2,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3f10] move.w (a0), -(a7) uses Op3f10 ----------
Op3f10:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r1:
  bl cyclone_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov r1,r1,lsr #16
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3f18] move.w (a0)+, -(a7) uses Op3f18 ----------
Op3f18:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r1:
  bl cyclone_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov r1,r1,lsr #16
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3f20] move.w -(a0), -(a7) uses Op3f20 ----------
Op3f20:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r1:
  bl cyclone_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov r1,r1,lsr #16
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3f28] move.w ($3333,a0), -(a7) uses Op3f28 ----------
Op3f28:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  bl cyclone_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov r1,r1,lsr #16
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3f30] move.w ($33,a0,d3.w*2), -(a7) uses Op3f30 ----------
Op3f30:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r1:
  bl cyclone_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov r1,r1,lsr #16
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3f38] move.w $3333.w, -(a7) uses Op3f38 ----------
Op3f38:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r1:
  bl cyclone_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov r1,r1,lsr #16
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3f39] move.w $33333333.l, -(a7) uses Op3f39 ----------
Op3f39:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r1:
  bl cyclone_read16 ;@ Call read16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov r1,r1,lsr #16
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3f3a] move.w ($3333,pc), -(a7); =3335 uses Op3f3a ----------
Op3f3a:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r2,r0 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r1:
  bl cyclone_fetch16 ;@ Call fetch16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov r1,r1,lsr #16
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3f3b] move.w ($33,pc,d3.w*2), -(a7); =35 uses Op3f3b ----------
Op3f3b:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r1:
  bl cyclone_fetch16 ;@ Call fetch16(r0) handler
  movs r1,r0,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov r1,r1,lsr #16
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [3f3c] move.w #$3333, -(a7) uses Op3f3c ----------
Op3f3c:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '#$3333' into r1:
  ldrsh r1,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r1) into r1:
  movs r1,r1,asl #16

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  mov r1,r1,lsr #16
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4000] negx.b d0 uses Op4000 ----------
Op4000:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

;@ Negx:
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  mvn r2,r2 ;@ Invert it
  tst r2,r2,lsl #3 ;@ Get into Carry

  mov r0,r0,asl #24
  rscs r1,r0,#0 ;@ do arithmetic
  orr r3,r10,#0xb0000000 ;@ for old Z
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit
  movs r1,r1,asr #24
  orreq r10,r10,#0x40000000 ;@ possily missed Z
  andeq r10,r10,r3 ;@ fix Z

;@ EaWrite: r1 into register[r11]:
  strb r1,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4010] negx.b (a0) uses Op4010 ----------
Op4010:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

;@ Negx:
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  mvn r2,r2 ;@ Invert it
  tst r2,r2,lsl #3 ;@ Get into Carry

  mov r0,r0,asl #24
  rscs r1,r0,#0 ;@ do arithmetic
  orr r3,r10,#0xb0000000 ;@ for old Z
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit
  movs r1,r1,asr #24
  orreq r10,r10,#0x40000000 ;@ possily missed Z
  andeq r10,r10,r3 ;@ fix Z

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  and r1,r1,#0xff
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4018] negx.b (a0)+ uses Op4018 ----------
Op4018:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

;@ Negx:
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  mvn r2,r2 ;@ Invert it
  tst r2,r2,lsl #3 ;@ Get into Carry

  mov r0,r0,asl #24
  rscs r1,r0,#0 ;@ do arithmetic
  orr r3,r10,#0xb0000000 ;@ for old Z
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit
  movs r1,r1,asr #24
  orreq r10,r10,#0x40000000 ;@ possily missed Z
  andeq r10,r10,r3 ;@ fix Z

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  and r1,r1,#0xff
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [401f] negx.b (a7)+ uses Op401f ----------
Op401f:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a7)+' into r11:
  ldr r11,[r7,#0x3c] ;@ A7
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

;@ Negx:
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  mvn r2,r2 ;@ Invert it
  tst r2,r2,lsl #3 ;@ Get into Carry

  mov r0,r0,asl #24
  rscs r1,r0,#0 ;@ do arithmetic
  orr r3,r10,#0xb0000000 ;@ for old Z
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit
  movs r1,r1,asr #24
  orreq r10,r10,#0x40000000 ;@ possily missed Z
  andeq r10,r10,r3 ;@ fix Z

;@ EaWrite: Write r1 into '(a7)+' (address in r11):
  and r1,r1,#0xff
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4020] negx.b -(a0) uses Op4020 ----------
Op4020:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#1 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

;@ Negx:
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  mvn r2,r2 ;@ Invert it
  tst r2,r2,lsl #3 ;@ Get into Carry

  mov r0,r0,asl #24
  rscs r1,r0,#0 ;@ do arithmetic
  orr r3,r10,#0xb0000000 ;@ for old Z
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit
  movs r1,r1,asr #24
  orreq r10,r10,#0x40000000 ;@ possily missed Z
  andeq r10,r10,r3 ;@ fix Z

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  and r1,r1,#0xff
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4027] negx.b -(a7) uses Op4027 ----------
Op4027:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a7)' into r11:
  ldr r11,[r7,#0x3c] ;@ A7
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

;@ Negx:
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  mvn r2,r2 ;@ Invert it
  tst r2,r2,lsl #3 ;@ Get into Carry

  mov r0,r0,asl #24
  rscs r1,r0,#0 ;@ do arithmetic
  orr r3,r10,#0xb0000000 ;@ for old Z
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit
  movs r1,r1,asr #24
  orreq r10,r10,#0x40000000 ;@ possily missed Z
  andeq r10,r10,r3 ;@ fix Z

;@ EaWrite: Write r1 into '-(a7)' (address in r11):
  and r1,r1,#0xff
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4028] negx.b ($3333,a0) uses Op4028 ----------
Op4028:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

;@ Negx:
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  mvn r2,r2 ;@ Invert it
  tst r2,r2,lsl #3 ;@ Get into Carry

  mov r0,r0,asl #24
  rscs r1,r0,#0 ;@ do arithmetic
  orr r3,r10,#0xb0000000 ;@ for old Z
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit
  movs r1,r1,asr #24
  orreq r10,r10,#0x40000000 ;@ possily missed Z
  andeq r10,r10,r3 ;@ fix Z

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  and r1,r1,#0xff
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4030] negx.b ($33,a0,d3.w*2) uses Op4030 ----------
Op4030:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

;@ Negx:
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  mvn r2,r2 ;@ Invert it
  tst r2,r2,lsl #3 ;@ Get into Carry

  mov r0,r0,asl #24
  rscs r1,r0,#0 ;@ do arithmetic
  orr r3,r10,#0xb0000000 ;@ for old Z
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit
  movs r1,r1,asr #24
  orreq r10,r10,#0x40000000 ;@ possily missed Z
  andeq r10,r10,r3 ;@ fix Z

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  and r1,r1,#0xff
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4038] negx.b $3333.w uses Op4038 ----------
Op4038:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

;@ Negx:
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  mvn r2,r2 ;@ Invert it
  tst r2,r2,lsl #3 ;@ Get into Carry

  mov r0,r0,asl #24
  rscs r1,r0,#0 ;@ do arithmetic
  orr r3,r10,#0xb0000000 ;@ for old Z
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit
  movs r1,r1,asr #24
  orreq r10,r10,#0x40000000 ;@ possily missed Z
  andeq r10,r10,r3 ;@ fix Z

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  and r1,r1,#0xff
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4039] negx.b $33333333.l uses Op4039 ----------
Op4039:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

;@ Negx:
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  mvn r2,r2 ;@ Invert it
  tst r2,r2,lsl #3 ;@ Get into Carry

  mov r0,r0,asl #24
  rscs r1,r0,#0 ;@ do arithmetic
  orr r3,r10,#0xb0000000 ;@ for old Z
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit
  movs r1,r1,asr #24
  orreq r10,r10,#0x40000000 ;@ possily missed Z
  andeq r10,r10,r3 ;@ fix Z

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  and r1,r1,#0xff
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4040] negx.w d0 uses Op4040 ----------
Op4040:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
  mov r11,r11,lsl #2
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11]

;@ Negx:
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  mvn r2,r2 ;@ Invert it
  tst r2,r2,lsl #3 ;@ Get into Carry

  mov r0,r0,asl #16
  rscs r1,r0,#0 ;@ do arithmetic
  orr r3,r10,#0xb0000000 ;@ for old Z
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit
  movs r1,r1,asr #16
  orreq r10,r10,#0x40000000 ;@ possily missed Z
  andeq r10,r10,r3 ;@ fix Z

;@ EaWrite: r1 into register[r11]:
  strh r1,[r7,r11]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4050] negx.w (a0) uses Op4050 ----------
Op4050:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ Negx:
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  mvn r2,r2 ;@ Invert it
  tst r2,r2,lsl #3 ;@ Get into Carry

  mov r0,r0,asl #16
  rscs r1,r0,#0 ;@ do arithmetic
  orr r3,r10,#0xb0000000 ;@ for old Z
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit
  movs r1,r1,asr #16
  orreq r10,r10,#0x40000000 ;@ possily missed Z
  andeq r10,r10,r3 ;@ fix Z

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  uxth r1,r1 ;@ zero extend
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4058] negx.w (a0)+ uses Op4058 ----------
Op4058:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ Negx:
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  mvn r2,r2 ;@ Invert it
  tst r2,r2,lsl #3 ;@ Get into Carry

  mov r0,r0,asl #16
  rscs r1,r0,#0 ;@ do arithmetic
  orr r3,r10,#0xb0000000 ;@ for old Z
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit
  movs r1,r1,asr #16
  orreq r10,r10,#0x40000000 ;@ possily missed Z
  andeq r10,r10,r3 ;@ fix Z

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  uxth r1,r1 ;@ zero extend
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4060] negx.w -(a0) uses Op4060 ----------
Op4060:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ Negx:
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  mvn r2,r2 ;@ Invert it
  tst r2,r2,lsl #3 ;@ Get into Carry

  mov r0,r0,asl #16
  rscs r1,r0,#0 ;@ do arithmetic
  orr r3,r10,#0xb0000000 ;@ for old Z
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit
  movs r1,r1,asr #16
  orreq r10,r10,#0x40000000 ;@ possily missed Z
  andeq r10,r10,r3 ;@ fix Z

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  uxth r1,r1 ;@ zero extend
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4068] negx.w ($3333,a0) uses Op4068 ----------
Op4068:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ Negx:
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  mvn r2,r2 ;@ Invert it
  tst r2,r2,lsl #3 ;@ Get into Carry

  mov r0,r0,asl #16
  rscs r1,r0,#0 ;@ do arithmetic
  orr r3,r10,#0xb0000000 ;@ for old Z
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit
  movs r1,r1,asr #16
  orreq r10,r10,#0x40000000 ;@ possily missed Z
  andeq r10,r10,r3 ;@ fix Z

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  uxth r1,r1 ;@ zero extend
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4070] negx.w ($33,a0,d3.w*2) uses Op4070 ----------
Op4070:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ Negx:
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  mvn r2,r2 ;@ Invert it
  tst r2,r2,lsl #3 ;@ Get into Carry

  mov r0,r0,asl #16
  rscs r1,r0,#0 ;@ do arithmetic
  orr r3,r10,#0xb0000000 ;@ for old Z
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit
  movs r1,r1,asr #16
  orreq r10,r10,#0x40000000 ;@ possily missed Z
  andeq r10,r10,r3 ;@ fix Z

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  uxth r1,r1 ;@ zero extend
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4078] negx.w $3333.w uses Op4078 ----------
Op4078:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ Negx:
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  mvn r2,r2 ;@ Invert it
  tst r2,r2,lsl #3 ;@ Get into Carry

  mov r0,r0,asl #16
  rscs r1,r0,#0 ;@ do arithmetic
  orr r3,r10,#0xb0000000 ;@ for old Z
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit
  movs r1,r1,asr #16
  orreq r10,r10,#0x40000000 ;@ possily missed Z
  andeq r10,r10,r3 ;@ fix Z

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  uxth r1,r1 ;@ zero extend
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4079] negx.w $33333333.l uses Op4079 ----------
Op4079:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ Negx:
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  mvn r2,r2 ;@ Invert it
  tst r2,r2,lsl #3 ;@ Get into Carry

  mov r0,r0,asl #16
  rscs r1,r0,#0 ;@ do arithmetic
  orr r3,r10,#0xb0000000 ;@ for old Z
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit
  movs r1,r1,asr #16
  orreq r10,r10,#0x40000000 ;@ possily missed Z
  andeq r10,r10,r3 ;@ fix Z

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  uxth r1,r1 ;@ zero extend
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4080] negx.l d0 uses Op4080 ----------
Op4080:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

;@ Negx:
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  mvn r2,r2 ;@ Invert it
  tst r2,r2,lsl #3 ;@ Get into Carry

  rscs r1,r0,#0 ;@ do arithmetic
  orr r3,r10,#0xb0000000 ;@ for old Z
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit
  andeq r10,r10,r3 ;@ fix Z

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4090] negx.l (a0) uses Op4090 ----------
Op4090:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ Negx:
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  mvn r2,r2 ;@ Invert it
  tst r2,r2,lsl #3 ;@ Get into Carry

  rscs r1,r0,#0 ;@ do arithmetic
  orr r3,r10,#0xb0000000 ;@ for old Z
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit
  andeq r10,r10,r3 ;@ fix Z

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  mov r0,r11
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4098] negx.l (a0)+ uses Op4098 ----------
Op4098:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ Negx:
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  mvn r2,r2 ;@ Invert it
  tst r2,r2,lsl #3 ;@ Get into Carry

  rscs r1,r0,#0 ;@ do arithmetic
  orr r3,r10,#0xb0000000 ;@ for old Z
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit
  andeq r10,r10,r3 ;@ fix Z

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  mov r0,r11
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [40a0] negx.l -(a0) uses Op40a0 ----------
Op40a0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#4 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ Negx:
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  mvn r2,r2 ;@ Invert it
  tst r2,r2,lsl #3 ;@ Get into Carry

  rscs r1,r0,#0 ;@ do arithmetic
  orr r3,r10,#0xb0000000 ;@ for old Z
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit
  andeq r10,r10,r3 ;@ fix Z

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r0,r11
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [40a8] negx.l ($3333,a0) uses Op40a8 ----------
Op40a8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ Negx:
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  mvn r2,r2 ;@ Invert it
  tst r2,r2,lsl #3 ;@ Get into Carry

  rscs r1,r0,#0 ;@ do arithmetic
  orr r3,r10,#0xb0000000 ;@ for old Z
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit
  andeq r10,r10,r3 ;@ fix Z

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  mov r0,r11
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [40b0] negx.l ($33,a0,d3.w*2) uses Op40b0 ----------
Op40b0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ Negx:
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  mvn r2,r2 ;@ Invert it
  tst r2,r2,lsl #3 ;@ Get into Carry

  rscs r1,r0,#0 ;@ do arithmetic
  orr r3,r10,#0xb0000000 ;@ for old Z
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit
  andeq r10,r10,r3 ;@ fix Z

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  mov r0,r11
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [40b8] negx.l $3333.w uses Op40b8 ----------
Op40b8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ Negx:
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  mvn r2,r2 ;@ Invert it
  tst r2,r2,lsl #3 ;@ Get into Carry

  rscs r1,r0,#0 ;@ do arithmetic
  orr r3,r10,#0xb0000000 ;@ for old Z
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit
  andeq r10,r10,r3 ;@ fix Z

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  mov r0,r11
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [40b9] negx.l $33333333.l uses Op40b9 ----------
Op40b9:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ Negx:
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  mvn r2,r2 ;@ Invert it
  tst r2,r2,lsl #3 ;@ Get into Carry

  rscs r1,r0,#0 ;@ do arithmetic
  orr r3,r10,#0xb0000000 ;@ for old Z
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit
  andeq r10,r10,r3 ;@ fix Z

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  mov r0,r11
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [40c0] move sr, d0 uses Op40c0 ----------
Op40c0:
  ldr r0,[r7,#0x4c]   ;@ X bit
  mov r1,r10,lsr #28  ;@ ____NZCV
  eor r2,r1,r1,ror #1 ;@ Bit 0=C^V
  tst r2,#1           ;@ 1 if C!=V
  eorne r1,r1,#3      ;@ ____NZVC

  ldrb r2,[r7,#0x44]  ;@ Include SR high
  and r0,r0,#0x20000000
  orr r1,r1,r0,lsr #25 ;@ ___XNZVC
  orr r1,r1,r2,lsl #8

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
  mov r0,r0,lsl #2
;@ EaWrite: r1 into register[r0]:
  strh r1,[r7,r0]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [40d0] move sr, (a0) uses Op40d0 ----------
Op40d0:
  str r5,[r7,#0x5c] ;@ Save Cycles

  ldr r0,[r7,#0x4c]   ;@ X bit
  mov r1,r10,lsr #28  ;@ ____NZCV
  eor r2,r1,r1,ror #1 ;@ Bit 0=C^V
  tst r2,#1           ;@ 1 if C!=V
  eorne r1,r1,#3      ;@ ____NZVC

  ldrb r2,[r7,#0x44]  ;@ Include SR high
  and r0,r0,#0x20000000
  orr r1,r1,r0,lsr #25 ;@ ___XNZVC
  orr r1,r1,r2,lsl #8

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  uxth r1,r1 ;@ zero extend
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [40d8] move sr, (a0)+ uses Op40d8 ----------
Op40d8:
  str r5,[r7,#0x5c] ;@ Save Cycles

  ldr r0,[r7,#0x4c]   ;@ X bit
  mov r1,r10,lsr #28  ;@ ____NZCV
  eor r2,r1,r1,ror #1 ;@ Bit 0=C^V
  tst r2,#1           ;@ 1 if C!=V
  eorne r1,r1,#3      ;@ ____NZVC

  ldrb r2,[r7,#0x44]  ;@ Include SR high
  and r0,r0,#0x20000000
  orr r1,r1,r0,lsr #25 ;@ ___XNZVC
  orr r1,r1,r2,lsl #8

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  uxth r1,r1 ;@ zero extend
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [40e0] move sr, -(a0) uses Op40e0 ----------
Op40e0:
  str r5,[r7,#0x5c] ;@ Save Cycles

  ldr r0,[r7,#0x4c]   ;@ X bit
  mov r1,r10,lsr #28  ;@ ____NZCV
  eor r2,r1,r1,ror #1 ;@ Bit 0=C^V
  tst r2,#1           ;@ 1 if C!=V
  eorne r1,r1,#3      ;@ ____NZVC

  ldrb r2,[r7,#0x44]  ;@ Include SR high
  and r0,r0,#0x20000000
  orr r1,r1,r0,lsr #25 ;@ ___XNZVC
  orr r1,r1,r2,lsl #8

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  uxth r1,r1 ;@ zero extend
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [40e8] move sr, ($3333,a0) uses Op40e8 ----------
Op40e8:
  str r5,[r7,#0x5c] ;@ Save Cycles

  ldr r0,[r7,#0x4c]   ;@ X bit
  mov r1,r10,lsr #28  ;@ ____NZCV
  eor r2,r1,r1,ror #1 ;@ Bit 0=C^V
  tst r2,#1           ;@ 1 if C!=V
  eorne r1,r1,#3      ;@ ____NZVC

  ldrb r2,[r7,#0x44]  ;@ Include SR high
  and r0,r0,#0x20000000
  orr r1,r1,r0,lsr #25 ;@ ___XNZVC
  orr r1,r1,r2,lsl #8

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  uxth r1,r1 ;@ zero extend
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [40f0] move sr, ($33,a0,d3.w*2) uses Op40f0 ----------
Op40f0:
  str r5,[r7,#0x5c] ;@ Save Cycles

  ldr r0,[r7,#0x4c]   ;@ X bit
  mov r1,r10,lsr #28  ;@ ____NZCV
  eor r2,r1,r1,ror #1 ;@ Bit 0=C^V
  tst r2,#1           ;@ 1 if C!=V
  eorne r1,r1,#3      ;@ ____NZVC

  ldrb r2,[r7,#0x44]  ;@ Include SR high
  and r0,r0,#0x20000000
  orr r1,r1,r0,lsr #25 ;@ ___XNZVC
  orr r1,r1,r2,lsl #8

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  uxth r1,r1 ;@ zero extend
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [40f8] move sr, $3333.w uses Op40f8 ----------
Op40f8:
  str r5,[r7,#0x5c] ;@ Save Cycles

  ldr r0,[r7,#0x4c]   ;@ X bit
  mov r1,r10,lsr #28  ;@ ____NZCV
  eor r2,r1,r1,ror #1 ;@ Bit 0=C^V
  tst r2,#1           ;@ 1 if C!=V
  eorne r1,r1,#3      ;@ ____NZVC

  ldrb r2,[r7,#0x44]  ;@ Include SR high
  and r0,r0,#0x20000000
  orr r1,r1,r0,lsr #25 ;@ ___XNZVC
  orr r1,r1,r2,lsl #8

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  uxth r1,r1 ;@ zero extend
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [40f9] move sr, $33333333.l uses Op40f9 ----------
Op40f9:
  str r5,[r7,#0x5c] ;@ Save Cycles

  ldr r0,[r7,#0x4c]   ;@ X bit
  mov r1,r10,lsr #28  ;@ ____NZCV
  eor r2,r1,r1,ror #1 ;@ Bit 0=C^V
  tst r2,#1           ;@ 1 if C!=V
  eorne r1,r1,#3      ;@ ____NZVC

  ldrb r2,[r7,#0x44]  ;@ Include SR high
  and r0,r0,#0x20000000
  orr r1,r1,r0,lsr #25 ;@ ___XNZVC
  orr r1,r1,r2,lsl #8

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  uxth r1,r1 ;@ zero extend
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4180] chk d0, a0 uses Op4180 ----------
Op4180:
;@ Get value into r0:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r0:
  ldr r0,[r7,r0,lsl #2]

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #16
  movs r1,r1,asl #16

;@ get flags, including undocumented ones
  and r3,r10,#0x80000000
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV
;@ is reg negative?
  bmi chktrap4180
;@ Do arithmetic:
  cmp r1,r0
  bgt chktrap4180
;@ old N remains
  orr r10,r10,r3
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

chktrap4180: ;@ CHK exception:
  mov r0,#6
  bl Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#50 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4190] chk (a0), a0 uses Op4190 ----------
Op4190:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get value into r0:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #16
  movs r1,r1,asl #16

;@ get flags, including undocumented ones
  and r3,r10,#0x80000000
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV
;@ is reg negative?
  bmi chktrap4190
;@ Do arithmetic:
  cmp r1,r0
  bgt chktrap4190
;@ old N remains
  orr r10,r10,r3
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

chktrap4190: ;@ CHK exception:
  mov r0,#6
  bl Exception
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#54 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4198] chk (a0)+, a0 uses Op4198 ----------
Op4198:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get value into r0:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #16
  movs r1,r1,asl #16

;@ get flags, including undocumented ones
  and r3,r10,#0x80000000
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV
;@ is reg negative?
  bmi chktrap4198
;@ Do arithmetic:
  cmp r1,r0
  bgt chktrap4198
;@ old N remains
  orr r10,r10,r3
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

chktrap4198: ;@ CHK exception:
  mov r0,#6
  bl Exception
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#54 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [41a0] chk -(a0), a0 uses Op41a0 ----------
Op41a0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get value into r0:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #16
  movs r1,r1,asl #16

;@ get flags, including undocumented ones
  and r3,r10,#0x80000000
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV
;@ is reg negative?
  bmi chktrap41a0
;@ Do arithmetic:
  cmp r1,r0
  bgt chktrap41a0
;@ old N remains
  orr r10,r10,r3
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

chktrap41a0: ;@ CHK exception:
  mov r0,#6
  bl Exception
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#56 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [41a8] chk ($3333,a0), a0 uses Op41a8 ----------
Op41a8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get value into r0:
;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #16
  movs r1,r1,asl #16

;@ get flags, including undocumented ones
  and r3,r10,#0x80000000
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV
;@ is reg negative?
  bmi chktrap41a8
;@ Do arithmetic:
  cmp r1,r0
  bgt chktrap41a8
;@ old N remains
  orr r10,r10,r3
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

chktrap41a8: ;@ CHK exception:
  mov r0,#6
  bl Exception
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#58 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [41b0] chk ($33,a0,d3.w*2), a0 uses Op41b0 ----------
Op41b0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get value into r0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #16
  movs r1,r1,asl #16

;@ get flags, including undocumented ones
  and r3,r10,#0x80000000
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV
;@ is reg negative?
  bmi chktrap41b0
;@ Do arithmetic:
  cmp r1,r0
  bgt chktrap41b0
;@ old N remains
  orr r10,r10,r3
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

chktrap41b0: ;@ CHK exception:
  mov r0,#6
  bl Exception
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#60 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [41b8] chk $3333.w, a0 uses Op41b8 ----------
Op41b8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get value into r0:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #16
  movs r1,r1,asl #16

;@ get flags, including undocumented ones
  and r3,r10,#0x80000000
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV
;@ is reg negative?
  bmi chktrap41b8
;@ Do arithmetic:
  cmp r1,r0
  bgt chktrap41b8
;@ old N remains
  orr r10,r10,r3
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

chktrap41b8: ;@ CHK exception:
  mov r0,#6
  bl Exception
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#58 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [41b9] chk $33333333.l, a0 uses Op41b9 ----------
Op41b9:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get value into r0:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #16
  movs r1,r1,asl #16

;@ get flags, including undocumented ones
  and r3,r10,#0x80000000
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV
;@ is reg negative?
  bmi chktrap41b9
;@ Do arithmetic:
  cmp r1,r0
  bgt chktrap41b9
;@ old N remains
  orr r10,r10,r3
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

chktrap41b9: ;@ CHK exception:
  mov r0,#6
  bl Exception
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#62 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [41ba] chk ($3333,pc), a0; =3335 uses Op41ba ----------
Op41ba:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get value into r0:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r2,r0 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r0:
  bl cyclone_fetch16 ;@ Call fetch16(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #16
  movs r1,r1,asl #16

;@ get flags, including undocumented ones
  and r3,r10,#0x80000000
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV
;@ is reg negative?
  bmi chktrap41ba
;@ Do arithmetic:
  cmp r1,r0
  bgt chktrap41ba
;@ old N remains
  orr r10,r10,r3
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

chktrap41ba: ;@ CHK exception:
  mov r0,#6
  bl Exception
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#58 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [41bb] chk ($33,pc,d3.w*2), a0; =35 uses Op41bb ----------
Op41bb:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get value into r0:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r0:
  bl cyclone_fetch16 ;@ Call fetch16(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #16
  movs r1,r1,asl #16

;@ get flags, including undocumented ones
  and r3,r10,#0x80000000
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV
;@ is reg negative?
  bmi chktrap41bb
;@ Do arithmetic:
  cmp r1,r0
  bgt chktrap41bb
;@ old N remains
  orr r10,r10,r3
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

chktrap41bb: ;@ CHK exception:
  mov r0,#6
  bl Exception
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#60 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [41bc] chk #$33, a0 uses Op41bc ----------
Op41bc:
;@ Get value into r0:
;@ EaCalc : Get '#$3333' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r0) into r0:

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #16
  movs r1,r1,asl #16

;@ get flags, including undocumented ones
  and r3,r10,#0x80000000
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV
;@ is reg negative?
  bmi chktrap41bc
;@ Do arithmetic:
  cmp r1,r0
  bgt chktrap41bc
;@ old N remains
  orr r10,r10,r3
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

chktrap41bc: ;@ CHK exception:
  mov r0,#6
  bl Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#54 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [41d0] lea (a0), a0 uses Op41d0 ----------
Op41d0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r1:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r1,[r7,r2,lsl #2]
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [41e8] lea ($3333,a0), a0 uses Op41e8 ----------
Op41e8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r1:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r1,r0,r2 ;@ Add on offset
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [41f8] lea $3333.w, a0 uses Op41f8 ----------
Op41f8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r1:
  ldrsh r1,[r4],#2 ;@ Fetch Absolute Short address
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [41f9] lea $33333333.l, a0 uses Op41f9 ----------
Op41f9:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r1:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r1,r0,r2,lsl #16
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [41fa] lea ($3333,pc), a0; =3335 uses Op41fa ----------
Op41fa:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,pc)' into r1:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r1,r2,r0 ;@ ($nn,PC)
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [41fb] lea ($33,pc,d3.w*2), a0; =35 uses Op41fb ----------
Op41fb:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,pc,d3.w*2)' into r1:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r1,r2,r0 ;@ r1=Disp+PC+Rn
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4200] clr.b d0 uses Op4200 ----------
Op4200:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f

;@ Clear:
  mov r1,#0
  mov r10,#0x40000000 ;@ NZCV=0100

;@ EaWrite: r1 into register[r11]:
  strb r1,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4210] clr.b (a0) uses Op4210 ----------
Op4210:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]

;@ Clear:
  mov r1,#0
  mov r10,#0x40000000 ;@ NZCV=0100

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  and r1,r1,#0xff
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4218] clr.b (a0)+ uses Op4218 ----------
Op4218:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]

;@ Clear:
  mov r1,#0
  mov r10,#0x40000000 ;@ NZCV=0100

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  and r1,r1,#0xff
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [421f] clr.b (a7)+ uses Op421f ----------
Op421f:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a7)+' into r11:
  ldr r11,[r7,#0x3c] ;@ A7
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7

;@ Clear:
  mov r1,#0
  mov r10,#0x40000000 ;@ NZCV=0100

;@ EaWrite: Write r1 into '(a7)+' (address in r11):
  and r1,r1,#0xff
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4220] clr.b -(a0) uses Op4220 ----------
Op4220:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#1 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]

;@ Clear:
  mov r1,#0
  mov r10,#0x40000000 ;@ NZCV=0100

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  and r1,r1,#0xff
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4227] clr.b -(a7) uses Op4227 ----------
Op4227:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a7)' into r11:
  ldr r11,[r7,#0x3c] ;@ A7
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,#0x3c] ;@ A7

;@ Clear:
  mov r1,#0
  mov r10,#0x40000000 ;@ NZCV=0100

;@ EaWrite: Write r1 into '-(a7)' (address in r11):
  and r1,r1,#0xff
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4228] clr.b ($3333,a0) uses Op4228 ----------
Op4228:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset

;@ Clear:
  mov r1,#0
  mov r10,#0x40000000 ;@ NZCV=0100

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  and r1,r1,#0xff
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4230] clr.b ($33,a0,d3.w*2) uses Op4230 ----------
Op4230:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn

;@ Clear:
  mov r1,#0
  mov r10,#0x40000000 ;@ NZCV=0100

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  and r1,r1,#0xff
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4238] clr.b $3333.w uses Op4238 ----------
Op4238:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address

;@ Clear:
  mov r1,#0
  mov r10,#0x40000000 ;@ NZCV=0100

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  and r1,r1,#0xff
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4239] clr.b $33333333.l uses Op4239 ----------
Op4239:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16

;@ Clear:
  mov r1,#0
  mov r10,#0x40000000 ;@ NZCV=0100

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  and r1,r1,#0xff
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4240] clr.w d0 uses Op4240 ----------
Op4240:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
  mov r11,r11,lsl #2

;@ Clear:
  mov r1,#0
  mov r10,#0x40000000 ;@ NZCV=0100

;@ EaWrite: r1 into register[r11]:
  strh r1,[r7,r11]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4250] clr.w (a0) uses Op4250 ----------
Op4250:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]

;@ Clear:
  mov r1,#0
  mov r10,#0x40000000 ;@ NZCV=0100

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  uxth r1,r1 ;@ zero extend
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4258] clr.w (a0)+ uses Op4258 ----------
Op4258:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]

;@ Clear:
  mov r1,#0
  mov r10,#0x40000000 ;@ NZCV=0100

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  uxth r1,r1 ;@ zero extend
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4260] clr.w -(a0) uses Op4260 ----------
Op4260:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]

;@ Clear:
  mov r1,#0
  mov r10,#0x40000000 ;@ NZCV=0100

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  uxth r1,r1 ;@ zero extend
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4268] clr.w ($3333,a0) uses Op4268 ----------
Op4268:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset

;@ Clear:
  mov r1,#0
  mov r10,#0x40000000 ;@ NZCV=0100

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  uxth r1,r1 ;@ zero extend
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4270] clr.w ($33,a0,d3.w*2) uses Op4270 ----------
Op4270:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn

;@ Clear:
  mov r1,#0
  mov r10,#0x40000000 ;@ NZCV=0100

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  uxth r1,r1 ;@ zero extend
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4278] clr.w $3333.w uses Op4278 ----------
Op4278:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address

;@ Clear:
  mov r1,#0
  mov r10,#0x40000000 ;@ NZCV=0100

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  uxth r1,r1 ;@ zero extend
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4279] clr.w $33333333.l uses Op4279 ----------
Op4279:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16

;@ Clear:
  mov r1,#0
  mov r10,#0x40000000 ;@ NZCV=0100

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  uxth r1,r1 ;@ zero extend
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4280] clr.l d0 uses Op4280 ----------
Op4280:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f

;@ Clear:
  mov r1,#0
  mov r10,#0x40000000 ;@ NZCV=0100

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4290] clr.l (a0) uses Op4290 ----------
Op4290:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]

;@ Clear:
  mov r1,#0
  mov r10,#0x40000000 ;@ NZCV=0100

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  mov r0,r11
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4298] clr.l (a0)+ uses Op4298 ----------
Op4298:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]

;@ Clear:
  mov r1,#0
  mov r10,#0x40000000 ;@ NZCV=0100

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  mov r0,r11
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [42a0] clr.l -(a0) uses Op42a0 ----------
Op42a0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#4 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]

;@ Clear:
  mov r1,#0
  mov r10,#0x40000000 ;@ NZCV=0100

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r0,r11
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [42a8] clr.l ($3333,a0) uses Op42a8 ----------
Op42a8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset

;@ Clear:
  mov r1,#0
  mov r10,#0x40000000 ;@ NZCV=0100

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  mov r0,r11
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [42b0] clr.l ($33,a0,d3.w*2) uses Op42b0 ----------
Op42b0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn

;@ Clear:
  mov r1,#0
  mov r10,#0x40000000 ;@ NZCV=0100

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  mov r0,r11
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [42b8] clr.l $3333.w uses Op42b8 ----------
Op42b8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address

;@ Clear:
  mov r1,#0
  mov r10,#0x40000000 ;@ NZCV=0100

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  mov r0,r11
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [42b9] clr.l $33333333.l uses Op42b9 ----------
Op42b9:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16

;@ Clear:
  mov r1,#0
  mov r10,#0x40000000 ;@ NZCV=0100

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  mov r0,r11
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4400] neg.b d0 uses Op4400 ----------
Op4400:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

;@ Neg:
  mov r0,r0,asl #24
  rsbs r1,r0,#0
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit
  mov r1,r1,asr #24

;@ EaWrite: r1 into register[r11]:
  strb r1,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4410] neg.b (a0) uses Op4410 ----------
Op4410:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

;@ Neg:
  mov r0,r0,asl #24
  rsbs r1,r0,#0
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit
  mov r1,r1,asr #24

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  and r1,r1,#0xff
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4418] neg.b (a0)+ uses Op4418 ----------
Op4418:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

;@ Neg:
  mov r0,r0,asl #24
  rsbs r1,r0,#0
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit
  mov r1,r1,asr #24

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  and r1,r1,#0xff
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [441f] neg.b (a7)+ uses Op441f ----------
Op441f:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a7)+' into r11:
  ldr r11,[r7,#0x3c] ;@ A7
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

;@ Neg:
  mov r0,r0,asl #24
  rsbs r1,r0,#0
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit
  mov r1,r1,asr #24

;@ EaWrite: Write r1 into '(a7)+' (address in r11):
  and r1,r1,#0xff
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4420] neg.b -(a0) uses Op4420 ----------
Op4420:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#1 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

;@ Neg:
  mov r0,r0,asl #24
  rsbs r1,r0,#0
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit
  mov r1,r1,asr #24

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  and r1,r1,#0xff
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4427] neg.b -(a7) uses Op4427 ----------
Op4427:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a7)' into r11:
  ldr r11,[r7,#0x3c] ;@ A7
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

;@ Neg:
  mov r0,r0,asl #24
  rsbs r1,r0,#0
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit
  mov r1,r1,asr #24

;@ EaWrite: Write r1 into '-(a7)' (address in r11):
  and r1,r1,#0xff
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4428] neg.b ($3333,a0) uses Op4428 ----------
Op4428:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

;@ Neg:
  mov r0,r0,asl #24
  rsbs r1,r0,#0
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit
  mov r1,r1,asr #24

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  and r1,r1,#0xff
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4430] neg.b ($33,a0,d3.w*2) uses Op4430 ----------
Op4430:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

;@ Neg:
  mov r0,r0,asl #24
  rsbs r1,r0,#0
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit
  mov r1,r1,asr #24

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  and r1,r1,#0xff
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4438] neg.b $3333.w uses Op4438 ----------
Op4438:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

;@ Neg:
  mov r0,r0,asl #24
  rsbs r1,r0,#0
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit
  mov r1,r1,asr #24

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  and r1,r1,#0xff
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4439] neg.b $33333333.l uses Op4439 ----------
Op4439:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

;@ Neg:
  mov r0,r0,asl #24
  rsbs r1,r0,#0
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit
  mov r1,r1,asr #24

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  and r1,r1,#0xff
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4440] neg.w d0 uses Op4440 ----------
Op4440:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
  mov r11,r11,lsl #2
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11]

;@ Neg:
  mov r0,r0,asl #16
  rsbs r1,r0,#0
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit
  mov r1,r1,asr #16

;@ EaWrite: r1 into register[r11]:
  strh r1,[r7,r11]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4450] neg.w (a0) uses Op4450 ----------
Op4450:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ Neg:
  mov r0,r0,asl #16
  rsbs r1,r0,#0
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit
  mov r1,r1,asr #16

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  uxth r1,r1 ;@ zero extend
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4458] neg.w (a0)+ uses Op4458 ----------
Op4458:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ Neg:
  mov r0,r0,asl #16
  rsbs r1,r0,#0
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit
  mov r1,r1,asr #16

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  uxth r1,r1 ;@ zero extend
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4460] neg.w -(a0) uses Op4460 ----------
Op4460:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ Neg:
  mov r0,r0,asl #16
  rsbs r1,r0,#0
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit
  mov r1,r1,asr #16

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  uxth r1,r1 ;@ zero extend
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4468] neg.w ($3333,a0) uses Op4468 ----------
Op4468:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ Neg:
  mov r0,r0,asl #16
  rsbs r1,r0,#0
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit
  mov r1,r1,asr #16

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  uxth r1,r1 ;@ zero extend
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4470] neg.w ($33,a0,d3.w*2) uses Op4470 ----------
Op4470:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ Neg:
  mov r0,r0,asl #16
  rsbs r1,r0,#0
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit
  mov r1,r1,asr #16

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  uxth r1,r1 ;@ zero extend
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4478] neg.w $3333.w uses Op4478 ----------
Op4478:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ Neg:
  mov r0,r0,asl #16
  rsbs r1,r0,#0
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit
  mov r1,r1,asr #16

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  uxth r1,r1 ;@ zero extend
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4479] neg.w $33333333.l uses Op4479 ----------
Op4479:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ Neg:
  mov r0,r0,asl #16
  rsbs r1,r0,#0
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit
  mov r1,r1,asr #16

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  uxth r1,r1 ;@ zero extend
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4480] neg.l d0 uses Op4480 ----------
Op4480:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

;@ Neg:
  rsbs r1,r0,#0
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4490] neg.l (a0) uses Op4490 ----------
Op4490:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ Neg:
  rsbs r1,r0,#0
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  mov r0,r11
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4498] neg.l (a0)+ uses Op4498 ----------
Op4498:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ Neg:
  rsbs r1,r0,#0
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  mov r0,r11
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [44a0] neg.l -(a0) uses Op44a0 ----------
Op44a0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#4 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ Neg:
  rsbs r1,r0,#0
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r0,r11
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [44a8] neg.l ($3333,a0) uses Op44a8 ----------
Op44a8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ Neg:
  rsbs r1,r0,#0
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  mov r0,r11
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [44b0] neg.l ($33,a0,d3.w*2) uses Op44b0 ----------
Op44b0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ Neg:
  rsbs r1,r0,#0
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  mov r0,r11
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [44b8] neg.l $3333.w uses Op44b8 ----------
Op44b8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ Neg:
  rsbs r1,r0,#0
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  mov r0,r11
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [44b9] neg.l $33333333.l uses Op44b9 ----------
Op44b9:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ Neg:
  rsbs r1,r0,#0
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  mov r0,r11
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [44c0] move d0, ccr uses Op44c0 ----------
Op44c0:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r0:
  ldr r0,[r7,r0,lsl #2]

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsl #25
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  str r2,[r7,#0x4c]   ;@ Store X bit
  mov r10,r0,lsl #28  ;@ r10=NZCV...

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [44d0] move (a0), ccr uses Op44d0 ----------
Op44d0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  bl cyclone_read16 ;@ Call read16(r0) handler

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsl #25
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  str r2,[r7,#0x4c]   ;@ Store X bit
  mov r10,r0,lsl #28  ;@ r10=NZCV...

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [44d8] move (a0)+, ccr uses Op44d8 ----------
Op44d8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  bl cyclone_read16 ;@ Call read16(r0) handler

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsl #25
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  str r2,[r7,#0x4c]   ;@ Store X bit
  mov r10,r0,lsl #28  ;@ r10=NZCV...

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [44e0] move -(a0), ccr uses Op44e0 ----------
Op44e0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  bl cyclone_read16 ;@ Call read16(r0) handler

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsl #25
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  str r2,[r7,#0x4c]   ;@ Store X bit
  mov r10,r0,lsl #28  ;@ r10=NZCV...

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [44e8] move ($3333,a0), ccr uses Op44e8 ----------
Op44e8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  bl cyclone_read16 ;@ Call read16(r0) handler

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsl #25
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  str r2,[r7,#0x4c]   ;@ Store X bit
  mov r10,r0,lsl #28  ;@ r10=NZCV...

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [44f0] move ($33,a0,d3.w*2), ccr uses Op44f0 ----------
Op44f0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  bl cyclone_read16 ;@ Call read16(r0) handler

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsl #25
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  str r2,[r7,#0x4c]   ;@ Store X bit
  mov r10,r0,lsl #28  ;@ r10=NZCV...

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [44f8] move $3333.w, ccr uses Op44f8 ----------
Op44f8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  bl cyclone_read16 ;@ Call read16(r0) handler

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsl #25
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  str r2,[r7,#0x4c]   ;@ Store X bit
  mov r10,r0,lsl #28  ;@ r10=NZCV...

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [44f9] move $33333333.l, ccr uses Op44f9 ----------
Op44f9:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  bl cyclone_read16 ;@ Call read16(r0) handler

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsl #25
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  str r2,[r7,#0x4c]   ;@ Store X bit
  mov r10,r0,lsl #28  ;@ r10=NZCV...

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [44fa] move ($3333,pc), ccr; =3335 uses Op44fa ----------
Op44fa:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r2,r0 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r0:
  bl cyclone_fetch16 ;@ Call fetch16(r0) handler

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsl #25
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  str r2,[r7,#0x4c]   ;@ Store X bit
  mov r10,r0,lsl #28  ;@ r10=NZCV...

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [44fb] move ($33,pc,d3.w*2), ccr; =35 uses Op44fb ----------
Op44fb:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r0:
  bl cyclone_fetch16 ;@ Call fetch16(r0) handler

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsl #25
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  str r2,[r7,#0x4c]   ;@ Store X bit
  mov r10,r0,lsl #28  ;@ r10=NZCV...

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [44fc] move #$3333, ccr uses Op44fc ----------
Op44fc:
;@ EaCalc : Get '#$3333' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r0) into r0:

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsl #25
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  str r2,[r7,#0x4c]   ;@ Store X bit
  mov r10,r0,lsl #28  ;@ r10=NZCV...

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4600] not.b d0 uses Op4600 ----------
Op4600:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

;@ Not:
  mov r0,r0,asl #24
  mvns r1,r0,asr #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: r1 into register[r11]:
  strb r1,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4610] not.b (a0) uses Op4610 ----------
Op4610:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

;@ Not:
  mov r0,r0,asl #24
  mvns r1,r0,asr #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  and r1,r1,#0xff
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4618] not.b (a0)+ uses Op4618 ----------
Op4618:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

;@ Not:
  mov r0,r0,asl #24
  mvns r1,r0,asr #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  and r1,r1,#0xff
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [461f] not.b (a7)+ uses Op461f ----------
Op461f:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a7)+' into r11:
  ldr r11,[r7,#0x3c] ;@ A7
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

;@ Not:
  mov r0,r0,asl #24
  mvns r1,r0,asr #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '(a7)+' (address in r11):
  and r1,r1,#0xff
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4620] not.b -(a0) uses Op4620 ----------
Op4620:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#1 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

;@ Not:
  mov r0,r0,asl #24
  mvns r1,r0,asr #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  and r1,r1,#0xff
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4627] not.b -(a7) uses Op4627 ----------
Op4627:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a7)' into r11:
  ldr r11,[r7,#0x3c] ;@ A7
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

;@ Not:
  mov r0,r0,asl #24
  mvns r1,r0,asr #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '-(a7)' (address in r11):
  and r1,r1,#0xff
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4628] not.b ($3333,a0) uses Op4628 ----------
Op4628:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

;@ Not:
  mov r0,r0,asl #24
  mvns r1,r0,asr #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  and r1,r1,#0xff
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4630] not.b ($33,a0,d3.w*2) uses Op4630 ----------
Op4630:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

;@ Not:
  mov r0,r0,asl #24
  mvns r1,r0,asr #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  and r1,r1,#0xff
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4638] not.b $3333.w uses Op4638 ----------
Op4638:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

;@ Not:
  mov r0,r0,asl #24
  mvns r1,r0,asr #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  and r1,r1,#0xff
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4639] not.b $33333333.l uses Op4639 ----------
Op4639:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

;@ Not:
  mov r0,r0,asl #24
  mvns r1,r0,asr #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  and r1,r1,#0xff
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4640] not.w d0 uses Op4640 ----------
Op4640:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
  mov r11,r11,lsl #2
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11]

;@ Not:
  mov r0,r0,asl #16
  mvns r1,r0,asr #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: r1 into register[r11]:
  strh r1,[r7,r11]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4650] not.w (a0) uses Op4650 ----------
Op4650:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ Not:
  mov r0,r0,asl #16
  mvns r1,r0,asr #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  uxth r1,r1 ;@ zero extend
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4658] not.w (a0)+ uses Op4658 ----------
Op4658:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ Not:
  mov r0,r0,asl #16
  mvns r1,r0,asr #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  uxth r1,r1 ;@ zero extend
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4660] not.w -(a0) uses Op4660 ----------
Op4660:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ Not:
  mov r0,r0,asl #16
  mvns r1,r0,asr #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  uxth r1,r1 ;@ zero extend
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4668] not.w ($3333,a0) uses Op4668 ----------
Op4668:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ Not:
  mov r0,r0,asl #16
  mvns r1,r0,asr #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  uxth r1,r1 ;@ zero extend
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4670] not.w ($33,a0,d3.w*2) uses Op4670 ----------
Op4670:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ Not:
  mov r0,r0,asl #16
  mvns r1,r0,asr #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  uxth r1,r1 ;@ zero extend
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4678] not.w $3333.w uses Op4678 ----------
Op4678:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ Not:
  mov r0,r0,asl #16
  mvns r1,r0,asr #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  uxth r1,r1 ;@ zero extend
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4679] not.w $33333333.l uses Op4679 ----------
Op4679:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ Not:
  mov r0,r0,asl #16
  mvns r1,r0,asr #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  uxth r1,r1 ;@ zero extend
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4680] not.l d0 uses Op4680 ----------
Op4680:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

;@ Not:
  mvns r1,r0
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4690] not.l (a0) uses Op4690 ----------
Op4690:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ Not:
  mvns r1,r0
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  mov r0,r11
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4698] not.l (a0)+ uses Op4698 ----------
Op4698:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ Not:
  mvns r1,r0
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  mov r0,r11
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [46a0] not.l -(a0) uses Op46a0 ----------
Op46a0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#4 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ Not:
  mvns r1,r0
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r0,r11
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [46a8] not.l ($3333,a0) uses Op46a8 ----------
Op46a8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ Not:
  mvns r1,r0
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  mov r0,r11
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [46b0] not.l ($33,a0,d3.w*2) uses Op46b0 ----------
Op46b0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ Not:
  mvns r1,r0
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  mov r0,r11
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [46b8] not.l $3333.w uses Op46b8 ----------
Op46b8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ Not:
  mvns r1,r0
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  mov r0,r11
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [46b9] not.l $33333333.l uses Op46b9 ----------
Op46b9:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ Not:
  mvns r1,r0
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  mov r0,r11
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [46c0] move d0, sr uses Op46c0 ----------
Op46c0:
  ldr r11,[r7,#0x44] ;@ Get SR high
  tst r11,#0x20 ;@ Check we are in supervisor mode
  beq WrongPrivilegeMode ;@ No

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r0:
  ldr r0,[r7,r0,lsl #2]

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsl #25
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  str r2,[r7,#0x4c]   ;@ Store X bit
  mov r10,r0,lsl #28  ;@ r10=NZCV...
  mov r1,r0,ror #8
  and r1,r1,#0xa7 ;@ only take defined bits
  strb r1,[r7,#0x44] ;@ Store SR high

;@ A7 <-> OSP?
  eor r0,r1,r11
  tst r0,#0x20
  beq no_sp_swap46c0
 ;@ swap OSP and A7:
  ldr r11,[r7,#0x3C] ;@ Get A7
  ldr r0, [r7,#0x48] ;@ Get OSP
  str r11,[r7,#0x48]
  str r0, [r7,#0x3C]
no_sp_swap46c0:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  ldr r1,[r7,#0x44]
  subs r5,r5,#12 ;@ Subtract cycles
;@ CheckTrace:
  tst r1,#0x80
  bne CycloneDoTraceWithChecks
  cmp r5,#0
  ble CycloneEnd
;@ CheckInterrupt:
  movs r0,r1,lsr #24 ;@ Get IRQ level
  ldreq pc,[r6,r8,asl #2] ;@ Jump to next opcode handler
  cmp r0,#6 ;@ irq>6 ?
  andle r1,r1,#7 ;@ Get interrupt mask
  cmple r0,r1 ;@ irq<=6: Is irq<=mask ?
  ldrle pc,[r6,r8,asl #2] ;@ Jump to next opcode handler
  b CycloneDoInterruptGoBack

;@ ---------- [46d0] move (a0), sr uses Op46d0 ----------
Op46d0:
  ldr r11,[r7,#0x44] ;@ Get SR high
  str r5,[r7,#0x5c] ;@ Save Cycles
  tst r11,#0x20 ;@ Check we are in supervisor mode
  beq WrongPrivilegeMode ;@ No

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  bl cyclone_read16 ;@ Call read16(r0) handler

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsl #25
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  str r2,[r7,#0x4c]   ;@ Store X bit
  mov r10,r0,lsl #28  ;@ r10=NZCV...
  mov r1,r0,ror #8
  and r1,r1,#0xa7 ;@ only take defined bits
  strb r1,[r7,#0x44] ;@ Store SR high

;@ A7 <-> OSP?
  eor r0,r1,r11
  tst r0,#0x20
  beq no_sp_swap46d0
 ;@ swap OSP and A7:
  ldr r11,[r7,#0x3C] ;@ Get A7
  ldr r0, [r7,#0x48] ;@ Get OSP
  str r11,[r7,#0x48]
  str r0, [r7,#0x3C]
no_sp_swap46d0:
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  ldr r1,[r7,#0x44]
  subs r5,r5,#16 ;@ Subtract cycles
;@ CheckTrace:
  tst r1,#0x80
  bne CycloneDoTraceWithChecks
  cmp r5,#0
  ble CycloneEnd
;@ CheckInterrupt:
  movs r0,r1,lsr #24 ;@ Get IRQ level
  ldreq pc,[r6,r8,asl #2] ;@ Jump to next opcode handler
  cmp r0,#6 ;@ irq>6 ?
  andle r1,r1,#7 ;@ Get interrupt mask
  cmple r0,r1 ;@ irq<=6: Is irq<=mask ?
  ldrle pc,[r6,r8,asl #2] ;@ Jump to next opcode handler
  b CycloneDoInterruptGoBack

;@ ---------- [46d8] move (a0)+, sr uses Op46d8 ----------
Op46d8:
  ldr r11,[r7,#0x44] ;@ Get SR high
  str r5,[r7,#0x5c] ;@ Save Cycles
  tst r11,#0x20 ;@ Check we are in supervisor mode
  beq WrongPrivilegeMode ;@ No

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  bl cyclone_read16 ;@ Call read16(r0) handler

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsl #25
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  str r2,[r7,#0x4c]   ;@ Store X bit
  mov r10,r0,lsl #28  ;@ r10=NZCV...
  mov r1,r0,ror #8
  and r1,r1,#0xa7 ;@ only take defined bits
  strb r1,[r7,#0x44] ;@ Store SR high

;@ A7 <-> OSP?
  eor r0,r1,r11
  tst r0,#0x20
  beq no_sp_swap46d8
 ;@ swap OSP and A7:
  ldr r11,[r7,#0x3C] ;@ Get A7
  ldr r0, [r7,#0x48] ;@ Get OSP
  str r11,[r7,#0x48]
  str r0, [r7,#0x3C]
no_sp_swap46d8:
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  ldr r1,[r7,#0x44]
  subs r5,r5,#16 ;@ Subtract cycles
;@ CheckTrace:
  tst r1,#0x80
  bne CycloneDoTraceWithChecks
  cmp r5,#0
  ble CycloneEnd
;@ CheckInterrupt:
  movs r0,r1,lsr #24 ;@ Get IRQ level
  ldreq pc,[r6,r8,asl #2] ;@ Jump to next opcode handler
  cmp r0,#6 ;@ irq>6 ?
  andle r1,r1,#7 ;@ Get interrupt mask
  cmple r0,r1 ;@ irq<=6: Is irq<=mask ?
  ldrle pc,[r6,r8,asl #2] ;@ Jump to next opcode handler
  b CycloneDoInterruptGoBack

;@ ---------- [46e0] move -(a0), sr uses Op46e0 ----------
Op46e0:
  ldr r11,[r7,#0x44] ;@ Get SR high
  str r5,[r7,#0x5c] ;@ Save Cycles
  tst r11,#0x20 ;@ Check we are in supervisor mode
  beq WrongPrivilegeMode ;@ No

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  bl cyclone_read16 ;@ Call read16(r0) handler

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsl #25
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  str r2,[r7,#0x4c]   ;@ Store X bit
  mov r10,r0,lsl #28  ;@ r10=NZCV...
  mov r1,r0,ror #8
  and r1,r1,#0xa7 ;@ only take defined bits
  strb r1,[r7,#0x44] ;@ Store SR high

;@ A7 <-> OSP?
  eor r0,r1,r11
  tst r0,#0x20
  beq no_sp_swap46e0
 ;@ swap OSP and A7:
  ldr r11,[r7,#0x3C] ;@ Get A7
  ldr r0, [r7,#0x48] ;@ Get OSP
  str r11,[r7,#0x48]
  str r0, [r7,#0x3C]
no_sp_swap46e0:
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  ldr r1,[r7,#0x44]
  subs r5,r5,#18 ;@ Subtract cycles
;@ CheckTrace:
  tst r1,#0x80
  bne CycloneDoTraceWithChecks
  cmp r5,#0
  ble CycloneEnd
;@ CheckInterrupt:
  movs r0,r1,lsr #24 ;@ Get IRQ level
  ldreq pc,[r6,r8,asl #2] ;@ Jump to next opcode handler
  cmp r0,#6 ;@ irq>6 ?
  andle r1,r1,#7 ;@ Get interrupt mask
  cmple r0,r1 ;@ irq<=6: Is irq<=mask ?
  ldrle pc,[r6,r8,asl #2] ;@ Jump to next opcode handler
  b CycloneDoInterruptGoBack

;@ ---------- [46e8] move ($3333,a0), sr uses Op46e8 ----------
Op46e8:
  ldr r11,[r7,#0x44] ;@ Get SR high
  str r5,[r7,#0x5c] ;@ Save Cycles
  tst r11,#0x20 ;@ Check we are in supervisor mode
  beq WrongPrivilegeMode ;@ No

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  bl cyclone_read16 ;@ Call read16(r0) handler

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsl #25
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  str r2,[r7,#0x4c]   ;@ Store X bit
  mov r10,r0,lsl #28  ;@ r10=NZCV...
  mov r1,r0,ror #8
  and r1,r1,#0xa7 ;@ only take defined bits
  strb r1,[r7,#0x44] ;@ Store SR high

;@ A7 <-> OSP?
  eor r0,r1,r11
  tst r0,#0x20
  beq no_sp_swap46e8
 ;@ swap OSP and A7:
  ldr r11,[r7,#0x3C] ;@ Get A7
  ldr r0, [r7,#0x48] ;@ Get OSP
  str r11,[r7,#0x48]
  str r0, [r7,#0x3C]
no_sp_swap46e8:
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  ldr r1,[r7,#0x44]
  subs r5,r5,#20 ;@ Subtract cycles
;@ CheckTrace:
  tst r1,#0x80
  bne CycloneDoTraceWithChecks
  cmp r5,#0
  ble CycloneEnd
;@ CheckInterrupt:
  movs r0,r1,lsr #24 ;@ Get IRQ level
  ldreq pc,[r6,r8,asl #2] ;@ Jump to next opcode handler
  cmp r0,#6 ;@ irq>6 ?
  andle r1,r1,#7 ;@ Get interrupt mask
  cmple r0,r1 ;@ irq<=6: Is irq<=mask ?
  ldrle pc,[r6,r8,asl #2] ;@ Jump to next opcode handler
  b CycloneDoInterruptGoBack

;@ ---------- [46f0] move ($33,a0,d3.w*2), sr uses Op46f0 ----------
Op46f0:
  ldr r11,[r7,#0x44] ;@ Get SR high
  str r5,[r7,#0x5c] ;@ Save Cycles
  tst r11,#0x20 ;@ Check we are in supervisor mode
  beq WrongPrivilegeMode ;@ No

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  bl cyclone_read16 ;@ Call read16(r0) handler

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsl #25
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  str r2,[r7,#0x4c]   ;@ Store X bit
  mov r10,r0,lsl #28  ;@ r10=NZCV...
  mov r1,r0,ror #8
  and r1,r1,#0xa7 ;@ only take defined bits
  strb r1,[r7,#0x44] ;@ Store SR high

;@ A7 <-> OSP?
  eor r0,r1,r11
  tst r0,#0x20
  beq no_sp_swap46f0
 ;@ swap OSP and A7:
  ldr r11,[r7,#0x3C] ;@ Get A7
  ldr r0, [r7,#0x48] ;@ Get OSP
  str r11,[r7,#0x48]
  str r0, [r7,#0x3C]
no_sp_swap46f0:
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  ldr r1,[r7,#0x44]
  subs r5,r5,#22 ;@ Subtract cycles
;@ CheckTrace:
  tst r1,#0x80
  bne CycloneDoTraceWithChecks
  cmp r5,#0
  ble CycloneEnd
;@ CheckInterrupt:
  movs r0,r1,lsr #24 ;@ Get IRQ level
  ldreq pc,[r6,r8,asl #2] ;@ Jump to next opcode handler
  cmp r0,#6 ;@ irq>6 ?
  andle r1,r1,#7 ;@ Get interrupt mask
  cmple r0,r1 ;@ irq<=6: Is irq<=mask ?
  ldrle pc,[r6,r8,asl #2] ;@ Jump to next opcode handler
  b CycloneDoInterruptGoBack

;@ ---------- [46f8] move $3333.w, sr uses Op46f8 ----------
Op46f8:
  ldr r11,[r7,#0x44] ;@ Get SR high
  str r5,[r7,#0x5c] ;@ Save Cycles
  tst r11,#0x20 ;@ Check we are in supervisor mode
  beq WrongPrivilegeMode ;@ No

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  bl cyclone_read16 ;@ Call read16(r0) handler

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsl #25
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  str r2,[r7,#0x4c]   ;@ Store X bit
  mov r10,r0,lsl #28  ;@ r10=NZCV...
  mov r1,r0,ror #8
  and r1,r1,#0xa7 ;@ only take defined bits
  strb r1,[r7,#0x44] ;@ Store SR high

;@ A7 <-> OSP?
  eor r0,r1,r11
  tst r0,#0x20
  beq no_sp_swap46f8
 ;@ swap OSP and A7:
  ldr r11,[r7,#0x3C] ;@ Get A7
  ldr r0, [r7,#0x48] ;@ Get OSP
  str r11,[r7,#0x48]
  str r0, [r7,#0x3C]
no_sp_swap46f8:
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  ldr r1,[r7,#0x44]
  subs r5,r5,#20 ;@ Subtract cycles
;@ CheckTrace:
  tst r1,#0x80
  bne CycloneDoTraceWithChecks
  cmp r5,#0
  ble CycloneEnd
;@ CheckInterrupt:
  movs r0,r1,lsr #24 ;@ Get IRQ level
  ldreq pc,[r6,r8,asl #2] ;@ Jump to next opcode handler
  cmp r0,#6 ;@ irq>6 ?
  andle r1,r1,#7 ;@ Get interrupt mask
  cmple r0,r1 ;@ irq<=6: Is irq<=mask ?
  ldrle pc,[r6,r8,asl #2] ;@ Jump to next opcode handler
  b CycloneDoInterruptGoBack

;@ ---------- [46f9] move $33333333.l, sr uses Op46f9 ----------
Op46f9:
  ldr r11,[r7,#0x44] ;@ Get SR high
  str r5,[r7,#0x5c] ;@ Save Cycles
  tst r11,#0x20 ;@ Check we are in supervisor mode
  beq WrongPrivilegeMode ;@ No

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  bl cyclone_read16 ;@ Call read16(r0) handler

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsl #25
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  str r2,[r7,#0x4c]   ;@ Store X bit
  mov r10,r0,lsl #28  ;@ r10=NZCV...
  mov r1,r0,ror #8
  and r1,r1,#0xa7 ;@ only take defined bits
  strb r1,[r7,#0x44] ;@ Store SR high

;@ A7 <-> OSP?
  eor r0,r1,r11
  tst r0,#0x20
  beq no_sp_swap46f9
 ;@ swap OSP and A7:
  ldr r11,[r7,#0x3C] ;@ Get A7
  ldr r0, [r7,#0x48] ;@ Get OSP
  str r11,[r7,#0x48]
  str r0, [r7,#0x3C]
no_sp_swap46f9:
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  ldr r1,[r7,#0x44]
  subs r5,r5,#24 ;@ Subtract cycles
;@ CheckTrace:
  tst r1,#0x80
  bne CycloneDoTraceWithChecks
  cmp r5,#0
  ble CycloneEnd
;@ CheckInterrupt:
  movs r0,r1,lsr #24 ;@ Get IRQ level
  ldreq pc,[r6,r8,asl #2] ;@ Jump to next opcode handler
  cmp r0,#6 ;@ irq>6 ?
  andle r1,r1,#7 ;@ Get interrupt mask
  cmple r0,r1 ;@ irq<=6: Is irq<=mask ?
  ldrle pc,[r6,r8,asl #2] ;@ Jump to next opcode handler
  b CycloneDoInterruptGoBack

;@ ---------- [46fa] move ($3333,pc), sr; =3335 uses Op46fa ----------
Op46fa:
  ldr r11,[r7,#0x44] ;@ Get SR high
  str r5,[r7,#0x5c] ;@ Save Cycles
  tst r11,#0x20 ;@ Check we are in supervisor mode
  beq WrongPrivilegeMode ;@ No

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r2,r0 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r0:
  bl cyclone_fetch16 ;@ Call fetch16(r0) handler

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsl #25
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  str r2,[r7,#0x4c]   ;@ Store X bit
  mov r10,r0,lsl #28  ;@ r10=NZCV...
  mov r1,r0,ror #8
  and r1,r1,#0xa7 ;@ only take defined bits
  strb r1,[r7,#0x44] ;@ Store SR high

;@ A7 <-> OSP?
  eor r0,r1,r11
  tst r0,#0x20
  beq no_sp_swap46fa
 ;@ swap OSP and A7:
  ldr r11,[r7,#0x3C] ;@ Get A7
  ldr r0, [r7,#0x48] ;@ Get OSP
  str r11,[r7,#0x48]
  str r0, [r7,#0x3C]
no_sp_swap46fa:
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  ldr r1,[r7,#0x44]
  subs r5,r5,#20 ;@ Subtract cycles
;@ CheckTrace:
  tst r1,#0x80
  bne CycloneDoTraceWithChecks
  cmp r5,#0
  ble CycloneEnd
;@ CheckInterrupt:
  movs r0,r1,lsr #24 ;@ Get IRQ level
  ldreq pc,[r6,r8,asl #2] ;@ Jump to next opcode handler
  cmp r0,#6 ;@ irq>6 ?
  andle r1,r1,#7 ;@ Get interrupt mask
  cmple r0,r1 ;@ irq<=6: Is irq<=mask ?
  ldrle pc,[r6,r8,asl #2] ;@ Jump to next opcode handler
  b CycloneDoInterruptGoBack

;@ ---------- [46fb] move ($33,pc,d3.w*2), sr; =35 uses Op46fb ----------
Op46fb:
  ldr r11,[r7,#0x44] ;@ Get SR high
  str r5,[r7,#0x5c] ;@ Save Cycles
  tst r11,#0x20 ;@ Check we are in supervisor mode
  beq WrongPrivilegeMode ;@ No

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r0:
  bl cyclone_fetch16 ;@ Call fetch16(r0) handler

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsl #25
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  str r2,[r7,#0x4c]   ;@ Store X bit
  mov r10,r0,lsl #28  ;@ r10=NZCV...
  mov r1,r0,ror #8
  and r1,r1,#0xa7 ;@ only take defined bits
  strb r1,[r7,#0x44] ;@ Store SR high

;@ A7 <-> OSP?
  eor r0,r1,r11
  tst r0,#0x20
  beq no_sp_swap46fb
 ;@ swap OSP and A7:
  ldr r11,[r7,#0x3C] ;@ Get A7
  ldr r0, [r7,#0x48] ;@ Get OSP
  str r11,[r7,#0x48]
  str r0, [r7,#0x3C]
no_sp_swap46fb:
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  ldr r1,[r7,#0x44]
  subs r5,r5,#22 ;@ Subtract cycles
;@ CheckTrace:
  tst r1,#0x80
  bne CycloneDoTraceWithChecks
  cmp r5,#0
  ble CycloneEnd
;@ CheckInterrupt:
  movs r0,r1,lsr #24 ;@ Get IRQ level
  ldreq pc,[r6,r8,asl #2] ;@ Jump to next opcode handler
  cmp r0,#6 ;@ irq>6 ?
  andle r1,r1,#7 ;@ Get interrupt mask
  cmple r0,r1 ;@ irq<=6: Is irq<=mask ?
  ldrle pc,[r6,r8,asl #2] ;@ Jump to next opcode handler
  b CycloneDoInterruptGoBack

;@ ---------- [46fc] move #$3333, sr uses Op46fc ----------
Op46fc:
  ldr r11,[r7,#0x44] ;@ Get SR high
  tst r11,#0x20 ;@ Check we are in supervisor mode
  beq WrongPrivilegeMode ;@ No

;@ EaCalc : Get '#$3333' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r0) into r0:

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsl #25
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  str r2,[r7,#0x4c]   ;@ Store X bit
  mov r10,r0,lsl #28  ;@ r10=NZCV...
  mov r1,r0,ror #8
  and r1,r1,#0xa7 ;@ only take defined bits
  strb r1,[r7,#0x44] ;@ Store SR high

;@ A7 <-> OSP?
  eor r0,r1,r11
  tst r0,#0x20
  beq no_sp_swap46fc
 ;@ swap OSP and A7:
  ldr r11,[r7,#0x3C] ;@ Get A7
  ldr r0, [r7,#0x48] ;@ Get OSP
  str r11,[r7,#0x48]
  str r0, [r7,#0x3C]
no_sp_swap46fc:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  ldr r1,[r7,#0x44]
  subs r5,r5,#16 ;@ Subtract cycles
;@ CheckTrace:
  tst r1,#0x80
  bne CycloneDoTraceWithChecks
  cmp r5,#0
  ble CycloneEnd
;@ CheckInterrupt:
  movs r0,r1,lsr #24 ;@ Get IRQ level
  ldreq pc,[r6,r8,asl #2] ;@ Jump to next opcode handler
  cmp r0,#6 ;@ irq>6 ?
  andle r1,r1,#7 ;@ Get interrupt mask
  cmple r0,r1 ;@ irq<=6: Is irq<=mask ?
  ldrle pc,[r6,r8,asl #2] ;@ Jump to next opcode handler
  b CycloneDoInterruptGoBack

;@ ---------- [4800] nbcd d0 uses Op4800 ----------
Op4800:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
;@ EaRead : Read register[r11] into r0:
  ldrb r0,[r7,r11,lsl #2]

  ldr r2,[r7,#0x4c]
  bic r10,r10,#0xb0000000 ;@ clear all flags, except Z
  and r2,r2,#0x20000000
  rsb r1,r0,#0 ;@ do arithmetic
  subs r1,r1,r2,lsr #29 ;@ X
  beq finish4800

  movs r1,r1,lsl #24
  orrmi r10,r10,#0x10000000 ;@ Undefined V behavior
  orr r2,r1,r0,lsl #24
  tst r2,#0x0f000000
  andeq r1,r1,#0xf0000000
  orreq r1,r1,#0x06000000
  adds r1,r1,#0x9a000000
  bicmi r10,r10,#0x10000000 ;@ Undefined V behavior part II
  orrmi r10,r10,#0x80000000 ;@ Undefined N behavior
  bicne r10,r10,#0x40000000 ;@ Z
  orr r10,r10,#0x20000000 ;@ C

;@ EaWrite: r1 into register[r11]:
  mov r1,r1,lsr #24
  strb r1,[r7,r11,lsl #2]

finish4800:
  str r10,[r7,#0x4c] ;@ Save X

  ldr r6,[r7,#0x54]
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4810] nbcd (a0) uses Op4810 ----------
Op4810:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

  ldr r2,[r7,#0x4c]
  bic r10,r10,#0xb0000000 ;@ clear all flags, except Z
  and r2,r2,#0x20000000
  rsb r1,r0,#0 ;@ do arithmetic
  subs r1,r1,r2,lsr #29 ;@ X
  beq finish4810

  movs r1,r1,lsl #24
  orrmi r10,r10,#0x10000000 ;@ Undefined V behavior
  orr r2,r1,r0,lsl #24
  tst r2,#0x0f000000
  andeq r1,r1,#0xf0000000
  orreq r1,r1,#0x06000000
  adds r1,r1,#0x9a000000
  bicmi r10,r10,#0x10000000 ;@ Undefined V behavior part II
  orrmi r10,r10,#0x80000000 ;@ Undefined N behavior
  bicne r10,r10,#0x40000000 ;@ Z
  orr r10,r10,#0x20000000 ;@ C

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  mov r1,r1,lsr #24
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

finish4810:
  str r10,[r7,#0x4c] ;@ Save X

  ldr r6,[r7,#0x54]
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4818] nbcd (a0)+ uses Op4818 ----------
Op4818:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

  ldr r2,[r7,#0x4c]
  bic r10,r10,#0xb0000000 ;@ clear all flags, except Z
  and r2,r2,#0x20000000
  rsb r1,r0,#0 ;@ do arithmetic
  subs r1,r1,r2,lsr #29 ;@ X
  beq finish4818

  movs r1,r1,lsl #24
  orrmi r10,r10,#0x10000000 ;@ Undefined V behavior
  orr r2,r1,r0,lsl #24
  tst r2,#0x0f000000
  andeq r1,r1,#0xf0000000
  orreq r1,r1,#0x06000000
  adds r1,r1,#0x9a000000
  bicmi r10,r10,#0x10000000 ;@ Undefined V behavior part II
  orrmi r10,r10,#0x80000000 ;@ Undefined N behavior
  bicne r10,r10,#0x40000000 ;@ Z
  orr r10,r10,#0x20000000 ;@ C

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  mov r1,r1,lsr #24
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

finish4818:
  str r10,[r7,#0x4c] ;@ Save X

  ldr r6,[r7,#0x54]
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [481f] nbcd (a7)+ uses Op481f ----------
Op481f:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a7)+' into r11:
  ldr r11,[r7,#0x3c] ;@ A7
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

  ldr r2,[r7,#0x4c]
  bic r10,r10,#0xb0000000 ;@ clear all flags, except Z
  and r2,r2,#0x20000000
  rsb r1,r0,#0 ;@ do arithmetic
  subs r1,r1,r2,lsr #29 ;@ X
  beq finish481f

  movs r1,r1,lsl #24
  orrmi r10,r10,#0x10000000 ;@ Undefined V behavior
  orr r2,r1,r0,lsl #24
  tst r2,#0x0f000000
  andeq r1,r1,#0xf0000000
  orreq r1,r1,#0x06000000
  adds r1,r1,#0x9a000000
  bicmi r10,r10,#0x10000000 ;@ Undefined V behavior part II
  orrmi r10,r10,#0x80000000 ;@ Undefined N behavior
  bicne r10,r10,#0x40000000 ;@ Z
  orr r10,r10,#0x20000000 ;@ C

;@ EaWrite: Write r1 into '(a7)+' (address in r11):
  mov r1,r1,lsr #24
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

finish481f:
  str r10,[r7,#0x4c] ;@ Save X

  ldr r6,[r7,#0x54]
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4820] nbcd -(a0) uses Op4820 ----------
Op4820:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#1 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

  ldr r2,[r7,#0x4c]
  bic r10,r10,#0xb0000000 ;@ clear all flags, except Z
  and r2,r2,#0x20000000
  rsb r1,r0,#0 ;@ do arithmetic
  subs r1,r1,r2,lsr #29 ;@ X
  beq finish4820

  movs r1,r1,lsl #24
  orrmi r10,r10,#0x10000000 ;@ Undefined V behavior
  orr r2,r1,r0,lsl #24
  tst r2,#0x0f000000
  andeq r1,r1,#0xf0000000
  orreq r1,r1,#0x06000000
  adds r1,r1,#0x9a000000
  bicmi r10,r10,#0x10000000 ;@ Undefined V behavior part II
  orrmi r10,r10,#0x80000000 ;@ Undefined N behavior
  bicne r10,r10,#0x40000000 ;@ Z
  orr r10,r10,#0x20000000 ;@ C

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r1,r1,lsr #24
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

finish4820:
  str r10,[r7,#0x4c] ;@ Save X

  ldr r6,[r7,#0x54]
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4827] nbcd -(a7) uses Op4827 ----------
Op4827:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a7)' into r11:
  ldr r11,[r7,#0x3c] ;@ A7
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

  ldr r2,[r7,#0x4c]
  bic r10,r10,#0xb0000000 ;@ clear all flags, except Z
  and r2,r2,#0x20000000
  rsb r1,r0,#0 ;@ do arithmetic
  subs r1,r1,r2,lsr #29 ;@ X
  beq finish4827

  movs r1,r1,lsl #24
  orrmi r10,r10,#0x10000000 ;@ Undefined V behavior
  orr r2,r1,r0,lsl #24
  tst r2,#0x0f000000
  andeq r1,r1,#0xf0000000
  orreq r1,r1,#0x06000000
  adds r1,r1,#0x9a000000
  bicmi r10,r10,#0x10000000 ;@ Undefined V behavior part II
  orrmi r10,r10,#0x80000000 ;@ Undefined N behavior
  bicne r10,r10,#0x40000000 ;@ Z
  orr r10,r10,#0x20000000 ;@ C

;@ EaWrite: Write r1 into '-(a7)' (address in r11):
  mov r1,r1,lsr #24
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

finish4827:
  str r10,[r7,#0x4c] ;@ Save X

  ldr r6,[r7,#0x54]
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4828] nbcd ($3333,a0) uses Op4828 ----------
Op4828:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

  ldr r2,[r7,#0x4c]
  bic r10,r10,#0xb0000000 ;@ clear all flags, except Z
  and r2,r2,#0x20000000
  rsb r1,r0,#0 ;@ do arithmetic
  subs r1,r1,r2,lsr #29 ;@ X
  beq finish4828

  movs r1,r1,lsl #24
  orrmi r10,r10,#0x10000000 ;@ Undefined V behavior
  orr r2,r1,r0,lsl #24
  tst r2,#0x0f000000
  andeq r1,r1,#0xf0000000
  orreq r1,r1,#0x06000000
  adds r1,r1,#0x9a000000
  bicmi r10,r10,#0x10000000 ;@ Undefined V behavior part II
  orrmi r10,r10,#0x80000000 ;@ Undefined N behavior
  bicne r10,r10,#0x40000000 ;@ Z
  orr r10,r10,#0x20000000 ;@ C

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  mov r1,r1,lsr #24
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

finish4828:
  str r10,[r7,#0x4c] ;@ Save X

  ldr r6,[r7,#0x54]
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4830] nbcd ($33,a0,d3.w*2) uses Op4830 ----------
Op4830:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

  ldr r2,[r7,#0x4c]
  bic r10,r10,#0xb0000000 ;@ clear all flags, except Z
  and r2,r2,#0x20000000
  rsb r1,r0,#0 ;@ do arithmetic
  subs r1,r1,r2,lsr #29 ;@ X
  beq finish4830

  movs r1,r1,lsl #24
  orrmi r10,r10,#0x10000000 ;@ Undefined V behavior
  orr r2,r1,r0,lsl #24
  tst r2,#0x0f000000
  andeq r1,r1,#0xf0000000
  orreq r1,r1,#0x06000000
  adds r1,r1,#0x9a000000
  bicmi r10,r10,#0x10000000 ;@ Undefined V behavior part II
  orrmi r10,r10,#0x80000000 ;@ Undefined N behavior
  bicne r10,r10,#0x40000000 ;@ Z
  orr r10,r10,#0x20000000 ;@ C

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  mov r1,r1,lsr #24
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

finish4830:
  str r10,[r7,#0x4c] ;@ Save X

  ldr r6,[r7,#0x54]
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4838] nbcd $3333.w uses Op4838 ----------
Op4838:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

  ldr r2,[r7,#0x4c]
  bic r10,r10,#0xb0000000 ;@ clear all flags, except Z
  and r2,r2,#0x20000000
  rsb r1,r0,#0 ;@ do arithmetic
  subs r1,r1,r2,lsr #29 ;@ X
  beq finish4838

  movs r1,r1,lsl #24
  orrmi r10,r10,#0x10000000 ;@ Undefined V behavior
  orr r2,r1,r0,lsl #24
  tst r2,#0x0f000000
  andeq r1,r1,#0xf0000000
  orreq r1,r1,#0x06000000
  adds r1,r1,#0x9a000000
  bicmi r10,r10,#0x10000000 ;@ Undefined V behavior part II
  orrmi r10,r10,#0x80000000 ;@ Undefined N behavior
  bicne r10,r10,#0x40000000 ;@ Z
  orr r10,r10,#0x20000000 ;@ C

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  mov r1,r1,lsr #24
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

finish4838:
  str r10,[r7,#0x4c] ;@ Save X

  ldr r6,[r7,#0x54]
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4839] nbcd $33333333.l uses Op4839 ----------
Op4839:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

  ldr r2,[r7,#0x4c]
  bic r10,r10,#0xb0000000 ;@ clear all flags, except Z
  and r2,r2,#0x20000000
  rsb r1,r0,#0 ;@ do arithmetic
  subs r1,r1,r2,lsr #29 ;@ X
  beq finish4839

  movs r1,r1,lsl #24
  orrmi r10,r10,#0x10000000 ;@ Undefined V behavior
  orr r2,r1,r0,lsl #24
  tst r2,#0x0f000000
  andeq r1,r1,#0xf0000000
  orreq r1,r1,#0x06000000
  adds r1,r1,#0x9a000000
  bicmi r10,r10,#0x10000000 ;@ Undefined V behavior part II
  orrmi r10,r10,#0x80000000 ;@ Undefined N behavior
  bicne r10,r10,#0x40000000 ;@ Z
  orr r10,r10,#0x20000000 ;@ C

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  mov r1,r1,lsr #24
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

finish4839:
  str r10,[r7,#0x4c] ;@ Save X

  ldr r6,[r7,#0x54]
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4850] pea (a0) uses Op4850 ----------
Op4850:
  str r5,[r7,#0x5c] ;@ Save Cycles

  ldr r11,[r7,#0x3c]
;@ EaCalc : Get '(a0)' into r1:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r1,[r7,r2,lsl #2]

  sub r0,r11,#4 ;@ Predecrement A7
  str r0,[r7,#0x3c] ;@ Save A7

  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4868] pea ($3333,a0) uses Op4868 ----------
Op4868:
  str r5,[r7,#0x5c] ;@ Save Cycles

  ldr r11,[r7,#0x3c]
;@ EaCalc : Get '($3333,a0)' into r1:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r1,r0,r2 ;@ Add on offset

  sub r0,r11,#4 ;@ Predecrement A7
  str r0,[r7,#0x3c] ;@ Save A7

  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4870] pea ($33,a0,d3.w*2) uses Op4870 ----------
Op4870:
  str r5,[r7,#0x5c] ;@ Save Cycles

  ldr r11,[r7,#0x3c]
;@ EaCalc : Get '($33,a0,d3.w*2)' into r1:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r1,r2,r3 ;@ r1=Disp+An+Rn

  sub r0,r11,#4 ;@ Predecrement A7
  str r0,[r7,#0x3c] ;@ Save A7

  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4878] pea $3333.w uses Op4878 ----------
Op4878:
  str r5,[r7,#0x5c] ;@ Save Cycles

  ldr r11,[r7,#0x3c]
;@ EaCalc : Get '$3333.w' into r1:
  ldrsh r1,[r4],#2 ;@ Fetch Absolute Short address

  sub r0,r11,#4 ;@ Predecrement A7
  str r0,[r7,#0x3c] ;@ Save A7

  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4879] pea $33333333.l uses Op4879 ----------
Op4879:
  str r5,[r7,#0x5c] ;@ Save Cycles

  ldr r11,[r7,#0x3c]
;@ EaCalc : Get '$33333333.l' into r1:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r1,r0,r2,lsl #16

  sub r0,r11,#4 ;@ Predecrement A7
  str r0,[r7,#0x3c] ;@ Save A7

  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [487a] pea ($3333,pc); =3335 uses Op487a ----------
Op487a:
  str r5,[r7,#0x5c] ;@ Save Cycles

  ldr r11,[r7,#0x3c]
;@ EaCalc : Get '($3333,pc)' into r1:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r1,r2,r0 ;@ ($nn,PC)

  sub r0,r11,#4 ;@ Predecrement A7
  str r0,[r7,#0x3c] ;@ Save A7

  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [487b] pea ($33,pc,d3.w*2); =35 uses Op487b ----------
Op487b:
  str r5,[r7,#0x5c] ;@ Save Cycles

  ldr r11,[r7,#0x3c]
;@ EaCalc : Get '($33,pc,d3.w*2)' into r1:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r1,r2,r0 ;@ r1=Disp+PC+Rn

  sub r0,r11,#4 ;@ Predecrement A7
  str r0,[r7,#0x3c] ;@ Save A7

  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4880] ext.w d0 uses Op4880 ----------
Op4880:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
  mov r11,r11,lsl #2
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11]

  movs r0,r0,asl #24
  and r10,r0,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV
  mov r1,r0,asr #24

;@ EaWrite: r1 into register[r11]:
  strh r1,[r7,r11]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4890] movem.w d0-d1/d4-d5/a0-a1/a4-a5, (a0) uses Op4890 ----------
Op4890:
  str r5,[r7,#0x5c] ;@ Save Cycles
  mov r5,#0

  ldrh r11,[r4],#2 ;@ r11=register mask

;@ Get the address into r6:
;@ EaCalc : Get '(a0)' into r6:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r6,[r7,r2,lsl #2]
  str r4,[r7,#0x40] ;@ Save PC
;@ r4=Register Index*4:
  mov r4,#-4

  tst r11,r11
  beq NoRegs4890

Movemloop4890:
  add r4,r4,#4 ;@ r4=Next Register
  movs r11,r11,lsr #1
  bcc Movemloop4890

  ;@ Copy register to memory:
  ldr r1,[r7,r4] ;@ Load value from Dn/An
;@ EaWrite: Write r1 into '(a0)' (address in r6):
  uxth r1,r1 ;@ zero extend
  mov r0,r6
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  add r6,r6,#2 ;@ Post-increment address
  sub r5,r5,#4 ;@ Take some cycles
  tst r11,r11
  bne Movemloop4890

NoRegs4890:
  ldr r4,[r7,#0x40]
  ldr r6,[r7,#0x54] ;@ restore Opcode Jump table

  ldr r0,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  add r5,r0,r5
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [48a0] movem.w d2-d3/d6-d7/a2-a3/a6-a7, -(a0) uses Op48a0 ----------
Op48a0:
  str r5,[r7,#0x5c] ;@ Save Cycles
  mov r5,#0

  ldrh r11,[r4],#2 ;@ r11=register mask

;@ Get the address into r6:
;@ EaCalc : Get '(a0)' into r6:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r6,[r7,r2,lsl #2]
  str r4,[r7,#0x40] ;@ Save PC
;@ r4=Register Index*4:
  mov r4,#0x40 ;@ order reversed for -(An)

  tst r11,r11
  beq NoRegs48a0

Movemloop48a0:
  add r4,r4,#-4 ;@ r4=Next Register
  movs r11,r11,lsr #1
  bcc Movemloop48a0

  sub r6,r6,#2 ;@ Pre-decrement address
  ;@ Copy register to memory:
  ldr r1,[r7,r4] ;@ Load value from Dn/An
;@ EaWrite: Write r1 into '-(a0)' (address in r6):
  uxth r1,r1 ;@ zero extend
  mov r0,r6
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  sub r5,r5,#4 ;@ Take some cycles
  tst r11,r11
  bne Movemloop48a0

;@ Write back address:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0007
  orr r0,r0,#0x8 ;@ A0-7
;@ EaWrite: r6 into register[r0]:
  str r6,[r7,r0,lsl #2]

NoRegs48a0:
  ldr r4,[r7,#0x40]
  ldr r6,[r7,#0x54] ;@ restore Opcode Jump table

  ldr r0,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  add r5,r0,r5
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [48a8] movem.w d0-d1/d4-d5/a0-a1/a4-a5, ($3333,a0) uses Op48a8 ----------
Op48a8:
  str r5,[r7,#0x5c] ;@ Save Cycles
  mov r5,#0

  ldrh r11,[r4],#2 ;@ r11=register mask

;@ Get the address into r6:
;@ EaCalc : Get '($3333,a0)' into r6:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r6,r0,r2 ;@ Add on offset
  str r4,[r7,#0x40] ;@ Save PC
;@ r4=Register Index*4:
  mov r4,#-4

  tst r11,r11
  beq NoRegs48a8

Movemloop48a8:
  add r4,r4,#4 ;@ r4=Next Register
  movs r11,r11,lsr #1
  bcc Movemloop48a8

  ;@ Copy register to memory:
  ldr r1,[r7,r4] ;@ Load value from Dn/An
;@ EaWrite: Write r1 into '($3333,a0)' (address in r6):
  uxth r1,r1 ;@ zero extend
  mov r0,r6
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  add r6,r6,#2 ;@ Post-increment address
  sub r5,r5,#4 ;@ Take some cycles
  tst r11,r11
  bne Movemloop48a8

NoRegs48a8:
  ldr r4,[r7,#0x40]
  ldr r6,[r7,#0x54] ;@ restore Opcode Jump table

  ldr r0,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  add r5,r0,r5
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [48b0] movem.w d0-d1/d4-d5/a0-a1/a4-a5, ($33,a0,d3.w*2) uses Op48b0 ----------
Op48b0:
  str r5,[r7,#0x5c] ;@ Save Cycles
  mov r5,#0

  ldrh r11,[r4],#2 ;@ r11=register mask

;@ Get the address into r6:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r6:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r6,r2,r3 ;@ r6=Disp+An+Rn
  str r4,[r7,#0x40] ;@ Save PC
;@ r4=Register Index*4:
  mov r4,#-4

  tst r11,r11
  beq NoRegs48b0

Movemloop48b0:
  add r4,r4,#4 ;@ r4=Next Register
  movs r11,r11,lsr #1
  bcc Movemloop48b0

  ;@ Copy register to memory:
  ldr r1,[r7,r4] ;@ Load value from Dn/An
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r6):
  uxth r1,r1 ;@ zero extend
  mov r0,r6
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  add r6,r6,#2 ;@ Post-increment address
  sub r5,r5,#4 ;@ Take some cycles
  tst r11,r11
  bne Movemloop48b0

NoRegs48b0:
  ldr r4,[r7,#0x40]
  ldr r6,[r7,#0x54] ;@ restore Opcode Jump table

  ldr r0,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  add r5,r0,r5
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [48b8] movem.w d0-d1/d4-d5/a0-a1/a4-a5, $3333.w uses Op48b8 ----------
Op48b8:
  str r5,[r7,#0x5c] ;@ Save Cycles
  mov r5,#0

  ldrh r11,[r4],#2 ;@ r11=register mask

;@ Get the address into r6:
;@ EaCalc : Get '$3333.w' into r6:
  ldrsh r6,[r4],#2 ;@ Fetch Absolute Short address
  str r4,[r7,#0x40] ;@ Save PC
;@ r4=Register Index*4:
  mov r4,#-4

  tst r11,r11
  beq NoRegs48b8

Movemloop48b8:
  add r4,r4,#4 ;@ r4=Next Register
  movs r11,r11,lsr #1
  bcc Movemloop48b8

  ;@ Copy register to memory:
  ldr r1,[r7,r4] ;@ Load value from Dn/An
;@ EaWrite: Write r1 into '$3333.w' (address in r6):
  uxth r1,r1 ;@ zero extend
  mov r0,r6
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  add r6,r6,#2 ;@ Post-increment address
  sub r5,r5,#4 ;@ Take some cycles
  tst r11,r11
  bne Movemloop48b8

NoRegs48b8:
  ldr r4,[r7,#0x40]
  ldr r6,[r7,#0x54] ;@ restore Opcode Jump table

  ldr r0,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  add r5,r0,r5
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [48b9] movem.w d0-d1/d4-d5/a0-a1/a4-a5, $33333333.l uses Op48b9 ----------
Op48b9:
  str r5,[r7,#0x5c] ;@ Save Cycles
  mov r5,#0

  ldrh r11,[r4],#2 ;@ r11=register mask

;@ Get the address into r6:
;@ EaCalc : Get '$33333333.l' into r6:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r6,r0,r2,lsl #16
  str r4,[r7,#0x40] ;@ Save PC
;@ r4=Register Index*4:
  mov r4,#-4

  tst r11,r11
  beq NoRegs48b9

Movemloop48b9:
  add r4,r4,#4 ;@ r4=Next Register
  movs r11,r11,lsr #1
  bcc Movemloop48b9

  ;@ Copy register to memory:
  ldr r1,[r7,r4] ;@ Load value from Dn/An
;@ EaWrite: Write r1 into '$33333333.l' (address in r6):
  uxth r1,r1 ;@ zero extend
  mov r0,r6
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  add r6,r6,#2 ;@ Post-increment address
  sub r5,r5,#4 ;@ Take some cycles
  tst r11,r11
  bne Movemloop48b9

NoRegs48b9:
  ldr r4,[r7,#0x40]
  ldr r6,[r7,#0x54] ;@ restore Opcode Jump table

  ldr r0,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  add r5,r0,r5
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [48c0] ext.l d0 uses Op48c0 ----------
Op48c0:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

  movs r0,r0,asl #16
  and r10,r0,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV
  mov r1,r0,asr #16

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [48d0] movem.l d0-d1/d4-d5/a0-a1/a4-a5, (a0) uses Op48d0 ----------
Op48d0:
  str r5,[r7,#0x5c] ;@ Save Cycles
  mov r5,#0

  ldrh r11,[r4],#2 ;@ r11=register mask

;@ Get the address into r6:
;@ EaCalc : Get '(a0)' into r6:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r6,[r7,r2,lsl #2]
  str r4,[r7,#0x40] ;@ Save PC
;@ r4=Register Index*4:
  mov r4,#-4

  tst r11,r11
  beq NoRegs48d0

Movemloop48d0:
  add r4,r4,#4 ;@ r4=Next Register
  movs r11,r11,lsr #1
  bcc Movemloop48d0

  ;@ Copy register to memory:
  ldr r1,[r7,r4] ;@ Load value from Dn/An
;@ EaWrite: Write r1 into '(a0)' (address in r6):
  mov r0,r6
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  add r6,r6,#4 ;@ Post-increment address
  sub r5,r5,#8 ;@ Take some cycles
  tst r11,r11
  bne Movemloop48d0

NoRegs48d0:
  ldr r4,[r7,#0x40]
  ldr r6,[r7,#0x54] ;@ restore Opcode Jump table

  ldr r0,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  add r5,r0,r5
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [48e0] movem.l d2-d3/d6-d7/a2-a3/a6-a7, -(a0) uses Op48e0 ----------
Op48e0:
  str r5,[r7,#0x5c] ;@ Save Cycles
  mov r5,#0

  ldrh r11,[r4],#2 ;@ r11=register mask

;@ Get the address into r6:
;@ EaCalc : Get '(a0)' into r6:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r6,[r7,r2,lsl #2]
  str r4,[r7,#0x40] ;@ Save PC
;@ r4=Register Index*4:
  mov r4,#0x40 ;@ order reversed for -(An)

  tst r11,r11
  beq NoRegs48e0

Movemloop48e0:
  add r4,r4,#-4 ;@ r4=Next Register
  movs r11,r11,lsr #1
  bcc Movemloop48e0

  sub r6,r6,#4 ;@ Pre-decrement address
  ;@ Copy register to memory:
  ldr r1,[r7,r4] ;@ Load value from Dn/An
  add r0,r6,#2
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  uxth r1,r1 ;@ zero extend
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r1,[r7,r4] ;@ Load value from Dn/An
  mov r0,r6
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  mov r1,r1,lsr #16
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  sub r5,r5,#8 ;@ Take some cycles
  tst r11,r11
  bne Movemloop48e0

;@ Write back address:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0007
  orr r0,r0,#0x8 ;@ A0-7
;@ EaWrite: r6 into register[r0]:
  str r6,[r7,r0,lsl #2]

NoRegs48e0:
  ldr r4,[r7,#0x40]
  ldr r6,[r7,#0x54] ;@ restore Opcode Jump table

  ldr r0,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  add r5,r0,r5
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [48e8] movem.l d0-d1/d4-d5/a0-a1/a4-a5, ($3333,a0) uses Op48e8 ----------
Op48e8:
  str r5,[r7,#0x5c] ;@ Save Cycles
  mov r5,#0

  ldrh r11,[r4],#2 ;@ r11=register mask

;@ Get the address into r6:
;@ EaCalc : Get '($3333,a0)' into r6:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r6,r0,r2 ;@ Add on offset
  str r4,[r7,#0x40] ;@ Save PC
;@ r4=Register Index*4:
  mov r4,#-4

  tst r11,r11
  beq NoRegs48e8

Movemloop48e8:
  add r4,r4,#4 ;@ r4=Next Register
  movs r11,r11,lsr #1
  bcc Movemloop48e8

  ;@ Copy register to memory:
  ldr r1,[r7,r4] ;@ Load value from Dn/An
;@ EaWrite: Write r1 into '($3333,a0)' (address in r6):
  mov r0,r6
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  add r6,r6,#4 ;@ Post-increment address
  sub r5,r5,#8 ;@ Take some cycles
  tst r11,r11
  bne Movemloop48e8

NoRegs48e8:
  ldr r4,[r7,#0x40]
  ldr r6,[r7,#0x54] ;@ restore Opcode Jump table

  ldr r0,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  add r5,r0,r5
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [48f0] movem.l d0-d1/d4-d5/a0-a1/a4-a5, ($33,a0,d3.w*2) uses Op48f0 ----------
Op48f0:
  str r5,[r7,#0x5c] ;@ Save Cycles
  mov r5,#0

  ldrh r11,[r4],#2 ;@ r11=register mask

;@ Get the address into r6:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r6:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r6,r2,r3 ;@ r6=Disp+An+Rn
  str r4,[r7,#0x40] ;@ Save PC
;@ r4=Register Index*4:
  mov r4,#-4

  tst r11,r11
  beq NoRegs48f0

Movemloop48f0:
  add r4,r4,#4 ;@ r4=Next Register
  movs r11,r11,lsr #1
  bcc Movemloop48f0

  ;@ Copy register to memory:
  ldr r1,[r7,r4] ;@ Load value from Dn/An
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r6):
  mov r0,r6
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  add r6,r6,#4 ;@ Post-increment address
  sub r5,r5,#8 ;@ Take some cycles
  tst r11,r11
  bne Movemloop48f0

NoRegs48f0:
  ldr r4,[r7,#0x40]
  ldr r6,[r7,#0x54] ;@ restore Opcode Jump table

  ldr r0,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  add r5,r0,r5
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [48f8] movem.l d0-d1/d4-d5/a0-a1/a4-a5, $3333.w uses Op48f8 ----------
Op48f8:
  str r5,[r7,#0x5c] ;@ Save Cycles
  mov r5,#0

  ldrh r11,[r4],#2 ;@ r11=register mask

;@ Get the address into r6:
;@ EaCalc : Get '$3333.w' into r6:
  ldrsh r6,[r4],#2 ;@ Fetch Absolute Short address
  str r4,[r7,#0x40] ;@ Save PC
;@ r4=Register Index*4:
  mov r4,#-4

  tst r11,r11
  beq NoRegs48f8

Movemloop48f8:
  add r4,r4,#4 ;@ r4=Next Register
  movs r11,r11,lsr #1
  bcc Movemloop48f8

  ;@ Copy register to memory:
  ldr r1,[r7,r4] ;@ Load value from Dn/An
;@ EaWrite: Write r1 into '$3333.w' (address in r6):
  mov r0,r6
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  add r6,r6,#4 ;@ Post-increment address
  sub r5,r5,#8 ;@ Take some cycles
  tst r11,r11
  bne Movemloop48f8

NoRegs48f8:
  ldr r4,[r7,#0x40]
  ldr r6,[r7,#0x54] ;@ restore Opcode Jump table

  ldr r0,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  add r5,r0,r5
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [48f9] movem.l d0-d1/d4-d5/a0-a1/a4-a5, $33333333.l uses Op48f9 ----------
Op48f9:
  str r5,[r7,#0x5c] ;@ Save Cycles
  mov r5,#0

  ldrh r11,[r4],#2 ;@ r11=register mask

;@ Get the address into r6:
;@ EaCalc : Get '$33333333.l' into r6:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r6,r0,r2,lsl #16
  str r4,[r7,#0x40] ;@ Save PC
;@ r4=Register Index*4:
  mov r4,#-4

  tst r11,r11
  beq NoRegs48f9

Movemloop48f9:
  add r4,r4,#4 ;@ r4=Next Register
  movs r11,r11,lsr #1
  bcc Movemloop48f9

  ;@ Copy register to memory:
  ldr r1,[r7,r4] ;@ Load value from Dn/An
;@ EaWrite: Write r1 into '$33333333.l' (address in r6):
  mov r0,r6
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  add r6,r6,#4 ;@ Post-increment address
  sub r5,r5,#8 ;@ Take some cycles
  tst r11,r11
  bne Movemloop48f9

NoRegs48f9:
  ldr r4,[r7,#0x40]
  ldr r6,[r7,#0x54] ;@ restore Opcode Jump table

  ldr r0,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  add r5,r0,r5
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [4a00] tst.b d0 uses Op4a00 ----------
Op4a00:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r0:
  ldr r0,[r7,r0,lsl #2]
  movs r0,r0,asl #24

  and r10,r0,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4a10] tst.b (a0) uses Op4a10 ----------
Op4a10:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  bl cyclone_read8 ;@ Call read8(r0) handler
  movs r0,r0,asl #24

  and r10,r0,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4a18] tst.b (a0)+ uses Op4a18 ----------
Op4a18:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  bl cyclone_read8 ;@ Call read8(r0) handler
  movs r0,r0,asl #24

  and r10,r0,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4a1f] tst.b (a7)+ uses Op4a1f ----------
Op4a1f:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r0) into r0:
  bl cyclone_read8 ;@ Call read8(r0) handler
  movs r0,r0,asl #24

  and r10,r0,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4a20] tst.b -(a0) uses Op4a20 ----------
Op4a20:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  bl cyclone_read8 ;@ Call read8(r0) handler
  movs r0,r0,asl #24

  and r10,r0,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4a27] tst.b -(a7) uses Op4a27 ----------
Op4a27:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r0) into r0:
  bl cyclone_read8 ;@ Call read8(r0) handler
  movs r0,r0,asl #24

  and r10,r0,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4a30] tst.b ($33,a0,d3.w*2) uses Op4a30 ----------
Op4a30:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  bl cyclone_read8 ;@ Call read8(r0) handler
  movs r0,r0,asl #24

  and r10,r0,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4a40] tst.w d0 uses Op4a40 ----------
Op4a40:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
  mov r0,r0,lsl #2
;@ EaRead : Read register[r0] into r0:
  ldr r0,[r7,r0]
  movs r0,r0,asl #16

  and r10,r0,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4a50] tst.w (a0) uses Op4a50 ----------
Op4a50:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  bl cyclone_read16 ;@ Call read16(r0) handler
  movs r0,r0,asl #16

  and r10,r0,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4a58] tst.w (a0)+ uses Op4a58 ----------
Op4a58:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  bl cyclone_read16 ;@ Call read16(r0) handler
  movs r0,r0,asl #16

  and r10,r0,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4a60] tst.w -(a0) uses Op4a60 ----------
Op4a60:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  bl cyclone_read16 ;@ Call read16(r0) handler
  movs r0,r0,asl #16

  and r10,r0,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4a68] tst.w ($3333,a0) uses Op4a68 ----------
Op4a68:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  bl cyclone_read16 ;@ Call read16(r0) handler
  movs r0,r0,asl #16

  and r10,r0,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4a70] tst.w ($33,a0,d3.w*2) uses Op4a70 ----------
Op4a70:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  bl cyclone_read16 ;@ Call read16(r0) handler
  movs r0,r0,asl #16

  and r10,r0,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4a78] tst.w $3333.w uses Op4a78 ----------
Op4a78:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  bl cyclone_read16 ;@ Call read16(r0) handler
  movs r0,r0,asl #16

  and r10,r0,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4a80] tst.l d0 uses Op4a80 ----------
Op4a80:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r0:
  ldr r0,[r7,r0,lsl #2]
  tst r0,r0

  and r10,r0,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4a90] tst.l (a0) uses Op4a90 ----------
Op4a90:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  bl cyclone_read32 ;@ Call read32(r0) handler
  tst r0,r0

  and r10,r0,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4a98] tst.l (a0)+ uses Op4a98 ----------
Op4a98:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  bl cyclone_read32 ;@ Call read32(r0) handler
  tst r0,r0

  and r10,r0,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4aa0] tst.l -(a0) uses Op4aa0 ----------
Op4aa0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  bl cyclone_read32 ;@ Call read32(r0) handler
  tst r0,r0

  and r10,r0,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4aa8] tst.l ($3333,a0) uses Op4aa8 ----------
Op4aa8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  bl cyclone_read32 ;@ Call read32(r0) handler
  tst r0,r0

  and r10,r0,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4ab0] tst.l ($33,a0,d3.w*2) uses Op4ab0 ----------
Op4ab0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  bl cyclone_read32 ;@ Call read32(r0) handler
  tst r0,r0

  and r10,r0,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4ab8] tst.l $3333.w uses Op4ab8 ----------
Op4ab8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  bl cyclone_read32 ;@ Call read32(r0) handler
  tst r0,r0

  and r10,r0,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4ab9] tst.l $33333333.l uses Op4ab9 ----------
Op4ab9:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  bl cyclone_read32 ;@ Call read32(r0) handler
  tst r0,r0

  and r10,r0,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4ac0] tas d0 uses Op4ac0 ----------
Op4ac0:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsl #2]
  movs r1,r1,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

  orr r1,r1,#0x80000000 ;@ set bit7
;@ EaWrite: r1 into register[r11]:
  mov r1,r1,lsr #24
  strb r1,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4ad0] tas (a0) uses Op4ad0 ----------
Op4ad0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r1:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

Op4ad0_:
;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r1:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

  orr r1,r1,#0x80000000 ;@ set bit7
;@ EaWrite: Write r1 into '(a0)' (address in r11):
  mov r1,r1,lsr #24
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4ad8] tas (a0)+ uses Op4ad8 ----------
Op4ad8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r1:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

Op4ad8_:
;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r1:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

  orr r1,r1,#0x80000000 ;@ set bit7
;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  mov r1,r1,lsr #24
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4adf] tas (a7)+ uses Op4adf ----------
Op4adf:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a7)+' into r11:
  ldr r11,[r7,#0x3c] ;@ A7
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r11) into r1:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

Op4adf_:
;@ EaCalc : Get '(a7)+' into r11:
  ldr r11,[r7,#0x3c] ;@ A7
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r11) into r1:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

  orr r1,r1,#0x80000000 ;@ set bit7
;@ EaWrite: Write r1 into '(a7)+' (address in r11):
  mov r1,r1,lsr #24
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4ae0] tas -(a0) uses Op4ae0 ----------
Op4ae0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#1 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r1:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

Op4ae0_:
;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#1 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r1:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

  orr r1,r1,#0x80000000 ;@ set bit7
;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r1,r1,lsr #24
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4ae7] tas -(a7) uses Op4ae7 ----------
Op4ae7:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a7)' into r11:
  ldr r11,[r7,#0x3c] ;@ A7
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r11) into r1:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

Op4ae7_:
;@ EaCalc : Get '-(a7)' into r11:
  ldr r11,[r7,#0x3c] ;@ A7
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r11) into r1:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

  orr r1,r1,#0x80000000 ;@ set bit7
;@ EaWrite: Write r1 into '-(a7)' (address in r11):
  mov r1,r1,lsr #24
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4ae8] tas ($3333,a0) uses Op4ae8 ----------
Op4ae8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r1:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

Op4ae8_:
;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r1:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

  orr r1,r1,#0x80000000 ;@ set bit7
;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  mov r1,r1,lsr #24
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4af0] tas ($33,a0,d3.w*2) uses Op4af0 ----------
Op4af0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r1:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

Op4af0_:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r1:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

  orr r1,r1,#0x80000000 ;@ set bit7
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  mov r1,r1,lsr #24
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4af8] tas $3333.w uses Op4af8 ----------
Op4af8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r1:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

Op4af8_:
;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r1:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

  orr r1,r1,#0x80000000 ;@ set bit7
;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  mov r1,r1,lsr #24
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4af9] tas $33333333.l uses Op4af9 ----------
Op4af9:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r1:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

Op4af9_:
;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r1:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler
  movs r1,r0,asl #24

  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

  orr r1,r1,#0x80000000 ;@ set bit7
;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  mov r1,r1,lsr #24
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4c90] movem.w (a0), d0-d1/d4-d5/a0-a1/a4-a5 uses Op4c90 ----------
Op4c90:
  str r5,[r7,#0x5c] ;@ Save Cycles
  mov r5,#0

  ldrh r11,[r4],#2 ;@ r11=register mask

;@ Get the address into r6:
;@ EaCalc : Get '(a0)' into r6:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r6,[r7,r2,lsl #2]
  str r4,[r7,#0x40] ;@ Save PC
;@ r4=Register Index*4:
  mov r4,#-4

  tst r11,r11
  beq NoRegs4c90

Movemloop4c90:
  add r4,r4,#4 ;@ r4=Next Register
  movs r11,r11,lsr #1
  bcc Movemloop4c90

  ;@ Copy memory to register:
;@ EaRead : Read '(a0)' (address in r6) into r0:
  mov r0,r6
  bl cyclone_read16 ;@ Call read16(r0) handler
  sxth r0,r0 ;@ sign extend

  str r0,[r7,r4] ;@ Save value into Dn/An
  add r6,r6,#2 ;@ Post-increment address
  sub r5,r5,#4 ;@ Take some cycles
  tst r11,r11
  bne Movemloop4c90

NoRegs4c90:
  ldr r4,[r7,#0x40]
  ldr r6,[r7,#0x54] ;@ restore Opcode Jump table

  ldr r0,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  add r5,r0,r5
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [4c98] movem.w (a0)+, d0-d1/d4-d5/a0-a1/a4-a5 uses Op4c98 ----------
Op4c98:
  str r5,[r7,#0x5c] ;@ Save Cycles
  mov r5,#0

  ldrh r11,[r4],#2 ;@ r11=register mask

;@ Get the address into r6:
;@ EaCalc : Get '(a0)' into r6:
  and r2,r8,#0x000f
  ldr r6,[r7,r2,lsl #2]
  str r4,[r7,#0x40] ;@ Save PC
;@ r4=Register Index*4:
  mov r4,#-4

  tst r11,r11
  beq NoRegs4c98

Movemloop4c98:
  add r4,r4,#4 ;@ r4=Next Register
  movs r11,r11,lsr #1
  bcc Movemloop4c98

  ;@ Copy memory to register:
;@ EaRead : Read '(a0)+' (address in r6) into r0:
  mov r0,r6
  bl cyclone_read16 ;@ Call read16(r0) handler
  sxth r0,r0 ;@ sign extend

  str r0,[r7,r4] ;@ Save value into Dn/An
  add r6,r6,#2 ;@ Post-increment address
  sub r5,r5,#4 ;@ Take some cycles
  tst r11,r11
  bne Movemloop4c98

;@ Write back address:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaWrite: r6 into register[r0]:
  str r6,[r7,r0,lsl #2]

NoRegs4c98:
  ldr r4,[r7,#0x40]
  ldr r6,[r7,#0x54] ;@ restore Opcode Jump table

  ldr r0,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  add r5,r0,r5
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [4ca8] movem.w ($3333,a0), d0-d1/d4-d5/a0-a1/a4-a5 uses Op4ca8 ----------
Op4ca8:
  str r5,[r7,#0x5c] ;@ Save Cycles
  mov r5,#0

  ldrh r11,[r4],#2 ;@ r11=register mask

;@ Get the address into r6:
;@ EaCalc : Get '($3333,a0)' into r6:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r6,r0,r2 ;@ Add on offset
  str r4,[r7,#0x40] ;@ Save PC
;@ r4=Register Index*4:
  mov r4,#-4

  tst r11,r11
  beq NoRegs4ca8

Movemloop4ca8:
  add r4,r4,#4 ;@ r4=Next Register
  movs r11,r11,lsr #1
  bcc Movemloop4ca8

  ;@ Copy memory to register:
;@ EaRead : Read '($3333,a0)' (address in r6) into r0:
  mov r0,r6
  bl cyclone_read16 ;@ Call read16(r0) handler
  sxth r0,r0 ;@ sign extend

  str r0,[r7,r4] ;@ Save value into Dn/An
  add r6,r6,#2 ;@ Post-increment address
  sub r5,r5,#4 ;@ Take some cycles
  tst r11,r11
  bne Movemloop4ca8

NoRegs4ca8:
  ldr r4,[r7,#0x40]
  ldr r6,[r7,#0x54] ;@ restore Opcode Jump table

  ldr r0,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  add r5,r0,r5
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [4cb0] movem.w ($33,a0,d3.w*2), d0-d1/d4-d5/a0-a1/a4-a5 uses Op4cb0 ----------
Op4cb0:
  str r5,[r7,#0x5c] ;@ Save Cycles
  mov r5,#0

  ldrh r11,[r4],#2 ;@ r11=register mask

;@ Get the address into r6:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r6:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r6,r2,r3 ;@ r6=Disp+An+Rn
  str r4,[r7,#0x40] ;@ Save PC
;@ r4=Register Index*4:
  mov r4,#-4

  tst r11,r11
  beq NoRegs4cb0

Movemloop4cb0:
  add r4,r4,#4 ;@ r4=Next Register
  movs r11,r11,lsr #1
  bcc Movemloop4cb0

  ;@ Copy memory to register:
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r6) into r0:
  mov r0,r6
  bl cyclone_read16 ;@ Call read16(r0) handler
  sxth r0,r0 ;@ sign extend

  str r0,[r7,r4] ;@ Save value into Dn/An
  add r6,r6,#2 ;@ Post-increment address
  sub r5,r5,#4 ;@ Take some cycles
  tst r11,r11
  bne Movemloop4cb0

NoRegs4cb0:
  ldr r4,[r7,#0x40]
  ldr r6,[r7,#0x54] ;@ restore Opcode Jump table

  ldr r0,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  add r5,r0,r5
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [4cb8] movem.w $3333.w, d0-d1/d4-d5/a0-a1/a4-a5 uses Op4cb8 ----------
Op4cb8:
  str r5,[r7,#0x5c] ;@ Save Cycles
  mov r5,#0

  ldrh r11,[r4],#2 ;@ r11=register mask

;@ Get the address into r6:
;@ EaCalc : Get '$3333.w' into r6:
  ldrsh r6,[r4],#2 ;@ Fetch Absolute Short address
  str r4,[r7,#0x40] ;@ Save PC
;@ r4=Register Index*4:
  mov r4,#-4

  tst r11,r11
  beq NoRegs4cb8

Movemloop4cb8:
  add r4,r4,#4 ;@ r4=Next Register
  movs r11,r11,lsr #1
  bcc Movemloop4cb8

  ;@ Copy memory to register:
;@ EaRead : Read '$3333.w' (address in r6) into r0:
  mov r0,r6
  bl cyclone_read16 ;@ Call read16(r0) handler
  sxth r0,r0 ;@ sign extend

  str r0,[r7,r4] ;@ Save value into Dn/An
  add r6,r6,#2 ;@ Post-increment address
  sub r5,r5,#4 ;@ Take some cycles
  tst r11,r11
  bne Movemloop4cb8

NoRegs4cb8:
  ldr r4,[r7,#0x40]
  ldr r6,[r7,#0x54] ;@ restore Opcode Jump table

  ldr r0,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  add r5,r0,r5
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [4cb9] movem.w $33333333.l, d0-d1/d4-d5/a0-a1/a4-a5 uses Op4cb9 ----------
Op4cb9:
  str r5,[r7,#0x5c] ;@ Save Cycles
  mov r5,#0

  ldrh r11,[r4],#2 ;@ r11=register mask

;@ Get the address into r6:
;@ EaCalc : Get '$33333333.l' into r6:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r6,r0,r2,lsl #16
  str r4,[r7,#0x40] ;@ Save PC
;@ r4=Register Index*4:
  mov r4,#-4

  tst r11,r11
  beq NoRegs4cb9

Movemloop4cb9:
  add r4,r4,#4 ;@ r4=Next Register
  movs r11,r11,lsr #1
  bcc Movemloop4cb9

  ;@ Copy memory to register:
;@ EaRead : Read '$33333333.l' (address in r6) into r0:
  mov r0,r6
  bl cyclone_read16 ;@ Call read16(r0) handler
  sxth r0,r0 ;@ sign extend

  str r0,[r7,r4] ;@ Save value into Dn/An
  add r6,r6,#2 ;@ Post-increment address
  sub r5,r5,#4 ;@ Take some cycles
  tst r11,r11
  bne Movemloop4cb9

NoRegs4cb9:
  ldr r4,[r7,#0x40]
  ldr r6,[r7,#0x54] ;@ restore Opcode Jump table

  ldr r0,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  add r5,r0,r5
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [4cba] movem.w ($3333,pc), d0-d1/d4-d5/a0-a1/a4-a5; =3337 uses Op4cba ----------
Op4cba:
  str r5,[r7,#0x5c] ;@ Save Cycles
  mov r5,#0

  ldrh r11,[r4],#2 ;@ r11=register mask

;@ Get the address into r6:
;@ EaCalc : Get '($3333,pc)' into r6:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r6,r2,r0 ;@ ($nn,PC)
  str r4,[r7,#0x40] ;@ Save PC
;@ r4=Register Index*4:
  mov r4,#-4

  tst r11,r11
  beq NoRegs4cba

Movemloop4cba:
  add r4,r4,#4 ;@ r4=Next Register
  movs r11,r11,lsr #1
  bcc Movemloop4cba

  ;@ Copy memory to register:
;@ EaRead : Read '($3333,pc)' (address in r6) into r0:
  mov r0,r6
  bl cyclone_fetch16 ;@ Call fetch16(r0) handler
  sxth r0,r0 ;@ sign extend

  str r0,[r7,r4] ;@ Save value into Dn/An
  add r6,r6,#2 ;@ Post-increment address
  sub r5,r5,#4 ;@ Take some cycles
  tst r11,r11
  bne Movemloop4cba

NoRegs4cba:
  ldr r4,[r7,#0x40]
  ldr r6,[r7,#0x54] ;@ restore Opcode Jump table

  ldr r0,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  add r5,r0,r5
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [4cbb] movem.w ($33,pc,d3.w*2), d0-d1/d4-d5/a0-a1/a4-a5; =37 uses Op4cbb ----------
Op4cbb:
  str r5,[r7,#0x5c] ;@ Save Cycles
  mov r5,#0

  ldrh r11,[r4],#2 ;@ r11=register mask

;@ Get the address into r6:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r6:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r6,r2,r0 ;@ r6=Disp+PC+Rn
  str r4,[r7,#0x40] ;@ Save PC
;@ r4=Register Index*4:
  mov r4,#-4

  tst r11,r11
  beq NoRegs4cbb

Movemloop4cbb:
  add r4,r4,#4 ;@ r4=Next Register
  movs r11,r11,lsr #1
  bcc Movemloop4cbb

  ;@ Copy memory to register:
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r6) into r0:
  mov r0,r6
  bl cyclone_fetch16 ;@ Call fetch16(r0) handler
  sxth r0,r0 ;@ sign extend

  str r0,[r7,r4] ;@ Save value into Dn/An
  add r6,r6,#2 ;@ Post-increment address
  sub r5,r5,#4 ;@ Take some cycles
  tst r11,r11
  bne Movemloop4cbb

NoRegs4cbb:
  ldr r4,[r7,#0x40]
  ldr r6,[r7,#0x54] ;@ restore Opcode Jump table

  ldr r0,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  add r5,r0,r5
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [4cd0] movem.l (a0), d0-d1/d4-d5/a0-a1/a4-a5 uses Op4cd0 ----------
Op4cd0:
  str r5,[r7,#0x5c] ;@ Save Cycles
  mov r5,#0

  ldrh r11,[r4],#2 ;@ r11=register mask

;@ Get the address into r6:
;@ EaCalc : Get '(a0)' into r6:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r6,[r7,r2,lsl #2]
  str r4,[r7,#0x40] ;@ Save PC
;@ r4=Register Index*4:
  mov r4,#-4

  tst r11,r11
  beq NoRegs4cd0

Movemloop4cd0:
  add r4,r4,#4 ;@ r4=Next Register
  movs r11,r11,lsr #1
  bcc Movemloop4cd0

  ;@ Copy memory to register:
;@ EaRead : Read '(a0)' (address in r6) into r0:
  mov r0,r6
  bl cyclone_read32 ;@ Call read32(r0) handler

  str r0,[r7,r4] ;@ Save value into Dn/An
  add r6,r6,#4 ;@ Post-increment address
  sub r5,r5,#8 ;@ Take some cycles
  tst r11,r11
  bne Movemloop4cd0

NoRegs4cd0:
  ldr r4,[r7,#0x40]
  ldr r6,[r7,#0x54] ;@ restore Opcode Jump table

  ldr r0,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  add r5,r0,r5
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [4cd8] movem.l (a0)+, d0-d1/d4-d5/a0-a1/a4-a5 uses Op4cd8 ----------
Op4cd8:
  str r5,[r7,#0x5c] ;@ Save Cycles
  mov r5,#0

  ldrh r11,[r4],#2 ;@ r11=register mask

;@ Get the address into r6:
;@ EaCalc : Get '(a0)' into r6:
  and r2,r8,#0x000f
  ldr r6,[r7,r2,lsl #2]
  str r4,[r7,#0x40] ;@ Save PC
;@ r4=Register Index*4:
  mov r4,#-4

  tst r11,r11
  beq NoRegs4cd8

Movemloop4cd8:
  add r4,r4,#4 ;@ r4=Next Register
  movs r11,r11,lsr #1
  bcc Movemloop4cd8

  ;@ Copy memory to register:
;@ EaRead : Read '(a0)+' (address in r6) into r0:
  mov r0,r6
  bl cyclone_read32 ;@ Call read32(r0) handler

  str r0,[r7,r4] ;@ Save value into Dn/An
  add r6,r6,#4 ;@ Post-increment address
  sub r5,r5,#8 ;@ Take some cycles
  tst r11,r11
  bne Movemloop4cd8

;@ Write back address:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaWrite: r6 into register[r0]:
  str r6,[r7,r0,lsl #2]

NoRegs4cd8:
  ldr r4,[r7,#0x40]
  ldr r6,[r7,#0x54] ;@ restore Opcode Jump table

  ldr r0,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  add r5,r0,r5
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [4ce8] movem.l ($3333,a0), d0-d1/d4-d5/a0-a1/a4-a5 uses Op4ce8 ----------
Op4ce8:
  str r5,[r7,#0x5c] ;@ Save Cycles
  mov r5,#0

  ldrh r11,[r4],#2 ;@ r11=register mask

;@ Get the address into r6:
;@ EaCalc : Get '($3333,a0)' into r6:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r6,r0,r2 ;@ Add on offset
  str r4,[r7,#0x40] ;@ Save PC
;@ r4=Register Index*4:
  mov r4,#-4

  tst r11,r11
  beq NoRegs4ce8

Movemloop4ce8:
  add r4,r4,#4 ;@ r4=Next Register
  movs r11,r11,lsr #1
  bcc Movemloop4ce8

  ;@ Copy memory to register:
;@ EaRead : Read '($3333,a0)' (address in r6) into r0:
  mov r0,r6
  bl cyclone_read32 ;@ Call read32(r0) handler

  str r0,[r7,r4] ;@ Save value into Dn/An
  add r6,r6,#4 ;@ Post-increment address
  sub r5,r5,#8 ;@ Take some cycles
  tst r11,r11
  bne Movemloop4ce8

NoRegs4ce8:
  ldr r4,[r7,#0x40]
  ldr r6,[r7,#0x54] ;@ restore Opcode Jump table

  ldr r0,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  add r5,r0,r5
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [4cf0] movem.l ($33,a0,d3.w*2), d0-d1/d4-d5/a0-a1/a4-a5 uses Op4cf0 ----------
Op4cf0:
  str r5,[r7,#0x5c] ;@ Save Cycles
  mov r5,#0

  ldrh r11,[r4],#2 ;@ r11=register mask

;@ Get the address into r6:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r6:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r6,r2,r3 ;@ r6=Disp+An+Rn
  str r4,[r7,#0x40] ;@ Save PC
;@ r4=Register Index*4:
  mov r4,#-4

  tst r11,r11
  beq NoRegs4cf0

Movemloop4cf0:
  add r4,r4,#4 ;@ r4=Next Register
  movs r11,r11,lsr #1
  bcc Movemloop4cf0

  ;@ Copy memory to register:
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r6) into r0:
  mov r0,r6
  bl cyclone_read32 ;@ Call read32(r0) handler

  str r0,[r7,r4] ;@ Save value into Dn/An
  add r6,r6,#4 ;@ Post-increment address
  sub r5,r5,#8 ;@ Take some cycles
  tst r11,r11
  bne Movemloop4cf0

NoRegs4cf0:
  ldr r4,[r7,#0x40]
  ldr r6,[r7,#0x54] ;@ restore Opcode Jump table

  ldr r0,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  add r5,r0,r5
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [4cf8] movem.l $3333.w, d0-d1/d4-d5/a0-a1/a4-a5 uses Op4cf8 ----------
Op4cf8:
  str r5,[r7,#0x5c] ;@ Save Cycles
  mov r5,#0

  ldrh r11,[r4],#2 ;@ r11=register mask

;@ Get the address into r6:
;@ EaCalc : Get '$3333.w' into r6:
  ldrsh r6,[r4],#2 ;@ Fetch Absolute Short address
  str r4,[r7,#0x40] ;@ Save PC
;@ r4=Register Index*4:
  mov r4,#-4

  tst r11,r11
  beq NoRegs4cf8

Movemloop4cf8:
  add r4,r4,#4 ;@ r4=Next Register
  movs r11,r11,lsr #1
  bcc Movemloop4cf8

  ;@ Copy memory to register:
;@ EaRead : Read '$3333.w' (address in r6) into r0:
  mov r0,r6
  bl cyclone_read32 ;@ Call read32(r0) handler

  str r0,[r7,r4] ;@ Save value into Dn/An
  add r6,r6,#4 ;@ Post-increment address
  sub r5,r5,#8 ;@ Take some cycles
  tst r11,r11
  bne Movemloop4cf8

NoRegs4cf8:
  ldr r4,[r7,#0x40]
  ldr r6,[r7,#0x54] ;@ restore Opcode Jump table

  ldr r0,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  add r5,r0,r5
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [4cf9] movem.l $33333333.l, d0-d1/d4-d5/a0-a1/a4-a5 uses Op4cf9 ----------
Op4cf9:
  str r5,[r7,#0x5c] ;@ Save Cycles
  mov r5,#0

  ldrh r11,[r4],#2 ;@ r11=register mask

;@ Get the address into r6:
;@ EaCalc : Get '$33333333.l' into r6:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r6,r0,r2,lsl #16
  str r4,[r7,#0x40] ;@ Save PC
;@ r4=Register Index*4:
  mov r4,#-4

  tst r11,r11
  beq NoRegs4cf9

Movemloop4cf9:
  add r4,r4,#4 ;@ r4=Next Register
  movs r11,r11,lsr #1
  bcc Movemloop4cf9

  ;@ Copy memory to register:
;@ EaRead : Read '$33333333.l' (address in r6) into r0:
  mov r0,r6
  bl cyclone_read32 ;@ Call read32(r0) handler

  str r0,[r7,r4] ;@ Save value into Dn/An
  add r6,r6,#4 ;@ Post-increment address
  sub r5,r5,#8 ;@ Take some cycles
  tst r11,r11
  bne Movemloop4cf9

NoRegs4cf9:
  ldr r4,[r7,#0x40]
  ldr r6,[r7,#0x54] ;@ restore Opcode Jump table

  ldr r0,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  add r5,r0,r5
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [4cfa] movem.l ($3333,pc), d0-d1/d4-d5/a0-a1/a4-a5; =3337 uses Op4cfa ----------
Op4cfa:
  str r5,[r7,#0x5c] ;@ Save Cycles
  mov r5,#0

  ldrh r11,[r4],#2 ;@ r11=register mask

;@ Get the address into r6:
;@ EaCalc : Get '($3333,pc)' into r6:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r6,r2,r0 ;@ ($nn,PC)
  str r4,[r7,#0x40] ;@ Save PC
;@ r4=Register Index*4:
  mov r4,#-4

  tst r11,r11
  beq NoRegs4cfa

Movemloop4cfa:
  add r4,r4,#4 ;@ r4=Next Register
  movs r11,r11,lsr #1
  bcc Movemloop4cfa

  ;@ Copy memory to register:
;@ EaRead : Read '($3333,pc)' (address in r6) into r0:
  mov r0,r6
  bl cyclone_fetch32 ;@ Call fetch32(r0) handler

  str r0,[r7,r4] ;@ Save value into Dn/An
  add r6,r6,#4 ;@ Post-increment address
  sub r5,r5,#8 ;@ Take some cycles
  tst r11,r11
  bne Movemloop4cfa

NoRegs4cfa:
  ldr r4,[r7,#0x40]
  ldr r6,[r7,#0x54] ;@ restore Opcode Jump table

  ldr r0,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  add r5,r0,r5
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [4cfb] movem.l ($33,pc,d3.w*2), d0-d1/d4-d5/a0-a1/a4-a5; =37 uses Op4cfb ----------
Op4cfb:
  str r5,[r7,#0x5c] ;@ Save Cycles
  mov r5,#0

  ldrh r11,[r4],#2 ;@ r11=register mask

;@ Get the address into r6:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r6:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r6,r2,r0 ;@ r6=Disp+PC+Rn
  str r4,[r7,#0x40] ;@ Save PC
;@ r4=Register Index*4:
  mov r4,#-4

  tst r11,r11
  beq NoRegs4cfb

Movemloop4cfb:
  add r4,r4,#4 ;@ r4=Next Register
  movs r11,r11,lsr #1
  bcc Movemloop4cfb

  ;@ Copy memory to register:
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r6) into r0:
  mov r0,r6
  bl cyclone_fetch32 ;@ Call fetch32(r0) handler

  str r0,[r7,r4] ;@ Save value into Dn/An
  add r6,r6,#4 ;@ Post-increment address
  sub r5,r5,#8 ;@ Take some cycles
  tst r11,r11
  bne Movemloop4cfb

NoRegs4cfb:
  ldr r4,[r7,#0x40]
  ldr r6,[r7,#0x54] ;@ restore Opcode Jump table

  ldr r0,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  add r5,r0,r5
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [4e40] trap #0 uses Op4e40 ----------
Op4e40:
  str r5,[r7,#0x5c] ;@ Save Cycles

  and r0,r8,#0xf ;@ Get trap number
  orr r0,r0,#0x20 ;@ 32+n
  bl Exception

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#38 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4e50] link a0,#$3333 uses Op4e50 ----------
Op4e50:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get An
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
  orr r11,r11,#0x8 ;@ A0-7
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsl #2]

  ldr r0,[r7,#0x3c] ;@ Get A7
  sub r0,r0,#4 ;@ A7-=4
  mov r8,r0 ;@ abuse r8

;@ Write An to Stack
  bl cyclone_write32 ;@ Call write32(r0,r1) handler
;@ Save to An
;@ EaWrite: r8 into register[r11]:
  str r8,[r7,r11,lsl #2]

;@ Get offset:
;@ EaCalc : Get '#$3333' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r0) into r0:

  add r8,r8,r0 ;@ Add offset to A7
  str r8,[r7,#0x3c]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4e57] link a7,#$3333 uses Op4e57 ----------
Op4e57:
  str r5,[r7,#0x5c] ;@ Save Cycles

  ldr r0,[r7,#0x3c] ;@ Get A7
  sub r0,r0,#4 ;@ A7-=4
  mov r8,r0 ;@ abuse r8
  mov r1,r0

;@ Write An to Stack
  bl cyclone_write32 ;@ Call write32(r0,r1) handler
;@ Save to An
;@ Get offset:
;@ EaCalc : Get '#$3333' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r0) into r0:

  add r8,r8,r0 ;@ Add offset to A7
  str r8,[r7,#0x3c]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4e58] unlk a0 uses Op4e58 ----------
Op4e58:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get An
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

  add r8,r0,#4 ;@ A7+=4, abuse r8

;@ Pop An from stack:
  bl cyclone_read32 ;@ Call read32(r0) handler

  str r8,[r7,#0x3c] ;@ Save A7

;@ An = value from stack:
;@ EaWrite: r0 into register[r11]:
  str r0,[r7,r11,lsl #2]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4e60] move a0, usp uses Op4e60 ----------
Op4e60:
  ldr r11,[r7,#0x44] ;@ Get SR high
  tst r11,#0x20 ;@ Check we are in supervisor mode
  beq WrongPrivilegeMode ;@ No

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
  orr r0,r0,#0x8 ;@ A0-7
;@ EaRead : Read register[r0] into r0:
  ldr r0,[r7,r0,lsl #2]

  str r0,[r7,#0x48] ;@ Put in USP

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4e68] move usp, a0 uses Op4e68 ----------
Op4e68:
  ldr r11,[r7,#0x44] ;@ Get SR high
  tst r11,#0x20 ;@ Check we are in supervisor mode
  beq WrongPrivilegeMode ;@ No

  ldr r1,[r7,#0x48] ;@ Get from USP

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4e70] reset uses Op4e70 ----------
Op4e70:
  ldr r11,[r7,#0x44] ;@ Get SR high
  tst r11,#0x20 ;@ Check we are in supervisor mode
  beq WrongPrivilegeMode ;@ No

  str r4,[r7,#0x40] ;@ Save PC
  mov r1,r10,lsr #28
  strb r1,[r7,#0x46] ;@ Save Flags (NZCV)
  str r5,[r7,#0x5c] ;@ Save Cycles
  ldr r11,[r7,#0x90] ;@ ResetCallback
  tst r11,r11
  movne lr,pc
  bxne r11 ;@ call ResetCallback if it is defined
  ldrb r10,[r7,#0x46] ;@ r10 = Load Flags (NZCV)
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldr r4,[r7,#0x40] ;@ Load PC
  mov r10,r10,lsl #28

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#132 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4e72] stop uses Op4e72 ----------
Op4e72:
  ldr r11,[r7,#0x44] ;@ Get SR high
  tst r11,#0x20 ;@ Check we are in supervisor mode
  beq WrongPrivilegeMode ;@ No

  ldrh r0,[r4],#2 ;@ Fetch the immediate
  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsl #25
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  str r2,[r7,#0x4c]   ;@ Store X bit
  mov r10,r0,lsl #28  ;@ r10=NZCV...
  mov r0,r0,ror #8
  and r0,r0,#0xa7 ;@ only take defined bits
  strb r0,[r7,#0x44] ;@ Store SR high

;@ A7 <-> OSP?
  eor r0,r0,r11
  tst r0,#0x20
  beq no_sp_swap4e72
 ;@ swap OSP and A7:
  ldr r11,[r7,#0x3C] ;@ Get A7
  ldr r0, [r7,#0x48] ;@ Get OSP
  str r11,[r7,#0x48]
  str r0, [r7,#0x3C]
no_sp_swap4e72:

  ldr r0,[r7,#0x58]
  mov r5,#0 ;@ eat cycles
  orr r0,r0,#1 ;@ stopped
  str r0,[r7,#0x58]


  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4e73] rte uses Op4e73 ----------
Op4e73:
  ldr r11,[r7,#0x44] ;@ Get SR high
  str r5,[r7,#0x5c] ;@ Save Cycles
  tst r11,#0x20 ;@ Check we are in supervisor mode
  beq WrongPrivilegeMode ;@ No

;@ Pop SR:
  ldr r0,[r7,#0x3c]
  add r1,r0,#2 ;@ Postincrement A7
  str r1,[r7,#0x3c] ;@ Save A7
  bl cyclone_read16 ;@ Call read16(r0) handler

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsl #25
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  str r2,[r7,#0x4c]   ;@ Store X bit
  mov r10,r0,lsl #28  ;@ r10=NZCV...
  mov r0,r0,ror #8
  and r0,r0,#0xa7 ;@ only take defined bits
  strb r0,[r7,#0x44] ;@ Store SR high

;@ Pop PC:
  ldr r0,[r7,#0x3c]
  add r1,r0,#4 ;@ Postincrement A7
  str r1,[r7,#0x3c] ;@ Save A7
  bl cyclone_read32 ;@ Call read32(r0) handler
  ldr r1,[r7,#0x60] ;@ Get Memory base
  add r0,r0,r1 ;@ Memory Base+PC

  bl cyclone_checkpc ;@ Call checkpc()
  mov r4,r0
  ldr r1,[r7,#0x44] ;@ reload SR high
;@ A7 <-> OSP?
  eor r0,r1,r11
  tst r0,#0x20
  beq no_sp_swap4e73
 ;@ swap OSP and A7:
  ldr r11,[r7,#0x3C] ;@ Get A7
  ldr r0, [r7,#0x48] ;@ Get OSP
  str r11,[r7,#0x48]
  str r0, [r7,#0x3C]
no_sp_swap4e73:
  ldr r1,[r7,#0x58]
  bic r1,r1,#0x0c ;@ clear 'not processing instruction' and 'doing addr error' bits
  str r1,[r7,#0x58]
  tst r4,#1 ;@ address error?
  bne ExceptionAddressError_r_prg_r4
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  ldr r1,[r7,#0x44]
  subs r5,r5,#20 ;@ Subtract cycles
;@ CheckTrace:
  tst r1,#0x80
  bne CycloneDoTraceWithChecks
  cmp r5,#0
  ble CycloneEnd
;@ CheckInterrupt:
  movs r0,r1,lsr #24 ;@ Get IRQ level
  ldreq pc,[r6,r8,asl #2] ;@ Jump to next opcode handler
  cmp r0,#6 ;@ irq>6 ?
  andle r1,r1,#7 ;@ Get interrupt mask
  cmple r0,r1 ;@ irq<=6: Is irq<=mask ?
  ldrle pc,[r6,r8,asl #2] ;@ Jump to next opcode handler
  b CycloneDoInterruptGoBack

;@ ---------- [4e76] trapv uses Op4e76 ----------
Op4e76:
  str r5,[r7,#0x5c] ;@ Save Cycles
  mov r5,#0

  tst r10,#0x10000000
  subne r5,r5,#34
  movne r0,#7 ;@ TRAPV exception
  blne Exception
  ldr r0,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  add r5,r0,r5
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4e77] rtr uses Op4e77 ----------
Op4e77:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Pop SR:
  ldr r0,[r7,#0x3c]
  add r1,r0,#2 ;@ Postincrement A7
  str r1,[r7,#0x3c] ;@ Save A7
  bl cyclone_read16 ;@ Call read16(r0) handler

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsl #25
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  str r2,[r7,#0x4c]   ;@ Store X bit
  mov r10,r0,lsl #28  ;@ r10=NZCV...

;@ Pop PC:
  ldr r0,[r7,#0x3c]
  add r1,r0,#4 ;@ Postincrement A7
  str r1,[r7,#0x3c] ;@ Save A7
  bl cyclone_read32 ;@ Call read32(r0) handler
  ldr r1,[r7,#0x60] ;@ Get Memory base
  add r0,r0,r1 ;@ Memory Base+PC

  bl cyclone_checkpc ;@ Call checkpc()
  mov r4,r0
  tst r4,#1 ;@ address error?
  bne ExceptionAddressError_r_prg_r4
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4e90] jsr (a0) uses Op4e90 ----------
Op4e90:
  str r5,[r7,#0x5c] ;@ Save Cycles

  ldr r11,[r7,#0x60] ;@ Get Memory base

;@ EaCalc : Get '(a0)' into r12:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r12,[r7,r2,lsl #2]
;@ Jump - Get new PC from r12
  add r0,r12,r11 ;@ Memory Base + New PC

  bl cyclone_checkpc ;@ Call checkpc()
  ldr r2,[r7,#0x3c]
  sub r1,r4,r11 ;@ r1 = Old PC
  mov r4,r0
  tst r4,#1 ;@ address error?
  bne ExceptionAddressError_r_prg_r4
;@ Push old PC onto stack
  sub r0,r2,#4 ;@ Predecrement A7
  str r0,[r7,#0x3c] ;@ Save A7
  bl cyclone_write32 ;@ Call write32(r0,r1) handler
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4ea8] jsr ($3333,a0) uses Op4ea8 ----------
Op4ea8:
  str r5,[r7,#0x5c] ;@ Save Cycles

  ldr r11,[r7,#0x60] ;@ Get Memory base

;@ EaCalc : Get '($3333,a0)' into r12:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r12,r0,r2 ;@ Add on offset
;@ Jump - Get new PC from r12
  add r0,r12,r11 ;@ Memory Base + New PC

  bl cyclone_checkpc ;@ Call checkpc()
  ldr r2,[r7,#0x3c]
  sub r1,r4,r11 ;@ r1 = Old PC
  mov r4,r0
  tst r4,#1 ;@ address error?
  bne ExceptionAddressError_r_prg_r4
;@ Push old PC onto stack
  sub r0,r2,#4 ;@ Predecrement A7
  str r0,[r7,#0x3c] ;@ Save A7
  bl cyclone_write32 ;@ Call write32(r0,r1) handler
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4eb0] jsr ($33,a0,d3.w*2) uses Op4eb0 ----------
Op4eb0:
  str r5,[r7,#0x5c] ;@ Save Cycles

  ldr r11,[r7,#0x60] ;@ Get Memory base

;@ EaCalc : Get '($33,a0,d3.w*2)' into r12:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r12,r2,r3 ;@ r12=Disp+An+Rn
;@ Jump - Get new PC from r12
  add r0,r12,r11 ;@ Memory Base + New PC

  bl cyclone_checkpc ;@ Call checkpc()
  ldr r2,[r7,#0x3c]
  sub r1,r4,r11 ;@ r1 = Old PC
  mov r4,r0
  tst r4,#1 ;@ address error?
  bne ExceptionAddressError_r_prg_r4
;@ Push old PC onto stack
  sub r0,r2,#4 ;@ Predecrement A7
  str r0,[r7,#0x3c] ;@ Save A7
  bl cyclone_write32 ;@ Call write32(r0,r1) handler
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4eb8] jsr $3333.w uses Op4eb8 ----------
Op4eb8:
  str r5,[r7,#0x5c] ;@ Save Cycles

  ldr r11,[r7,#0x60] ;@ Get Memory base

;@ EaCalc : Get '$3333.w' into r12:
  ldrsh r12,[r4],#2 ;@ Fetch Absolute Short address
;@ Jump - Get new PC from r12
  add r0,r12,r11 ;@ Memory Base + New PC

  bl cyclone_checkpc ;@ Call checkpc()
  ldr r2,[r7,#0x3c]
  sub r1,r4,r11 ;@ r1 = Old PC
  mov r4,r0
  tst r4,#1 ;@ address error?
  bne ExceptionAddressError_r_prg_r4
;@ Push old PC onto stack
  sub r0,r2,#4 ;@ Predecrement A7
  str r0,[r7,#0x3c] ;@ Save A7
  bl cyclone_write32 ;@ Call write32(r0,r1) handler
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4eb9] jsr $33333333.l uses Op4eb9 ----------
Op4eb9:
  str r5,[r7,#0x5c] ;@ Save Cycles

  ldr r11,[r7,#0x60] ;@ Get Memory base

;@ EaCalc : Get '$33333333.l' into r12:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r12,r0,r2,lsl #16
;@ Jump - Get new PC from r12
  add r0,r12,r11 ;@ Memory Base + New PC

  bl cyclone_checkpc ;@ Call checkpc()
  ldr r2,[r7,#0x3c]
  sub r1,r4,r11 ;@ r1 = Old PC
  mov r4,r0
  tst r4,#1 ;@ address error?
  bne ExceptionAddressError_r_prg_r4
;@ Push old PC onto stack
  sub r0,r2,#4 ;@ Predecrement A7
  str r0,[r7,#0x3c] ;@ Save A7
  bl cyclone_write32 ;@ Call write32(r0,r1) handler
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4eba] jsr ($3333,pc); =3335 uses Op4eba ----------
Op4eba:
  str r5,[r7,#0x5c] ;@ Save Cycles

  ldr r11,[r7,#0x60] ;@ Get Memory base

;@ EaCalc : Get '($3333,pc)' into r12:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r12,r2,r0 ;@ ($nn,PC)
;@ Jump - Get new PC from r12
  add r0,r12,r11 ;@ Memory Base + New PC

  bl cyclone_checkpc ;@ Call checkpc()
  ldr r2,[r7,#0x3c]
  sub r1,r4,r11 ;@ r1 = Old PC
  mov r4,r0
  tst r4,#1 ;@ address error?
  bne ExceptionAddressError_r_prg_r4
;@ Push old PC onto stack
  sub r0,r2,#4 ;@ Predecrement A7
  str r0,[r7,#0x3c] ;@ Save A7
  bl cyclone_write32 ;@ Call write32(r0,r1) handler
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4ebb] jsr ($33,pc,d3.w*2); =35 uses Op4ebb ----------
Op4ebb:
  str r5,[r7,#0x5c] ;@ Save Cycles

  ldr r11,[r7,#0x60] ;@ Get Memory base

;@ EaCalc : Get '($33,pc,d3.w*2)' into r12:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r12,r2,r0 ;@ r12=Disp+PC+Rn
;@ Jump - Get new PC from r12
  add r0,r12,r11 ;@ Memory Base + New PC

  bl cyclone_checkpc ;@ Call checkpc()
  ldr r2,[r7,#0x3c]
  sub r1,r4,r11 ;@ r1 = Old PC
  mov r4,r0
  tst r4,#1 ;@ address error?
  bne ExceptionAddressError_r_prg_r4
;@ Push old PC onto stack
  sub r0,r2,#4 ;@ Predecrement A7
  str r0,[r7,#0x3c] ;@ Save A7
  bl cyclone_write32 ;@ Call write32(r0,r1) handler
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4ed0] jmp (a0) uses Op4ed0 ----------
Op4ed0:
  ldr r11,[r7,#0x60] ;@ Get Memory base

;@ EaCalc : Get '(a0)' into r12:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r12,[r7,r2,lsl #2]
;@ Jump - Get new PC from r12
  add r0,r12,r11 ;@ Memory Base + New PC

  bl cyclone_checkpc ;@ Call checkpc()
  mov r4,r0
  tst r4,#1 ;@ address error?
  bne ExceptionAddressError_r_prg_r4
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4ee8] jmp ($3333,a0) uses Op4ee8 ----------
Op4ee8:
  ldr r11,[r7,#0x60] ;@ Get Memory base

;@ EaCalc : Get '($3333,a0)' into r12:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r12,r0,r2 ;@ Add on offset
;@ Jump - Get new PC from r12
  add r0,r12,r11 ;@ Memory Base + New PC

  bl cyclone_checkpc ;@ Call checkpc()
  mov r4,r0
  tst r4,#1 ;@ address error?
  bne ExceptionAddressError_r_prg_r4
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4ef0] jmp ($33,a0,d3.w*2) uses Op4ef0 ----------
Op4ef0:
  ldr r11,[r7,#0x60] ;@ Get Memory base

;@ EaCalc : Get '($33,a0,d3.w*2)' into r12:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r12,r2,r3 ;@ r12=Disp+An+Rn
;@ Jump - Get new PC from r12
  add r0,r12,r11 ;@ Memory Base + New PC

  bl cyclone_checkpc ;@ Call checkpc()
  mov r4,r0
  tst r4,#1 ;@ address error?
  bne ExceptionAddressError_r_prg_r4
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4ef8] jmp $3333.w uses Op4ef8 ----------
Op4ef8:
  ldr r11,[r7,#0x60] ;@ Get Memory base

;@ EaCalc : Get '$3333.w' into r12:
  ldrsh r12,[r4],#2 ;@ Fetch Absolute Short address
;@ Jump - Get new PC from r12
  add r0,r12,r11 ;@ Memory Base + New PC

  bl cyclone_checkpc ;@ Call checkpc()
  mov r4,r0
  tst r4,#1 ;@ address error?
  bne ExceptionAddressError_r_prg_r4
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4ef9] jmp $33333333.l uses Op4ef9 ----------
Op4ef9:
  ldr r11,[r7,#0x60] ;@ Get Memory base

;@ EaCalc : Get '$33333333.l' into r12:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r12,r0,r2,lsl #16
;@ Jump - Get new PC from r12
  add r0,r12,r11 ;@ Memory Base + New PC

  bl cyclone_checkpc ;@ Call checkpc()
  mov r4,r0
  tst r4,#1 ;@ address error?
  bne ExceptionAddressError_r_prg_r4
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4efa] jmp ($3333,pc); =3335 uses Op4efa ----------
Op4efa:
  ldr r11,[r7,#0x60] ;@ Get Memory base

;@ EaCalc : Get '($3333,pc)' into r12:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r12,r2,r0 ;@ ($nn,PC)
;@ Jump - Get new PC from r12
  add r0,r12,r11 ;@ Memory Base + New PC

  bl cyclone_checkpc ;@ Call checkpc()
  mov r4,r0
  tst r4,#1 ;@ address error?
  bne ExceptionAddressError_r_prg_r4
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [4efb] jmp ($33,pc,d3.w*2); =35 uses Op4efb ----------
Op4efb:
  ldr r11,[r7,#0x60] ;@ Get Memory base

;@ EaCalc : Get '($33,pc,d3.w*2)' into r12:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r12,r2,r0 ;@ r12=Disp+PC+Rn
;@ Jump - Get new PC from r12
  add r0,r12,r11 ;@ Memory Base + New PC

  bl cyclone_checkpc ;@ Call checkpc()
  mov r4,r0
  tst r4,#1 ;@ address error?
  bne ExceptionAddressError_r_prg_r4
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5000] addq.b #8, d0 uses Op5000 ----------
Op5000:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

  mov r0,r0,asl #24

  adds r1,r0,#0x8000000
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: r1 into register[r11]:
  mov r1,r1,lsr #24
  strb r1,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5010] addq.b #8, (a0) uses Op5010 ----------
Op5010:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

  mov r0,r0,asl #24

  adds r1,r0,#0x8000000
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  mov r1,r1,lsr #24
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5018] addq.b #8, (a0)+ uses Op5018 ----------
Op5018:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

  mov r0,r0,asl #24

  adds r1,r0,#0x8000000
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  mov r1,r1,lsr #24
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [501f] addq.b #8, (a7)+ uses Op501f ----------
Op501f:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a7)+' into r11:
  ldr r11,[r7,#0x3c] ;@ A7
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

  mov r0,r0,asl #24

  adds r1,r0,#0x8000000
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '(a7)+' (address in r11):
  mov r1,r1,lsr #24
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5020] addq.b #8, -(a0) uses Op5020 ----------
Op5020:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#1 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

  mov r0,r0,asl #24

  adds r1,r0,#0x8000000
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r1,r1,lsr #24
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5027] addq.b #8, -(a7) uses Op5027 ----------
Op5027:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a7)' into r11:
  ldr r11,[r7,#0x3c] ;@ A7
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

  mov r0,r0,asl #24

  adds r1,r0,#0x8000000
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '-(a7)' (address in r11):
  mov r1,r1,lsr #24
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5028] addq.b #8, ($3333,a0) uses Op5028 ----------
Op5028:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

  mov r0,r0,asl #24

  adds r1,r0,#0x8000000
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  mov r1,r1,lsr #24
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5030] addq.b #8, ($33,a0,d3.w*2) uses Op5030 ----------
Op5030:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

  mov r0,r0,asl #24

  adds r1,r0,#0x8000000
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  mov r1,r1,lsr #24
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5038] addq.b #8, $3333.w uses Op5038 ----------
Op5038:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

  mov r0,r0,asl #24

  adds r1,r0,#0x8000000
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  mov r1,r1,lsr #24
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5039] addq.b #8, $33333333.l uses Op5039 ----------
Op5039:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

  mov r0,r0,asl #24

  adds r1,r0,#0x8000000
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  mov r1,r1,lsr #24
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5040] addq.w #8, d0 uses Op5040 ----------
Op5040:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
  mov r11,r11,lsl #2
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11]

  mov r0,r0,asl #16

  adds r1,r0,#0x80000
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: r1 into register[r11]:
  mov r1,r1,lsr #16
  strh r1,[r7,r11]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5048] addq.w #8, a0 uses Op5048 ----------
Op5048:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

  adds r1,r0,#0x0008

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5050] addq.w #8, (a0) uses Op5050 ----------
Op5050:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler

  mov r0,r0,asl #16

  adds r1,r0,#0x80000
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  mov r1,r1,lsr #16
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5058] addq.w #8, (a0)+ uses Op5058 ----------
Op5058:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler

  mov r0,r0,asl #16

  adds r1,r0,#0x80000
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  mov r1,r1,lsr #16
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5060] addq.w #8, -(a0) uses Op5060 ----------
Op5060:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler

  mov r0,r0,asl #16

  adds r1,r0,#0x80000
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r1,r1,lsr #16
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5068] addq.w #8, ($3333,a0) uses Op5068 ----------
Op5068:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler

  mov r0,r0,asl #16

  adds r1,r0,#0x80000
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  mov r1,r1,lsr #16
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5070] addq.w #8, ($33,a0,d3.w*2) uses Op5070 ----------
Op5070:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler

  mov r0,r0,asl #16

  adds r1,r0,#0x80000
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  mov r1,r1,lsr #16
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5078] addq.w #8, $3333.w uses Op5078 ----------
Op5078:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler

  mov r0,r0,asl #16

  adds r1,r0,#0x80000
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  mov r1,r1,lsr #16
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5079] addq.w #8, $33333333.l uses Op5079 ----------
Op5079:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler

  mov r0,r0,asl #16

  adds r1,r0,#0x80000
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  mov r1,r1,lsr #16
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5080] addq.l #8, d0 uses Op5080 ----------
Op5080:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

  adds r1,r0,#0x0008
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5088] addq.l #8, a0 uses Op5088 ----------
Op5088:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

  adds r1,r0,#0x0008

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5090] addq.l #8, (a0) uses Op5090 ----------
Op5090:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read32 ;@ Call read32(r0) handler

  adds r1,r0,#0x0008
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  mov r0,r11
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5098] addq.l #8, (a0)+ uses Op5098 ----------
Op5098:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read32 ;@ Call read32(r0) handler

  adds r1,r0,#0x0008
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  mov r0,r11
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [50a0] addq.l #8, -(a0) uses Op50a0 ----------
Op50a0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#4 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read32 ;@ Call read32(r0) handler

  adds r1,r0,#0x0008
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r0,r11
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [50a8] addq.l #8, ($3333,a0) uses Op50a8 ----------
Op50a8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read32 ;@ Call read32(r0) handler

  adds r1,r0,#0x0008
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  mov r0,r11
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [50b0] addq.l #8, ($33,a0,d3.w*2) uses Op50b0 ----------
Op50b0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read32 ;@ Call read32(r0) handler

  adds r1,r0,#0x0008
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  mov r0,r11
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [50b8] addq.l #8, $3333.w uses Op50b8 ----------
Op50b8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read32 ;@ Call read32(r0) handler

  adds r1,r0,#0x0008
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  mov r0,r11
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [50b9] addq.l #8, $33333333.l uses Op50b9 ----------
Op50b9:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read32 ;@ Call read32(r0) handler

  adds r1,r0,#0x0008
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  mov r0,r11
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [50c0] st d0 uses Op50c0 ----------
Op50c0:
  mvn r1,#0

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaWrite: r1 into register[r0]:
  strb r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [50c8] dbt d0, 3335 uses Op50c8 ----------
Op50c8:
;@ condition true:
DbraTrue:
  add r4,r4,#2 ;@ Skip branch offset

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [50d0] st (a0) uses Op50d0 ----------
Op50d0:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mvn r1,#0

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [50d8] st (a0)+ uses Op50d8 ----------
Op50d8:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mvn r1,#0

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [50df] st (a7)+ uses Op50df ----------
Op50df:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mvn r1,#0

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [50e0] st -(a0) uses Op50e0 ----------
Op50e0:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mvn r1,#0

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [50e7] st -(a7) uses Op50e7 ----------
Op50e7:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mvn r1,#0

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [50e8] st ($3333,a0) uses Op50e8 ----------
Op50e8:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mvn r1,#0

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [50f0] st ($33,a0,d3.w*2) uses Op50f0 ----------
Op50f0:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mvn r1,#0

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [50f8] st $3333.w uses Op50f8 ----------
Op50f8:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mvn r1,#0

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [50f9] st $33333333.l uses Op50f9 ----------
Op50f9:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mvn r1,#0

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5100] subq.b #8, d0 uses Op5100 ----------
Op5100:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

  mov r0,r0,asl #24

  subs r1,r0,#0x8000000
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: r1 into register[r11]:
  mov r1,r1,lsr #24
  strb r1,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5110] subq.b #8, (a0) uses Op5110 ----------
Op5110:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

  mov r0,r0,asl #24

  subs r1,r0,#0x8000000
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  mov r1,r1,lsr #24
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5118] subq.b #8, (a0)+ uses Op5118 ----------
Op5118:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

  mov r0,r0,asl #24

  subs r1,r0,#0x8000000
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  mov r1,r1,lsr #24
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [511f] subq.b #8, (a7)+ uses Op511f ----------
Op511f:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a7)+' into r11:
  ldr r11,[r7,#0x3c] ;@ A7
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

  mov r0,r0,asl #24

  subs r1,r0,#0x8000000
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '(a7)+' (address in r11):
  mov r1,r1,lsr #24
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5120] subq.b #8, -(a0) uses Op5120 ----------
Op5120:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#1 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

  mov r0,r0,asl #24

  subs r1,r0,#0x8000000
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r1,r1,lsr #24
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5127] subq.b #8, -(a7) uses Op5127 ----------
Op5127:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a7)' into r11:
  ldr r11,[r7,#0x3c] ;@ A7
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

  mov r0,r0,asl #24

  subs r1,r0,#0x8000000
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '-(a7)' (address in r11):
  mov r1,r1,lsr #24
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5128] subq.b #8, ($3333,a0) uses Op5128 ----------
Op5128:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

  mov r0,r0,asl #24

  subs r1,r0,#0x8000000
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  mov r1,r1,lsr #24
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5130] subq.b #8, ($33,a0,d3.w*2) uses Op5130 ----------
Op5130:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

  mov r0,r0,asl #24

  subs r1,r0,#0x8000000
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  mov r1,r1,lsr #24
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5138] subq.b #8, $3333.w uses Op5138 ----------
Op5138:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

  mov r0,r0,asl #24

  subs r1,r0,#0x8000000
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  mov r1,r1,lsr #24
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5139] subq.b #8, $33333333.l uses Op5139 ----------
Op5139:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

  mov r0,r0,asl #24

  subs r1,r0,#0x8000000
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  mov r1,r1,lsr #24
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5140] subq.w #8, d0 uses Op5140 ----------
Op5140:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
  mov r11,r11,lsl #2
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11]

  mov r0,r0,asl #16

  subs r1,r0,#0x80000
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: r1 into register[r11]:
  mov r1,r1,lsr #16
  strh r1,[r7,r11]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5148] subq.w #8, a0 uses Op5148 ----------
Op5148:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

  subs r1,r0,#0x0008

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5150] subq.w #8, (a0) uses Op5150 ----------
Op5150:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler

  mov r0,r0,asl #16

  subs r1,r0,#0x80000
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  mov r1,r1,lsr #16
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5158] subq.w #8, (a0)+ uses Op5158 ----------
Op5158:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler

  mov r0,r0,asl #16

  subs r1,r0,#0x80000
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  mov r1,r1,lsr #16
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5160] subq.w #8, -(a0) uses Op5160 ----------
Op5160:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler

  mov r0,r0,asl #16

  subs r1,r0,#0x80000
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r1,r1,lsr #16
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5168] subq.w #8, ($3333,a0) uses Op5168 ----------
Op5168:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler

  mov r0,r0,asl #16

  subs r1,r0,#0x80000
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  mov r1,r1,lsr #16
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5170] subq.w #8, ($33,a0,d3.w*2) uses Op5170 ----------
Op5170:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler

  mov r0,r0,asl #16

  subs r1,r0,#0x80000
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  mov r1,r1,lsr #16
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5178] subq.w #8, $3333.w uses Op5178 ----------
Op5178:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler

  mov r0,r0,asl #16

  subs r1,r0,#0x80000
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  mov r1,r1,lsr #16
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5179] subq.w #8, $33333333.l uses Op5179 ----------
Op5179:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler

  mov r0,r0,asl #16

  subs r1,r0,#0x80000
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  mov r1,r1,lsr #16
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5180] subq.l #8, d0 uses Op5180 ----------
Op5180:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

  subs r1,r0,#0x0008
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5188] subq.l #8, a0 uses Op5188 ----------
Op5188:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

  subs r1,r0,#0x0008

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5190] subq.l #8, (a0) uses Op5190 ----------
Op5190:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read32 ;@ Call read32(r0) handler

  subs r1,r0,#0x0008
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  mov r0,r11
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5198] subq.l #8, (a0)+ uses Op5198 ----------
Op5198:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read32 ;@ Call read32(r0) handler

  subs r1,r0,#0x0008
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  mov r0,r11
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [51a0] subq.l #8, -(a0) uses Op51a0 ----------
Op51a0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#4 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read32 ;@ Call read32(r0) handler

  subs r1,r0,#0x0008
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r0,r11
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [51a8] subq.l #8, ($3333,a0) uses Op51a8 ----------
Op51a8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read32 ;@ Call read32(r0) handler

  subs r1,r0,#0x0008
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  mov r0,r11
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [51b0] subq.l #8, ($33,a0,d3.w*2) uses Op51b0 ----------
Op51b0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read32 ;@ Call read32(r0) handler

  subs r1,r0,#0x0008
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  mov r0,r11
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [51b8] subq.l #8, $3333.w uses Op51b8 ----------
Op51b8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read32 ;@ Call read32(r0) handler

  subs r1,r0,#0x0008
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  mov r0,r11
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [51b9] subq.l #8, $33333333.l uses Op51b9 ----------
Op51b9:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read32 ;@ Call read32(r0) handler

  subs r1,r0,#0x0008
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  mov r0,r11
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [51c0] sf d0 uses Op51c0 ----------
Op51c0:
  mov r1,#0

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaWrite: r1 into register[r0]:
  strb r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [51d0] sf (a0) uses Op51d0 ----------
Op51d0:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [51d8] sf (a0)+ uses Op51d8 ----------
Op51d8:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [51df] sf (a7)+ uses Op51df ----------
Op51df:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [51e0] sf -(a0) uses Op51e0 ----------
Op51e0:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [51e7] sf -(a7) uses Op51e7 ----------
Op51e7:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [51e8] sf ($3333,a0) uses Op51e8 ----------
Op51e8:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [51f0] sf ($33,a0,d3.w*2) uses Op51f0 ----------
Op51f0:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [51f8] sf $3333.w uses Op51f8 ----------
Op51f8:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [51f9] sf $33333333.l uses Op51f9 ----------
Op51f9:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [52c0] shi d0 uses Op52c0 ----------
Op52c0:
  mov r1,#0
  tst r10,#0x60000000 ;@ hi: !C && !Z
  mvneq r1,#0
  subeq r5,r5,#2 ;@ Extra cycles

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaWrite: r1 into register[r0]:
  strb r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [52c8] dbhi d0, 3335 uses Op52c8 ----------
Op52c8:
;@ Is the condition true?
  tst r10,#0x60000000 ;@ hi: !C && !Z
;@ If so, don't dbra
  beq DbraTrue

;@ Decrement Dn.w
  and r1,r8,#0x0007
  mov r1,r1,lsl #2
  ldrsh r0,[r7,r1]
  strb r8,[r7,#0x45] ;@ not polling
  sub r0,r0,#1
  strh r0,[r7,r1]

;@ Check if Dn.w is -1
  cmn r0,#1
  beq DbraMin1

;@ Get Branch offset:
  ldrsh r0,[r4]
  add r0,r4,r0 ;@ r0 = New PC
  bl cyclone_checkpc ;@ Call checkpc()
  mov r4,r0
  tst r4,#1 ;@ address error?
  bne ExceptionAddressError_r_prg_r4
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [52d0] shi (a0) uses Op52d0 ----------
Op52d0:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x60000000 ;@ hi: !C && !Z
  mvneq r1,#0

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [52d8] shi (a0)+ uses Op52d8 ----------
Op52d8:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x60000000 ;@ hi: !C && !Z
  mvneq r1,#0

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [52df] shi (a7)+ uses Op52df ----------
Op52df:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x60000000 ;@ hi: !C && !Z
  mvneq r1,#0

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [52e0] shi -(a0) uses Op52e0 ----------
Op52e0:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x60000000 ;@ hi: !C && !Z
  mvneq r1,#0

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [52e7] shi -(a7) uses Op52e7 ----------
Op52e7:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x60000000 ;@ hi: !C && !Z
  mvneq r1,#0

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [52e8] shi ($3333,a0) uses Op52e8 ----------
Op52e8:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x60000000 ;@ hi: !C && !Z
  mvneq r1,#0

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [52f0] shi ($33,a0,d3.w*2) uses Op52f0 ----------
Op52f0:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x60000000 ;@ hi: !C && !Z
  mvneq r1,#0

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [52f8] shi $3333.w uses Op52f8 ----------
Op52f8:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x60000000 ;@ hi: !C && !Z
  mvneq r1,#0

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [52f9] shi $33333333.l uses Op52f9 ----------
Op52f9:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x60000000 ;@ hi: !C && !Z
  mvneq r1,#0

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [53c0] sls d0 uses Op53c0 ----------
Op53c0:
  mov r1,#0
  tst r10,#0x60000000 ;@ ls: C || Z
  mvnne r1,#0
  subne r5,r5,#2 ;@ Extra cycles

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaWrite: r1 into register[r0]:
  strb r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [53c8] dbls d0, 3335 uses Op53c8 ----------
Op53c8:
;@ Is the condition true?
  tst r10,#0x60000000 ;@ ls: C || Z
;@ If so, don't dbra
  bne DbraTrue

;@ Decrement Dn.w
  and r1,r8,#0x0007
  mov r1,r1,lsl #2
  ldrsh r0,[r7,r1]
  strb r8,[r7,#0x45] ;@ not polling
  sub r0,r0,#1
  strh r0,[r7,r1]

;@ Check if Dn.w is -1
  cmn r0,#1
  beq DbraMin1

;@ Get Branch offset:
  ldrsh r0,[r4]
  add r0,r4,r0 ;@ r0 = New PC
  bl cyclone_checkpc ;@ Call checkpc()
  mov r4,r0
  tst r4,#1 ;@ address error?
  bne ExceptionAddressError_r_prg_r4
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [53d0] sls (a0) uses Op53d0 ----------
Op53d0:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x60000000 ;@ ls: C || Z
  mvnne r1,#0

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [53d8] sls (a0)+ uses Op53d8 ----------
Op53d8:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x60000000 ;@ ls: C || Z
  mvnne r1,#0

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [53df] sls (a7)+ uses Op53df ----------
Op53df:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x60000000 ;@ ls: C || Z
  mvnne r1,#0

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [53e0] sls -(a0) uses Op53e0 ----------
Op53e0:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x60000000 ;@ ls: C || Z
  mvnne r1,#0

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [53e7] sls -(a7) uses Op53e7 ----------
Op53e7:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x60000000 ;@ ls: C || Z
  mvnne r1,#0

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [53e8] sls ($3333,a0) uses Op53e8 ----------
Op53e8:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x60000000 ;@ ls: C || Z
  mvnne r1,#0

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [53f0] sls ($33,a0,d3.w*2) uses Op53f0 ----------
Op53f0:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x60000000 ;@ ls: C || Z
  mvnne r1,#0

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [53f8] sls $3333.w uses Op53f8 ----------
Op53f8:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x60000000 ;@ ls: C || Z
  mvnne r1,#0

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [53f9] sls $33333333.l uses Op53f9 ----------
Op53f9:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x60000000 ;@ ls: C || Z
  mvnne r1,#0

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [54c0] scc d0 uses Op54c0 ----------
Op54c0:
  mov r1,#0
  tst r10,#0x20000000 ;@ cc: !C
  mvneq r1,#0
  subeq r5,r5,#2 ;@ Extra cycles

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaWrite: r1 into register[r0]:
  strb r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [54c8] dbcc d0, 3335 uses Op54c8 ----------
Op54c8:
;@ Is the condition true?
  tst r10,#0x20000000 ;@ cc: !C
;@ If so, don't dbra
  beq DbraTrue

;@ Decrement Dn.w
  and r1,r8,#0x0007
  mov r1,r1,lsl #2
  ldrsh r0,[r7,r1]
  strb r8,[r7,#0x45] ;@ not polling
  sub r0,r0,#1
  strh r0,[r7,r1]

;@ Check if Dn.w is -1
  cmn r0,#1
  beq DbraMin1

;@ Get Branch offset:
  ldrsh r0,[r4]
  add r0,r4,r0 ;@ r0 = New PC
  bl cyclone_checkpc ;@ Call checkpc()
  mov r4,r0
  tst r4,#1 ;@ address error?
  bne ExceptionAddressError_r_prg_r4
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [54d0] scc (a0) uses Op54d0 ----------
Op54d0:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x20000000 ;@ cc: !C
  mvneq r1,#0

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [54d8] scc (a0)+ uses Op54d8 ----------
Op54d8:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x20000000 ;@ cc: !C
  mvneq r1,#0

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [54df] scc (a7)+ uses Op54df ----------
Op54df:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x20000000 ;@ cc: !C
  mvneq r1,#0

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [54e0] scc -(a0) uses Op54e0 ----------
Op54e0:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x20000000 ;@ cc: !C
  mvneq r1,#0

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [54e7] scc -(a7) uses Op54e7 ----------
Op54e7:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x20000000 ;@ cc: !C
  mvneq r1,#0

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [54e8] scc ($3333,a0) uses Op54e8 ----------
Op54e8:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x20000000 ;@ cc: !C
  mvneq r1,#0

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [54f0] scc ($33,a0,d3.w*2) uses Op54f0 ----------
Op54f0:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x20000000 ;@ cc: !C
  mvneq r1,#0

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [54f8] scc $3333.w uses Op54f8 ----------
Op54f8:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x20000000 ;@ cc: !C
  mvneq r1,#0

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [54f9] scc $33333333.l uses Op54f9 ----------
Op54f9:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x20000000 ;@ cc: !C
  mvneq r1,#0

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [55c0] scs d0 uses Op55c0 ----------
Op55c0:
  mov r1,#0
  tst r10,#0x20000000 ;@ cs: C
  mvnne r1,#0
  subne r5,r5,#2 ;@ Extra cycles

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaWrite: r1 into register[r0]:
  strb r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [55c8] dbcs d0, 3335 uses Op55c8 ----------
Op55c8:
;@ Is the condition true?
  tst r10,#0x20000000 ;@ cs: C
;@ If so, don't dbra
  bne DbraTrue

;@ Decrement Dn.w
  and r1,r8,#0x0007
  mov r1,r1,lsl #2
  ldrsh r0,[r7,r1]
  strb r8,[r7,#0x45] ;@ not polling
  sub r0,r0,#1
  strh r0,[r7,r1]

;@ Check if Dn.w is -1
  cmn r0,#1
  beq DbraMin1

;@ Get Branch offset:
  ldrsh r0,[r4]
  add r0,r4,r0 ;@ r0 = New PC
  bl cyclone_checkpc ;@ Call checkpc()
  mov r4,r0
  tst r4,#1 ;@ address error?
  bne ExceptionAddressError_r_prg_r4
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [55d0] scs (a0) uses Op55d0 ----------
Op55d0:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x20000000 ;@ cs: C
  mvnne r1,#0

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [55d8] scs (a0)+ uses Op55d8 ----------
Op55d8:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x20000000 ;@ cs: C
  mvnne r1,#0

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [55df] scs (a7)+ uses Op55df ----------
Op55df:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x20000000 ;@ cs: C
  mvnne r1,#0

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [55e0] scs -(a0) uses Op55e0 ----------
Op55e0:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x20000000 ;@ cs: C
  mvnne r1,#0

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [55e7] scs -(a7) uses Op55e7 ----------
Op55e7:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x20000000 ;@ cs: C
  mvnne r1,#0

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [55e8] scs ($3333,a0) uses Op55e8 ----------
Op55e8:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x20000000 ;@ cs: C
  mvnne r1,#0

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [55f0] scs ($33,a0,d3.w*2) uses Op55f0 ----------
Op55f0:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x20000000 ;@ cs: C
  mvnne r1,#0

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [55f8] scs $3333.w uses Op55f8 ----------
Op55f8:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x20000000 ;@ cs: C
  mvnne r1,#0

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [55f9] scs $33333333.l uses Op55f9 ----------
Op55f9:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x20000000 ;@ cs: C
  mvnne r1,#0

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [56c0] sne d0 uses Op56c0 ----------
Op56c0:
  mov r1,#0
  tst r10,#0x40000000 ;@ ne: !Z
  mvneq r1,#0
  subeq r5,r5,#2 ;@ Extra cycles

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaWrite: r1 into register[r0]:
  strb r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [56c8] dbne d0, 3335 uses Op56c8 ----------
Op56c8:
;@ Is the condition true?
  tst r10,#0x40000000 ;@ ne: !Z
;@ If so, don't dbra
  beq DbraTrue

;@ Decrement Dn.w
  and r1,r8,#0x0007
  mov r1,r1,lsl #2
  ldrsh r0,[r7,r1]
  strb r8,[r7,#0x45] ;@ not polling
  sub r0,r0,#1
  strh r0,[r7,r1]

;@ Check if Dn.w is -1
  cmn r0,#1
  beq DbraMin1

;@ Get Branch offset:
  ldrsh r0,[r4]
  add r0,r4,r0 ;@ r0 = New PC
  bl cyclone_checkpc ;@ Call checkpc()
  mov r4,r0
  tst r4,#1 ;@ address error?
  bne ExceptionAddressError_r_prg_r4
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [56d0] sne (a0) uses Op56d0 ----------
Op56d0:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x40000000 ;@ ne: !Z
  mvneq r1,#0

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [56d8] sne (a0)+ uses Op56d8 ----------
Op56d8:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x40000000 ;@ ne: !Z
  mvneq r1,#0

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [56df] sne (a7)+ uses Op56df ----------
Op56df:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x40000000 ;@ ne: !Z
  mvneq r1,#0

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [56e0] sne -(a0) uses Op56e0 ----------
Op56e0:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x40000000 ;@ ne: !Z
  mvneq r1,#0

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [56e7] sne -(a7) uses Op56e7 ----------
Op56e7:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x40000000 ;@ ne: !Z
  mvneq r1,#0

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [56e8] sne ($3333,a0) uses Op56e8 ----------
Op56e8:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x40000000 ;@ ne: !Z
  mvneq r1,#0

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [56f0] sne ($33,a0,d3.w*2) uses Op56f0 ----------
Op56f0:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x40000000 ;@ ne: !Z
  mvneq r1,#0

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [56f8] sne $3333.w uses Op56f8 ----------
Op56f8:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x40000000 ;@ ne: !Z
  mvneq r1,#0

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [56f9] sne $33333333.l uses Op56f9 ----------
Op56f9:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x40000000 ;@ ne: !Z
  mvneq r1,#0

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [57c0] seq d0 uses Op57c0 ----------
Op57c0:
  mov r1,#0
  tst r10,#0x40000000 ;@ eq: Z
  mvnne r1,#0
  subne r5,r5,#2 ;@ Extra cycles

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaWrite: r1 into register[r0]:
  strb r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [57c8] dbeq d0, 3335 uses Op57c8 ----------
Op57c8:
;@ Is the condition true?
  tst r10,#0x40000000 ;@ eq: Z
;@ If so, don't dbra
  bne DbraTrue

;@ Decrement Dn.w
  and r1,r8,#0x0007
  mov r1,r1,lsl #2
  ldrsh r0,[r7,r1]
  strb r8,[r7,#0x45] ;@ not polling
  sub r0,r0,#1
  strh r0,[r7,r1]

;@ Check if Dn.w is -1
  cmn r0,#1
  beq DbraMin1

;@ Get Branch offset:
  ldrsh r0,[r4]
  add r0,r4,r0 ;@ r0 = New PC
  bl cyclone_checkpc ;@ Call checkpc()
  mov r4,r0
  tst r4,#1 ;@ address error?
  bne ExceptionAddressError_r_prg_r4
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [57d0] seq (a0) uses Op57d0 ----------
Op57d0:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x40000000 ;@ eq: Z
  mvnne r1,#0

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [57d8] seq (a0)+ uses Op57d8 ----------
Op57d8:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x40000000 ;@ eq: Z
  mvnne r1,#0

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [57df] seq (a7)+ uses Op57df ----------
Op57df:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x40000000 ;@ eq: Z
  mvnne r1,#0

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [57e0] seq -(a0) uses Op57e0 ----------
Op57e0:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x40000000 ;@ eq: Z
  mvnne r1,#0

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [57e7] seq -(a7) uses Op57e7 ----------
Op57e7:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x40000000 ;@ eq: Z
  mvnne r1,#0

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [57e8] seq ($3333,a0) uses Op57e8 ----------
Op57e8:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x40000000 ;@ eq: Z
  mvnne r1,#0

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [57f0] seq ($33,a0,d3.w*2) uses Op57f0 ----------
Op57f0:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x40000000 ;@ eq: Z
  mvnne r1,#0

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [57f8] seq $3333.w uses Op57f8 ----------
Op57f8:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x40000000 ;@ eq: Z
  mvnne r1,#0

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [57f9] seq $33333333.l uses Op57f9 ----------
Op57f9:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x40000000 ;@ eq: Z
  mvnne r1,#0

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [58c0] svc d0 uses Op58c0 ----------
Op58c0:
  mov r1,#0
  tst r10,#0x10000000 ;@ vc: !V
  mvneq r1,#0
  subeq r5,r5,#2 ;@ Extra cycles

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaWrite: r1 into register[r0]:
  strb r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [58c8] dbvc d0, 3335 uses Op58c8 ----------
Op58c8:
;@ Is the condition true?
  tst r10,#0x10000000 ;@ vc: !V
;@ If so, don't dbra
  beq DbraTrue

;@ Decrement Dn.w
  and r1,r8,#0x0007
  mov r1,r1,lsl #2
  ldrsh r0,[r7,r1]
  strb r8,[r7,#0x45] ;@ not polling
  sub r0,r0,#1
  strh r0,[r7,r1]

;@ Check if Dn.w is -1
  cmn r0,#1
  beq DbraMin1

;@ Get Branch offset:
  ldrsh r0,[r4]
  add r0,r4,r0 ;@ r0 = New PC
  bl cyclone_checkpc ;@ Call checkpc()
  mov r4,r0
  tst r4,#1 ;@ address error?
  bne ExceptionAddressError_r_prg_r4
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [58d0] svc (a0) uses Op58d0 ----------
Op58d0:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x10000000 ;@ vc: !V
  mvneq r1,#0

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [58d8] svc (a0)+ uses Op58d8 ----------
Op58d8:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x10000000 ;@ vc: !V
  mvneq r1,#0

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [58df] svc (a7)+ uses Op58df ----------
Op58df:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x10000000 ;@ vc: !V
  mvneq r1,#0

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [58e0] svc -(a0) uses Op58e0 ----------
Op58e0:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x10000000 ;@ vc: !V
  mvneq r1,#0

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [58e7] svc -(a7) uses Op58e7 ----------
Op58e7:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x10000000 ;@ vc: !V
  mvneq r1,#0

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [58e8] svc ($3333,a0) uses Op58e8 ----------
Op58e8:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x10000000 ;@ vc: !V
  mvneq r1,#0

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [58f0] svc ($33,a0,d3.w*2) uses Op58f0 ----------
Op58f0:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x10000000 ;@ vc: !V
  mvneq r1,#0

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [58f8] svc $3333.w uses Op58f8 ----------
Op58f8:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x10000000 ;@ vc: !V
  mvneq r1,#0

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [58f9] svc $33333333.l uses Op58f9 ----------
Op58f9:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x10000000 ;@ vc: !V
  mvneq r1,#0

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [59c0] svs d0 uses Op59c0 ----------
Op59c0:
  mov r1,#0
  tst r10,#0x10000000 ;@ vs: V
  mvnne r1,#0
  subne r5,r5,#2 ;@ Extra cycles

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaWrite: r1 into register[r0]:
  strb r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [59c8] dbvs d0, 3335 uses Op59c8 ----------
Op59c8:
;@ Is the condition true?
  tst r10,#0x10000000 ;@ vs: V
;@ If so, don't dbra
  bne DbraTrue

;@ Decrement Dn.w
  and r1,r8,#0x0007
  mov r1,r1,lsl #2
  ldrsh r0,[r7,r1]
  strb r8,[r7,#0x45] ;@ not polling
  sub r0,r0,#1
  strh r0,[r7,r1]

;@ Check if Dn.w is -1
  cmn r0,#1
  beq DbraMin1

;@ Get Branch offset:
  ldrsh r0,[r4]
  add r0,r4,r0 ;@ r0 = New PC
  bl cyclone_checkpc ;@ Call checkpc()
  mov r4,r0
  tst r4,#1 ;@ address error?
  bne ExceptionAddressError_r_prg_r4
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [59d0] svs (a0) uses Op59d0 ----------
Op59d0:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x10000000 ;@ vs: V
  mvnne r1,#0

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [59d8] svs (a0)+ uses Op59d8 ----------
Op59d8:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x10000000 ;@ vs: V
  mvnne r1,#0

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [59df] svs (a7)+ uses Op59df ----------
Op59df:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x10000000 ;@ vs: V
  mvnne r1,#0

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [59e0] svs -(a0) uses Op59e0 ----------
Op59e0:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x10000000 ;@ vs: V
  mvnne r1,#0

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [59e7] svs -(a7) uses Op59e7 ----------
Op59e7:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x10000000 ;@ vs: V
  mvnne r1,#0

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [59e8] svs ($3333,a0) uses Op59e8 ----------
Op59e8:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x10000000 ;@ vs: V
  mvnne r1,#0

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [59f0] svs ($33,a0,d3.w*2) uses Op59f0 ----------
Op59f0:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x10000000 ;@ vs: V
  mvnne r1,#0

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [59f8] svs $3333.w uses Op59f8 ----------
Op59f8:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x10000000 ;@ vs: V
  mvnne r1,#0

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [59f9] svs $33333333.l uses Op59f9 ----------
Op59f9:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,#0x10000000 ;@ vs: V
  mvnne r1,#0

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5ac0] spl d0 uses Op5ac0 ----------
Op5ac0:
  mov r1,#0
  tst r10,r10 ;@ pl: !N
  mvnpl r1,#0
  subpl r5,r5,#2 ;@ Extra cycles

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaWrite: r1 into register[r0]:
  strb r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5ac8] dbpl d0, 3335 uses Op5ac8 ----------
Op5ac8:
;@ Is the condition true?
  tst r10,r10 ;@ pl: !N
;@ If so, don't dbra
  bpl DbraTrue

;@ Decrement Dn.w
  and r1,r8,#0x0007
  mov r1,r1,lsl #2
  ldrsh r0,[r7,r1]
  strb r8,[r7,#0x45] ;@ not polling
  sub r0,r0,#1
  strh r0,[r7,r1]

;@ Check if Dn.w is -1
  cmn r0,#1
  beq DbraMin1

;@ Get Branch offset:
  ldrsh r0,[r4]
  add r0,r4,r0 ;@ r0 = New PC
  bl cyclone_checkpc ;@ Call checkpc()
  mov r4,r0
  tst r4,#1 ;@ address error?
  bne ExceptionAddressError_r_prg_r4
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5ad0] spl (a0) uses Op5ad0 ----------
Op5ad0:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,r10 ;@ pl: !N
  mvnpl r1,#0

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5ad8] spl (a0)+ uses Op5ad8 ----------
Op5ad8:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,r10 ;@ pl: !N
  mvnpl r1,#0

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5adf] spl (a7)+ uses Op5adf ----------
Op5adf:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,r10 ;@ pl: !N
  mvnpl r1,#0

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5ae0] spl -(a0) uses Op5ae0 ----------
Op5ae0:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,r10 ;@ pl: !N
  mvnpl r1,#0

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5ae7] spl -(a7) uses Op5ae7 ----------
Op5ae7:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,r10 ;@ pl: !N
  mvnpl r1,#0

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5ae8] spl ($3333,a0) uses Op5ae8 ----------
Op5ae8:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,r10 ;@ pl: !N
  mvnpl r1,#0

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5af0] spl ($33,a0,d3.w*2) uses Op5af0 ----------
Op5af0:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,r10 ;@ pl: !N
  mvnpl r1,#0

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5af8] spl $3333.w uses Op5af8 ----------
Op5af8:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,r10 ;@ pl: !N
  mvnpl r1,#0

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5af9] spl $33333333.l uses Op5af9 ----------
Op5af9:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,r10 ;@ pl: !N
  mvnpl r1,#0

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5bc0] smi d0 uses Op5bc0 ----------
Op5bc0:
  mov r1,#0
  tst r10,r10 ;@ mi: N
  mvnmi r1,#0
  submi r5,r5,#2 ;@ Extra cycles

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaWrite: r1 into register[r0]:
  strb r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5bc8] dbmi d0, 3335 uses Op5bc8 ----------
Op5bc8:
;@ Is the condition true?
  tst r10,r10 ;@ mi: N
;@ If so, don't dbra
  bmi DbraTrue

;@ Decrement Dn.w
  and r1,r8,#0x0007
  mov r1,r1,lsl #2
  ldrsh r0,[r7,r1]
  strb r8,[r7,#0x45] ;@ not polling
  sub r0,r0,#1
  strh r0,[r7,r1]

;@ Check if Dn.w is -1
  cmn r0,#1
  beq DbraMin1

;@ Get Branch offset:
  ldrsh r0,[r4]
  add r0,r4,r0 ;@ r0 = New PC
  bl cyclone_checkpc ;@ Call checkpc()
  mov r4,r0
  tst r4,#1 ;@ address error?
  bne ExceptionAddressError_r_prg_r4
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5bd0] smi (a0) uses Op5bd0 ----------
Op5bd0:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,r10 ;@ mi: N
  mvnmi r1,#0

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5bd8] smi (a0)+ uses Op5bd8 ----------
Op5bd8:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,r10 ;@ mi: N
  mvnmi r1,#0

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5bdf] smi (a7)+ uses Op5bdf ----------
Op5bdf:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,r10 ;@ mi: N
  mvnmi r1,#0

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5be0] smi -(a0) uses Op5be0 ----------
Op5be0:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,r10 ;@ mi: N
  mvnmi r1,#0

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5be7] smi -(a7) uses Op5be7 ----------
Op5be7:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,r10 ;@ mi: N
  mvnmi r1,#0

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5be8] smi ($3333,a0) uses Op5be8 ----------
Op5be8:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,r10 ;@ mi: N
  mvnmi r1,#0

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5bf0] smi ($33,a0,d3.w*2) uses Op5bf0 ----------
Op5bf0:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,r10 ;@ mi: N
  mvnmi r1,#0

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5bf8] smi $3333.w uses Op5bf8 ----------
Op5bf8:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,r10 ;@ mi: N
  mvnmi r1,#0

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5bf9] smi $33333333.l uses Op5bf9 ----------
Op5bf9:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  tst r10,r10 ;@ mi: N
  mvnmi r1,#0

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5cc0] sge d0 uses Op5cc0 ----------
Op5cc0:
  mov r1,#0
  teq r10,r10,lsl #3 ;@ ge: N == V
  mvnpl r1,#0
  subpl r5,r5,#2 ;@ Extra cycles

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaWrite: r1 into register[r0]:
  strb r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5cc8] dbge d0, 3335 uses Op5cc8 ----------
Op5cc8:
;@ Is the condition true?
  teq r10,r10,lsl #3 ;@ ge: N == V
;@ If so, don't dbra
  bpl DbraTrue

;@ Decrement Dn.w
  and r1,r8,#0x0007
  mov r1,r1,lsl #2
  ldrsh r0,[r7,r1]
  strb r8,[r7,#0x45] ;@ not polling
  sub r0,r0,#1
  strh r0,[r7,r1]

;@ Check if Dn.w is -1
  cmn r0,#1
  beq DbraMin1

;@ Get Branch offset:
  ldrsh r0,[r4]
  add r0,r4,r0 ;@ r0 = New PC
  bl cyclone_checkpc ;@ Call checkpc()
  mov r4,r0
  tst r4,#1 ;@ address error?
  bne ExceptionAddressError_r_prg_r4
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5cd0] sge (a0) uses Op5cd0 ----------
Op5cd0:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  teq r10,r10,lsl #3 ;@ ge: N == V
  mvnpl r1,#0

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5cd8] sge (a0)+ uses Op5cd8 ----------
Op5cd8:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  teq r10,r10,lsl #3 ;@ ge: N == V
  mvnpl r1,#0

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5cdf] sge (a7)+ uses Op5cdf ----------
Op5cdf:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  teq r10,r10,lsl #3 ;@ ge: N == V
  mvnpl r1,#0

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5ce0] sge -(a0) uses Op5ce0 ----------
Op5ce0:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  teq r10,r10,lsl #3 ;@ ge: N == V
  mvnpl r1,#0

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5ce7] sge -(a7) uses Op5ce7 ----------
Op5ce7:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  teq r10,r10,lsl #3 ;@ ge: N == V
  mvnpl r1,#0

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5ce8] sge ($3333,a0) uses Op5ce8 ----------
Op5ce8:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  teq r10,r10,lsl #3 ;@ ge: N == V
  mvnpl r1,#0

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5cf0] sge ($33,a0,d3.w*2) uses Op5cf0 ----------
Op5cf0:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  teq r10,r10,lsl #3 ;@ ge: N == V
  mvnpl r1,#0

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5cf8] sge $3333.w uses Op5cf8 ----------
Op5cf8:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  teq r10,r10,lsl #3 ;@ ge: N == V
  mvnpl r1,#0

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5cf9] sge $33333333.l uses Op5cf9 ----------
Op5cf9:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  teq r10,r10,lsl #3 ;@ ge: N == V
  mvnpl r1,#0

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5dc0] slt d0 uses Op5dc0 ----------
Op5dc0:
  mov r1,#0
  teq r10,r10,lsl #3 ;@ lt: N != V
  mvnmi r1,#0
  submi r5,r5,#2 ;@ Extra cycles

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaWrite: r1 into register[r0]:
  strb r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5dc8] dblt d0, 3335 uses Op5dc8 ----------
Op5dc8:
;@ Is the condition true?
  teq r10,r10,lsl #3 ;@ lt: N != V
;@ If so, don't dbra
  bmi DbraTrue

;@ Decrement Dn.w
  and r1,r8,#0x0007
  mov r1,r1,lsl #2
  ldrsh r0,[r7,r1]
  strb r8,[r7,#0x45] ;@ not polling
  sub r0,r0,#1
  strh r0,[r7,r1]

;@ Check if Dn.w is -1
  cmn r0,#1
  beq DbraMin1

;@ Get Branch offset:
  ldrsh r0,[r4]
  add r0,r4,r0 ;@ r0 = New PC
  bl cyclone_checkpc ;@ Call checkpc()
  mov r4,r0
  tst r4,#1 ;@ address error?
  bne ExceptionAddressError_r_prg_r4
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5dd0] slt (a0) uses Op5dd0 ----------
Op5dd0:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  teq r10,r10,lsl #3 ;@ lt: N != V
  mvnmi r1,#0

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5dd8] slt (a0)+ uses Op5dd8 ----------
Op5dd8:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  teq r10,r10,lsl #3 ;@ lt: N != V
  mvnmi r1,#0

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5ddf] slt (a7)+ uses Op5ddf ----------
Op5ddf:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  teq r10,r10,lsl #3 ;@ lt: N != V
  mvnmi r1,#0

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5de0] slt -(a0) uses Op5de0 ----------
Op5de0:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  teq r10,r10,lsl #3 ;@ lt: N != V
  mvnmi r1,#0

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5de7] slt -(a7) uses Op5de7 ----------
Op5de7:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  teq r10,r10,lsl #3 ;@ lt: N != V
  mvnmi r1,#0

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5de8] slt ($3333,a0) uses Op5de8 ----------
Op5de8:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  teq r10,r10,lsl #3 ;@ lt: N != V
  mvnmi r1,#0

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5df0] slt ($33,a0,d3.w*2) uses Op5df0 ----------
Op5df0:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  teq r10,r10,lsl #3 ;@ lt: N != V
  mvnmi r1,#0

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5df8] slt $3333.w uses Op5df8 ----------
Op5df8:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  teq r10,r10,lsl #3 ;@ lt: N != V
  mvnmi r1,#0

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5df9] slt $33333333.l uses Op5df9 ----------
Op5df9:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  teq r10,r10,lsl #3 ;@ lt: N != V
  mvnmi r1,#0

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5e00] addq.b #7, d0 uses Op5e00 ----------
Op5e00:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

  and r2,r8,#0x0e00 ;@ Get quick value

  mov r0,r0,asl #24

  adds r1,r0,r2,lsl #15
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: r1 into register[r11]:
  mov r1,r1,lsr #24
  strb r1,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5e10] addq.b #7, (a0) uses Op5e10 ----------
Op5e10:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

  and r2,r8,#0x0e00 ;@ Get quick value

  mov r0,r0,asl #24

  adds r1,r0,r2,lsl #15
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  mov r1,r1,lsr #24
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5e18] addq.b #7, (a0)+ uses Op5e18 ----------
Op5e18:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

  and r2,r8,#0x0e00 ;@ Get quick value

  mov r0,r0,asl #24

  adds r1,r0,r2,lsl #15
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  mov r1,r1,lsr #24
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5e1f] addq.b #7, (a7)+ uses Op5e1f ----------
Op5e1f:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a7)+' into r11:
  ldr r11,[r7,#0x3c] ;@ A7
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

  and r2,r8,#0x0e00 ;@ Get quick value

  mov r0,r0,asl #24

  adds r1,r0,r2,lsl #15
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '(a7)+' (address in r11):
  mov r1,r1,lsr #24
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5e20] addq.b #7, -(a0) uses Op5e20 ----------
Op5e20:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#1 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

  and r2,r8,#0x0e00 ;@ Get quick value

  mov r0,r0,asl #24

  adds r1,r0,r2,lsl #15
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r1,r1,lsr #24
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5e27] addq.b #7, -(a7) uses Op5e27 ----------
Op5e27:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a7)' into r11:
  ldr r11,[r7,#0x3c] ;@ A7
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

  and r2,r8,#0x0e00 ;@ Get quick value

  mov r0,r0,asl #24

  adds r1,r0,r2,lsl #15
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '-(a7)' (address in r11):
  mov r1,r1,lsr #24
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5e28] addq.b #7, ($3333,a0) uses Op5e28 ----------
Op5e28:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

  and r2,r8,#0x0e00 ;@ Get quick value

  mov r0,r0,asl #24

  adds r1,r0,r2,lsl #15
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  mov r1,r1,lsr #24
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5e30] addq.b #7, ($33,a0,d3.w*2) uses Op5e30 ----------
Op5e30:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

  and r2,r8,#0x0e00 ;@ Get quick value

  mov r0,r0,asl #24

  adds r1,r0,r2,lsl #15
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  mov r1,r1,lsr #24
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5e38] addq.b #7, $3333.w uses Op5e38 ----------
Op5e38:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

  and r2,r8,#0x0e00 ;@ Get quick value

  mov r0,r0,asl #24

  adds r1,r0,r2,lsl #15
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  mov r1,r1,lsr #24
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5e39] addq.b #7, $33333333.l uses Op5e39 ----------
Op5e39:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

  and r2,r8,#0x0e00 ;@ Get quick value

  mov r0,r0,asl #24

  adds r1,r0,r2,lsl #15
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  mov r1,r1,lsr #24
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5e48] addq.w #7, a0 uses Op5e48 ----------
Op5e48:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

  and r2,r8,#0x0e00 ;@ Get quick value

  adds r1,r0,r2,lsr #9

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5e50] addq.w #7, (a0) uses Op5e50 ----------
Op5e50:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler

  and r2,r8,#0x0e00 ;@ Get quick value

  mov r0,r0,asl #16

  adds r1,r0,r2,lsl #7
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  mov r1,r1,lsr #16
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5e58] addq.w #7, (a0)+ uses Op5e58 ----------
Op5e58:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler

  and r2,r8,#0x0e00 ;@ Get quick value

  mov r0,r0,asl #16

  adds r1,r0,r2,lsl #7
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  mov r1,r1,lsr #16
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5e60] addq.w #7, -(a0) uses Op5e60 ----------
Op5e60:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler

  and r2,r8,#0x0e00 ;@ Get quick value

  mov r0,r0,asl #16

  adds r1,r0,r2,lsl #7
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r1,r1,lsr #16
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5e68] addq.w #7, ($3333,a0) uses Op5e68 ----------
Op5e68:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler

  and r2,r8,#0x0e00 ;@ Get quick value

  mov r0,r0,asl #16

  adds r1,r0,r2,lsl #7
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  mov r1,r1,lsr #16
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5e70] addq.w #7, ($33,a0,d3.w*2) uses Op5e70 ----------
Op5e70:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler

  and r2,r8,#0x0e00 ;@ Get quick value

  mov r0,r0,asl #16

  adds r1,r0,r2,lsl #7
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  mov r1,r1,lsr #16
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5e78] addq.w #7, $3333.w uses Op5e78 ----------
Op5e78:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler

  and r2,r8,#0x0e00 ;@ Get quick value

  mov r0,r0,asl #16

  adds r1,r0,r2,lsl #7
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  mov r1,r1,lsr #16
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5e79] addq.w #7, $33333333.l uses Op5e79 ----------
Op5e79:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler

  and r2,r8,#0x0e00 ;@ Get quick value

  mov r0,r0,asl #16

  adds r1,r0,r2,lsl #7
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  mov r1,r1,lsr #16
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5e80] addq.l #7, d0 uses Op5e80 ----------
Op5e80:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

  and r2,r8,#0x0e00 ;@ Get quick value

  adds r1,r0,r2,lsr #9
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5e88] addq.l #7, a0 uses Op5e88 ----------
Op5e88:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

  and r2,r8,#0x0e00 ;@ Get quick value

  adds r1,r0,r2,lsr #9

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5e90] addq.l #7, (a0) uses Op5e90 ----------
Op5e90:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read32 ;@ Call read32(r0) handler

  and r2,r8,#0x0e00 ;@ Get quick value

  adds r1,r0,r2,lsr #9
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  mov r0,r11
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5e98] addq.l #7, (a0)+ uses Op5e98 ----------
Op5e98:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read32 ;@ Call read32(r0) handler

  and r2,r8,#0x0e00 ;@ Get quick value

  adds r1,r0,r2,lsr #9
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  mov r0,r11
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5ea0] addq.l #7, -(a0) uses Op5ea0 ----------
Op5ea0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#4 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read32 ;@ Call read32(r0) handler

  and r2,r8,#0x0e00 ;@ Get quick value

  adds r1,r0,r2,lsr #9
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r0,r11
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5ea8] addq.l #7, ($3333,a0) uses Op5ea8 ----------
Op5ea8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read32 ;@ Call read32(r0) handler

  and r2,r8,#0x0e00 ;@ Get quick value

  adds r1,r0,r2,lsr #9
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  mov r0,r11
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5eb0] addq.l #7, ($33,a0,d3.w*2) uses Op5eb0 ----------
Op5eb0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read32 ;@ Call read32(r0) handler

  and r2,r8,#0x0e00 ;@ Get quick value

  adds r1,r0,r2,lsr #9
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  mov r0,r11
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5eb8] addq.l #7, $3333.w uses Op5eb8 ----------
Op5eb8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read32 ;@ Call read32(r0) handler

  and r2,r8,#0x0e00 ;@ Get quick value

  adds r1,r0,r2,lsr #9
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  mov r0,r11
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5eb9] addq.l #7, $33333333.l uses Op5eb9 ----------
Op5eb9:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read32 ;@ Call read32(r0) handler

  and r2,r8,#0x0e00 ;@ Get quick value

  adds r1,r0,r2,lsr #9
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  mov r0,r11
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5ec0] sgt d0 uses Op5ec0 ----------
Op5ec0:
  mov r1,#0
  eor r0,r10,r10,lsl #3 ;@ gt: !Z && N == V
  orrs r0,r10,lsl #1
  mvnpl r1,#0
  subpl r5,r5,#2 ;@ Extra cycles

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaWrite: r1 into register[r0]:
  strb r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5ec8] dbgt d0, 3335 uses Op5ec8 ----------
Op5ec8:
;@ Is the condition true?
  eor r0,r10,r10,lsl #3 ;@ gt: !Z && N == V
  orrs r0,r10,lsl #1
;@ If so, don't dbra
  bpl DbraTrue

;@ Decrement Dn.w
  and r1,r8,#0x0007
  mov r1,r1,lsl #2
  ldrsh r0,[r7,r1]
  strb r8,[r7,#0x45] ;@ not polling
  sub r0,r0,#1
  strh r0,[r7,r1]

;@ Check if Dn.w is -1
  cmn r0,#1
  beq DbraMin1

;@ Get Branch offset:
  ldrsh r0,[r4]
  add r0,r4,r0 ;@ r0 = New PC
  bl cyclone_checkpc ;@ Call checkpc()
  mov r4,r0
  tst r4,#1 ;@ address error?
  bne ExceptionAddressError_r_prg_r4
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5ed0] sgt (a0) uses Op5ed0 ----------
Op5ed0:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  eor r0,r10,r10,lsl #3 ;@ gt: !Z && N == V
  orrs r0,r10,lsl #1
  mvnpl r1,#0

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5ed8] sgt (a0)+ uses Op5ed8 ----------
Op5ed8:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  eor r0,r10,r10,lsl #3 ;@ gt: !Z && N == V
  orrs r0,r10,lsl #1
  mvnpl r1,#0

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5edf] sgt (a7)+ uses Op5edf ----------
Op5edf:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  eor r0,r10,r10,lsl #3 ;@ gt: !Z && N == V
  orrs r0,r10,lsl #1
  mvnpl r1,#0

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5ee0] sgt -(a0) uses Op5ee0 ----------
Op5ee0:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  eor r0,r10,r10,lsl #3 ;@ gt: !Z && N == V
  orrs r0,r10,lsl #1
  mvnpl r1,#0

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5ee7] sgt -(a7) uses Op5ee7 ----------
Op5ee7:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  eor r0,r10,r10,lsl #3 ;@ gt: !Z && N == V
  orrs r0,r10,lsl #1
  mvnpl r1,#0

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5ee8] sgt ($3333,a0) uses Op5ee8 ----------
Op5ee8:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  eor r0,r10,r10,lsl #3 ;@ gt: !Z && N == V
  orrs r0,r10,lsl #1
  mvnpl r1,#0

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5ef0] sgt ($33,a0,d3.w*2) uses Op5ef0 ----------
Op5ef0:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  eor r0,r10,r10,lsl #3 ;@ gt: !Z && N == V
  orrs r0,r10,lsl #1
  mvnpl r1,#0

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5ef8] sgt $3333.w uses Op5ef8 ----------
Op5ef8:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  eor r0,r10,r10,lsl #3 ;@ gt: !Z && N == V
  orrs r0,r10,lsl #1
  mvnpl r1,#0

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5ef9] sgt $33333333.l uses Op5ef9 ----------
Op5ef9:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  eor r0,r10,r10,lsl #3 ;@ gt: !Z && N == V
  orrs r0,r10,lsl #1
  mvnpl r1,#0

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5f00] subq.b #7, d0 uses Op5f00 ----------
Op5f00:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

  and r2,r8,#0x0e00 ;@ Get quick value

  mov r0,r0,asl #24

  subs r1,r0,r2,lsl #15
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: r1 into register[r11]:
  mov r1,r1,lsr #24
  strb r1,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5f10] subq.b #7, (a0) uses Op5f10 ----------
Op5f10:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

  and r2,r8,#0x0e00 ;@ Get quick value

  mov r0,r0,asl #24

  subs r1,r0,r2,lsl #15
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  mov r1,r1,lsr #24
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5f18] subq.b #7, (a0)+ uses Op5f18 ----------
Op5f18:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

  and r2,r8,#0x0e00 ;@ Get quick value

  mov r0,r0,asl #24

  subs r1,r0,r2,lsl #15
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  mov r1,r1,lsr #24
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5f1f] subq.b #7, (a7)+ uses Op5f1f ----------
Op5f1f:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a7)+' into r11:
  ldr r11,[r7,#0x3c] ;@ A7
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

  and r2,r8,#0x0e00 ;@ Get quick value

  mov r0,r0,asl #24

  subs r1,r0,r2,lsl #15
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '(a7)+' (address in r11):
  mov r1,r1,lsr #24
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5f20] subq.b #7, -(a0) uses Op5f20 ----------
Op5f20:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#1 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

  and r2,r8,#0x0e00 ;@ Get quick value

  mov r0,r0,asl #24

  subs r1,r0,r2,lsl #15
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r1,r1,lsr #24
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5f27] subq.b #7, -(a7) uses Op5f27 ----------
Op5f27:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a7)' into r11:
  ldr r11,[r7,#0x3c] ;@ A7
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

  and r2,r8,#0x0e00 ;@ Get quick value

  mov r0,r0,asl #24

  subs r1,r0,r2,lsl #15
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '-(a7)' (address in r11):
  mov r1,r1,lsr #24
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5f28] subq.b #7, ($3333,a0) uses Op5f28 ----------
Op5f28:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

  and r2,r8,#0x0e00 ;@ Get quick value

  mov r0,r0,asl #24

  subs r1,r0,r2,lsl #15
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  mov r1,r1,lsr #24
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5f30] subq.b #7, ($33,a0,d3.w*2) uses Op5f30 ----------
Op5f30:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

  and r2,r8,#0x0e00 ;@ Get quick value

  mov r0,r0,asl #24

  subs r1,r0,r2,lsl #15
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  mov r1,r1,lsr #24
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5f38] subq.b #7, $3333.w uses Op5f38 ----------
Op5f38:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

  and r2,r8,#0x0e00 ;@ Get quick value

  mov r0,r0,asl #24

  subs r1,r0,r2,lsl #15
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  mov r1,r1,lsr #24
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5f39] subq.b #7, $33333333.l uses Op5f39 ----------
Op5f39:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

  and r2,r8,#0x0e00 ;@ Get quick value

  mov r0,r0,asl #24

  subs r1,r0,r2,lsl #15
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  mov r1,r1,lsr #24
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5f40] subq.w #7, d0 uses Op5f40 ----------
Op5f40:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
  mov r11,r11,lsl #2
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11]

  and r2,r8,#0x0e00 ;@ Get quick value

  mov r0,r0,asl #16

  subs r1,r0,r2,lsl #7
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: r1 into register[r11]:
  mov r1,r1,lsr #16
  strh r1,[r7,r11]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5f48] subq.w #7, a0 uses Op5f48 ----------
Op5f48:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

  and r2,r8,#0x0e00 ;@ Get quick value

  subs r1,r0,r2,lsr #9

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5f50] subq.w #7, (a0) uses Op5f50 ----------
Op5f50:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler

  and r2,r8,#0x0e00 ;@ Get quick value

  mov r0,r0,asl #16

  subs r1,r0,r2,lsl #7
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  mov r1,r1,lsr #16
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5f58] subq.w #7, (a0)+ uses Op5f58 ----------
Op5f58:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler

  and r2,r8,#0x0e00 ;@ Get quick value

  mov r0,r0,asl #16

  subs r1,r0,r2,lsl #7
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  mov r1,r1,lsr #16
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5f60] subq.w #7, -(a0) uses Op5f60 ----------
Op5f60:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler

  and r2,r8,#0x0e00 ;@ Get quick value

  mov r0,r0,asl #16

  subs r1,r0,r2,lsl #7
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r1,r1,lsr #16
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5f68] subq.w #7, ($3333,a0) uses Op5f68 ----------
Op5f68:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler

  and r2,r8,#0x0e00 ;@ Get quick value

  mov r0,r0,asl #16

  subs r1,r0,r2,lsl #7
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  mov r1,r1,lsr #16
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5f70] subq.w #7, ($33,a0,d3.w*2) uses Op5f70 ----------
Op5f70:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler

  and r2,r8,#0x0e00 ;@ Get quick value

  mov r0,r0,asl #16

  subs r1,r0,r2,lsl #7
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  mov r1,r1,lsr #16
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5f78] subq.w #7, $3333.w uses Op5f78 ----------
Op5f78:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler

  and r2,r8,#0x0e00 ;@ Get quick value

  mov r0,r0,asl #16

  subs r1,r0,r2,lsl #7
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  mov r1,r1,lsr #16
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5f79] subq.w #7, $33333333.l uses Op5f79 ----------
Op5f79:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler

  and r2,r8,#0x0e00 ;@ Get quick value

  mov r0,r0,asl #16

  subs r1,r0,r2,lsl #7
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  mov r1,r1,lsr #16
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5f80] subq.l #7, d0 uses Op5f80 ----------
Op5f80:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

  and r2,r8,#0x0e00 ;@ Get quick value

  subs r1,r0,r2,lsr #9
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5f88] subq.l #7, a0 uses Op5f88 ----------
Op5f88:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

  and r2,r8,#0x0e00 ;@ Get quick value

  subs r1,r0,r2,lsr #9

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5f90] subq.l #7, (a0) uses Op5f90 ----------
Op5f90:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read32 ;@ Call read32(r0) handler

  and r2,r8,#0x0e00 ;@ Get quick value

  subs r1,r0,r2,lsr #9
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  mov r0,r11
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5f98] subq.l #7, (a0)+ uses Op5f98 ----------
Op5f98:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read32 ;@ Call read32(r0) handler

  and r2,r8,#0x0e00 ;@ Get quick value

  subs r1,r0,r2,lsr #9
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  mov r0,r11
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5fa0] subq.l #7, -(a0) uses Op5fa0 ----------
Op5fa0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#4 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read32 ;@ Call read32(r0) handler

  and r2,r8,#0x0e00 ;@ Get quick value

  subs r1,r0,r2,lsr #9
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r0,r11
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5fa8] subq.l #7, ($3333,a0) uses Op5fa8 ----------
Op5fa8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read32 ;@ Call read32(r0) handler

  and r2,r8,#0x0e00 ;@ Get quick value

  subs r1,r0,r2,lsr #9
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  mov r0,r11
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5fb0] subq.l #7, ($33,a0,d3.w*2) uses Op5fb0 ----------
Op5fb0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read32 ;@ Call read32(r0) handler

  and r2,r8,#0x0e00 ;@ Get quick value

  subs r1,r0,r2,lsr #9
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  mov r0,r11
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5fb8] subq.l #7, $3333.w uses Op5fb8 ----------
Op5fb8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read32 ;@ Call read32(r0) handler

  and r2,r8,#0x0e00 ;@ Get quick value

  subs r1,r0,r2,lsr #9
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  mov r0,r11
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5fb9] subq.l #7, $33333333.l uses Op5fb9 ----------
Op5fb9:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read32 ;@ Call read32(r0) handler

  and r2,r8,#0x0e00 ;@ Get quick value

  subs r1,r0,r2,lsr #9
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  mov r0,r11
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5fc0] sle d0 uses Op5fc0 ----------
Op5fc0:
  mov r1,#0
  eor r0,r10,r10,lsl #3 ;@ le: Z || N != V
  orrs r0,r10,lsl #1
  mvnmi r1,#0
  submi r5,r5,#2 ;@ Extra cycles

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaWrite: r1 into register[r0]:
  strb r1,[r7,r0,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5fc8] dble d0, 3335 uses Op5fc8 ----------
Op5fc8:
;@ Is the condition true?
  eor r0,r10,r10,lsl #3 ;@ le: Z || N != V
  orrs r0,r10,lsl #1
;@ If so, don't dbra
  bmi DbraTrue

;@ Decrement Dn.w
  and r1,r8,#0x0007
  mov r1,r1,lsl #2
  ldrsh r0,[r7,r1]
  strb r8,[r7,#0x45] ;@ not polling
  sub r0,r0,#1
  strh r0,[r7,r1]

;@ Check if Dn.w is -1
  cmn r0,#1
  beq DbraMin1

;@ Get Branch offset:
  ldrsh r0,[r4]
  add r0,r4,r0 ;@ r0 = New PC
  bl cyclone_checkpc ;@ Call checkpc()
  mov r4,r0
  tst r4,#1 ;@ address error?
  bne ExceptionAddressError_r_prg_r4
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5fd0] sle (a0) uses Op5fd0 ----------
Op5fd0:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  eor r0,r10,r10,lsl #3 ;@ le: Z || N != V
  orrs r0,r10,lsl #1
  mvnmi r1,#0

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5fd8] sle (a0)+ uses Op5fd8 ----------
Op5fd8:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  eor r0,r10,r10,lsl #3 ;@ le: Z || N != V
  orrs r0,r10,lsl #1
  mvnmi r1,#0

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5fdf] sle (a7)+ uses Op5fdf ----------
Op5fdf:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  eor r0,r10,r10,lsl #3 ;@ le: Z || N != V
  orrs r0,r10,lsl #1
  mvnmi r1,#0

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5fe0] sle -(a0) uses Op5fe0 ----------
Op5fe0:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  eor r0,r10,r10,lsl #3 ;@ le: Z || N != V
  orrs r0,r10,lsl #1
  mvnmi r1,#0

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5fe7] sle -(a7) uses Op5fe7 ----------
Op5fe7:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  eor r0,r10,r10,lsl #3 ;@ le: Z || N != V
  orrs r0,r10,lsl #1
  mvnmi r1,#0

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5fe8] sle ($3333,a0) uses Op5fe8 ----------
Op5fe8:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  eor r0,r10,r10,lsl #3 ;@ le: Z || N != V
  orrs r0,r10,lsl #1
  mvnmi r1,#0

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5ff0] sle ($33,a0,d3.w*2) uses Op5ff0 ----------
Op5ff0:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  eor r0,r10,r10,lsl #3 ;@ le: Z || N != V
  orrs r0,r10,lsl #1
  mvnmi r1,#0

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5ff8] sle $3333.w uses Op5ff8 ----------
Op5ff8:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  eor r0,r10,r10,lsl #3 ;@ le: Z || N != V
  orrs r0,r10,lsl #1
  mvnmi r1,#0

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [5ff9] sle $33333333.l uses Op5ff9 ----------
Op5ff9:
  str r5,[r7,#0x5c] ;@ Save Cycles

  mov r1,#0
  eor r0,r10,r10,lsl #3 ;@ le: Z || N != V
  orrs r0,r10,lsl #1
  mvnmi r1,#0

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  and r1,r1,#0xff
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6000] bra 3335 uses Op6000 ----------
Op6000:
  str r5,[r7,#0x5c] ;@ Save Cycles

  ldrsh r11,[r4] ;@ Fetch Branch offset
;@ Branch taken - Add on r0 to PC
  add r0,r4,r11 ;@ New PC
  bl cyclone_checkpc ;@ Call checkpc()
  mov r4,r0
  tst r4,#1 ;@ address error?
  bne ExceptionAddressError_r_prg_r4

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6003] bra 5 uses Op6003 ----------
Op6003:
  mov r11,r8,asl #24 ;@ Shift 8-bit signed offset up...

;@ Branch taken - Add on r0 to PC
  add r4,r4,r11,asr #24 ;@ r4 = New PC
  b ExceptionAddressError_r_prg_r4

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6103] bsr 5 uses Op6103 ----------
Op6103:
  mov r11,r8,asl #24 ;@ Shift 8-bit signed offset up...

;@ Branch taken - Add on r0 to PC
;@ Bsr - remember old PC
  ldr r12,[r7,#0x60] ;@ Get Memory base
  ldr r2,[r7,#0x3c]
  sub r1,r4,r12 ;@ r1 = Old PC

;@ Push r1 onto stack
  sub r0,r2,#4 ;@ Predecrement A7
  str r0,[r7,#0x3c] ;@ Save A7
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  add r4,r4,r11,asr #24 ;@ r4 = New PC
  b ExceptionAddressError_r_prg_r4

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6200] bhi 3335 uses Op6200 ----------
Op6200:
  str r5,[r7,#0x5c] ;@ Save Cycles

  tst r10,#0x60000000 ;@ hi: !C && !Z
  bne BccDontBranch16

  ldrsh r11,[r4] ;@ Fetch Branch offset
;@ Branch taken - Add on r0 to PC
  add r0,r4,r11 ;@ New PC
  bl cyclone_checkpc ;@ Call checkpc()
  mov r4,r0
  tst r4,#1 ;@ address error?
  bne ExceptionAddressError_r_prg_r4

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6202] bhi 4 uses Op6202 ----------
Op6202:
  tst r10,#0x60000000 ;@ hi: !C && !Z
  bne BccDontBranch8

  mov r11,r8,asl #24 ;@ Shift 8-bit signed offset up...

;@ Branch taken - Add on r0 to PC
  add r4,r4,r11,asr #24 ;@ r4 = New PC

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6203] bhi 5 uses Op6203 ----------
Op6203:
  tst r10,#0x60000000 ;@ hi: !C && !Z
  bne BccDontBranch8

  mov r11,r8,asl #24 ;@ Shift 8-bit signed offset up...

;@ Branch taken - Add on r0 to PC
  add r4,r4,r11,asr #24 ;@ r4 = New PC
  b ExceptionAddressError_r_prg_r4

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6300] bls 3335 uses Op6300 ----------
Op6300:
  str r5,[r7,#0x5c] ;@ Save Cycles

  tst r10,#0x60000000 ;@ ls: C || Z
  beq BccDontBranch16

  ldrsh r11,[r4] ;@ Fetch Branch offset
;@ Branch taken - Add on r0 to PC
  add r0,r4,r11 ;@ New PC
  bl cyclone_checkpc ;@ Call checkpc()
  mov r4,r0
  tst r4,#1 ;@ address error?
  bne ExceptionAddressError_r_prg_r4

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6302] bls 4 uses Op6302 ----------
Op6302:
  tst r10,#0x60000000 ;@ ls: C || Z
  beq BccDontBranch8

  mov r11,r8,asl #24 ;@ Shift 8-bit signed offset up...

;@ Branch taken - Add on r0 to PC
  add r4,r4,r11,asr #24 ;@ r4 = New PC

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6303] bls 5 uses Op6303 ----------
Op6303:
  tst r10,#0x60000000 ;@ ls: C || Z
  beq BccDontBranch8

  mov r11,r8,asl #24 ;@ Shift 8-bit signed offset up...

;@ Branch taken - Add on r0 to PC
  add r4,r4,r11,asr #24 ;@ r4 = New PC
  b ExceptionAddressError_r_prg_r4

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6400] bcc 3335 uses Op6400 ----------
Op6400:
  str r5,[r7,#0x5c] ;@ Save Cycles

  tst r10,#0x20000000 ;@ cc: !C
  bne BccDontBranch16

  ldrsh r11,[r4] ;@ Fetch Branch offset
;@ Branch taken - Add on r0 to PC
  add r0,r4,r11 ;@ New PC
  bl cyclone_checkpc ;@ Call checkpc()
  mov r4,r0
  tst r4,#1 ;@ address error?
  bne ExceptionAddressError_r_prg_r4

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6403] bcc 5 uses Op6403 ----------
Op6403:
  tst r10,#0x20000000 ;@ cc: !C
  bne BccDontBranch8

  mov r11,r8,asl #24 ;@ Shift 8-bit signed offset up...

;@ Branch taken - Add on r0 to PC
  add r4,r4,r11,asr #24 ;@ r4 = New PC
  b ExceptionAddressError_r_prg_r4

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6503] bcs 5 uses Op6503 ----------
Op6503:
  tst r10,#0x20000000 ;@ cs: C
  beq BccDontBranch8

  mov r11,r8,asl #24 ;@ Shift 8-bit signed offset up...

;@ Branch taken - Add on r0 to PC
  add r4,r4,r11,asr #24 ;@ r4 = New PC
  b ExceptionAddressError_r_prg_r4

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6600] bne 3335 uses Op6600 ----------
Op6600:
  str r5,[r7,#0x5c] ;@ Save Cycles

  tst r10,#0x40000000 ;@ ne: !Z
  bne BccDontBranch16

  ldrsh r11,[r4] ;@ Fetch Branch offset
;@ Branch taken - Add on r0 to PC
  add r0,r4,r11 ;@ New PC
  bl cyclone_checkpc ;@ Call checkpc()
  mov r4,r0
  tst r4,#1 ;@ address error?
  bne ExceptionAddressError_r_prg_r4

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6603] bne 5 uses Op6603 ----------
Op6603:
  tst r10,#0x40000000 ;@ ne: !Z
  bne BccDontBranch8

  mov r11,r8,asl #24 ;@ Shift 8-bit signed offset up...

;@ Branch taken - Add on r0 to PC
  add r4,r4,r11,asr #24 ;@ r4 = New PC
  b ExceptionAddressError_r_prg_r4

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6703] beq 5 uses Op6703 ----------
Op6703:
  tst r10,#0x40000000 ;@ eq: Z
  beq BccDontBranch8

  mov r11,r8,asl #24 ;@ Shift 8-bit signed offset up...

;@ Branch taken - Add on r0 to PC
  add r4,r4,r11,asr #24 ;@ r4 = New PC
  b ExceptionAddressError_r_prg_r4

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6800] bvc 3335 uses Op6800 ----------
Op6800:
  str r5,[r7,#0x5c] ;@ Save Cycles

  tst r10,#0x10000000 ;@ vc: !V
  bne BccDontBranch16

  ldrsh r11,[r4] ;@ Fetch Branch offset
;@ Branch taken - Add on r0 to PC
  add r0,r4,r11 ;@ New PC
  bl cyclone_checkpc ;@ Call checkpc()
  mov r4,r0
  tst r4,#1 ;@ address error?
  bne ExceptionAddressError_r_prg_r4

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6802] bvc 4 uses Op6802 ----------
Op6802:
  tst r10,#0x10000000 ;@ vc: !V
  bne BccDontBranch8

  mov r11,r8,asl #24 ;@ Shift 8-bit signed offset up...

;@ Branch taken - Add on r0 to PC
  add r4,r4,r11,asr #24 ;@ r4 = New PC

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6803] bvc 5 uses Op6803 ----------
Op6803:
  tst r10,#0x10000000 ;@ vc: !V
  bne BccDontBranch8

  mov r11,r8,asl #24 ;@ Shift 8-bit signed offset up...

;@ Branch taken - Add on r0 to PC
  add r4,r4,r11,asr #24 ;@ r4 = New PC
  b ExceptionAddressError_r_prg_r4

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6900] bvs 3335 uses Op6900 ----------
Op6900:
  str r5,[r7,#0x5c] ;@ Save Cycles

  tst r10,#0x10000000 ;@ vs: V
  beq BccDontBranch16

  ldrsh r11,[r4] ;@ Fetch Branch offset
;@ Branch taken - Add on r0 to PC
  add r0,r4,r11 ;@ New PC
  bl cyclone_checkpc ;@ Call checkpc()
  mov r4,r0
  tst r4,#1 ;@ address error?
  bne ExceptionAddressError_r_prg_r4

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6902] bvs 4 uses Op6902 ----------
Op6902:
  tst r10,#0x10000000 ;@ vs: V
  beq BccDontBranch8

  mov r11,r8,asl #24 ;@ Shift 8-bit signed offset up...

;@ Branch taken - Add on r0 to PC
  add r4,r4,r11,asr #24 ;@ r4 = New PC

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6903] bvs 5 uses Op6903 ----------
Op6903:
  tst r10,#0x10000000 ;@ vs: V
  beq BccDontBranch8

  mov r11,r8,asl #24 ;@ Shift 8-bit signed offset up...

;@ Branch taken - Add on r0 to PC
  add r4,r4,r11,asr #24 ;@ r4 = New PC
  b ExceptionAddressError_r_prg_r4

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6a00] bpl 3335 uses Op6a00 ----------
Op6a00:
  str r5,[r7,#0x5c] ;@ Save Cycles

  tst r10,r10 ;@ pl: !N
  bmi BccDontBranch16

  ldrsh r11,[r4] ;@ Fetch Branch offset
;@ Branch taken - Add on r0 to PC
  add r0,r4,r11 ;@ New PC
  bl cyclone_checkpc ;@ Call checkpc()
  mov r4,r0
  tst r4,#1 ;@ address error?
  bne ExceptionAddressError_r_prg_r4

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6a03] bpl 5 uses Op6a03 ----------
Op6a03:
  tst r10,r10 ;@ pl: !N
  bmi BccDontBranch8

  mov r11,r8,asl #24 ;@ Shift 8-bit signed offset up...

;@ Branch taken - Add on r0 to PC
  add r4,r4,r11,asr #24 ;@ r4 = New PC
  b ExceptionAddressError_r_prg_r4

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6b00] bmi 3335 uses Op6b00 ----------
Op6b00:
  str r5,[r7,#0x5c] ;@ Save Cycles

  tst r10,r10 ;@ mi: N
  bpl BccDontBranch16

  ldrsh r11,[r4] ;@ Fetch Branch offset
;@ Branch taken - Add on r0 to PC
  add r0,r4,r11 ;@ New PC
  bl cyclone_checkpc ;@ Call checkpc()
  mov r4,r0
  tst r4,#1 ;@ address error?
  bne ExceptionAddressError_r_prg_r4

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6b02] bmi 4 uses Op6b02 ----------
Op6b02:
  tst r10,r10 ;@ mi: N
  bpl BccDontBranch8

  mov r11,r8,asl #24 ;@ Shift 8-bit signed offset up...

;@ Branch taken - Add on r0 to PC
  add r4,r4,r11,asr #24 ;@ r4 = New PC

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6b03] bmi 5 uses Op6b03 ----------
Op6b03:
  tst r10,r10 ;@ mi: N
  bpl BccDontBranch8

  mov r11,r8,asl #24 ;@ Shift 8-bit signed offset up...

;@ Branch taken - Add on r0 to PC
  add r4,r4,r11,asr #24 ;@ r4 = New PC
  b ExceptionAddressError_r_prg_r4

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6c00] bge 3335 uses Op6c00 ----------
Op6c00:
  str r5,[r7,#0x5c] ;@ Save Cycles

  teq r10,r10,lsl #3 ;@ ge: N == V
  bmi BccDontBranch16

  ldrsh r11,[r4] ;@ Fetch Branch offset
;@ Branch taken - Add on r0 to PC
  add r0,r4,r11 ;@ New PC
  bl cyclone_checkpc ;@ Call checkpc()
  mov r4,r0
  tst r4,#1 ;@ address error?
  bne ExceptionAddressError_r_prg_r4

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6c02] bge 4 uses Op6c02 ----------
Op6c02:
  teq r10,r10,lsl #3 ;@ ge: N == V
  bmi BccDontBranch8

  mov r11,r8,asl #24 ;@ Shift 8-bit signed offset up...

;@ Branch taken - Add on r0 to PC
  add r4,r4,r11,asr #24 ;@ r4 = New PC

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6c03] bge 5 uses Op6c03 ----------
Op6c03:
  teq r10,r10,lsl #3 ;@ ge: N == V
  bmi BccDontBranch8

  mov r11,r8,asl #24 ;@ Shift 8-bit signed offset up...

;@ Branch taken - Add on r0 to PC
  add r4,r4,r11,asr #24 ;@ r4 = New PC
  b ExceptionAddressError_r_prg_r4

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6d00] blt 3335 uses Op6d00 ----------
Op6d00:
  str r5,[r7,#0x5c] ;@ Save Cycles

  teq r10,r10,lsl #3 ;@ lt: N != V
  bpl BccDontBranch16

  ldrsh r11,[r4] ;@ Fetch Branch offset
;@ Branch taken - Add on r0 to PC
  add r0,r4,r11 ;@ New PC
  bl cyclone_checkpc ;@ Call checkpc()
  mov r4,r0
  tst r4,#1 ;@ address error?
  bne ExceptionAddressError_r_prg_r4

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6d02] blt 4 uses Op6d02 ----------
Op6d02:
  teq r10,r10,lsl #3 ;@ lt: N != V
  bpl BccDontBranch8

  mov r11,r8,asl #24 ;@ Shift 8-bit signed offset up...

;@ Branch taken - Add on r0 to PC
  add r4,r4,r11,asr #24 ;@ r4 = New PC

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6d03] blt 5 uses Op6d03 ----------
Op6d03:
  teq r10,r10,lsl #3 ;@ lt: N != V
  bpl BccDontBranch8

  mov r11,r8,asl #24 ;@ Shift 8-bit signed offset up...

;@ Branch taken - Add on r0 to PC
  add r4,r4,r11,asr #24 ;@ r4 = New PC
  b ExceptionAddressError_r_prg_r4

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6e00] bgt 3335 uses Op6e00 ----------
Op6e00:
  str r5,[r7,#0x5c] ;@ Save Cycles

  eor r0,r10,r10,lsl #3 ;@ gt: !Z && N == V
  orrs r0,r10,lsl #1
  bmi BccDontBranch16

  ldrsh r11,[r4] ;@ Fetch Branch offset
;@ Branch taken - Add on r0 to PC
  add r0,r4,r11 ;@ New PC
  bl cyclone_checkpc ;@ Call checkpc()
  mov r4,r0
  tst r4,#1 ;@ address error?
  bne ExceptionAddressError_r_prg_r4

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6e02] bgt 4 uses Op6e02 ----------
Op6e02:
  eor r0,r10,r10,lsl #3 ;@ gt: !Z && N == V
  orrs r0,r10,lsl #1
  bmi BccDontBranch8

  mov r11,r8,asl #24 ;@ Shift 8-bit signed offset up...

;@ Branch taken - Add on r0 to PC
  add r4,r4,r11,asr #24 ;@ r4 = New PC

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6e03] bgt 5 uses Op6e03 ----------
Op6e03:
  eor r0,r10,r10,lsl #3 ;@ gt: !Z && N == V
  orrs r0,r10,lsl #1
  bmi BccDontBranch8

  mov r11,r8,asl #24 ;@ Shift 8-bit signed offset up...

;@ Branch taken - Add on r0 to PC
  add r4,r4,r11,asr #24 ;@ r4 = New PC
  b ExceptionAddressError_r_prg_r4

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6f00] ble 3335 uses Op6f00 ----------
Op6f00:
  str r5,[r7,#0x5c] ;@ Save Cycles

  eor r0,r10,r10,lsl #3 ;@ le: Z || N != V
  orrs r0,r10,lsl #1
  bpl BccDontBranch16

  ldrsh r11,[r4] ;@ Fetch Branch offset
;@ Branch taken - Add on r0 to PC
  add r0,r4,r11 ;@ New PC
  bl cyclone_checkpc ;@ Call checkpc()
  mov r4,r0
  tst r4,#1 ;@ address error?
  bne ExceptionAddressError_r_prg_r4

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6f02] ble 4 uses Op6f02 ----------
Op6f02:
  eor r0,r10,r10,lsl #3 ;@ le: Z || N != V
  orrs r0,r10,lsl #1
  bpl BccDontBranch8

  mov r11,r8,asl #24 ;@ Shift 8-bit signed offset up...

;@ Branch taken - Add on r0 to PC
  add r4,r4,r11,asr #24 ;@ r4 = New PC

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [6f03] ble 5 uses Op6f03 ----------
Op6f03:
  eor r0,r10,r10,lsl #3 ;@ le: Z || N != V
  orrs r0,r10,lsl #1
  bpl BccDontBranch8

  mov r11,r8,asl #24 ;@ Shift 8-bit signed offset up...

;@ Branch taken - Add on r0 to PC
  add r4,r4,r11,asr #24 ;@ r4 = New PC
  b ExceptionAddressError_r_prg_r4

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8000] or.b d0, d0 uses Op8000 ----------
Op8000:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r0:
  ldr r0,[r7,r0,lsl #2]

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  orrs r1,r0,r1,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r11]:
  strb r1,[r7,r11,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8010] or.b (a0), d0 uses Op8010 ----------
Op8010:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  bl cyclone_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  orrs r1,r0,r1,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r11]:
  strb r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8018] or.b (a0)+, d0 uses Op8018 ----------
Op8018:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  bl cyclone_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  orrs r1,r0,r1,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r11]:
  strb r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [801f] or.b (a7)+, d0 uses Op801f ----------
Op801f:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r0) into r0:
  bl cyclone_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  orrs r1,r0,r1,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r11]:
  strb r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8020] or.b -(a0), d0 uses Op8020 ----------
Op8020:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  bl cyclone_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  orrs r1,r0,r1,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r11]:
  strb r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8027] or.b -(a7), d0 uses Op8027 ----------
Op8027:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r0) into r0:
  bl cyclone_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  orrs r1,r0,r1,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r11]:
  strb r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8028] or.b ($3333,a0), d0 uses Op8028 ----------
Op8028:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  bl cyclone_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  orrs r1,r0,r1,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r11]:
  strb r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8030] or.b ($33,a0,d3.w*2), d0 uses Op8030 ----------
Op8030:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  bl cyclone_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  orrs r1,r0,r1,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r11]:
  strb r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8038] or.b $3333.w, d0 uses Op8038 ----------
Op8038:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  bl cyclone_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  orrs r1,r0,r1,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r11]:
  strb r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8039] or.b $33333333.l, d0 uses Op8039 ----------
Op8039:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  bl cyclone_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  orrs r1,r0,r1,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r11]:
  strb r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [803a] or.b ($3333,pc), d0; =3335 uses Op803a ----------
Op803a:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r2,r0 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r0:
  bl cyclone_fetch8 ;@ Call fetch8(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  orrs r1,r0,r1,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r11]:
  strb r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [803b] or.b ($33,pc,d3.w*2), d0; =35 uses Op803b ----------
Op803b:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r0:
  bl cyclone_fetch8 ;@ Call fetch8(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  orrs r1,r0,r1,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r11]:
  strb r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [803c] or.b #$33, d0 uses Op803c ----------
Op803c:
;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  orrs r1,r0,r1,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r11]:
  strb r1,[r7,r11,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8040] or.w d0, d0 uses Op8040 ----------
Op8040:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r0:
  ldr r0,[r7,r0,lsl #2]

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
  mov r11,r11,lsr #7
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11]

;@ Do arithmetic:
  mov r0,r0,asl #16
  orrs r1,r0,r1,asl #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: r1 into register[r11]:
  strh r1,[r7,r11]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8050] or.w (a0), d0 uses Op8050 ----------
Op8050:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
  mov r11,r11,lsr #7
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11]

;@ Do arithmetic:
  mov r0,r0,asl #16
  orrs r1,r0,r1,asl #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: r1 into register[r11]:
  strh r1,[r7,r11]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8058] or.w (a0)+, d0 uses Op8058 ----------
Op8058:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
  mov r11,r11,lsr #7
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11]

;@ Do arithmetic:
  mov r0,r0,asl #16
  orrs r1,r0,r1,asl #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: r1 into register[r11]:
  strh r1,[r7,r11]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8060] or.w -(a0), d0 uses Op8060 ----------
Op8060:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
  mov r11,r11,lsr #7
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11]

;@ Do arithmetic:
  mov r0,r0,asl #16
  orrs r1,r0,r1,asl #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: r1 into register[r11]:
  strh r1,[r7,r11]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8068] or.w ($3333,a0), d0 uses Op8068 ----------
Op8068:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
  mov r11,r11,lsr #7
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11]

;@ Do arithmetic:
  mov r0,r0,asl #16
  orrs r1,r0,r1,asl #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: r1 into register[r11]:
  strh r1,[r7,r11]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8070] or.w ($33,a0,d3.w*2), d0 uses Op8070 ----------
Op8070:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
  mov r11,r11,lsr #7
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11]

;@ Do arithmetic:
  mov r0,r0,asl #16
  orrs r1,r0,r1,asl #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: r1 into register[r11]:
  strh r1,[r7,r11]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8078] or.w $3333.w, d0 uses Op8078 ----------
Op8078:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
  mov r11,r11,lsr #7
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11]

;@ Do arithmetic:
  mov r0,r0,asl #16
  orrs r1,r0,r1,asl #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: r1 into register[r11]:
  strh r1,[r7,r11]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8079] or.w $33333333.l, d0 uses Op8079 ----------
Op8079:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
  mov r11,r11,lsr #7
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11]

;@ Do arithmetic:
  mov r0,r0,asl #16
  orrs r1,r0,r1,asl #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: r1 into register[r11]:
  strh r1,[r7,r11]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [807a] or.w ($3333,pc), d0; =3335 uses Op807a ----------
Op807a:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r2,r0 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r0:
  bl cyclone_fetch16 ;@ Call fetch16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
  mov r11,r11,lsr #7
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11]

;@ Do arithmetic:
  mov r0,r0,asl #16
  orrs r1,r0,r1,asl #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: r1 into register[r11]:
  strh r1,[r7,r11]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [807b] or.w ($33,pc,d3.w*2), d0; =35 uses Op807b ----------
Op807b:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r0:
  bl cyclone_fetch16 ;@ Call fetch16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
  mov r11,r11,lsr #7
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11]

;@ Do arithmetic:
  mov r0,r0,asl #16
  orrs r1,r0,r1,asl #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: r1 into register[r11]:
  strh r1,[r7,r11]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [807c] or.w #$3333, d0 uses Op807c ----------
Op807c:
;@ EaCalc : Get '#$3333' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r0) into r0:

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
  mov r11,r11,lsr #7
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11]

;@ Do arithmetic:
  mov r0,r0,asl #16
  orrs r1,r0,r1,asl #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: r1 into register[r11]:
  strh r1,[r7,r11]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8080] or.l d0, d0 uses Op8080 ----------
Op8080:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r0:
  ldr r0,[r7,r0,lsl #2]

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  orrs r1,r0,r1
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8090] or.l (a0), d0 uses Op8090 ----------
Op8090:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  orrs r1,r0,r1
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8098] or.l (a0)+, d0 uses Op8098 ----------
Op8098:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  orrs r1,r0,r1
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [80a0] or.l -(a0), d0 uses Op80a0 ----------
Op80a0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  orrs r1,r0,r1
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [80a8] or.l ($3333,a0), d0 uses Op80a8 ----------
Op80a8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  orrs r1,r0,r1
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [80b0] or.l ($33,a0,d3.w*2), d0 uses Op80b0 ----------
Op80b0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  orrs r1,r0,r1
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [80b8] or.l $3333.w, d0 uses Op80b8 ----------
Op80b8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  orrs r1,r0,r1
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [80b9] or.l $33333333.l, d0 uses Op80b9 ----------
Op80b9:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  orrs r1,r0,r1
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [80ba] or.l ($3333,pc), d0; =3335 uses Op80ba ----------
Op80ba:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r2,r0 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r0:
  bl cyclone_fetch32 ;@ Call fetch32(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  orrs r1,r0,r1
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [80bb] or.l ($33,pc,d3.w*2), d0; =35 uses Op80bb ----------
Op80bb:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r0:
  bl cyclone_fetch32 ;@ Call fetch32(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  orrs r1,r0,r1
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [80bc] or.l #$33333333, d0 uses Op80bc ----------
Op80bc:
;@ EaCalc : Get '#$33333333' into r0:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r0,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r0) into r0:

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  orrs r1,r0,r1
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [80c0] divu.w d0, d0 uses Op80c0 ----------
Op80c0:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r0:
  ldr r0,[r7,r0,lsl #2]

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r2:
  ldr r2,[r7,r11,lsr #7]

  movs r1,r0,asl #16
  beq divzero80c0 ;@ division by zero

  mov r0,r1,lsr #16 ;@ use only 16 bits of divisor

;@ Divide r2 by r0
  mov r3,#0
  mov r1,r0

;@ Shift up divisor till it's just less than numerator
Shift80c0:
  cmp r1,r2,lsr #1
  movls r1,r1,lsl #1
  bcc Shift80c0

Divide80c0:
  cmp r2,r1
  adc r3,r3,r3 ;@ Double r3 and add 1 if carry set
  subcs r2,r2,r1
  teq r1,r0
  movne r1,r1,lsr #1
  bne Divide80c0

;@r3==quotient,r2==remainder
  movs r1,r3,lsr #16 ;@ check for overflow condition
  orrne r10,r10,#0x10000000 ;@ set overflow flag
  bne endofop80c0 ;@ overflow!

  movs r1,r3,lsl #16 ;@ Clip to 16-bits
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV
  mov r1,r1,lsr #16
  orr r1,r1,r2,lsl #16 ;@ Insert remainder

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

endofop80c0:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#140 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

divzero80c0:
  mov r0,#5 ;@ Divide by zero
  bl Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#178 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [80d0] divu.w (a0), d0 uses Op80d0 ----------
Op80d0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r2:
  ldr r2,[r7,r11,lsr #7]

  movs r1,r0,asl #16
  beq divzero80d0 ;@ division by zero

  mov r0,r1,lsr #16 ;@ use only 16 bits of divisor

;@ Divide r2 by r0
  mov r3,#0
  mov r1,r0

;@ Shift up divisor till it's just less than numerator
Shift80d0:
  cmp r1,r2,lsr #1
  movls r1,r1,lsl #1
  bcc Shift80d0

Divide80d0:
  cmp r2,r1
  adc r3,r3,r3 ;@ Double r3 and add 1 if carry set
  subcs r2,r2,r1
  teq r1,r0
  movne r1,r1,lsr #1
  bne Divide80d0

;@r3==quotient,r2==remainder
  movs r1,r3,lsr #16 ;@ check for overflow condition
  orrne r10,r10,#0x10000000 ;@ set overflow flag
  bne endofop80d0 ;@ overflow!

  movs r1,r3,lsl #16 ;@ Clip to 16-bits
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV
  mov r1,r1,lsr #16
  orr r1,r1,r2,lsl #16 ;@ Insert remainder

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

endofop80d0:
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#144 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

divzero80d0:
  mov r0,#5 ;@ Divide by zero
  bl Exception
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#182 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [80d8] divu.w (a0)+, d0 uses Op80d8 ----------
Op80d8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r2:
  ldr r2,[r7,r11,lsr #7]

  movs r1,r0,asl #16
  beq divzero80d8 ;@ division by zero

  mov r0,r1,lsr #16 ;@ use only 16 bits of divisor

;@ Divide r2 by r0
  mov r3,#0
  mov r1,r0

;@ Shift up divisor till it's just less than numerator
Shift80d8:
  cmp r1,r2,lsr #1
  movls r1,r1,lsl #1
  bcc Shift80d8

Divide80d8:
  cmp r2,r1
  adc r3,r3,r3 ;@ Double r3 and add 1 if carry set
  subcs r2,r2,r1
  teq r1,r0
  movne r1,r1,lsr #1
  bne Divide80d8

;@r3==quotient,r2==remainder
  movs r1,r3,lsr #16 ;@ check for overflow condition
  orrne r10,r10,#0x10000000 ;@ set overflow flag
  bne endofop80d8 ;@ overflow!

  movs r1,r3,lsl #16 ;@ Clip to 16-bits
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV
  mov r1,r1,lsr #16
  orr r1,r1,r2,lsl #16 ;@ Insert remainder

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

endofop80d8:
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#144 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

divzero80d8:
  mov r0,#5 ;@ Divide by zero
  bl Exception
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#182 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [80e0] divu.w -(a0), d0 uses Op80e0 ----------
Op80e0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r2:
  ldr r2,[r7,r11,lsr #7]

  movs r1,r0,asl #16
  beq divzero80e0 ;@ division by zero

  mov r0,r1,lsr #16 ;@ use only 16 bits of divisor

;@ Divide r2 by r0
  mov r3,#0
  mov r1,r0

;@ Shift up divisor till it's just less than numerator
Shift80e0:
  cmp r1,r2,lsr #1
  movls r1,r1,lsl #1
  bcc Shift80e0

Divide80e0:
  cmp r2,r1
  adc r3,r3,r3 ;@ Double r3 and add 1 if carry set
  subcs r2,r2,r1
  teq r1,r0
  movne r1,r1,lsr #1
  bne Divide80e0

;@r3==quotient,r2==remainder
  movs r1,r3,lsr #16 ;@ check for overflow condition
  orrne r10,r10,#0x10000000 ;@ set overflow flag
  bne endofop80e0 ;@ overflow!

  movs r1,r3,lsl #16 ;@ Clip to 16-bits
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV
  mov r1,r1,lsr #16
  orr r1,r1,r2,lsl #16 ;@ Insert remainder

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

endofop80e0:
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#146 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

divzero80e0:
  mov r0,#5 ;@ Divide by zero
  bl Exception
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#184 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [80e8] divu.w ($3333,a0), d0 uses Op80e8 ----------
Op80e8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r2:
  ldr r2,[r7,r11,lsr #7]

  movs r1,r0,asl #16
  beq divzero80e8 ;@ division by zero

  mov r0,r1,lsr #16 ;@ use only 16 bits of divisor

;@ Divide r2 by r0
  mov r3,#0
  mov r1,r0

;@ Shift up divisor till it's just less than numerator
Shift80e8:
  cmp r1,r2,lsr #1
  movls r1,r1,lsl #1
  bcc Shift80e8

Divide80e8:
  cmp r2,r1
  adc r3,r3,r3 ;@ Double r3 and add 1 if carry set
  subcs r2,r2,r1
  teq r1,r0
  movne r1,r1,lsr #1
  bne Divide80e8

;@r3==quotient,r2==remainder
  movs r1,r3,lsr #16 ;@ check for overflow condition
  orrne r10,r10,#0x10000000 ;@ set overflow flag
  bne endofop80e8 ;@ overflow!

  movs r1,r3,lsl #16 ;@ Clip to 16-bits
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV
  mov r1,r1,lsr #16
  orr r1,r1,r2,lsl #16 ;@ Insert remainder

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

endofop80e8:
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#148 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

divzero80e8:
  mov r0,#5 ;@ Divide by zero
  bl Exception
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#186 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [80f0] divu.w ($33,a0,d3.w*2), d0 uses Op80f0 ----------
Op80f0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r2:
  ldr r2,[r7,r11,lsr #7]

  movs r1,r0,asl #16
  beq divzero80f0 ;@ division by zero

  mov r0,r1,lsr #16 ;@ use only 16 bits of divisor

;@ Divide r2 by r0
  mov r3,#0
  mov r1,r0

;@ Shift up divisor till it's just less than numerator
Shift80f0:
  cmp r1,r2,lsr #1
  movls r1,r1,lsl #1
  bcc Shift80f0

Divide80f0:
  cmp r2,r1
  adc r3,r3,r3 ;@ Double r3 and add 1 if carry set
  subcs r2,r2,r1
  teq r1,r0
  movne r1,r1,lsr #1
  bne Divide80f0

;@r3==quotient,r2==remainder
  movs r1,r3,lsr #16 ;@ check for overflow condition
  orrne r10,r10,#0x10000000 ;@ set overflow flag
  bne endofop80f0 ;@ overflow!

  movs r1,r3,lsl #16 ;@ Clip to 16-bits
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV
  mov r1,r1,lsr #16
  orr r1,r1,r2,lsl #16 ;@ Insert remainder

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

endofop80f0:
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#150 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

divzero80f0:
  mov r0,#5 ;@ Divide by zero
  bl Exception
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#188 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [80f8] divu.w $3333.w, d0 uses Op80f8 ----------
Op80f8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r2:
  ldr r2,[r7,r11,lsr #7]

  movs r1,r0,asl #16
  beq divzero80f8 ;@ division by zero

  mov r0,r1,lsr #16 ;@ use only 16 bits of divisor

;@ Divide r2 by r0
  mov r3,#0
  mov r1,r0

;@ Shift up divisor till it's just less than numerator
Shift80f8:
  cmp r1,r2,lsr #1
  movls r1,r1,lsl #1
  bcc Shift80f8

Divide80f8:
  cmp r2,r1
  adc r3,r3,r3 ;@ Double r3 and add 1 if carry set
  subcs r2,r2,r1
  teq r1,r0
  movne r1,r1,lsr #1
  bne Divide80f8

;@r3==quotient,r2==remainder
  movs r1,r3,lsr #16 ;@ check for overflow condition
  orrne r10,r10,#0x10000000 ;@ set overflow flag
  bne endofop80f8 ;@ overflow!

  movs r1,r3,lsl #16 ;@ Clip to 16-bits
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV
  mov r1,r1,lsr #16
  orr r1,r1,r2,lsl #16 ;@ Insert remainder

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

endofop80f8:
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#148 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

divzero80f8:
  mov r0,#5 ;@ Divide by zero
  bl Exception
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#186 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [80f9] divu.w $33333333.l, d0 uses Op80f9 ----------
Op80f9:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r2:
  ldr r2,[r7,r11,lsr #7]

  movs r1,r0,asl #16
  beq divzero80f9 ;@ division by zero

  mov r0,r1,lsr #16 ;@ use only 16 bits of divisor

;@ Divide r2 by r0
  mov r3,#0
  mov r1,r0

;@ Shift up divisor till it's just less than numerator
Shift80f9:
  cmp r1,r2,lsr #1
  movls r1,r1,lsl #1
  bcc Shift80f9

Divide80f9:
  cmp r2,r1
  adc r3,r3,r3 ;@ Double r3 and add 1 if carry set
  subcs r2,r2,r1
  teq r1,r0
  movne r1,r1,lsr #1
  bne Divide80f9

;@r3==quotient,r2==remainder
  movs r1,r3,lsr #16 ;@ check for overflow condition
  orrne r10,r10,#0x10000000 ;@ set overflow flag
  bne endofop80f9 ;@ overflow!

  movs r1,r3,lsl #16 ;@ Clip to 16-bits
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV
  mov r1,r1,lsr #16
  orr r1,r1,r2,lsl #16 ;@ Insert remainder

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

endofop80f9:
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#152 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

divzero80f9:
  mov r0,#5 ;@ Divide by zero
  bl Exception
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#190 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [80fa] divu.w ($3333,pc), d0; =3335 uses Op80fa ----------
Op80fa:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r2,r0 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r0:
  bl cyclone_fetch16 ;@ Call fetch16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r2:
  ldr r2,[r7,r11,lsr #7]

  movs r1,r0,asl #16
  beq divzero80fa ;@ division by zero

  mov r0,r1,lsr #16 ;@ use only 16 bits of divisor

;@ Divide r2 by r0
  mov r3,#0
  mov r1,r0

;@ Shift up divisor till it's just less than numerator
Shift80fa:
  cmp r1,r2,lsr #1
  movls r1,r1,lsl #1
  bcc Shift80fa

Divide80fa:
  cmp r2,r1
  adc r3,r3,r3 ;@ Double r3 and add 1 if carry set
  subcs r2,r2,r1
  teq r1,r0
  movne r1,r1,lsr #1
  bne Divide80fa

;@r3==quotient,r2==remainder
  movs r1,r3,lsr #16 ;@ check for overflow condition
  orrne r10,r10,#0x10000000 ;@ set overflow flag
  bne endofop80fa ;@ overflow!

  movs r1,r3,lsl #16 ;@ Clip to 16-bits
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV
  mov r1,r1,lsr #16
  orr r1,r1,r2,lsl #16 ;@ Insert remainder

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

endofop80fa:
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#148 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

divzero80fa:
  mov r0,#5 ;@ Divide by zero
  bl Exception
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#186 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [80fb] divu.w ($33,pc,d3.w*2), d0; =35 uses Op80fb ----------
Op80fb:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r0:
  bl cyclone_fetch16 ;@ Call fetch16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r2:
  ldr r2,[r7,r11,lsr #7]

  movs r1,r0,asl #16
  beq divzero80fb ;@ division by zero

  mov r0,r1,lsr #16 ;@ use only 16 bits of divisor

;@ Divide r2 by r0
  mov r3,#0
  mov r1,r0

;@ Shift up divisor till it's just less than numerator
Shift80fb:
  cmp r1,r2,lsr #1
  movls r1,r1,lsl #1
  bcc Shift80fb

Divide80fb:
  cmp r2,r1
  adc r3,r3,r3 ;@ Double r3 and add 1 if carry set
  subcs r2,r2,r1
  teq r1,r0
  movne r1,r1,lsr #1
  bne Divide80fb

;@r3==quotient,r2==remainder
  movs r1,r3,lsr #16 ;@ check for overflow condition
  orrne r10,r10,#0x10000000 ;@ set overflow flag
  bne endofop80fb ;@ overflow!

  movs r1,r3,lsl #16 ;@ Clip to 16-bits
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV
  mov r1,r1,lsr #16
  orr r1,r1,r2,lsl #16 ;@ Insert remainder

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

endofop80fb:
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#150 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

divzero80fb:
  mov r0,#5 ;@ Divide by zero
  bl Exception
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#188 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [80fc] divu.w #$3333, d0 uses Op80fc ----------
Op80fc:
;@ EaCalc : Get '#$3333' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r0) into r0:

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r2:
  ldr r2,[r7,r11,lsr #7]

  movs r1,r0,asl #16
  beq divzero80fc ;@ division by zero

  mov r0,r1,lsr #16 ;@ use only 16 bits of divisor

;@ Divide r2 by r0
  mov r3,#0
  mov r1,r0

;@ Shift up divisor till it's just less than numerator
Shift80fc:
  cmp r1,r2,lsr #1
  movls r1,r1,lsl #1
  bcc Shift80fc

Divide80fc:
  cmp r2,r1
  adc r3,r3,r3 ;@ Double r3 and add 1 if carry set
  subcs r2,r2,r1
  teq r1,r0
  movne r1,r1,lsr #1
  bne Divide80fc

;@r3==quotient,r2==remainder
  movs r1,r3,lsr #16 ;@ check for overflow condition
  orrne r10,r10,#0x10000000 ;@ set overflow flag
  bne endofop80fc ;@ overflow!

  movs r1,r3,lsl #16 ;@ Clip to 16-bits
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV
  mov r1,r1,lsr #16
  orr r1,r1,r2,lsl #16 ;@ Insert remainder

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

endofop80fc:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#144 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

divzero80fc:
  mov r0,#5 ;@ Divide by zero
  bl Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#182 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [8100] sbcd d0, d0 uses Op8100 ----------
Op8100:
;@ Get src/dest reg vals
;@ EaCalc : Get register index into r6:
  and r6,r8,#0x0007
;@ EaRead : Read register[r6] into r6:
  ldr r6,[r7,r6,lsl #2]

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsr #7]

  bic r10,r10,#0xb1000000 ;@ clear all flags except old Z
  ldr r1,[r7,#0x4c] ;@ Get X bit
  and r2,r0,#0x0f
  movs r12,r1,lsl #3 ;@ X into carry
  and r1,r6,#0x0f
  mov r12,#0 ;@ corf
  adc r1,r1,#0
  sub r1,r2,r1
  cmp r1,#0x0f
  movhi r12,#6
  and r0,r0,#0xf0
  and r6,r6,#0xf0
  add r1,r1,r0
  sub r1,r1,r6
  tst r1,#0x80
  orrne r10,r10,#0x10000000 ;@ Undefined V behavior
  cmp r1,r12
  orrlt r10,r10,#0x20000000 ;@ C
  cmp r1,#0xff
  addhi r1,#0xa0
  sub r12,r1,r12
  movs r0,r12,lsl #24
  bicmi r10,r10,#0x10000000 ;@ Undefined V behavior part II
  orrmi r10,r10,#0x80000000 ;@ Undefined N behavior
  bicne r10,r10,#0x40000000 ;@ Z flag
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: r0 into register[r11]:
  mov r0,r0,lsr #24
  strb r0,[r7,r11,lsr #7]

  ldr r6,[r7,#0x54]
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8108] sbcd -(a0), -(a0) uses Op8108 ----------
Op8108:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get src/dest EA vals
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r6:
  bl cyclone_read8 ;@ Call read8(r0) handler
  mov r6,r0

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r11,[r7,r2,lsr #7]
  sub r11,r11,#1 ;@ Pre-decrement An
  str r11,[r7,r2,lsr #7]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

  bic r10,r10,#0xb1000000 ;@ clear all flags except old Z
  ldr r1,[r7,#0x4c] ;@ Get X bit
  and r2,r0,#0x0f
  movs r12,r1,lsl #3 ;@ X into carry
  and r1,r6,#0x0f
  mov r12,#0 ;@ corf
  adc r1,r1,#0
  sub r1,r2,r1
  cmp r1,#0x0f
  movhi r12,#6
  and r0,r0,#0xf0
  and r6,r6,#0xf0
  add r1,r1,r0
  sub r1,r1,r6
  tst r1,#0x80
  orrne r10,r10,#0x10000000 ;@ Undefined V behavior
  cmp r1,r12
  orrlt r10,r10,#0x20000000 ;@ C
  cmp r1,#0xff
  addhi r1,#0xa0
  sub r12,r1,r12
  movs r0,r12,lsl #24
  bicmi r10,r10,#0x10000000 ;@ Undefined V behavior part II
  orrmi r10,r10,#0x80000000 ;@ Undefined N behavior
  bicne r10,r10,#0x40000000 ;@ Z flag
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r0 into '-(a0)' (address in r11):
  mov r1,r0,lsr #24
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r6,[r7,#0x54]
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [810f] sbcd -(a7), -(a0) uses Op810f ----------
Op810f:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get src/dest EA vals
;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r0) into r6:
  bl cyclone_read8 ;@ Call read8(r0) handler
  mov r6,r0

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r11,[r7,r2,lsr #7]
  sub r11,r11,#1 ;@ Pre-decrement An
  str r11,[r7,r2,lsr #7]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

  bic r10,r10,#0xb1000000 ;@ clear all flags except old Z
  ldr r1,[r7,#0x4c] ;@ Get X bit
  and r2,r0,#0x0f
  movs r12,r1,lsl #3 ;@ X into carry
  and r1,r6,#0x0f
  mov r12,#0 ;@ corf
  adc r1,r1,#0
  sub r1,r2,r1
  cmp r1,#0x0f
  movhi r12,#6
  and r0,r0,#0xf0
  and r6,r6,#0xf0
  add r1,r1,r0
  sub r1,r1,r6
  tst r1,#0x80
  orrne r10,r10,#0x10000000 ;@ Undefined V behavior
  cmp r1,r12
  orrlt r10,r10,#0x20000000 ;@ C
  cmp r1,#0xff
  addhi r1,#0xa0
  sub r12,r1,r12
  movs r0,r12,lsl #24
  bicmi r10,r10,#0x10000000 ;@ Undefined V behavior part II
  orrmi r10,r10,#0x80000000 ;@ Undefined N behavior
  bicne r10,r10,#0x40000000 ;@ Z flag
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r0 into '-(a0)' (address in r11):
  mov r1,r0,lsr #24
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r6,[r7,#0x54]
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8110] or.b d0, (a0) uses Op8110 ----------
Op8110:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  orrs r1,r0,r1,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: Write r1 into '(a0)' (address in r11):
  and r1,r1,#0xff
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8118] or.b d0, (a0)+ uses Op8118 ----------
Op8118:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  orrs r1,r0,r1,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  and r1,r1,#0xff
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [811f] or.b d0, (a7)+ uses Op811f ----------
Op811f:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a7)+' into r11:
  ldr r11,[r7,#0x3c] ;@ A7
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  orrs r1,r0,r1,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: Write r1 into '(a7)+' (address in r11):
  and r1,r1,#0xff
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8120] or.b d0, -(a0) uses Op8120 ----------
Op8120:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#1 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  orrs r1,r0,r1,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  and r1,r1,#0xff
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8127] or.b d0, -(a7) uses Op8127 ----------
Op8127:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a7)' into r11:
  ldr r11,[r7,#0x3c] ;@ A7
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  orrs r1,r0,r1,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: Write r1 into '-(a7)' (address in r11):
  and r1,r1,#0xff
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8128] or.b d0, ($3333,a0) uses Op8128 ----------
Op8128:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  orrs r1,r0,r1,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  and r1,r1,#0xff
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8130] or.b d0, ($33,a0,d3.w*2) uses Op8130 ----------
Op8130:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  orrs r1,r0,r1,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  and r1,r1,#0xff
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8138] or.b d0, $3333.w uses Op8138 ----------
Op8138:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  orrs r1,r0,r1,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  and r1,r1,#0xff
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8139] or.b d0, $33333333.l uses Op8139 ----------
Op8139:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  orrs r1,r0,r1,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  and r1,r1,#0xff
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8150] or.w d0, (a0) uses Op8150 ----------
Op8150:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #16
  orrs r1,r0,r1,asl #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: Write r1 into '(a0)' (address in r11):
  uxth r1,r1 ;@ zero extend
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8158] or.w d0, (a0)+ uses Op8158 ----------
Op8158:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #16
  orrs r1,r0,r1,asl #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  uxth r1,r1 ;@ zero extend
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8160] or.w d0, -(a0) uses Op8160 ----------
Op8160:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #16
  orrs r1,r0,r1,asl #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  uxth r1,r1 ;@ zero extend
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8168] or.w d0, ($3333,a0) uses Op8168 ----------
Op8168:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #16
  orrs r1,r0,r1,asl #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  uxth r1,r1 ;@ zero extend
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8170] or.w d0, ($33,a0,d3.w*2) uses Op8170 ----------
Op8170:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #16
  orrs r1,r0,r1,asl #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  uxth r1,r1 ;@ zero extend
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8178] or.w d0, $3333.w uses Op8178 ----------
Op8178:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #16
  orrs r1,r0,r1,asl #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  uxth r1,r1 ;@ zero extend
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8179] or.w d0, $33333333.l uses Op8179 ----------
Op8179:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #16
  orrs r1,r0,r1,asl #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  uxth r1,r1 ;@ zero extend
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8190] or.l d0, (a0) uses Op8190 ----------
Op8190:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  orrs r1,r0,r1
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
;@ EaWrite: Write r1 into '(a0)' (address in r11):
  mov r0,r11
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8198] or.l d0, (a0)+ uses Op8198 ----------
Op8198:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  orrs r1,r0,r1
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  mov r0,r11
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [81a0] or.l d0, -(a0) uses Op81a0 ----------
Op81a0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#4 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  orrs r1,r0,r1
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r0,r11
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [81a8] or.l d0, ($3333,a0) uses Op81a8 ----------
Op81a8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  orrs r1,r0,r1
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  mov r0,r11
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [81b0] or.l d0, ($33,a0,d3.w*2) uses Op81b0 ----------
Op81b0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  orrs r1,r0,r1
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  mov r0,r11
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [81b8] or.l d0, $3333.w uses Op81b8 ----------
Op81b8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  orrs r1,r0,r1
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  mov r0,r11
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [81b9] or.l d0, $33333333.l uses Op81b9 ----------
Op81b9:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  orrs r1,r0,r1
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  mov r0,r11
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [81c0] divs.w d0, d0 uses Op81c0 ----------
Op81c0:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r0:
  ldr r0,[r7,r0,lsl #2]

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r2:
  ldr r2,[r7,r11,lsr #7]

  movs r1,r0,asl #16
  beq divzero81c0 ;@ division by zero

  mov r12,#0 ;@ r12 = 1 or 2 if the result is negative
  tst r2,r2
  orrmi r12,r12,#2
  rsbmi r2,r2,#0 ;@ Make r2 positive

  movs r0,r1,asr #16
  orrmi r12,r12,#1
  rsbmi r0,r0,#0 ;@ Make r0 positive

;@ detect the nasty 0x80000000 / -1 situation
  mov r3,r2,asr #31
  eors r3,r3,r1,asr #16
  beq wrendofop81c0

;@ Divide r2 by r0
  mov r3,#0
  mov r1,r0

;@ Shift up divisor till it's just less than numerator
Shift81c0:
  cmp r1,r2,lsr #1
  movls r1,r1,lsl #1
  bcc Shift81c0

Divide81c0:
  cmp r2,r1
  adc r3,r3,r3 ;@ Double r3 and add 1 if carry set
  subcs r2,r2,r1
  teq r1,r0
  movne r1,r1,lsr #1
  bne Divide81c0

;@r3==quotient,r2==remainder
  and r1,r12,#1
  teq r1,r12,lsr #1
  rsbne r3,r3,#0 ;@ negate if quotient is negative
  tst r12,#2
  rsbne r2,r2,#0 ;@ negate the remainder if divident was negative

  mov r1,r3,asl #16
  cmp r3,r1,asr #16 ;@ signed overflow?
  orrne r10,r10,#0x10000000 ;@ set overflow flag
  bne endofop81c0 ;@ overflow!

wrendofop81c0:
  movs r1,r3,lsl #16 ;@ Clip to 16-bits
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV
  mov r1,r1,lsr #16
  orr r1,r1,r2,lsl #16 ;@ Insert remainder

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

endofop81c0:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#158 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

divzero81c0:
  mov r0,#5 ;@ Divide by zero
  bl Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#196 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [81d0] divs.w (a0), d0 uses Op81d0 ----------
Op81d0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r2:
  ldr r2,[r7,r11,lsr #7]

  movs r1,r0,asl #16
  beq divzero81d0 ;@ division by zero

  mov r12,#0 ;@ r12 = 1 or 2 if the result is negative
  tst r2,r2
  orrmi r12,r12,#2
  rsbmi r2,r2,#0 ;@ Make r2 positive

  movs r0,r1,asr #16
  orrmi r12,r12,#1
  rsbmi r0,r0,#0 ;@ Make r0 positive

;@ detect the nasty 0x80000000 / -1 situation
  mov r3,r2,asr #31
  eors r3,r3,r1,asr #16
  beq wrendofop81d0

;@ Divide r2 by r0
  mov r3,#0
  mov r1,r0

;@ Shift up divisor till it's just less than numerator
Shift81d0:
  cmp r1,r2,lsr #1
  movls r1,r1,lsl #1
  bcc Shift81d0

Divide81d0:
  cmp r2,r1
  adc r3,r3,r3 ;@ Double r3 and add 1 if carry set
  subcs r2,r2,r1
  teq r1,r0
  movne r1,r1,lsr #1
  bne Divide81d0

;@r3==quotient,r2==remainder
  and r1,r12,#1
  teq r1,r12,lsr #1
  rsbne r3,r3,#0 ;@ negate if quotient is negative
  tst r12,#2
  rsbne r2,r2,#0 ;@ negate the remainder if divident was negative

  mov r1,r3,asl #16
  cmp r3,r1,asr #16 ;@ signed overflow?
  orrne r10,r10,#0x10000000 ;@ set overflow flag
  bne endofop81d0 ;@ overflow!

wrendofop81d0:
  movs r1,r3,lsl #16 ;@ Clip to 16-bits
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV
  mov r1,r1,lsr #16
  orr r1,r1,r2,lsl #16 ;@ Insert remainder

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

endofop81d0:
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#162 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

divzero81d0:
  mov r0,#5 ;@ Divide by zero
  bl Exception
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#200 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [81d8] divs.w (a0)+, d0 uses Op81d8 ----------
Op81d8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r2:
  ldr r2,[r7,r11,lsr #7]

  movs r1,r0,asl #16
  beq divzero81d8 ;@ division by zero

  mov r12,#0 ;@ r12 = 1 or 2 if the result is negative
  tst r2,r2
  orrmi r12,r12,#2
  rsbmi r2,r2,#0 ;@ Make r2 positive

  movs r0,r1,asr #16
  orrmi r12,r12,#1
  rsbmi r0,r0,#0 ;@ Make r0 positive

;@ detect the nasty 0x80000000 / -1 situation
  mov r3,r2,asr #31
  eors r3,r3,r1,asr #16
  beq wrendofop81d8

;@ Divide r2 by r0
  mov r3,#0
  mov r1,r0

;@ Shift up divisor till it's just less than numerator
Shift81d8:
  cmp r1,r2,lsr #1
  movls r1,r1,lsl #1
  bcc Shift81d8

Divide81d8:
  cmp r2,r1
  adc r3,r3,r3 ;@ Double r3 and add 1 if carry set
  subcs r2,r2,r1
  teq r1,r0
  movne r1,r1,lsr #1
  bne Divide81d8

;@r3==quotient,r2==remainder
  and r1,r12,#1
  teq r1,r12,lsr #1
  rsbne r3,r3,#0 ;@ negate if quotient is negative
  tst r12,#2
  rsbne r2,r2,#0 ;@ negate the remainder if divident was negative

  mov r1,r3,asl #16
  cmp r3,r1,asr #16 ;@ signed overflow?
  orrne r10,r10,#0x10000000 ;@ set overflow flag
  bne endofop81d8 ;@ overflow!

wrendofop81d8:
  movs r1,r3,lsl #16 ;@ Clip to 16-bits
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV
  mov r1,r1,lsr #16
  orr r1,r1,r2,lsl #16 ;@ Insert remainder

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

endofop81d8:
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#162 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

divzero81d8:
  mov r0,#5 ;@ Divide by zero
  bl Exception
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#200 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [81e0] divs.w -(a0), d0 uses Op81e0 ----------
Op81e0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r2:
  ldr r2,[r7,r11,lsr #7]

  movs r1,r0,asl #16
  beq divzero81e0 ;@ division by zero

  mov r12,#0 ;@ r12 = 1 or 2 if the result is negative
  tst r2,r2
  orrmi r12,r12,#2
  rsbmi r2,r2,#0 ;@ Make r2 positive

  movs r0,r1,asr #16
  orrmi r12,r12,#1
  rsbmi r0,r0,#0 ;@ Make r0 positive

;@ detect the nasty 0x80000000 / -1 situation
  mov r3,r2,asr #31
  eors r3,r3,r1,asr #16
  beq wrendofop81e0

;@ Divide r2 by r0
  mov r3,#0
  mov r1,r0

;@ Shift up divisor till it's just less than numerator
Shift81e0:
  cmp r1,r2,lsr #1
  movls r1,r1,lsl #1
  bcc Shift81e0

Divide81e0:
  cmp r2,r1
  adc r3,r3,r3 ;@ Double r3 and add 1 if carry set
  subcs r2,r2,r1
  teq r1,r0
  movne r1,r1,lsr #1
  bne Divide81e0

;@r3==quotient,r2==remainder
  and r1,r12,#1
  teq r1,r12,lsr #1
  rsbne r3,r3,#0 ;@ negate if quotient is negative
  tst r12,#2
  rsbne r2,r2,#0 ;@ negate the remainder if divident was negative

  mov r1,r3,asl #16
  cmp r3,r1,asr #16 ;@ signed overflow?
  orrne r10,r10,#0x10000000 ;@ set overflow flag
  bne endofop81e0 ;@ overflow!

wrendofop81e0:
  movs r1,r3,lsl #16 ;@ Clip to 16-bits
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV
  mov r1,r1,lsr #16
  orr r1,r1,r2,lsl #16 ;@ Insert remainder

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

endofop81e0:
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#164 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

divzero81e0:
  mov r0,#5 ;@ Divide by zero
  bl Exception
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#202 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [81e8] divs.w ($3333,a0), d0 uses Op81e8 ----------
Op81e8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r2:
  ldr r2,[r7,r11,lsr #7]

  movs r1,r0,asl #16
  beq divzero81e8 ;@ division by zero

  mov r12,#0 ;@ r12 = 1 or 2 if the result is negative
  tst r2,r2
  orrmi r12,r12,#2
  rsbmi r2,r2,#0 ;@ Make r2 positive

  movs r0,r1,asr #16
  orrmi r12,r12,#1
  rsbmi r0,r0,#0 ;@ Make r0 positive

;@ detect the nasty 0x80000000 / -1 situation
  mov r3,r2,asr #31
  eors r3,r3,r1,asr #16
  beq wrendofop81e8

;@ Divide r2 by r0
  mov r3,#0
  mov r1,r0

;@ Shift up divisor till it's just less than numerator
Shift81e8:
  cmp r1,r2,lsr #1
  movls r1,r1,lsl #1
  bcc Shift81e8

Divide81e8:
  cmp r2,r1
  adc r3,r3,r3 ;@ Double r3 and add 1 if carry set
  subcs r2,r2,r1
  teq r1,r0
  movne r1,r1,lsr #1
  bne Divide81e8

;@r3==quotient,r2==remainder
  and r1,r12,#1
  teq r1,r12,lsr #1
  rsbne r3,r3,#0 ;@ negate if quotient is negative
  tst r12,#2
  rsbne r2,r2,#0 ;@ negate the remainder if divident was negative

  mov r1,r3,asl #16
  cmp r3,r1,asr #16 ;@ signed overflow?
  orrne r10,r10,#0x10000000 ;@ set overflow flag
  bne endofop81e8 ;@ overflow!

wrendofop81e8:
  movs r1,r3,lsl #16 ;@ Clip to 16-bits
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV
  mov r1,r1,lsr #16
  orr r1,r1,r2,lsl #16 ;@ Insert remainder

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

endofop81e8:
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#166 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

divzero81e8:
  mov r0,#5 ;@ Divide by zero
  bl Exception
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#204 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [81f0] divs.w ($33,a0,d3.w*2), d0 uses Op81f0 ----------
Op81f0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r2:
  ldr r2,[r7,r11,lsr #7]

  movs r1,r0,asl #16
  beq divzero81f0 ;@ division by zero

  mov r12,#0 ;@ r12 = 1 or 2 if the result is negative
  tst r2,r2
  orrmi r12,r12,#2
  rsbmi r2,r2,#0 ;@ Make r2 positive

  movs r0,r1,asr #16
  orrmi r12,r12,#1
  rsbmi r0,r0,#0 ;@ Make r0 positive

;@ detect the nasty 0x80000000 / -1 situation
  mov r3,r2,asr #31
  eors r3,r3,r1,asr #16
  beq wrendofop81f0

;@ Divide r2 by r0
  mov r3,#0
  mov r1,r0

;@ Shift up divisor till it's just less than numerator
Shift81f0:
  cmp r1,r2,lsr #1
  movls r1,r1,lsl #1
  bcc Shift81f0

Divide81f0:
  cmp r2,r1
  adc r3,r3,r3 ;@ Double r3 and add 1 if carry set
  subcs r2,r2,r1
  teq r1,r0
  movne r1,r1,lsr #1
  bne Divide81f0

;@r3==quotient,r2==remainder
  and r1,r12,#1
  teq r1,r12,lsr #1
  rsbne r3,r3,#0 ;@ negate if quotient is negative
  tst r12,#2
  rsbne r2,r2,#0 ;@ negate the remainder if divident was negative

  mov r1,r3,asl #16
  cmp r3,r1,asr #16 ;@ signed overflow?
  orrne r10,r10,#0x10000000 ;@ set overflow flag
  bne endofop81f0 ;@ overflow!

wrendofop81f0:
  movs r1,r3,lsl #16 ;@ Clip to 16-bits
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV
  mov r1,r1,lsr #16
  orr r1,r1,r2,lsl #16 ;@ Insert remainder

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

endofop81f0:
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#168 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

divzero81f0:
  mov r0,#5 ;@ Divide by zero
  bl Exception
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#206 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [81f8] divs.w $3333.w, d0 uses Op81f8 ----------
Op81f8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r2:
  ldr r2,[r7,r11,lsr #7]

  movs r1,r0,asl #16
  beq divzero81f8 ;@ division by zero

  mov r12,#0 ;@ r12 = 1 or 2 if the result is negative
  tst r2,r2
  orrmi r12,r12,#2
  rsbmi r2,r2,#0 ;@ Make r2 positive

  movs r0,r1,asr #16
  orrmi r12,r12,#1
  rsbmi r0,r0,#0 ;@ Make r0 positive

;@ detect the nasty 0x80000000 / -1 situation
  mov r3,r2,asr #31
  eors r3,r3,r1,asr #16
  beq wrendofop81f8

;@ Divide r2 by r0
  mov r3,#0
  mov r1,r0

;@ Shift up divisor till it's just less than numerator
Shift81f8:
  cmp r1,r2,lsr #1
  movls r1,r1,lsl #1
  bcc Shift81f8

Divide81f8:
  cmp r2,r1
  adc r3,r3,r3 ;@ Double r3 and add 1 if carry set
  subcs r2,r2,r1
  teq r1,r0
  movne r1,r1,lsr #1
  bne Divide81f8

;@r3==quotient,r2==remainder
  and r1,r12,#1
  teq r1,r12,lsr #1
  rsbne r3,r3,#0 ;@ negate if quotient is negative
  tst r12,#2
  rsbne r2,r2,#0 ;@ negate the remainder if divident was negative

  mov r1,r3,asl #16
  cmp r3,r1,asr #16 ;@ signed overflow?
  orrne r10,r10,#0x10000000 ;@ set overflow flag
  bne endofop81f8 ;@ overflow!

wrendofop81f8:
  movs r1,r3,lsl #16 ;@ Clip to 16-bits
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV
  mov r1,r1,lsr #16
  orr r1,r1,r2,lsl #16 ;@ Insert remainder

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

endofop81f8:
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#166 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

divzero81f8:
  mov r0,#5 ;@ Divide by zero
  bl Exception
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#204 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [81f9] divs.w $33333333.l, d0 uses Op81f9 ----------
Op81f9:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r2:
  ldr r2,[r7,r11,lsr #7]

  movs r1,r0,asl #16
  beq divzero81f9 ;@ division by zero

  mov r12,#0 ;@ r12 = 1 or 2 if the result is negative
  tst r2,r2
  orrmi r12,r12,#2
  rsbmi r2,r2,#0 ;@ Make r2 positive

  movs r0,r1,asr #16
  orrmi r12,r12,#1
  rsbmi r0,r0,#0 ;@ Make r0 positive

;@ detect the nasty 0x80000000 / -1 situation
  mov r3,r2,asr #31
  eors r3,r3,r1,asr #16
  beq wrendofop81f9

;@ Divide r2 by r0
  mov r3,#0
  mov r1,r0

;@ Shift up divisor till it's just less than numerator
Shift81f9:
  cmp r1,r2,lsr #1
  movls r1,r1,lsl #1
  bcc Shift81f9

Divide81f9:
  cmp r2,r1
  adc r3,r3,r3 ;@ Double r3 and add 1 if carry set
  subcs r2,r2,r1
  teq r1,r0
  movne r1,r1,lsr #1
  bne Divide81f9

;@r3==quotient,r2==remainder
  and r1,r12,#1
  teq r1,r12,lsr #1
  rsbne r3,r3,#0 ;@ negate if quotient is negative
  tst r12,#2
  rsbne r2,r2,#0 ;@ negate the remainder if divident was negative

  mov r1,r3,asl #16
  cmp r3,r1,asr #16 ;@ signed overflow?
  orrne r10,r10,#0x10000000 ;@ set overflow flag
  bne endofop81f9 ;@ overflow!

wrendofop81f9:
  movs r1,r3,lsl #16 ;@ Clip to 16-bits
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV
  mov r1,r1,lsr #16
  orr r1,r1,r2,lsl #16 ;@ Insert remainder

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

endofop81f9:
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#170 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

divzero81f9:
  mov r0,#5 ;@ Divide by zero
  bl Exception
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#208 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [81fa] divs.w ($3333,pc), d0; =3335 uses Op81fa ----------
Op81fa:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r2,r0 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r0:
  bl cyclone_fetch16 ;@ Call fetch16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r2:
  ldr r2,[r7,r11,lsr #7]

  movs r1,r0,asl #16
  beq divzero81fa ;@ division by zero

  mov r12,#0 ;@ r12 = 1 or 2 if the result is negative
  tst r2,r2
  orrmi r12,r12,#2
  rsbmi r2,r2,#0 ;@ Make r2 positive

  movs r0,r1,asr #16
  orrmi r12,r12,#1
  rsbmi r0,r0,#0 ;@ Make r0 positive

;@ detect the nasty 0x80000000 / -1 situation
  mov r3,r2,asr #31
  eors r3,r3,r1,asr #16
  beq wrendofop81fa

;@ Divide r2 by r0
  mov r3,#0
  mov r1,r0

;@ Shift up divisor till it's just less than numerator
Shift81fa:
  cmp r1,r2,lsr #1
  movls r1,r1,lsl #1
  bcc Shift81fa

Divide81fa:
  cmp r2,r1
  adc r3,r3,r3 ;@ Double r3 and add 1 if carry set
  subcs r2,r2,r1
  teq r1,r0
  movne r1,r1,lsr #1
  bne Divide81fa

;@r3==quotient,r2==remainder
  and r1,r12,#1
  teq r1,r12,lsr #1
  rsbne r3,r3,#0 ;@ negate if quotient is negative
  tst r12,#2
  rsbne r2,r2,#0 ;@ negate the remainder if divident was negative

  mov r1,r3,asl #16
  cmp r3,r1,asr #16 ;@ signed overflow?
  orrne r10,r10,#0x10000000 ;@ set overflow flag
  bne endofop81fa ;@ overflow!

wrendofop81fa:
  movs r1,r3,lsl #16 ;@ Clip to 16-bits
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV
  mov r1,r1,lsr #16
  orr r1,r1,r2,lsl #16 ;@ Insert remainder

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

endofop81fa:
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#166 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

divzero81fa:
  mov r0,#5 ;@ Divide by zero
  bl Exception
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#204 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [81fb] divs.w ($33,pc,d3.w*2), d0; =35 uses Op81fb ----------
Op81fb:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r0:
  bl cyclone_fetch16 ;@ Call fetch16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r2:
  ldr r2,[r7,r11,lsr #7]

  movs r1,r0,asl #16
  beq divzero81fb ;@ division by zero

  mov r12,#0 ;@ r12 = 1 or 2 if the result is negative
  tst r2,r2
  orrmi r12,r12,#2
  rsbmi r2,r2,#0 ;@ Make r2 positive

  movs r0,r1,asr #16
  orrmi r12,r12,#1
  rsbmi r0,r0,#0 ;@ Make r0 positive

;@ detect the nasty 0x80000000 / -1 situation
  mov r3,r2,asr #31
  eors r3,r3,r1,asr #16
  beq wrendofop81fb

;@ Divide r2 by r0
  mov r3,#0
  mov r1,r0

;@ Shift up divisor till it's just less than numerator
Shift81fb:
  cmp r1,r2,lsr #1
  movls r1,r1,lsl #1
  bcc Shift81fb

Divide81fb:
  cmp r2,r1
  adc r3,r3,r3 ;@ Double r3 and add 1 if carry set
  subcs r2,r2,r1
  teq r1,r0
  movne r1,r1,lsr #1
  bne Divide81fb

;@r3==quotient,r2==remainder
  and r1,r12,#1
  teq r1,r12,lsr #1
  rsbne r3,r3,#0 ;@ negate if quotient is negative
  tst r12,#2
  rsbne r2,r2,#0 ;@ negate the remainder if divident was negative

  mov r1,r3,asl #16
  cmp r3,r1,asr #16 ;@ signed overflow?
  orrne r10,r10,#0x10000000 ;@ set overflow flag
  bne endofop81fb ;@ overflow!

wrendofop81fb:
  movs r1,r3,lsl #16 ;@ Clip to 16-bits
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV
  mov r1,r1,lsr #16
  orr r1,r1,r2,lsl #16 ;@ Insert remainder

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

endofop81fb:
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#168 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

divzero81fb:
  mov r0,#5 ;@ Divide by zero
  bl Exception
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#206 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [81fc] divs.w #$3333, d0 uses Op81fc ----------
Op81fc:
;@ EaCalc : Get '#$3333' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r0) into r0:

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r2:
  ldr r2,[r7,r11,lsr #7]

  movs r1,r0,asl #16
  beq divzero81fc ;@ division by zero

  mov r12,#0 ;@ r12 = 1 or 2 if the result is negative
  tst r2,r2
  orrmi r12,r12,#2
  rsbmi r2,r2,#0 ;@ Make r2 positive

  movs r0,r1,asr #16
  orrmi r12,r12,#1
  rsbmi r0,r0,#0 ;@ Make r0 positive

;@ detect the nasty 0x80000000 / -1 situation
  mov r3,r2,asr #31
  eors r3,r3,r1,asr #16
  beq wrendofop81fc

;@ Divide r2 by r0
  mov r3,#0
  mov r1,r0

;@ Shift up divisor till it's just less than numerator
Shift81fc:
  cmp r1,r2,lsr #1
  movls r1,r1,lsl #1
  bcc Shift81fc

Divide81fc:
  cmp r2,r1
  adc r3,r3,r3 ;@ Double r3 and add 1 if carry set
  subcs r2,r2,r1
  teq r1,r0
  movne r1,r1,lsr #1
  bne Divide81fc

;@r3==quotient,r2==remainder
  and r1,r12,#1
  teq r1,r12,lsr #1
  rsbne r3,r3,#0 ;@ negate if quotient is negative
  tst r12,#2
  rsbne r2,r2,#0 ;@ negate the remainder if divident was negative

  mov r1,r3,asl #16
  cmp r3,r1,asr #16 ;@ signed overflow?
  orrne r10,r10,#0x10000000 ;@ set overflow flag
  bne endofop81fc ;@ overflow!

wrendofop81fc:
  movs r1,r3,lsl #16 ;@ Clip to 16-bits
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV
  mov r1,r1,lsr #16
  orr r1,r1,r2,lsl #16 ;@ Insert remainder

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

endofop81fc:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#162 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

divzero81fc:
  mov r0,#5 ;@ Divide by zero
  bl Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#200 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ ---------- [8f08] sbcd -(a0), -(a7) uses Op8f08 ----------
Op8f08:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get src/dest EA vals
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r6:
  bl cyclone_read8 ;@ Call read8(r0) handler
  mov r6,r0

;@ EaCalc : Get '-(a7)' into r11:
  ldr r11,[r7,#0x3c] ;@ A7
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

  bic r10,r10,#0xb1000000 ;@ clear all flags except old Z
  ldr r1,[r7,#0x4c] ;@ Get X bit
  and r2,r0,#0x0f
  movs r12,r1,lsl #3 ;@ X into carry
  and r1,r6,#0x0f
  mov r12,#0 ;@ corf
  adc r1,r1,#0
  sub r1,r2,r1
  cmp r1,#0x0f
  movhi r12,#6
  and r0,r0,#0xf0
  and r6,r6,#0xf0
  add r1,r1,r0
  sub r1,r1,r6
  tst r1,#0x80
  orrne r10,r10,#0x10000000 ;@ Undefined V behavior
  cmp r1,r12
  orrlt r10,r10,#0x20000000 ;@ C
  cmp r1,#0xff
  addhi r1,#0xa0
  sub r12,r1,r12
  movs r0,r12,lsl #24
  bicmi r10,r10,#0x10000000 ;@ Undefined V behavior part II
  orrmi r10,r10,#0x80000000 ;@ Undefined N behavior
  bicne r10,r10,#0x40000000 ;@ Z flag
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r0 into '-(a7)' (address in r11):
  mov r1,r0,lsr #24
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r6,[r7,#0x54]
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [8f0f] sbcd -(a7), -(a7) uses Op8f0f ----------
Op8f0f:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get src/dest EA vals
;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r0) into r6:
  bl cyclone_read8 ;@ Call read8(r0) handler
  mov r6,r0

;@ EaCalc : Get '-(a7)' into r11:
  ldr r11,[r7,#0x3c] ;@ A7
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

  bic r10,r10,#0xb1000000 ;@ clear all flags except old Z
  ldr r1,[r7,#0x4c] ;@ Get X bit
  and r2,r0,#0x0f
  movs r12,r1,lsl #3 ;@ X into carry
  and r1,r6,#0x0f
  mov r12,#0 ;@ corf
  adc r1,r1,#0
  sub r1,r2,r1
  cmp r1,#0x0f
  movhi r12,#6
  and r0,r0,#0xf0
  and r6,r6,#0xf0
  add r1,r1,r0
  sub r1,r1,r6
  tst r1,#0x80
  orrne r10,r10,#0x10000000 ;@ Undefined V behavior
  cmp r1,r12
  orrlt r10,r10,#0x20000000 ;@ C
  cmp r1,#0xff
  addhi r1,#0xa0
  sub r12,r1,r12
  movs r0,r12,lsl #24
  bicmi r10,r10,#0x10000000 ;@ Undefined V behavior part II
  orrmi r10,r10,#0x80000000 ;@ Undefined N behavior
  bicne r10,r10,#0x40000000 ;@ Z flag
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r0 into '-(a7)' (address in r11):
  mov r1,r0,lsr #24
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r6,[r7,#0x54]
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9000] sub.b d0, d0 uses Op9000 ----------
Op9000:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r0:
  ldr r0,[r7,r0,lsl #2]

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  rsbs r1,r0,r1,asl #24
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r11]:
  strb r1,[r7,r11,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9010] sub.b (a0), d0 uses Op9010 ----------
Op9010:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  bl cyclone_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  rsbs r1,r0,r1,asl #24
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r11]:
  strb r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9018] sub.b (a0)+, d0 uses Op9018 ----------
Op9018:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  bl cyclone_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  rsbs r1,r0,r1,asl #24
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r11]:
  strb r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [901f] sub.b (a7)+, d0 uses Op901f ----------
Op901f:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r0) into r0:
  bl cyclone_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  rsbs r1,r0,r1,asl #24
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r11]:
  strb r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9020] sub.b -(a0), d0 uses Op9020 ----------
Op9020:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  bl cyclone_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  rsbs r1,r0,r1,asl #24
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r11]:
  strb r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9027] sub.b -(a7), d0 uses Op9027 ----------
Op9027:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r0) into r0:
  bl cyclone_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  rsbs r1,r0,r1,asl #24
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r11]:
  strb r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9028] sub.b ($3333,a0), d0 uses Op9028 ----------
Op9028:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  bl cyclone_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  rsbs r1,r0,r1,asl #24
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r11]:
  strb r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9030] sub.b ($33,a0,d3.w*2), d0 uses Op9030 ----------
Op9030:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  bl cyclone_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  rsbs r1,r0,r1,asl #24
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r11]:
  strb r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9038] sub.b $3333.w, d0 uses Op9038 ----------
Op9038:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  bl cyclone_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  rsbs r1,r0,r1,asl #24
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r11]:
  strb r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9039] sub.b $33333333.l, d0 uses Op9039 ----------
Op9039:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  bl cyclone_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  rsbs r1,r0,r1,asl #24
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r11]:
  strb r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [903a] sub.b ($3333,pc), d0; =3335 uses Op903a ----------
Op903a:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r2,r0 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r0:
  bl cyclone_fetch8 ;@ Call fetch8(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  rsbs r1,r0,r1,asl #24
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r11]:
  strb r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [903b] sub.b ($33,pc,d3.w*2), d0; =35 uses Op903b ----------
Op903b:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r0:
  bl cyclone_fetch8 ;@ Call fetch8(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  rsbs r1,r0,r1,asl #24
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r11]:
  strb r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [903c] sub.b #$33, d0 uses Op903c ----------
Op903c:
;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  rsbs r1,r0,r1,asl #24
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r11]:
  strb r1,[r7,r11,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9040] sub.w d0, d0 uses Op9040 ----------
Op9040:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r0:
  ldr r0,[r7,r0,lsl #2]

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
  mov r11,r11,lsr #7
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11]

;@ Do arithmetic:
  mov r0,r0,asl #16
  rsbs r1,r0,r1,asl #16
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: r1 into register[r11]:
  strh r1,[r7,r11]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9050] sub.w (a0), d0 uses Op9050 ----------
Op9050:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
  mov r11,r11,lsr #7
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11]

;@ Do arithmetic:
  mov r0,r0,asl #16
  rsbs r1,r0,r1,asl #16
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: r1 into register[r11]:
  strh r1,[r7,r11]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9058] sub.w (a0)+, d0 uses Op9058 ----------
Op9058:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
  mov r11,r11,lsr #7
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11]

;@ Do arithmetic:
  mov r0,r0,asl #16
  rsbs r1,r0,r1,asl #16
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: r1 into register[r11]:
  strh r1,[r7,r11]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9060] sub.w -(a0), d0 uses Op9060 ----------
Op9060:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
  mov r11,r11,lsr #7
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11]

;@ Do arithmetic:
  mov r0,r0,asl #16
  rsbs r1,r0,r1,asl #16
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: r1 into register[r11]:
  strh r1,[r7,r11]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9068] sub.w ($3333,a0), d0 uses Op9068 ----------
Op9068:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
  mov r11,r11,lsr #7
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11]

;@ Do arithmetic:
  mov r0,r0,asl #16
  rsbs r1,r0,r1,asl #16
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: r1 into register[r11]:
  strh r1,[r7,r11]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9070] sub.w ($33,a0,d3.w*2), d0 uses Op9070 ----------
Op9070:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
  mov r11,r11,lsr #7
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11]

;@ Do arithmetic:
  mov r0,r0,asl #16
  rsbs r1,r0,r1,asl #16
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: r1 into register[r11]:
  strh r1,[r7,r11]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9078] sub.w $3333.w, d0 uses Op9078 ----------
Op9078:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
  mov r11,r11,lsr #7
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11]

;@ Do arithmetic:
  mov r0,r0,asl #16
  rsbs r1,r0,r1,asl #16
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: r1 into register[r11]:
  strh r1,[r7,r11]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9079] sub.w $33333333.l, d0 uses Op9079 ----------
Op9079:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
  mov r11,r11,lsr #7
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11]

;@ Do arithmetic:
  mov r0,r0,asl #16
  rsbs r1,r0,r1,asl #16
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: r1 into register[r11]:
  strh r1,[r7,r11]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [907a] sub.w ($3333,pc), d0; =3335 uses Op907a ----------
Op907a:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r2,r0 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r0:
  bl cyclone_fetch16 ;@ Call fetch16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
  mov r11,r11,lsr #7
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11]

;@ Do arithmetic:
  mov r0,r0,asl #16
  rsbs r1,r0,r1,asl #16
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: r1 into register[r11]:
  strh r1,[r7,r11]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [907b] sub.w ($33,pc,d3.w*2), d0; =35 uses Op907b ----------
Op907b:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r0:
  bl cyclone_fetch16 ;@ Call fetch16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
  mov r11,r11,lsr #7
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11]

;@ Do arithmetic:
  mov r0,r0,asl #16
  rsbs r1,r0,r1,asl #16
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: r1 into register[r11]:
  strh r1,[r7,r11]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [907c] sub.w #$3333, d0 uses Op907c ----------
Op907c:
;@ EaCalc : Get '#$3333' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r0) into r0:

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
  mov r11,r11,lsr #7
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11]

;@ Do arithmetic:
  mov r0,r0,asl #16
  rsbs r1,r0,r1,asl #16
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: r1 into register[r11]:
  strh r1,[r7,r11]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9080] sub.l d0, d0 uses Op9080 ----------
Op9080:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r0:
  ldr r0,[r7,r0,lsl #2]

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  rsbs r1,r0,r1
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9090] sub.l (a0), d0 uses Op9090 ----------
Op9090:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  rsbs r1,r0,r1
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9098] sub.l (a0)+, d0 uses Op9098 ----------
Op9098:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  rsbs r1,r0,r1
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [90a0] sub.l -(a0), d0 uses Op90a0 ----------
Op90a0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  rsbs r1,r0,r1
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [90a8] sub.l ($3333,a0), d0 uses Op90a8 ----------
Op90a8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  rsbs r1,r0,r1
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [90b0] sub.l ($33,a0,d3.w*2), d0 uses Op90b0 ----------
Op90b0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  rsbs r1,r0,r1
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [90b8] sub.l $3333.w, d0 uses Op90b8 ----------
Op90b8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  rsbs r1,r0,r1
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [90b9] sub.l $33333333.l, d0 uses Op90b9 ----------
Op90b9:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  rsbs r1,r0,r1
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [90ba] sub.l ($3333,pc), d0; =3335 uses Op90ba ----------
Op90ba:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r2,r0 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r0:
  bl cyclone_fetch32 ;@ Call fetch32(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  rsbs r1,r0,r1
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [90bb] sub.l ($33,pc,d3.w*2), d0; =35 uses Op90bb ----------
Op90bb:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r0:
  bl cyclone_fetch32 ;@ Call fetch32(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  rsbs r1,r0,r1
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [90bc] sub.l #$33333333, d0 uses Op90bc ----------
Op90bc:
;@ EaCalc : Get '#$33333333' into r0:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r0,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r0) into r0:

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  rsbs r1,r0,r1
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [90c0] suba.w d0, a0 uses Op90c0 ----------
Op90c0:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r0:
  ldr r0,[r7,r0,lsl #2]

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x1e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

  mov r0,r0,asl #16

  sub r1,r1,r0,asr #16

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [90d0] suba.w (a0), a0 uses Op90d0 ----------
Op90d0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x1e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

  mov r0,r0,asl #16

  sub r1,r1,r0,asr #16

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [90d8] suba.w (a0)+, a0 uses Op90d8 ----------
Op90d8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x1e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

  mov r0,r0,asl #16

  sub r1,r1,r0,asr #16

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [90e0] suba.w -(a0), a0 uses Op90e0 ----------
Op90e0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x1e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

  mov r0,r0,asl #16

  sub r1,r1,r0,asr #16

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [90e8] suba.w ($3333,a0), a0 uses Op90e8 ----------
Op90e8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x1e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

  mov r0,r0,asl #16

  sub r1,r1,r0,asr #16

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [90f0] suba.w ($33,a0,d3.w*2), a0 uses Op90f0 ----------
Op90f0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x1e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

  mov r0,r0,asl #16

  sub r1,r1,r0,asr #16

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [90f8] suba.w $3333.w, a0 uses Op90f8 ----------
Op90f8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x1e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

  mov r0,r0,asl #16

  sub r1,r1,r0,asr #16

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [90f9] suba.w $33333333.l, a0 uses Op90f9 ----------
Op90f9:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x1e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

  mov r0,r0,asl #16

  sub r1,r1,r0,asr #16

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [90fa] suba.w ($3333,pc), a0; =3335 uses Op90fa ----------
Op90fa:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r2,r0 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r0:
  bl cyclone_fetch16 ;@ Call fetch16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x1e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

  mov r0,r0,asl #16

  sub r1,r1,r0,asr #16

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [90fb] suba.w ($33,pc,d3.w*2), a0; =35 uses Op90fb ----------
Op90fb:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r0:
  bl cyclone_fetch16 ;@ Call fetch16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x1e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

  mov r0,r0,asl #16

  sub r1,r1,r0,asr #16

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [90fc] suba.w #$3333, a0 uses Op90fc ----------
Op90fc:
;@ EaCalc : Get '#$3333' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r0) into r0:

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x1e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

  mov r0,r0,asl #16

  sub r1,r1,r0,asr #16

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9100] subx.b d0, d0 uses Op9100 ----------
Op9100:
;@ Get src/dest reg vals
;@ EaCalc : Get register index into r6:
  and r6,r8,#0x0007
;@ EaRead : Read register[r6] into r6:
  ldr r6,[r7,r6,lsl #2]

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsr #7]

  mov r6,r6,asl #24

;@ Do arithmetic:
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  mvn r2,r2 ;@ Invert it
  tst r2,r2,lsl #3 ;@ Get into Carry

  rscs r1,r6,r0,asl #24
  orr r3,r10,#0xb0000000 ;@ for old Z
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit
  movs r2,r1,lsr #24
  orreq r10,r10,#0x40000000 ;@ add potentially missed Z
  andeq r10,r10,r3 ;@ fix Z

;@ Save result:
;@ EaWrite: r1 into register[r11]:
  mov r1,r1,lsr #24
  strb r1,[r7,r11,lsr #7]

  ldr r6,[r7,#0x54]
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9108] subx.b -(a0), -(a0) uses Op9108 ----------
Op9108:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get src/dest EA vals
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r6:
  bl cyclone_read8 ;@ Call read8(r0) handler
  mov r6,r0,asl #24

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x1e00
  ldr r11,[r7,r2,lsr #7]
  sub r11,r11,#1 ;@ Pre-decrement An
  str r11,[r7,r2,lsr #7]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

;@ Do arithmetic:
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  mvn r2,r2 ;@ Invert it
  tst r2,r2,lsl #3 ;@ Get into Carry

  rscs r1,r6,r0,asl #24
  orr r3,r10,#0xb0000000 ;@ for old Z
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit
  movs r2,r1,lsr #24
  orreq r10,r10,#0x40000000 ;@ add potentially missed Z
  andeq r10,r10,r3 ;@ fix Z

;@ Save result:
;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r1,r1,lsr #24
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r6,[r7,#0x54]
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [910f] subx.b -(a7), -(a0) uses Op910f ----------
Op910f:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get src/dest EA vals
;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r0) into r6:
  bl cyclone_read8 ;@ Call read8(r0) handler
  mov r6,r0,asl #24

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x1e00
  ldr r11,[r7,r2,lsr #7]
  sub r11,r11,#1 ;@ Pre-decrement An
  str r11,[r7,r2,lsr #7]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

;@ Do arithmetic:
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  mvn r2,r2 ;@ Invert it
  tst r2,r2,lsl #3 ;@ Get into Carry

  rscs r1,r6,r0,asl #24
  orr r3,r10,#0xb0000000 ;@ for old Z
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit
  movs r2,r1,lsr #24
  orreq r10,r10,#0x40000000 ;@ add potentially missed Z
  andeq r10,r10,r3 ;@ fix Z

;@ Save result:
;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r1,r1,lsr #24
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r6,[r7,#0x54]
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9110] sub.b d0, (a0) uses Op9110 ----------
Op9110:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  subs r1,r0,r1,asl #24
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: Write r1 into '(a0)' (address in r11):
  and r1,r1,#0xff
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9118] sub.b d0, (a0)+ uses Op9118 ----------
Op9118:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  subs r1,r0,r1,asl #24
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  and r1,r1,#0xff
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [911f] sub.b d0, (a7)+ uses Op911f ----------
Op911f:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a7)+' into r11:
  ldr r11,[r7,#0x3c] ;@ A7
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  subs r1,r0,r1,asl #24
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: Write r1 into '(a7)+' (address in r11):
  and r1,r1,#0xff
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9120] sub.b d0, -(a0) uses Op9120 ----------
Op9120:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#1 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  subs r1,r0,r1,asl #24
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  and r1,r1,#0xff
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9127] sub.b d0, -(a7) uses Op9127 ----------
Op9127:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a7)' into r11:
  ldr r11,[r7,#0x3c] ;@ A7
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  subs r1,r0,r1,asl #24
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: Write r1 into '-(a7)' (address in r11):
  and r1,r1,#0xff
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9128] sub.b d0, ($3333,a0) uses Op9128 ----------
Op9128:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  subs r1,r0,r1,asl #24
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  and r1,r1,#0xff
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9130] sub.b d0, ($33,a0,d3.w*2) uses Op9130 ----------
Op9130:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  subs r1,r0,r1,asl #24
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  and r1,r1,#0xff
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9138] sub.b d0, $3333.w uses Op9138 ----------
Op9138:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  subs r1,r0,r1,asl #24
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  and r1,r1,#0xff
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9139] sub.b d0, $33333333.l uses Op9139 ----------
Op9139:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  subs r1,r0,r1,asl #24
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  and r1,r1,#0xff
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9140] subx.w d0, d0 uses Op9140 ----------
Op9140:
;@ Get src/dest reg vals
;@ EaCalc : Get register index into r6:
  and r6,r8,#0x0007
;@ EaRead : Read register[r6] into r6:
  ldr r6,[r7,r6,lsl #2]

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
  mov r11,r11,lsr #7
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11]

  mov r6,r6,asl #16

;@ Do arithmetic:
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  mvn r2,r2 ;@ Invert it
  tst r2,r2,lsl #3 ;@ Get into Carry

  rscs r1,r6,r0,asl #16
  orr r3,r10,#0xb0000000 ;@ for old Z
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit
  movs r2,r1,lsr #16
  orreq r10,r10,#0x40000000 ;@ add potentially missed Z
  andeq r10,r10,r3 ;@ fix Z

;@ Save result:
;@ EaWrite: r1 into register[r11]:
  mov r1,r1,lsr #16
  strh r1,[r7,r11]

  ldr r6,[r7,#0x54]
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9148] subx.w -(a0), -(a0) uses Op9148 ----------
Op9148:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get src/dest EA vals
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r6:
  bl cyclone_read16 ;@ Call read16(r0) handler
  mov r6,r0,asl #16

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x1e00
  ldr r11,[r7,r2,lsr #7]
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,r2,lsr #7]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ Do arithmetic:
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  mvn r2,r2 ;@ Invert it
  tst r2,r2,lsl #3 ;@ Get into Carry

  rscs r1,r6,r0,asl #16
  orr r3,r10,#0xb0000000 ;@ for old Z
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit
  movs r2,r1,lsr #16
  orreq r10,r10,#0x40000000 ;@ add potentially missed Z
  andeq r10,r10,r3 ;@ fix Z

;@ Save result:
;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r1,r1,lsr #16
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r6,[r7,#0x54]
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9150] sub.w d0, (a0) uses Op9150 ----------
Op9150:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #16
  subs r1,r0,r1,asl #16
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: Write r1 into '(a0)' (address in r11):
  uxth r1,r1 ;@ zero extend
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9158] sub.w d0, (a0)+ uses Op9158 ----------
Op9158:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #16
  subs r1,r0,r1,asl #16
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  uxth r1,r1 ;@ zero extend
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9160] sub.w d0, -(a0) uses Op9160 ----------
Op9160:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #16
  subs r1,r0,r1,asl #16
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  uxth r1,r1 ;@ zero extend
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9168] sub.w d0, ($3333,a0) uses Op9168 ----------
Op9168:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #16
  subs r1,r0,r1,asl #16
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  uxth r1,r1 ;@ zero extend
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9170] sub.w d0, ($33,a0,d3.w*2) uses Op9170 ----------
Op9170:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #16
  subs r1,r0,r1,asl #16
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  uxth r1,r1 ;@ zero extend
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9178] sub.w d0, $3333.w uses Op9178 ----------
Op9178:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #16
  subs r1,r0,r1,asl #16
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  uxth r1,r1 ;@ zero extend
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9179] sub.w d0, $33333333.l uses Op9179 ----------
Op9179:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #16
  subs r1,r0,r1,asl #16
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  uxth r1,r1 ;@ zero extend
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9180] subx.l d0, d0 uses Op9180 ----------
Op9180:
;@ Get src/dest reg vals
;@ EaCalc : Get register index into r6:
  and r6,r8,#0x0007
;@ EaRead : Read register[r6] into r6:
  ldr r6,[r7,r6,lsl #2]

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsr #7]

;@ Do arithmetic:
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  mvn r2,r2 ;@ Invert it
  tst r2,r2,lsl #3 ;@ Get into Carry

  rscs r1,r6,r0
  orr r3,r10,#0xb0000000 ;@ for old Z
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit
  andeq r10,r10,r3 ;@ fix Z

;@ Save result:
;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r6,[r7,#0x54]
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9188] subx.l -(a0), -(a0) uses Op9188 ----------
Op9188:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get src/dest EA vals
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r6:
  bl cyclone_read32 ;@ Call read32(r0) handler
  mov r6,r0

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x1e00
  ldr r11,[r7,r2,lsr #7]
  sub r11,r11,#4 ;@ Pre-decrement An
  str r11,[r7,r2,lsr #7]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ Do arithmetic:
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  mvn r2,r2 ;@ Invert it
  tst r2,r2,lsl #3 ;@ Get into Carry

  rscs r1,r6,r0
  orr r3,r10,#0xb0000000 ;@ for old Z
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit
  andeq r10,r10,r3 ;@ fix Z

;@ Save result:
;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r0,r11
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r6,[r7,#0x54]
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#30 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9190] sub.l d0, (a0) uses Op9190 ----------
Op9190:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  subs r1,r0,r1
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '(a0)' (address in r11):
  mov r0,r11
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9198] sub.l d0, (a0)+ uses Op9198 ----------
Op9198:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  subs r1,r0,r1
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  mov r0,r11
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [91a0] sub.l d0, -(a0) uses Op91a0 ----------
Op91a0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#4 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  subs r1,r0,r1
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r0,r11
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [91a8] sub.l d0, ($3333,a0) uses Op91a8 ----------
Op91a8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  subs r1,r0,r1
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  mov r0,r11
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [91b0] sub.l d0, ($33,a0,d3.w*2) uses Op91b0 ----------
Op91b0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  subs r1,r0,r1
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  mov r0,r11
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [91b8] sub.l d0, $3333.w uses Op91b8 ----------
Op91b8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  subs r1,r0,r1
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  mov r0,r11
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [91b9] sub.l d0, $33333333.l uses Op91b9 ----------
Op91b9:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  subs r1,r0,r1
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  mov r0,r11
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [91c0] suba.l d0, a0 uses Op91c0 ----------
Op91c0:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r0:
  ldr r0,[r7,r0,lsl #2]

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x1e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

  sub r1,r1,r0

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [91d0] suba.l (a0), a0 uses Op91d0 ----------
Op91d0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x1e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

  sub r1,r1,r0

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [91d8] suba.l (a0)+, a0 uses Op91d8 ----------
Op91d8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x1e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

  sub r1,r1,r0

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [91e0] suba.l -(a0), a0 uses Op91e0 ----------
Op91e0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x1e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

  sub r1,r1,r0

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [91e8] suba.l ($3333,a0), a0 uses Op91e8 ----------
Op91e8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x1e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

  sub r1,r1,r0

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [91f0] suba.l ($33,a0,d3.w*2), a0 uses Op91f0 ----------
Op91f0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x1e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

  sub r1,r1,r0

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [91f8] suba.l $3333.w, a0 uses Op91f8 ----------
Op91f8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x1e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

  sub r1,r1,r0

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [91f9] suba.l $33333333.l, a0 uses Op91f9 ----------
Op91f9:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x1e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

  sub r1,r1,r0

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [91fa] suba.l ($3333,pc), a0; =3335 uses Op91fa ----------
Op91fa:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r2,r0 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r0:
  bl cyclone_fetch32 ;@ Call fetch32(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x1e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

  sub r1,r1,r0

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [91fb] suba.l ($33,pc,d3.w*2), a0; =35 uses Op91fb ----------
Op91fb:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r0:
  bl cyclone_fetch32 ;@ Call fetch32(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x1e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

  sub r1,r1,r0

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [91fc] suba.l #$33333333, a0 uses Op91fc ----------
Op91fc:
;@ EaCalc : Get '#$33333333' into r0:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r0,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r0) into r0:

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x1e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

  sub r1,r1,r0

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9f08] subx.b -(a0), -(a7) uses Op9f08 ----------
Op9f08:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get src/dest EA vals
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r6:
  bl cyclone_read8 ;@ Call read8(r0) handler
  mov r6,r0,asl #24

;@ EaCalc : Get '-(a7)' into r11:
  ldr r11,[r7,#0x3c] ;@ A7
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

;@ Do arithmetic:
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  mvn r2,r2 ;@ Invert it
  tst r2,r2,lsl #3 ;@ Get into Carry

  rscs r1,r6,r0,asl #24
  orr r3,r10,#0xb0000000 ;@ for old Z
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit
  movs r2,r1,lsr #24
  orreq r10,r10,#0x40000000 ;@ add potentially missed Z
  andeq r10,r10,r3 ;@ fix Z

;@ Save result:
;@ EaWrite: Write r1 into '-(a7)' (address in r11):
  mov r1,r1,lsr #24
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r6,[r7,#0x54]
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [9f0f] subx.b -(a7), -(a7) uses Op9f0f ----------
Op9f0f:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get src/dest EA vals
;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r0) into r6:
  bl cyclone_read8 ;@ Call read8(r0) handler
  mov r6,r0,asl #24

;@ EaCalc : Get '-(a7)' into r11:
  ldr r11,[r7,#0x3c] ;@ A7
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

;@ Do arithmetic:
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  mvn r2,r2 ;@ Invert it
  tst r2,r2,lsl #3 ;@ Get into Carry

  rscs r1,r6,r0,asl #24
  orr r3,r10,#0xb0000000 ;@ for old Z
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry
  str r10,[r7,#0x4c] ;@ Save X bit
  movs r2,r1,lsr #24
  orreq r10,r10,#0x40000000 ;@ add potentially missed Z
  andeq r10,r10,r3 ;@ fix Z

;@ Save result:
;@ EaWrite: Write r1 into '-(a7)' (address in r11):
  mov r1,r1,lsr #24
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r6,[r7,#0x54]
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b000] cmp.b d0, d0 uses Opb000 ----------
Opb000:
;@ Get EA into r11 and value into r0:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r0:
  ldr r0,[r7,r0,lsl #2]

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #24

;@ Do arithmetic:
  rsbs r1,r0,r1,asl #24
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b010] cmp.b (a0), d0 uses Opb010 ----------
Opb010:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get EA into r11 and value into r0:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  bl cyclone_read8 ;@ Call read8(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #24

;@ Do arithmetic:
  rsbs r1,r0,r1,asl #24
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b018] cmp.b (a0)+, d0 uses Opb018 ----------
Opb018:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get EA into r11 and value into r0:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  bl cyclone_read8 ;@ Call read8(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #24

;@ Do arithmetic:
  rsbs r1,r0,r1,asl #24
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b01f] cmp.b (a7)+, d0 uses Opb01f ----------
Opb01f:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get EA into r11 and value into r0:
;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r0) into r0:
  bl cyclone_read8 ;@ Call read8(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #24

;@ Do arithmetic:
  rsbs r1,r0,r1,asl #24
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b020] cmp.b -(a0), d0 uses Opb020 ----------
Opb020:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get EA into r11 and value into r0:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  bl cyclone_read8 ;@ Call read8(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #24

;@ Do arithmetic:
  rsbs r1,r0,r1,asl #24
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b027] cmp.b -(a7), d0 uses Opb027 ----------
Opb027:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get EA into r11 and value into r0:
;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r0) into r0:
  bl cyclone_read8 ;@ Call read8(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #24

;@ Do arithmetic:
  rsbs r1,r0,r1,asl #24
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b028] cmp.b ($3333,a0), d0 uses Opb028 ----------
Opb028:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get EA into r11 and value into r0:
;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  bl cyclone_read8 ;@ Call read8(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #24

;@ Do arithmetic:
  rsbs r1,r0,r1,asl #24
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b030] cmp.b ($33,a0,d3.w*2), d0 uses Opb030 ----------
Opb030:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get EA into r11 and value into r0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  bl cyclone_read8 ;@ Call read8(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #24

;@ Do arithmetic:
  rsbs r1,r0,r1,asl #24
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b039] cmp.b $33333333.l, d0 uses Opb039 ----------
Opb039:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get EA into r11 and value into r0:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  bl cyclone_read8 ;@ Call read8(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #24

;@ Do arithmetic:
  rsbs r1,r0,r1,asl #24
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b03a] cmp.b ($3333,pc), d0; =3335 uses Opb03a ----------
Opb03a:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get EA into r11 and value into r0:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r2,r0 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r0:
  bl cyclone_fetch8 ;@ Call fetch8(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #24

;@ Do arithmetic:
  rsbs r1,r0,r1,asl #24
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b03b] cmp.b ($33,pc,d3.w*2), d0; =35 uses Opb03b ----------
Opb03b:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get EA into r11 and value into r0:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r0:
  bl cyclone_fetch8 ;@ Call fetch8(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #24

;@ Do arithmetic:
  rsbs r1,r0,r1,asl #24
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b03c] cmp.b #$33, d0 uses Opb03c ----------
Opb03c:
;@ Get EA into r11 and value into r0:
;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #24

;@ Do arithmetic:
  rsbs r1,r0,r1,asl #24
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b040] cmp.w d0, d0 uses Opb040 ----------
Opb040:
;@ Get EA into r11 and value into r0:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r0:
  ldr r0,[r7,r0,lsl #2]

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #16

;@ Do arithmetic:
  rsbs r1,r0,r1,asl #16
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b050] cmp.w (a0), d0 uses Opb050 ----------
Opb050:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get EA into r11 and value into r0:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #16

;@ Do arithmetic:
  rsbs r1,r0,r1,asl #16
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b058] cmp.w (a0)+, d0 uses Opb058 ----------
Opb058:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get EA into r11 and value into r0:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #16

;@ Do arithmetic:
  rsbs r1,r0,r1,asl #16
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b060] cmp.w -(a0), d0 uses Opb060 ----------
Opb060:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get EA into r11 and value into r0:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #16

;@ Do arithmetic:
  rsbs r1,r0,r1,asl #16
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b068] cmp.w ($3333,a0), d0 uses Opb068 ----------
Opb068:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get EA into r11 and value into r0:
;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #16

;@ Do arithmetic:
  rsbs r1,r0,r1,asl #16
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b070] cmp.w ($33,a0,d3.w*2), d0 uses Opb070 ----------
Opb070:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get EA into r11 and value into r0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #16

;@ Do arithmetic:
  rsbs r1,r0,r1,asl #16
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b078] cmp.w $3333.w, d0 uses Opb078 ----------
Opb078:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get EA into r11 and value into r0:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #16

;@ Do arithmetic:
  rsbs r1,r0,r1,asl #16
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b079] cmp.w $33333333.l, d0 uses Opb079 ----------
Opb079:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get EA into r11 and value into r0:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #16

;@ Do arithmetic:
  rsbs r1,r0,r1,asl #16
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b07a] cmp.w ($3333,pc), d0; =3335 uses Opb07a ----------
Opb07a:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get EA into r11 and value into r0:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r2,r0 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r0:
  bl cyclone_fetch16 ;@ Call fetch16(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #16

;@ Do arithmetic:
  rsbs r1,r0,r1,asl #16
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b07b] cmp.w ($33,pc,d3.w*2), d0; =35 uses Opb07b ----------
Opb07b:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get EA into r11 and value into r0:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r0:
  bl cyclone_fetch16 ;@ Call fetch16(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #16

;@ Do arithmetic:
  rsbs r1,r0,r1,asl #16
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b07c] cmp.w #$3333, d0 uses Opb07c ----------
Opb07c:
;@ Get EA into r11 and value into r0:
;@ EaCalc : Get '#$3333' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r0) into r0:

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #16

;@ Do arithmetic:
  rsbs r1,r0,r1,asl #16
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b080] cmp.l d0, d0 uses Opb080 ----------
Opb080:
;@ Get EA into r11 and value into r0:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r0:
  ldr r0,[r7,r0,lsl #2]

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  rsbs r1,r0,r1
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b090] cmp.l (a0), d0 uses Opb090 ----------
Opb090:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get EA into r11 and value into r0:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  rsbs r1,r0,r1
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b098] cmp.l (a0)+, d0 uses Opb098 ----------
Opb098:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get EA into r11 and value into r0:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  rsbs r1,r0,r1
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b0a0] cmp.l -(a0), d0 uses Opb0a0 ----------
Opb0a0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get EA into r11 and value into r0:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  rsbs r1,r0,r1
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b0a8] cmp.l ($3333,a0), d0 uses Opb0a8 ----------
Opb0a8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get EA into r11 and value into r0:
;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  rsbs r1,r0,r1
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b0b0] cmp.l ($33,a0,d3.w*2), d0 uses Opb0b0 ----------
Opb0b0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get EA into r11 and value into r0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  rsbs r1,r0,r1
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b0b9] cmp.l $33333333.l, d0 uses Opb0b9 ----------
Opb0b9:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get EA into r11 and value into r0:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  rsbs r1,r0,r1
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b0ba] cmp.l ($3333,pc), d0; =3335 uses Opb0ba ----------
Opb0ba:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get EA into r11 and value into r0:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r2,r0 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r0:
  bl cyclone_fetch32 ;@ Call fetch32(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  rsbs r1,r0,r1
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b0bb] cmp.l ($33,pc,d3.w*2), d0; =35 uses Opb0bb ----------
Opb0bb:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get EA into r11 and value into r0:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r0:
  bl cyclone_fetch32 ;@ Call fetch32(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  rsbs r1,r0,r1
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b0bc] cmp.l #$33333333, d0 uses Opb0bc ----------
Opb0bc:
;@ Get EA into r11 and value into r0:
;@ EaCalc : Get '#$33333333' into r0:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r0,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r0) into r0:

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  rsbs r1,r0,r1
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b0c0] cmpa.w d0, a0 uses Opb0c0 ----------
Opb0c0:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r0:
  ldr r0,[r7,r0,lsl #2]

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x1e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #16

  cmp r1,r0,asr #16 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b0d0] cmpa.w (a0), a0 uses Opb0d0 ----------
Opb0d0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x1e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #16

  cmp r1,r0,asr #16 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b0d8] cmpa.w (a0)+, a0 uses Opb0d8 ----------
Opb0d8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x1e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #16

  cmp r1,r0,asr #16 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b0e0] cmpa.w -(a0), a0 uses Opb0e0 ----------
Opb0e0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x1e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #16

  cmp r1,r0,asr #16 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b0e8] cmpa.w ($3333,a0), a0 uses Opb0e8 ----------
Opb0e8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x1e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #16

  cmp r1,r0,asr #16 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b0f0] cmpa.w ($33,a0,d3.w*2), a0 uses Opb0f0 ----------
Opb0f0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x1e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #16

  cmp r1,r0,asr #16 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b0f8] cmpa.w $3333.w, a0 uses Opb0f8 ----------
Opb0f8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x1e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #16

  cmp r1,r0,asr #16 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b0f9] cmpa.w $33333333.l, a0 uses Opb0f9 ----------
Opb0f9:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x1e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #16

  cmp r1,r0,asr #16 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b0fa] cmpa.w ($3333,pc), a0; =3335 uses Opb0fa ----------
Opb0fa:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r2,r0 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r0:
  bl cyclone_fetch16 ;@ Call fetch16(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x1e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #16

  cmp r1,r0,asr #16 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b0fb] cmpa.w ($33,pc,d3.w*2), a0; =35 uses Opb0fb ----------
Opb0fb:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r0:
  bl cyclone_fetch16 ;@ Call fetch16(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x1e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #16

  cmp r1,r0,asr #16 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b0fc] cmpa.w #$3333, a0 uses Opb0fc ----------
Opb0fc:
;@ EaCalc : Get '#$3333' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r0) into r0:

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x1e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #16

  cmp r1,r0,asr #16 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b100] eor.b d0, d0 uses Opb100 ----------
Opb100:
;@ Get EA into r11 and value into r0:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #24

;@ Do arithmetic:
  eors r1,r0,r1,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: r1 into register[r11]:
  mov r1,r1,lsr #24
  strb r1,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b108] cmpm.b (a0)+, (a0)+ uses Opb108 ----------
Opb108:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get src operand into r11:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r11:
  bl cyclone_read8 ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get dst operand into r0:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  bl cyclone_read8 ;@ Call read8(r0) handler

  rsbs r0,r11,r0,asl #24
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b10f] cmpm.b (a7)+, (a0)+ uses Opb10f ----------
Opb10f:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get src operand into r11:
;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r0) into r11:
  bl cyclone_read8 ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get dst operand into r0:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  bl cyclone_read8 ;@ Call read8(r0) handler

  rsbs r0,r11,r0,asl #24
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b110] eor.b d0, (a0) uses Opb110 ----------
Opb110:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get EA into r11 and value into r0:
;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #24

;@ Do arithmetic:
  eors r1,r0,r1,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  mov r1,r1,lsr #24
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b118] eor.b d0, (a0)+ uses Opb118 ----------
Opb118:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get EA into r11 and value into r0:
;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #24

;@ Do arithmetic:
  eors r1,r0,r1,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  mov r1,r1,lsr #24
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b11f] eor.b d0, (a7)+ uses Opb11f ----------
Opb11f:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get EA into r11 and value into r0:
;@ EaCalc : Get '(a7)+' into r11:
  ldr r11,[r7,#0x3c] ;@ A7
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #24

;@ Do arithmetic:
  eors r1,r0,r1,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '(a7)+' (address in r11):
  mov r1,r1,lsr #24
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b120] eor.b d0, -(a0) uses Opb120 ----------
Opb120:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get EA into r11 and value into r0:
;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#1 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #24

;@ Do arithmetic:
  eors r1,r0,r1,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r1,r1,lsr #24
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b127] eor.b d0, -(a7) uses Opb127 ----------
Opb127:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get EA into r11 and value into r0:
;@ EaCalc : Get '-(a7)' into r11:
  ldr r11,[r7,#0x3c] ;@ A7
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #24

;@ Do arithmetic:
  eors r1,r0,r1,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '-(a7)' (address in r11):
  mov r1,r1,lsr #24
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b128] eor.b d0, ($3333,a0) uses Opb128 ----------
Opb128:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get EA into r11 and value into r0:
;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #24

;@ Do arithmetic:
  eors r1,r0,r1,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  mov r1,r1,lsr #24
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b130] eor.b d0, ($33,a0,d3.w*2) uses Opb130 ----------
Opb130:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get EA into r11 and value into r0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #24

;@ Do arithmetic:
  eors r1,r0,r1,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  mov r1,r1,lsr #24
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b138] eor.b d0, $3333.w uses Opb138 ----------
Opb138:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get EA into r11 and value into r0:
;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #24

;@ Do arithmetic:
  eors r1,r0,r1,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  mov r1,r1,lsr #24
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b139] eor.b d0, $33333333.l uses Opb139 ----------
Opb139:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get EA into r11 and value into r0:
;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #24

;@ Do arithmetic:
  eors r1,r0,r1,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  mov r1,r1,lsr #24
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b140] eor.w d0, d0 uses Opb140 ----------
Opb140:
;@ Get EA into r11 and value into r0:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
  mov r11,r11,lsl #2
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11]

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #16

;@ Do arithmetic:
  eors r1,r0,r1,asl #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: r1 into register[r11]:
  mov r1,r1,lsr #16
  strh r1,[r7,r11]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b148] cmpm.w (a0)+, (a0)+ uses Opb148 ----------
Opb148:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get src operand into r11:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r11:
  bl cyclone_read16 ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ Get dst operand into r0:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  bl cyclone_read16 ;@ Call read16(r0) handler

  rsbs r0,r11,r0,asl #16
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b150] eor.w d0, (a0) uses Opb150 ----------
Opb150:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get EA into r11 and value into r0:
;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #16

;@ Do arithmetic:
  eors r1,r0,r1,asl #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  mov r1,r1,lsr #16
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b158] eor.w d0, (a0)+ uses Opb158 ----------
Opb158:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get EA into r11 and value into r0:
;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #16

;@ Do arithmetic:
  eors r1,r0,r1,asl #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  mov r1,r1,lsr #16
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b160] eor.w d0, -(a0) uses Opb160 ----------
Opb160:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get EA into r11 and value into r0:
;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #16

;@ Do arithmetic:
  eors r1,r0,r1,asl #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r1,r1,lsr #16
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b168] eor.w d0, ($3333,a0) uses Opb168 ----------
Opb168:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get EA into r11 and value into r0:
;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #16

;@ Do arithmetic:
  eors r1,r0,r1,asl #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  mov r1,r1,lsr #16
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b170] eor.w d0, ($33,a0,d3.w*2) uses Opb170 ----------
Opb170:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get EA into r11 and value into r0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #16

;@ Do arithmetic:
  eors r1,r0,r1,asl #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  mov r1,r1,lsr #16
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b178] eor.w d0, $3333.w uses Opb178 ----------
Opb178:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get EA into r11 and value into r0:
;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #16

;@ Do arithmetic:
  eors r1,r0,r1,asl #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  mov r1,r1,lsr #16
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b179] eor.w d0, $33333333.l uses Opb179 ----------
Opb179:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get EA into r11 and value into r0:
;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #16

;@ Do arithmetic:
  eors r1,r0,r1,asl #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  mov r1,r1,lsr #16
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b180] eor.l d0, d0 uses Opb180 ----------
Opb180:
;@ Get EA into r11 and value into r0:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  eors r1,r0,r1
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b188] cmpm.l (a0)+, (a0)+ uses Opb188 ----------
Opb188:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get src operand into r11:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r11:
  bl cyclone_read32 ;@ Call read32(r0) handler
  mov r11,r0

;@ Get dst operand into r0:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  bl cyclone_read32 ;@ Call read32(r0) handler

  rsbs r0,r11,r0
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b190] eor.l d0, (a0) uses Opb190 ----------
Opb190:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get EA into r11 and value into r0:
;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  eors r1,r0,r1
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  mov r0,r11
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b198] eor.l d0, (a0)+ uses Opb198 ----------
Opb198:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get EA into r11 and value into r0:
;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  eors r1,r0,r1
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  mov r0,r11
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b1a0] eor.l d0, -(a0) uses Opb1a0 ----------
Opb1a0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get EA into r11 and value into r0:
;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#4 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  eors r1,r0,r1
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r0,r11
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b1a8] eor.l d0, ($3333,a0) uses Opb1a8 ----------
Opb1a8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get EA into r11 and value into r0:
;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  eors r1,r0,r1
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  mov r0,r11
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b1b0] eor.l d0, ($33,a0,d3.w*2) uses Opb1b0 ----------
Opb1b0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get EA into r11 and value into r0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  eors r1,r0,r1
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  mov r0,r11
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b1b8] eor.l d0, $3333.w uses Opb1b8 ----------
Opb1b8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get EA into r11 and value into r0:
;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  eors r1,r0,r1
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  mov r0,r11
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b1b9] eor.l d0, $33333333.l uses Opb1b9 ----------
Opb1b9:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get EA into r11 and value into r0:
;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  eors r1,r0,r1
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  mov r0,r11
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b1c0] cmpa.l d0, a0 uses Opb1c0 ----------
Opb1c0:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r0:
  ldr r0,[r7,r0,lsl #2]

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x1e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  cmp r1,r0 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b1d0] cmpa.l (a0), a0 uses Opb1d0 ----------
Opb1d0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x1e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  cmp r1,r0 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b1d8] cmpa.l (a0)+, a0 uses Opb1d8 ----------
Opb1d8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x1e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  cmp r1,r0 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b1e0] cmpa.l -(a0), a0 uses Opb1e0 ----------
Opb1e0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x1e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  cmp r1,r0 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b1e8] cmpa.l ($3333,a0), a0 uses Opb1e8 ----------
Opb1e8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x1e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  cmp r1,r0 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b1f0] cmpa.l ($33,a0,d3.w*2), a0 uses Opb1f0 ----------
Opb1f0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x1e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  cmp r1,r0 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b1f8] cmpa.l $3333.w, a0 uses Opb1f8 ----------
Opb1f8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x1e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  cmp r1,r0 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b1f9] cmpa.l $33333333.l, a0 uses Opb1f9 ----------
Opb1f9:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x1e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  cmp r1,r0 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b1fa] cmpa.l ($3333,pc), a0; =3335 uses Opb1fa ----------
Opb1fa:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r2,r0 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r0:
  bl cyclone_fetch32 ;@ Call fetch32(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x1e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  cmp r1,r0 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b1fb] cmpa.l ($33,pc,d3.w*2), a0; =35 uses Opb1fb ----------
Opb1fb:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r0:
  bl cyclone_fetch32 ;@ Call fetch32(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x1e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  cmp r1,r0 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [b1fc] cmpa.l #$33333333, a0 uses Opb1fc ----------
Opb1fc:
;@ EaCalc : Get '#$33333333' into r0:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r0,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r0) into r0:

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x1e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  cmp r1,r0 ;@ Defines NZCV
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [bf08] cmpm.b (a0)+, (a7)+ uses Opbf08 ----------
Opbf08:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get src operand into r11:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r11:
  bl cyclone_read8 ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get dst operand into r0:
;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r0) into r0:
  bl cyclone_read8 ;@ Call read8(r0) handler

  rsbs r0,r11,r0,asl #24
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [bf0f] cmpm.b (a7)+, (a7)+ uses Opbf0f ----------
Opbf0f:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get src operand into r11:
;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r0) into r11:
  bl cyclone_read8 ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ Get dst operand into r0:
;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r0) into r0:
  bl cyclone_read8 ;@ Call read8(r0) handler

  rsbs r0,r11,r0,asl #24
  mrs r10,cpsr ;@ r10=flags
  eor r10,r10,#0x20000000 ;@ Invert carry

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c000] and.b d0, d0 uses Opc000 ----------
Opc000:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r0:
  ldr r0,[r7,r0,lsl #2]

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  ands r1,r0,r1,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r11]:
  strb r1,[r7,r11,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c010] and.b (a0), d0 uses Opc010 ----------
Opc010:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  bl cyclone_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  ands r1,r0,r1,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r11]:
  strb r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c018] and.b (a0)+, d0 uses Opc018 ----------
Opc018:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  bl cyclone_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  ands r1,r0,r1,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r11]:
  strb r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c01f] and.b (a7)+, d0 uses Opc01f ----------
Opc01f:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r0) into r0:
  bl cyclone_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  ands r1,r0,r1,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r11]:
  strb r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c020] and.b -(a0), d0 uses Opc020 ----------
Opc020:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  bl cyclone_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  ands r1,r0,r1,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r11]:
  strb r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c027] and.b -(a7), d0 uses Opc027 ----------
Opc027:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r0) into r0:
  bl cyclone_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  ands r1,r0,r1,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r11]:
  strb r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c028] and.b ($3333,a0), d0 uses Opc028 ----------
Opc028:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  bl cyclone_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  ands r1,r0,r1,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r11]:
  strb r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c030] and.b ($33,a0,d3.w*2), d0 uses Opc030 ----------
Opc030:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  bl cyclone_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  ands r1,r0,r1,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r11]:
  strb r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c038] and.b $3333.w, d0 uses Opc038 ----------
Opc038:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  bl cyclone_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  ands r1,r0,r1,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r11]:
  strb r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c039] and.b $33333333.l, d0 uses Opc039 ----------
Opc039:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  bl cyclone_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  ands r1,r0,r1,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r11]:
  strb r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c03a] and.b ($3333,pc), d0; =3335 uses Opc03a ----------
Opc03a:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r2,r0 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r0:
  bl cyclone_fetch8 ;@ Call fetch8(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  ands r1,r0,r1,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r11]:
  strb r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c03b] and.b ($33,pc,d3.w*2), d0; =35 uses Opc03b ----------
Opc03b:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r0:
  bl cyclone_fetch8 ;@ Call fetch8(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  ands r1,r0,r1,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r11]:
  strb r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c03c] and.b #$33, d0 uses Opc03c ----------
Opc03c:
;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  ands r1,r0,r1,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r11]:
  strb r1,[r7,r11,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c050] and.w (a0), d0 uses Opc050 ----------
Opc050:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
  mov r11,r11,lsr #7
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11]

;@ Do arithmetic:
  mov r0,r0,asl #16
  ands r1,r0,r1,asl #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: r1 into register[r11]:
  strh r1,[r7,r11]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c058] and.w (a0)+, d0 uses Opc058 ----------
Opc058:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
  mov r11,r11,lsr #7
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11]

;@ Do arithmetic:
  mov r0,r0,asl #16
  ands r1,r0,r1,asl #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: r1 into register[r11]:
  strh r1,[r7,r11]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c060] and.w -(a0), d0 uses Opc060 ----------
Opc060:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
  mov r11,r11,lsr #7
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11]

;@ Do arithmetic:
  mov r0,r0,asl #16
  ands r1,r0,r1,asl #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: r1 into register[r11]:
  strh r1,[r7,r11]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c068] and.w ($3333,a0), d0 uses Opc068 ----------
Opc068:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
  mov r11,r11,lsr #7
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11]

;@ Do arithmetic:
  mov r0,r0,asl #16
  ands r1,r0,r1,asl #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: r1 into register[r11]:
  strh r1,[r7,r11]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c070] and.w ($33,a0,d3.w*2), d0 uses Opc070 ----------
Opc070:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
  mov r11,r11,lsr #7
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11]

;@ Do arithmetic:
  mov r0,r0,asl #16
  ands r1,r0,r1,asl #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: r1 into register[r11]:
  strh r1,[r7,r11]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c078] and.w $3333.w, d0 uses Opc078 ----------
Opc078:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
  mov r11,r11,lsr #7
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11]

;@ Do arithmetic:
  mov r0,r0,asl #16
  ands r1,r0,r1,asl #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: r1 into register[r11]:
  strh r1,[r7,r11]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c079] and.w $33333333.l, d0 uses Opc079 ----------
Opc079:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
  mov r11,r11,lsr #7
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11]

;@ Do arithmetic:
  mov r0,r0,asl #16
  ands r1,r0,r1,asl #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: r1 into register[r11]:
  strh r1,[r7,r11]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c07a] and.w ($3333,pc), d0; =3335 uses Opc07a ----------
Opc07a:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r2,r0 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r0:
  bl cyclone_fetch16 ;@ Call fetch16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
  mov r11,r11,lsr #7
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11]

;@ Do arithmetic:
  mov r0,r0,asl #16
  ands r1,r0,r1,asl #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: r1 into register[r11]:
  strh r1,[r7,r11]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c07b] and.w ($33,pc,d3.w*2), d0; =35 uses Opc07b ----------
Opc07b:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r0:
  bl cyclone_fetch16 ;@ Call fetch16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
  mov r11,r11,lsr #7
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11]

;@ Do arithmetic:
  mov r0,r0,asl #16
  ands r1,r0,r1,asl #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: r1 into register[r11]:
  strh r1,[r7,r11]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c07c] and.w #$3333, d0 uses Opc07c ----------
Opc07c:
;@ EaCalc : Get '#$3333' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r0) into r0:

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
  mov r11,r11,lsr #7
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11]

;@ Do arithmetic:
  mov r0,r0,asl #16
  ands r1,r0,r1,asl #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: r1 into register[r11]:
  strh r1,[r7,r11]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c080] and.l d0, d0 uses Opc080 ----------
Opc080:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r0:
  ldr r0,[r7,r0,lsl #2]

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  ands r1,r0,r1
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c090] and.l (a0), d0 uses Opc090 ----------
Opc090:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  ands r1,r0,r1
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c098] and.l (a0)+, d0 uses Opc098 ----------
Opc098:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  ands r1,r0,r1
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c0a0] and.l -(a0), d0 uses Opc0a0 ----------
Opc0a0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  ands r1,r0,r1
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c0a8] and.l ($3333,a0), d0 uses Opc0a8 ----------
Opc0a8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  ands r1,r0,r1
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c0b0] and.l ($33,a0,d3.w*2), d0 uses Opc0b0 ----------
Opc0b0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  ands r1,r0,r1
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c0b8] and.l $3333.w, d0 uses Opc0b8 ----------
Opc0b8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  ands r1,r0,r1
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c0b9] and.l $33333333.l, d0 uses Opc0b9 ----------
Opc0b9:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  ands r1,r0,r1
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c0ba] and.l ($3333,pc), d0; =3335 uses Opc0ba ----------
Opc0ba:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r2,r0 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r0:
  bl cyclone_fetch32 ;@ Call fetch32(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  ands r1,r0,r1
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c0bb] and.l ($33,pc,d3.w*2), d0; =35 uses Opc0bb ----------
Opc0bb:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r0:
  bl cyclone_fetch32 ;@ Call fetch32(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  ands r1,r0,r1
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c0bc] and.l #$33333333, d0 uses Opc0bc ----------
Opc0bc:
;@ EaCalc : Get '#$33333333' into r0:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r0,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r0) into r0:

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  ands r1,r0,r1
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c0c0] mulu.w d0, d0 uses Opc0c0 ----------
Opc0c0:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r0:
  ldr r0,[r7,r0,lsl #2]

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r2:
  ldr r2,[r7,r11,lsr #7]

  movs r1,r0,asl #16
;@ Get 16-bit signs right:
  mov r0,r1,lsr #16
  mov r2,r2,lsl #16
  mov r2,r2,lsr #16

  muls r1,r2,r0
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#54 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c0d0] mulu.w (a0), d0 uses Opc0d0 ----------
Opc0d0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r2:
  ldr r2,[r7,r11,lsr #7]

  movs r1,r0,asl #16
;@ Get 16-bit signs right:
  mov r0,r1,lsr #16
  mov r2,r2,lsl #16
  mov r2,r2,lsr #16

  muls r1,r2,r0
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#58 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c0d8] mulu.w (a0)+, d0 uses Opc0d8 ----------
Opc0d8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r2:
  ldr r2,[r7,r11,lsr #7]

  movs r1,r0,asl #16
;@ Get 16-bit signs right:
  mov r0,r1,lsr #16
  mov r2,r2,lsl #16
  mov r2,r2,lsr #16

  muls r1,r2,r0
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#58 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c0e0] mulu.w -(a0), d0 uses Opc0e0 ----------
Opc0e0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r2:
  ldr r2,[r7,r11,lsr #7]

  movs r1,r0,asl #16
;@ Get 16-bit signs right:
  mov r0,r1,lsr #16
  mov r2,r2,lsl #16
  mov r2,r2,lsr #16

  muls r1,r2,r0
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#60 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c0e8] mulu.w ($3333,a0), d0 uses Opc0e8 ----------
Opc0e8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r2:
  ldr r2,[r7,r11,lsr #7]

  movs r1,r0,asl #16
;@ Get 16-bit signs right:
  mov r0,r1,lsr #16
  mov r2,r2,lsl #16
  mov r2,r2,lsr #16

  muls r1,r2,r0
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#62 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c0f0] mulu.w ($33,a0,d3.w*2), d0 uses Opc0f0 ----------
Opc0f0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r2:
  ldr r2,[r7,r11,lsr #7]

  movs r1,r0,asl #16
;@ Get 16-bit signs right:
  mov r0,r1,lsr #16
  mov r2,r2,lsl #16
  mov r2,r2,lsr #16

  muls r1,r2,r0
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#64 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c0f8] mulu.w $3333.w, d0 uses Opc0f8 ----------
Opc0f8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r2:
  ldr r2,[r7,r11,lsr #7]

  movs r1,r0,asl #16
;@ Get 16-bit signs right:
  mov r0,r1,lsr #16
  mov r2,r2,lsl #16
  mov r2,r2,lsr #16

  muls r1,r2,r0
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#62 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c0f9] mulu.w $33333333.l, d0 uses Opc0f9 ----------
Opc0f9:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r2:
  ldr r2,[r7,r11,lsr #7]

  movs r1,r0,asl #16
;@ Get 16-bit signs right:
  mov r0,r1,lsr #16
  mov r2,r2,lsl #16
  mov r2,r2,lsr #16

  muls r1,r2,r0
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#66 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c0fa] mulu.w ($3333,pc), d0; =3335 uses Opc0fa ----------
Opc0fa:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r2,r0 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r0:
  bl cyclone_fetch16 ;@ Call fetch16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r2:
  ldr r2,[r7,r11,lsr #7]

  movs r1,r0,asl #16
;@ Get 16-bit signs right:
  mov r0,r1,lsr #16
  mov r2,r2,lsl #16
  mov r2,r2,lsr #16

  muls r1,r2,r0
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#62 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c0fb] mulu.w ($33,pc,d3.w*2), d0; =35 uses Opc0fb ----------
Opc0fb:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r0:
  bl cyclone_fetch16 ;@ Call fetch16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r2:
  ldr r2,[r7,r11,lsr #7]

  movs r1,r0,asl #16
;@ Get 16-bit signs right:
  mov r0,r1,lsr #16
  mov r2,r2,lsl #16
  mov r2,r2,lsr #16

  muls r1,r2,r0
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#64 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c0fc] mulu.w #$3333, d0 uses Opc0fc ----------
Opc0fc:
;@ EaCalc : Get '#$3333' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r0) into r0:

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r2:
  ldr r2,[r7,r11,lsr #7]

  movs r1,r0,asl #16
;@ Get 16-bit signs right:
  mov r0,r1,lsr #16
  mov r2,r2,lsl #16
  mov r2,r2,lsr #16

  muls r1,r2,r0
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#58 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c100] abcd d0, d0 uses Opc100 ----------
Opc100:
;@ Get src/dest reg vals
;@ EaCalc : Get register index into r6:
  and r6,r8,#0x0007
;@ EaRead : Read register[r6] into r6:
  ldr r6,[r7,r6,lsl #2]

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsr #7]

  bic r10,r10,#0xb1000000 ;@ clear all flags except old Z
  ldr r1,[r7,#0x4c] ;@ Get X bit
  and r2,r0,#0x0f
  movs r12,r1,lsl #3 ;@ X into carry
  and r1,r6,#0x0f
  adc r1,r2,r1
  cmp r1,#9
  and r0,r0,#0xf0
  and r6,r6,#0xf0
  add r1,r1,r0
  add r1,r1,r6
  mov r12,r1
  addhi r12,#6 ;@ Decimal adjust units
  tst r1,#0x80
  orreq r10,r10,#0x10000000 ;@ Undefined V behavior
  cmp r12,#0x9f
  orrhi r10,r10,#0x20000000 ;@ C
  subhi r12,r12,#0xa0
  movs r0,r12,lsl #24
  bicpl r10,r10,#0x10000000 ;@ Undefined V behavior part II
  orrmi r10,r10,#0x80000000 ;@ Undefined N behavior
  bicne r10,r10,#0x40000000 ;@ Z flag
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: r0 into register[r11]:
  mov r0,r0,lsr #24
  strb r0,[r7,r11,lsr #7]

  ldr r6,[r7,#0x54]
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c108] abcd -(a0), -(a0) uses Opc108 ----------
Opc108:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get src/dest EA vals
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r6:
  bl cyclone_read8 ;@ Call read8(r0) handler
  mov r6,r0

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r11,[r7,r2,lsr #7]
  sub r11,r11,#1 ;@ Pre-decrement An
  str r11,[r7,r2,lsr #7]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

  bic r10,r10,#0xb1000000 ;@ clear all flags except old Z
  ldr r1,[r7,#0x4c] ;@ Get X bit
  and r2,r0,#0x0f
  movs r12,r1,lsl #3 ;@ X into carry
  and r1,r6,#0x0f
  adc r1,r2,r1
  cmp r1,#9
  and r0,r0,#0xf0
  and r6,r6,#0xf0
  add r1,r1,r0
  add r1,r1,r6
  mov r12,r1
  addhi r12,#6 ;@ Decimal adjust units
  tst r1,#0x80
  orreq r10,r10,#0x10000000 ;@ Undefined V behavior
  cmp r12,#0x9f
  orrhi r10,r10,#0x20000000 ;@ C
  subhi r12,r12,#0xa0
  movs r0,r12,lsl #24
  bicpl r10,r10,#0x10000000 ;@ Undefined V behavior part II
  orrmi r10,r10,#0x80000000 ;@ Undefined N behavior
  bicne r10,r10,#0x40000000 ;@ Z flag
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r0 into '-(a0)' (address in r11):
  mov r1,r0,lsr #24
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r6,[r7,#0x54]
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c10f] abcd -(a7), -(a0) uses Opc10f ----------
Opc10f:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get src/dest EA vals
;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r0) into r6:
  bl cyclone_read8 ;@ Call read8(r0) handler
  mov r6,r0

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r11,[r7,r2,lsr #7]
  sub r11,r11,#1 ;@ Pre-decrement An
  str r11,[r7,r2,lsr #7]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

  bic r10,r10,#0xb1000000 ;@ clear all flags except old Z
  ldr r1,[r7,#0x4c] ;@ Get X bit
  and r2,r0,#0x0f
  movs r12,r1,lsl #3 ;@ X into carry
  and r1,r6,#0x0f
  adc r1,r2,r1
  cmp r1,#9
  and r0,r0,#0xf0
  and r6,r6,#0xf0
  add r1,r1,r0
  add r1,r1,r6
  mov r12,r1
  addhi r12,#6 ;@ Decimal adjust units
  tst r1,#0x80
  orreq r10,r10,#0x10000000 ;@ Undefined V behavior
  cmp r12,#0x9f
  orrhi r10,r10,#0x20000000 ;@ C
  subhi r12,r12,#0xa0
  movs r0,r12,lsl #24
  bicpl r10,r10,#0x10000000 ;@ Undefined V behavior part II
  orrmi r10,r10,#0x80000000 ;@ Undefined N behavior
  bicne r10,r10,#0x40000000 ;@ Z flag
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r0 into '-(a0)' (address in r11):
  mov r1,r0,lsr #24
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r6,[r7,#0x54]
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c110] and.b d0, (a0) uses Opc110 ----------
Opc110:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  ands r1,r0,r1,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: Write r1 into '(a0)' (address in r11):
  and r1,r1,#0xff
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c118] and.b d0, (a0)+ uses Opc118 ----------
Opc118:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  ands r1,r0,r1,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  and r1,r1,#0xff
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c11f] and.b d0, (a7)+ uses Opc11f ----------
Opc11f:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a7)+' into r11:
  ldr r11,[r7,#0x3c] ;@ A7
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  ands r1,r0,r1,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: Write r1 into '(a7)+' (address in r11):
  and r1,r1,#0xff
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c120] and.b d0, -(a0) uses Opc120 ----------
Opc120:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#1 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  ands r1,r0,r1,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  and r1,r1,#0xff
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c127] and.b d0, -(a7) uses Opc127 ----------
Opc127:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a7)' into r11:
  ldr r11,[r7,#0x3c] ;@ A7
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  ands r1,r0,r1,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: Write r1 into '-(a7)' (address in r11):
  and r1,r1,#0xff
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c128] and.b d0, ($3333,a0) uses Opc128 ----------
Opc128:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  ands r1,r0,r1,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  and r1,r1,#0xff
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c130] and.b d0, ($33,a0,d3.w*2) uses Opc130 ----------
Opc130:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  ands r1,r0,r1,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  and r1,r1,#0xff
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c138] and.b d0, $3333.w uses Opc138 ----------
Opc138:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  ands r1,r0,r1,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  and r1,r1,#0xff
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c139] and.b d0, $33333333.l uses Opc139 ----------
Opc139:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  ands r1,r0,r1,asl #24
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  and r1,r1,#0xff
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c140] exg d0, d0 uses Opc140 ----------
Opc140:
  and r2,r8,#0x0e00 ;@ Find T register
  and r3,r8,#0x000f ;@ Find S register

  ldr r0,[r7,r2,lsr #7] ;@ Get T
  ldr r1,[r7,r3,lsl #2] ;@ Get S

  str r0,[r7,r3,lsl #2] ;@ T->S
  str r1,[r7,r2,lsr #7] ;@ S->T

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c148] exg a0, a0 uses Opc148 ----------
Opc148:
  and r2,r8,#0x0e00 ;@ Find T register
  and r3,r8,#0x000f ;@ Find S register
  orr r2,r2,#0x1000 ;@ T is an address register

  ldr r0,[r7,r2,lsr #7] ;@ Get T
  ldr r1,[r7,r3,lsl #2] ;@ Get S

  str r0,[r7,r3,lsl #2] ;@ T->S
  str r1,[r7,r2,lsr #7] ;@ S->T

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c150] and.w d0, (a0) uses Opc150 ----------
Opc150:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #16
  ands r1,r0,r1,asl #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: Write r1 into '(a0)' (address in r11):
  uxth r1,r1 ;@ zero extend
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c158] and.w d0, (a0)+ uses Opc158 ----------
Opc158:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #16
  ands r1,r0,r1,asl #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  uxth r1,r1 ;@ zero extend
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c160] and.w d0, -(a0) uses Opc160 ----------
Opc160:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #16
  ands r1,r0,r1,asl #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  uxth r1,r1 ;@ zero extend
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c168] and.w d0, ($3333,a0) uses Opc168 ----------
Opc168:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #16
  ands r1,r0,r1,asl #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  uxth r1,r1 ;@ zero extend
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c170] and.w d0, ($33,a0,d3.w*2) uses Opc170 ----------
Opc170:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #16
  ands r1,r0,r1,asl #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  uxth r1,r1 ;@ zero extend
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c178] and.w d0, $3333.w uses Opc178 ----------
Opc178:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #16
  ands r1,r0,r1,asl #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  uxth r1,r1 ;@ zero extend
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c179] and.w d0, $33333333.l uses Opc179 ----------
Opc179:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #16
  ands r1,r0,r1,asl #16
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  uxth r1,r1 ;@ zero extend
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c188] exg a0, d0 uses Opc188 ----------
Opc188:
  and r2,r8,#0x0e00 ;@ Find T register
  and r3,r8,#0x000f ;@ Find S register

  ldr r0,[r7,r2,lsr #7] ;@ Get T
  ldr r1,[r7,r3,lsl #2] ;@ Get S

  str r0,[r7,r3,lsl #2] ;@ T->S
  str r1,[r7,r2,lsr #7] ;@ S->T

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c190] and.l d0, (a0) uses Opc190 ----------
Opc190:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  ands r1,r0,r1
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
;@ EaWrite: Write r1 into '(a0)' (address in r11):
  mov r0,r11
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c198] and.l d0, (a0)+ uses Opc198 ----------
Opc198:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  ands r1,r0,r1
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  mov r0,r11
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c1a0] and.l d0, -(a0) uses Opc1a0 ----------
Opc1a0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#4 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  ands r1,r0,r1
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r0,r11
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c1a8] and.l d0, ($3333,a0) uses Opc1a8 ----------
Opc1a8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  ands r1,r0,r1
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  mov r0,r11
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c1b0] and.l d0, ($33,a0,d3.w*2) uses Opc1b0 ----------
Opc1b0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  ands r1,r0,r1
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  mov r0,r11
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c1b8] and.l d0, $3333.w uses Opc1b8 ----------
Opc1b8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  ands r1,r0,r1
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  mov r0,r11
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c1b9] and.l d0, $33333333.l uses Opc1b9 ----------
Opc1b9:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  ands r1,r0,r1
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ Save result:
;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  mov r0,r11
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c1c0] muls.w d0, d0 uses Opc1c0 ----------
Opc1c0:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r0:
  ldr r0,[r7,r0,lsl #2]

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r2:
  ldr r2,[r7,r11,lsr #7]

  movs r1,r0,asl #16
;@ Get 16-bit signs right:
  mov r0,r1,asr #16
  mov r2,r2,lsl #16
  mov r2,r2,asr #16

  muls r1,r2,r0
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#54 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c1d0] muls.w (a0), d0 uses Opc1d0 ----------
Opc1d0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r2:
  ldr r2,[r7,r11,lsr #7]

  movs r1,r0,asl #16
;@ Get 16-bit signs right:
  mov r0,r1,asr #16
  mov r2,r2,lsl #16
  mov r2,r2,asr #16

  muls r1,r2,r0
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#58 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c1d8] muls.w (a0)+, d0 uses Opc1d8 ----------
Opc1d8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r2:
  ldr r2,[r7,r11,lsr #7]

  movs r1,r0,asl #16
;@ Get 16-bit signs right:
  mov r0,r1,asr #16
  mov r2,r2,lsl #16
  mov r2,r2,asr #16

  muls r1,r2,r0
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#58 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c1e0] muls.w -(a0), d0 uses Opc1e0 ----------
Opc1e0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r2:
  ldr r2,[r7,r11,lsr #7]

  movs r1,r0,asl #16
;@ Get 16-bit signs right:
  mov r0,r1,asr #16
  mov r2,r2,lsl #16
  mov r2,r2,asr #16

  muls r1,r2,r0
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#60 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c1e8] muls.w ($3333,a0), d0 uses Opc1e8 ----------
Opc1e8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r2:
  ldr r2,[r7,r11,lsr #7]

  movs r1,r0,asl #16
;@ Get 16-bit signs right:
  mov r0,r1,asr #16
  mov r2,r2,lsl #16
  mov r2,r2,asr #16

  muls r1,r2,r0
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#62 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c1f0] muls.w ($33,a0,d3.w*2), d0 uses Opc1f0 ----------
Opc1f0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r2:
  ldr r2,[r7,r11,lsr #7]

  movs r1,r0,asl #16
;@ Get 16-bit signs right:
  mov r0,r1,asr #16
  mov r2,r2,lsl #16
  mov r2,r2,asr #16

  muls r1,r2,r0
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#64 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c1f8] muls.w $3333.w, d0 uses Opc1f8 ----------
Opc1f8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r2:
  ldr r2,[r7,r11,lsr #7]

  movs r1,r0,asl #16
;@ Get 16-bit signs right:
  mov r0,r1,asr #16
  mov r2,r2,lsl #16
  mov r2,r2,asr #16

  muls r1,r2,r0
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#62 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c1f9] muls.w $33333333.l, d0 uses Opc1f9 ----------
Opc1f9:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r2:
  ldr r2,[r7,r11,lsr #7]

  movs r1,r0,asl #16
;@ Get 16-bit signs right:
  mov r0,r1,asr #16
  mov r2,r2,lsl #16
  mov r2,r2,asr #16

  muls r1,r2,r0
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#66 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c1fa] muls.w ($3333,pc), d0; =3335 uses Opc1fa ----------
Opc1fa:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r2,r0 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r0:
  bl cyclone_fetch16 ;@ Call fetch16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r2:
  ldr r2,[r7,r11,lsr #7]

  movs r1,r0,asl #16
;@ Get 16-bit signs right:
  mov r0,r1,asr #16
  mov r2,r2,lsl #16
  mov r2,r2,asr #16

  muls r1,r2,r0
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#62 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c1fb] muls.w ($33,pc,d3.w*2), d0; =35 uses Opc1fb ----------
Opc1fb:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r0:
  bl cyclone_fetch16 ;@ Call fetch16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r2:
  ldr r2,[r7,r11,lsr #7]

  movs r1,r0,asl #16
;@ Get 16-bit signs right:
  mov r0,r1,asr #16
  mov r2,r2,lsl #16
  mov r2,r2,asr #16

  muls r1,r2,r0
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#64 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [c1fc] muls.w #$3333, d0 uses Opc1fc ----------
Opc1fc:
;@ EaCalc : Get '#$3333' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r0) into r0:

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r2:
  ldr r2,[r7,r11,lsr #7]

  movs r1,r0,asl #16
;@ Get 16-bit signs right:
  mov r0,r1,asr #16
  mov r2,r2,lsl #16
  mov r2,r2,asr #16

  muls r1,r2,r0
  and r10,r1,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#58 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [cf08] abcd -(a0), -(a7) uses Opcf08 ----------
Opcf08:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get src/dest EA vals
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r6:
  bl cyclone_read8 ;@ Call read8(r0) handler
  mov r6,r0

;@ EaCalc : Get '-(a7)' into r11:
  ldr r11,[r7,#0x3c] ;@ A7
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

  bic r10,r10,#0xb1000000 ;@ clear all flags except old Z
  ldr r1,[r7,#0x4c] ;@ Get X bit
  and r2,r0,#0x0f
  movs r12,r1,lsl #3 ;@ X into carry
  and r1,r6,#0x0f
  adc r1,r2,r1
  cmp r1,#9
  and r0,r0,#0xf0
  and r6,r6,#0xf0
  add r1,r1,r0
  add r1,r1,r6
  mov r12,r1
  addhi r12,#6 ;@ Decimal adjust units
  tst r1,#0x80
  orreq r10,r10,#0x10000000 ;@ Undefined V behavior
  cmp r12,#0x9f
  orrhi r10,r10,#0x20000000 ;@ C
  subhi r12,r12,#0xa0
  movs r0,r12,lsl #24
  bicpl r10,r10,#0x10000000 ;@ Undefined V behavior part II
  orrmi r10,r10,#0x80000000 ;@ Undefined N behavior
  bicne r10,r10,#0x40000000 ;@ Z flag
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r0 into '-(a7)' (address in r11):
  mov r1,r0,lsr #24
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r6,[r7,#0x54]
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [cf0f] abcd -(a7), -(a7) uses Opcf0f ----------
Opcf0f:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get src/dest EA vals
;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r0) into r6:
  bl cyclone_read8 ;@ Call read8(r0) handler
  mov r6,r0

;@ EaCalc : Get '-(a7)' into r11:
  ldr r11,[r7,#0x3c] ;@ A7
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

  bic r10,r10,#0xb1000000 ;@ clear all flags except old Z
  ldr r1,[r7,#0x4c] ;@ Get X bit
  and r2,r0,#0x0f
  movs r12,r1,lsl #3 ;@ X into carry
  and r1,r6,#0x0f
  adc r1,r2,r1
  cmp r1,#9
  and r0,r0,#0xf0
  and r6,r6,#0xf0
  add r1,r1,r0
  add r1,r1,r6
  mov r12,r1
  addhi r12,#6 ;@ Decimal adjust units
  tst r1,#0x80
  orreq r10,r10,#0x10000000 ;@ Undefined V behavior
  cmp r12,#0x9f
  orrhi r10,r10,#0x20000000 ;@ C
  subhi r12,r12,#0xa0
  movs r0,r12,lsl #24
  bicpl r10,r10,#0x10000000 ;@ Undefined V behavior part II
  orrmi r10,r10,#0x80000000 ;@ Undefined N behavior
  bicne r10,r10,#0x40000000 ;@ Z flag
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r0 into '-(a7)' (address in r11):
  mov r1,r0,lsr #24
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r6,[r7,#0x54]
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d000] add.b d0, d0 uses Opd000 ----------
Opd000:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r0:
  ldr r0,[r7,r0,lsl #2]

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  adds r1,r0,r1,asl #24
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r11]:
  strb r1,[r7,r11,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d010] add.b (a0), d0 uses Opd010 ----------
Opd010:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  bl cyclone_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  adds r1,r0,r1,asl #24
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r11]:
  strb r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d018] add.b (a0)+, d0 uses Opd018 ----------
Opd018:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  bl cyclone_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  adds r1,r0,r1,asl #24
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r11]:
  strb r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d01f] add.b (a7)+, d0 uses Opd01f ----------
Opd01f:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r0) into r0:
  bl cyclone_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  adds r1,r0,r1,asl #24
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r11]:
  strb r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d020] add.b -(a0), d0 uses Opd020 ----------
Opd020:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  bl cyclone_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  adds r1,r0,r1,asl #24
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r11]:
  strb r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d027] add.b -(a7), d0 uses Opd027 ----------
Opd027:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r0) into r0:
  bl cyclone_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  adds r1,r0,r1,asl #24
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r11]:
  strb r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d028] add.b ($3333,a0), d0 uses Opd028 ----------
Opd028:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  bl cyclone_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  adds r1,r0,r1,asl #24
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r11]:
  strb r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d030] add.b ($33,a0,d3.w*2), d0 uses Opd030 ----------
Opd030:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  bl cyclone_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  adds r1,r0,r1,asl #24
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r11]:
  strb r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d038] add.b $3333.w, d0 uses Opd038 ----------
Opd038:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  bl cyclone_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  adds r1,r0,r1,asl #24
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r11]:
  strb r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d039] add.b $33333333.l, d0 uses Opd039 ----------
Opd039:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  bl cyclone_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  adds r1,r0,r1,asl #24
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r11]:
  strb r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d03a] add.b ($3333,pc), d0; =3335 uses Opd03a ----------
Opd03a:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r2,r0 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r0:
  bl cyclone_fetch8 ;@ Call fetch8(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  adds r1,r0,r1,asl #24
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r11]:
  strb r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d03b] add.b ($33,pc,d3.w*2), d0; =35 uses Opd03b ----------
Opd03b:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r0:
  bl cyclone_fetch8 ;@ Call fetch8(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  adds r1,r0,r1,asl #24
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r11]:
  strb r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d03c] add.b #$33, d0 uses Opd03c ----------
Opd03c:
;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  adds r1,r0,r1,asl #24
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r11]:
  strb r1,[r7,r11,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d050] add.w (a0), d0 uses Opd050 ----------
Opd050:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
  mov r11,r11,lsr #7
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11]

;@ Do arithmetic:
  mov r0,r0,asl #16
  adds r1,r0,r1,asl #16
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: r1 into register[r11]:
  strh r1,[r7,r11]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d058] add.w (a0)+, d0 uses Opd058 ----------
Opd058:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
  mov r11,r11,lsr #7
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11]

;@ Do arithmetic:
  mov r0,r0,asl #16
  adds r1,r0,r1,asl #16
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: r1 into register[r11]:
  strh r1,[r7,r11]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d060] add.w -(a0), d0 uses Opd060 ----------
Opd060:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
  mov r11,r11,lsr #7
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11]

;@ Do arithmetic:
  mov r0,r0,asl #16
  adds r1,r0,r1,asl #16
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: r1 into register[r11]:
  strh r1,[r7,r11]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d068] add.w ($3333,a0), d0 uses Opd068 ----------
Opd068:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
  mov r11,r11,lsr #7
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11]

;@ Do arithmetic:
  mov r0,r0,asl #16
  adds r1,r0,r1,asl #16
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: r1 into register[r11]:
  strh r1,[r7,r11]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d070] add.w ($33,a0,d3.w*2), d0 uses Opd070 ----------
Opd070:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
  mov r11,r11,lsr #7
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11]

;@ Do arithmetic:
  mov r0,r0,asl #16
  adds r1,r0,r1,asl #16
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: r1 into register[r11]:
  strh r1,[r7,r11]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d078] add.w $3333.w, d0 uses Opd078 ----------
Opd078:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
  mov r11,r11,lsr #7
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11]

;@ Do arithmetic:
  mov r0,r0,asl #16
  adds r1,r0,r1,asl #16
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: r1 into register[r11]:
  strh r1,[r7,r11]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d079] add.w $33333333.l, d0 uses Opd079 ----------
Opd079:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
  mov r11,r11,lsr #7
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11]

;@ Do arithmetic:
  mov r0,r0,asl #16
  adds r1,r0,r1,asl #16
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: r1 into register[r11]:
  strh r1,[r7,r11]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d07a] add.w ($3333,pc), d0; =3335 uses Opd07a ----------
Opd07a:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r2,r0 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r0:
  bl cyclone_fetch16 ;@ Call fetch16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
  mov r11,r11,lsr #7
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11]

;@ Do arithmetic:
  mov r0,r0,asl #16
  adds r1,r0,r1,asl #16
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: r1 into register[r11]:
  strh r1,[r7,r11]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d07b] add.w ($33,pc,d3.w*2), d0; =35 uses Opd07b ----------
Opd07b:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r0:
  bl cyclone_fetch16 ;@ Call fetch16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
  mov r11,r11,lsr #7
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11]

;@ Do arithmetic:
  mov r0,r0,asl #16
  adds r1,r0,r1,asl #16
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: r1 into register[r11]:
  strh r1,[r7,r11]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d07c] add.w #$3333, d0 uses Opd07c ----------
Opd07c:
;@ EaCalc : Get '#$3333' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r0) into r0:

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
  mov r11,r11,lsr #7
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11]

;@ Do arithmetic:
  mov r0,r0,asl #16
  adds r1,r0,r1,asl #16
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: r1 into register[r11]:
  strh r1,[r7,r11]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d080] add.l d0, d0 uses Opd080 ----------
Opd080:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r0:
  ldr r0,[r7,r0,lsl #2]

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  adds r1,r0,r1
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d090] add.l (a0), d0 uses Opd090 ----------
Opd090:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  adds r1,r0,r1
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d098] add.l (a0)+, d0 uses Opd098 ----------
Opd098:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  adds r1,r0,r1
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d0a0] add.l -(a0), d0 uses Opd0a0 ----------
Opd0a0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  adds r1,r0,r1
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d0a8] add.l ($3333,a0), d0 uses Opd0a8 ----------
Opd0a8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  adds r1,r0,r1
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d0b0] add.l ($33,a0,d3.w*2), d0 uses Opd0b0 ----------
Opd0b0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  adds r1,r0,r1
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d0b8] add.l $3333.w, d0 uses Opd0b8 ----------
Opd0b8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  adds r1,r0,r1
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d0b9] add.l $33333333.l, d0 uses Opd0b9 ----------
Opd0b9:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  adds r1,r0,r1
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d0ba] add.l ($3333,pc), d0; =3335 uses Opd0ba ----------
Opd0ba:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r2,r0 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r0:
  bl cyclone_fetch32 ;@ Call fetch32(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  adds r1,r0,r1
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d0bb] add.l ($33,pc,d3.w*2), d0; =35 uses Opd0bb ----------
Opd0bb:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r0:
  bl cyclone_fetch32 ;@ Call fetch32(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  adds r1,r0,r1
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d0bc] add.l #$33333333, d0 uses Opd0bc ----------
Opd0bc:
;@ EaCalc : Get '#$33333333' into r0:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r0,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r0) into r0:

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

;@ Do arithmetic:
  adds r1,r0,r1
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d0c0] adda.w d0, a0 uses Opd0c0 ----------
Opd0c0:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r0:
  ldr r0,[r7,r0,lsl #2]

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x1e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

  mov r0,r0,asl #16

  add r1,r1,r0,asr #16

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d0d0] adda.w (a0), a0 uses Opd0d0 ----------
Opd0d0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x1e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

  mov r0,r0,asl #16

  add r1,r1,r0,asr #16

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d0d8] adda.w (a0)+, a0 uses Opd0d8 ----------
Opd0d8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x1e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

  mov r0,r0,asl #16

  add r1,r1,r0,asr #16

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d0e0] adda.w -(a0), a0 uses Opd0e0 ----------
Opd0e0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x1e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

  mov r0,r0,asl #16

  add r1,r1,r0,asr #16

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d0e8] adda.w ($3333,a0), a0 uses Opd0e8 ----------
Opd0e8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x1e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

  mov r0,r0,asl #16

  add r1,r1,r0,asr #16

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d0f0] adda.w ($33,a0,d3.w*2), a0 uses Opd0f0 ----------
Opd0f0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x1e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

  mov r0,r0,asl #16

  add r1,r1,r0,asr #16

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d0f8] adda.w $3333.w, a0 uses Opd0f8 ----------
Opd0f8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x1e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

  mov r0,r0,asl #16

  add r1,r1,r0,asr #16

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d0f9] adda.w $33333333.l, a0 uses Opd0f9 ----------
Opd0f9:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x1e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

  mov r0,r0,asl #16

  add r1,r1,r0,asr #16

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d0fa] adda.w ($3333,pc), a0; =3335 uses Opd0fa ----------
Opd0fa:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r2,r0 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r0:
  bl cyclone_fetch16 ;@ Call fetch16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x1e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

  mov r0,r0,asl #16

  add r1,r1,r0,asr #16

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d0fb] adda.w ($33,pc,d3.w*2), a0; =35 uses Opd0fb ----------
Opd0fb:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r0:
  bl cyclone_fetch16 ;@ Call fetch16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x1e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

  mov r0,r0,asl #16

  add r1,r1,r0,asr #16

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d0fc] adda.w #$3333, a0 uses Opd0fc ----------
Opd0fc:
;@ EaCalc : Get '#$3333' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r0) into r0:

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x1e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

  mov r0,r0,asl #16

  add r1,r1,r0,asr #16

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d100] addx.b d0, d0 uses Opd100 ----------
Opd100:
;@ Get src/dest reg vals
;@ EaCalc : Get register index into r6:
  and r6,r8,#0x0007
;@ EaRead : Read register[r6] into r6:
  ldr r6,[r7,r6,lsl #2]

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsr #7]

  mov r6,r6,asl #24

;@ Do arithmetic:
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  tst r2,r2,lsl #3 ;@ Get into Carry

;@ Make sure the carry bit will tip the balance:
  mvn r2,#0
  orr r6,r6,r2,lsr #8

  adcs r1,r6,r0,asl #24
  orr r3,r10,#0xb0000000 ;@ for old Z
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit
  movs r2,r1,lsr #24
  orreq r10,r10,#0x40000000 ;@ add potentially missed Z
  andeq r10,r10,r3 ;@ fix Z

;@ Save result:
;@ EaWrite: r1 into register[r11]:
  mov r1,r1,lsr #24
  strb r1,[r7,r11,lsr #7]

  ldr r6,[r7,#0x54]
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d108] addx.b -(a0), -(a0) uses Opd108 ----------
Opd108:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get src/dest EA vals
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r6:
  bl cyclone_read8 ;@ Call read8(r0) handler
  mov r6,r0,asl #24

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x1e00
  ldr r11,[r7,r2,lsr #7]
  sub r11,r11,#1 ;@ Pre-decrement An
  str r11,[r7,r2,lsr #7]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

;@ Do arithmetic:
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  tst r2,r2,lsl #3 ;@ Get into Carry

;@ Make sure the carry bit will tip the balance:
  mvn r2,#0
  orr r6,r6,r2,lsr #8

  adcs r1,r6,r0,asl #24
  orr r3,r10,#0xb0000000 ;@ for old Z
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit
  movs r2,r1,lsr #24
  orreq r10,r10,#0x40000000 ;@ add potentially missed Z
  andeq r10,r10,r3 ;@ fix Z

;@ Save result:
;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r1,r1,lsr #24
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r6,[r7,#0x54]
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d10f] addx.b -(a7), -(a0) uses Opd10f ----------
Opd10f:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get src/dest EA vals
;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r0) into r6:
  bl cyclone_read8 ;@ Call read8(r0) handler
  mov r6,r0,asl #24

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x1e00
  ldr r11,[r7,r2,lsr #7]
  sub r11,r11,#1 ;@ Pre-decrement An
  str r11,[r7,r2,lsr #7]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

;@ Do arithmetic:
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  tst r2,r2,lsl #3 ;@ Get into Carry

;@ Make sure the carry bit will tip the balance:
  mvn r2,#0
  orr r6,r6,r2,lsr #8

  adcs r1,r6,r0,asl #24
  orr r3,r10,#0xb0000000 ;@ for old Z
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit
  movs r2,r1,lsr #24
  orreq r10,r10,#0x40000000 ;@ add potentially missed Z
  andeq r10,r10,r3 ;@ fix Z

;@ Save result:
;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r1,r1,lsr #24
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r6,[r7,#0x54]
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d110] add.b d0, (a0) uses Opd110 ----------
Opd110:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  adds r1,r0,r1,asl #24
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: Write r1 into '(a0)' (address in r11):
  and r1,r1,#0xff
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d118] add.b d0, (a0)+ uses Opd118 ----------
Opd118:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  adds r1,r0,r1,asl #24
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  and r1,r1,#0xff
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d11f] add.b d0, (a7)+ uses Opd11f ----------
Opd11f:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a7)+' into r11:
  ldr r11,[r7,#0x3c] ;@ A7
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  adds r1,r0,r1,asl #24
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: Write r1 into '(a7)+' (address in r11):
  and r1,r1,#0xff
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d120] add.b d0, -(a0) uses Opd120 ----------
Opd120:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#1 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  adds r1,r0,r1,asl #24
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  and r1,r1,#0xff
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d127] add.b d0, -(a7) uses Opd127 ----------
Opd127:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a7)' into r11:
  ldr r11,[r7,#0x3c] ;@ A7
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  adds r1,r0,r1,asl #24
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: Write r1 into '-(a7)' (address in r11):
  and r1,r1,#0xff
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d128] add.b d0, ($3333,a0) uses Opd128 ----------
Opd128:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  adds r1,r0,r1,asl #24
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  and r1,r1,#0xff
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d130] add.b d0, ($33,a0,d3.w*2) uses Opd130 ----------
Opd130:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  adds r1,r0,r1,asl #24
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  and r1,r1,#0xff
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d138] add.b d0, $3333.w uses Opd138 ----------
Opd138:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  adds r1,r0,r1,asl #24
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  and r1,r1,#0xff
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d139] add.b d0, $33333333.l uses Opd139 ----------
Opd139:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  adds r1,r0,r1,asl #24
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  and r1,r1,#0xff
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d140] addx.w d0, d0 uses Opd140 ----------
Opd140:
;@ Get src/dest reg vals
;@ EaCalc : Get register index into r6:
  and r6,r8,#0x0007
;@ EaRead : Read register[r6] into r6:
  ldr r6,[r7,r6,lsl #2]

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
  mov r11,r11,lsr #7
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11]

  mov r6,r6,asl #16

;@ Do arithmetic:
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  tst r2,r2,lsl #3 ;@ Get into Carry

;@ Make sure the carry bit will tip the balance:
  mvn r2,#0
  orr r6,r6,r2,lsr #16

  adcs r1,r6,r0,asl #16
  orr r3,r10,#0xb0000000 ;@ for old Z
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit
  movs r2,r1,lsr #16
  orreq r10,r10,#0x40000000 ;@ add potentially missed Z
  andeq r10,r10,r3 ;@ fix Z

;@ Save result:
;@ EaWrite: r1 into register[r11]:
  mov r1,r1,lsr #16
  strh r1,[r7,r11]

  ldr r6,[r7,#0x54]
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#4 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d148] addx.w -(a0), -(a0) uses Opd148 ----------
Opd148:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get src/dest EA vals
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r6:
  bl cyclone_read16 ;@ Call read16(r0) handler
  mov r6,r0,asl #16

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x1e00
  ldr r11,[r7,r2,lsr #7]
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,r2,lsr #7]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ Do arithmetic:
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  tst r2,r2,lsl #3 ;@ Get into Carry

;@ Make sure the carry bit will tip the balance:
  mvn r2,#0
  orr r6,r6,r2,lsr #16

  adcs r1,r6,r0,asl #16
  orr r3,r10,#0xb0000000 ;@ for old Z
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit
  movs r2,r1,lsr #16
  orreq r10,r10,#0x40000000 ;@ add potentially missed Z
  andeq r10,r10,r3 ;@ fix Z

;@ Save result:
;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r1,r1,lsr #16
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r6,[r7,#0x54]
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d150] add.w d0, (a0) uses Opd150 ----------
Opd150:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #16
  adds r1,r0,r1,asl #16
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: Write r1 into '(a0)' (address in r11):
  uxth r1,r1 ;@ zero extend
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d158] add.w d0, (a0)+ uses Opd158 ----------
Opd158:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #16
  adds r1,r0,r1,asl #16
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  uxth r1,r1 ;@ zero extend
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d160] add.w d0, -(a0) uses Opd160 ----------
Opd160:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #16
  adds r1,r0,r1,asl #16
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  uxth r1,r1 ;@ zero extend
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d168] add.w d0, ($3333,a0) uses Opd168 ----------
Opd168:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #16
  adds r1,r0,r1,asl #16
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  uxth r1,r1 ;@ zero extend
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d170] add.w d0, ($33,a0,d3.w*2) uses Opd170 ----------
Opd170:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #16
  adds r1,r0,r1,asl #16
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  uxth r1,r1 ;@ zero extend
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d178] add.w d0, $3333.w uses Opd178 ----------
Opd178:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #16
  adds r1,r0,r1,asl #16
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  uxth r1,r1 ;@ zero extend
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d179] add.w d0, $33333333.l uses Opd179 ----------
Opd179:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #16
  adds r1,r0,r1,asl #16
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  uxth r1,r1 ;@ zero extend
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d180] addx.l d0, d0 uses Opd180 ----------
Opd180:
;@ Get src/dest reg vals
;@ EaCalc : Get register index into r6:
  and r6,r8,#0x0007
;@ EaRead : Read register[r6] into r6:
  ldr r6,[r7,r6,lsl #2]

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsr #7]

;@ Do arithmetic:
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  tst r2,r2,lsl #3 ;@ Get into Carry

  adcs r1,r6,r0
  orr r3,r10,#0xb0000000 ;@ for old Z
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit
  andeq r10,r10,r3 ;@ fix Z

;@ Save result:
;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r6,[r7,#0x54]
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d188] addx.l -(a0), -(a0) uses Opd188 ----------
Opd188:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get src/dest EA vals
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r6:
  bl cyclone_read32 ;@ Call read32(r0) handler
  mov r6,r0

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x1e00
  ldr r11,[r7,r2,lsr #7]
  sub r11,r11,#4 ;@ Pre-decrement An
  str r11,[r7,r2,lsr #7]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ Do arithmetic:
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  tst r2,r2,lsl #3 ;@ Get into Carry

  adcs r1,r6,r0
  orr r3,r10,#0xb0000000 ;@ for old Z
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit
  andeq r10,r10,r3 ;@ fix Z

;@ Save result:
;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r0,r11
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r6,[r7,#0x54]
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#30 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d190] add.l d0, (a0) uses Opd190 ----------
Opd190:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  adds r1,r0,r1
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '(a0)' (address in r11):
  mov r0,r11
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d198] add.l d0, (a0)+ uses Opd198 ----------
Opd198:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  adds r1,r0,r1
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  mov r0,r11
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d1a0] add.l d0, -(a0) uses Opd1a0 ----------
Opd1a0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#4 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  adds r1,r0,r1
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r0,r11
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d1a8] add.l d0, ($3333,a0) uses Opd1a8 ----------
Opd1a8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  adds r1,r0,r1
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  mov r0,r11
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d1b0] add.l d0, ($33,a0,d3.w*2) uses Opd1b0 ----------
Opd1b0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  adds r1,r0,r1
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  mov r0,r11
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#26 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d1b8] add.l d0, $3333.w uses Opd1b8 ----------
Opd1b8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  adds r1,r0,r1
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  mov r0,r11
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d1b9] add.l d0, $33333333.l uses Opd1b9 ----------
Opd1b9:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  adds r1,r0,r1
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  mov r0,r11
  bl cyclone_write32 ;@ Call write32(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#28 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d1c0] adda.l d0, a0 uses Opd1c0 ----------
Opd1c0:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r0:
  ldr r0,[r7,r0,lsl #2]

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x1e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

  add r1,r1,r0

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d1d0] adda.l (a0), a0 uses Opd1d0 ----------
Opd1d0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x1e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

  add r1,r1,r0

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d1d8] adda.l (a0)+, a0 uses Opd1d8 ----------
Opd1d8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x1e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

  add r1,r1,r0

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d1e0] adda.l -(a0), a0 uses Opd1e0 ----------
Opd1e0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x1e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

  add r1,r1,r0

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d1e8] adda.l ($3333,a0), a0 uses Opd1e8 ----------
Opd1e8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x1e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

  add r1,r1,r0

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d1f0] adda.l ($33,a0,d3.w*2), a0 uses Opd1f0 ----------
Opd1f0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x1e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

  add r1,r1,r0

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d1f8] adda.l $3333.w, a0 uses Opd1f8 ----------
Opd1f8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x1e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

  add r1,r1,r0

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d1f9] adda.l $33333333.l, a0 uses Opd1f9 ----------
Opd1f9:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  bl cyclone_read32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x1e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

  add r1,r1,r0

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d1fa] adda.l ($3333,pc), a0; =3335 uses Opd1fa ----------
Opd1fa:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  add r0,r2,r0 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r0:
  bl cyclone_fetch32 ;@ Call fetch32(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x1e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

  add r1,r1,r0

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d1fb] adda.l ($33,pc,d3.w*2), a0; =35 uses Opd1fb ----------
Opd1fb:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r0:
  bl cyclone_fetch32 ;@ Call fetch32(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x1e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

  add r1,r1,r0

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [d1fc] adda.l #$33333333, a0 uses Opd1fc ----------
Opd1fc:
;@ EaCalc : Get '#$33333333' into r0:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r0,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r0) into r0:

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x1e00
;@ EaRead : Read register[r11] into r1:
  ldr r1,[r7,r11,lsr #7]

  add r1,r1,r0

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [df08] addx.b -(a0), -(a7) uses Opdf08 ----------
Opdf08:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get src/dest EA vals
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r6:
  bl cyclone_read8 ;@ Call read8(r0) handler
  mov r6,r0,asl #24

;@ EaCalc : Get '-(a7)' into r11:
  ldr r11,[r7,#0x3c] ;@ A7
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

;@ Do arithmetic:
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  tst r2,r2,lsl #3 ;@ Get into Carry

;@ Make sure the carry bit will tip the balance:
  mvn r2,#0
  orr r6,r6,r2,lsr #8

  adcs r1,r6,r0,asl #24
  orr r3,r10,#0xb0000000 ;@ for old Z
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit
  movs r2,r1,lsr #24
  orreq r10,r10,#0x40000000 ;@ add potentially missed Z
  andeq r10,r10,r3 ;@ fix Z

;@ Save result:
;@ EaWrite: Write r1 into '-(a7)' (address in r11):
  mov r1,r1,lsr #24
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r6,[r7,#0x54]
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [df0f] addx.b -(a7), -(a7) uses Opdf0f ----------
Opdf0f:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ Get src/dest EA vals
;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r0) into r6:
  bl cyclone_read8 ;@ Call read8(r0) handler
  mov r6,r0,asl #24

;@ EaCalc : Get '-(a7)' into r11:
  ldr r11,[r7,#0x3c] ;@ A7
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read8 ;@ Call read8(r0) handler

;@ Do arithmetic:
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  tst r2,r2,lsl #3 ;@ Get into Carry

;@ Make sure the carry bit will tip the balance:
  mvn r2,#0
  orr r6,r6,r2,lsr #8

  adcs r1,r6,r0,asl #24
  orr r3,r10,#0xb0000000 ;@ for old Z
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit
  movs r2,r1,lsr #24
  orreq r10,r10,#0x40000000 ;@ add potentially missed Z
  andeq r10,r10,r3 ;@ fix Z

;@ Save result:
;@ EaWrite: Write r1 into '-(a7)' (address in r11):
  mov r1,r1,lsr #24
  mov r0,r11
  bl cyclone_write8 ;@ Call write8(r0,r1) handler

  ldr r6,[r7,#0x54]
  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e000] asr.b #8, d0 uses Ope000 ----------
Ope000:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]
  mov r0,r0,asl #24

;@ For shift right, use loworder bits for the operation:
  mov r0,r0,asr #24

;@ Shift register:
  movs r0,r0,asr #8
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ restore after right shift:
  movs r0,r0,lsl #24

;@ EaWrite: r0 into register[r11]:
  mov r0,r0,lsr #24
  strb r0,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e008] lsr.b #8, d0 uses Ope008 ----------
Ope008:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]
  mov r0,r0,asl #24

;@ For shift right, use loworder bits for the operation:
  mov r0,r0,lsr #24

;@ Shift register:
  movs r0,r0,lsr #8
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ restore after right shift:
  movs r0,r0,lsl #24
  orrmi r10,r10,#0x80000000 ;@ Potentially missed N flag

;@ EaWrite: r0 into register[r11]:
  mov r0,r0,lsr #24
  strb r0,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e010] roxr.b #8, d0 uses Ope010 ----------
Ope010:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]
  mov r0,r0,asl #24

  mov r2,#8
  mov r0,r0,lsr #24 ;@ Shift down

;@ First get X bit (middle):
  ldr r3,[r7,#0x4c]
  rsb r1,r2,#8
  and r3,r3,#0x20000000
  mov r3,r3,lsr #29
  mov r3,r3,lsl r1
;@ Rotate bits:
  orr r3,r3,r0,lsr r2 ;@ Orr right part
  rsbs r2,r2,#9 ;@ should also clear ARM V
  orrs r0,r3,r0,lsl r2 ;@ Orr left part, set flags

  movs r0,r0,lsl #24 ;@ Shift up and get correct NC flags
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: r0 into register[r11]:
  mov r0,r0,lsr #24
  strb r0,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e018] ror.b #8, d0 uses Ope018 ----------
Ope018:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]
  mov r0,r0,asl #24

;@ Mirror value in whole 32 bits:
  orr r0,r0,r0,lsr #8
  orr r0,r0,r0,lsr #16

;@ Rotate register:
  adds r0,r0,#0 ;@ first clear V and C
  movs r0,r0,ror #8
  mrs r10,cpsr ;@ r10=flags

;@ EaWrite: r0 into register[r11]:
  mov r0,r0,lsr #24
  strb r0,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e020] asr.b d0, d0 uses Ope020 ----------
Ope020:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]
  mov r0,r0,asl #24

;@ Use Dn for count:
  and r2,r8,#0x0e00
  ldr r2,[r7,r2,lsr #7]
  and r2,r2,#63

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ For shift right, use loworder bits for the operation:
  mov r0,r0,asr #24

;@ Shift register:
  movs r0,r0,asr r2
  mrs r10,cpsr ;@ r10=flags
  cmp r2,#0 ;@ shifting by 0?
  biceq r10,r10,#0x20000000 ;@ if so, clear carry
  strne r10,[r7,#0x4c] ;@ else Save X bit

;@ restore after right shift:
  movs r0,r0,lsl #24

;@ EaWrite: r0 into register[r11]:
  mov r0,r0,lsr #24
  strb r0,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e028] lsr.b d0, d0 uses Ope028 ----------
Ope028:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]
  mov r0,r0,asl #24

;@ Use Dn for count:
  and r2,r8,#0x0e00
  ldr r2,[r7,r2,lsr #7]
  and r2,r2,#63

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ For shift right, use loworder bits for the operation:
  mov r0,r0,lsr #24

;@ Shift register:
  movs r0,r0,lsr r2
  mrs r10,cpsr ;@ r10=flags
  cmp r2,#0 ;@ shifting by 0?
  biceq r10,r10,#0x20000000 ;@ if so, clear carry
  strne r10,[r7,#0x4c] ;@ else Save X bit

;@ restore after right shift:
  movs r0,r0,lsl #24
  orrmi r10,r10,#0x80000000 ;@ Potentially missed N flag

;@ EaWrite: r0 into register[r11]:
  mov r0,r0,lsr #24
  strb r0,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e030] roxr.b d0, d0 uses Ope030 ----------
Ope030:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]
  mov r0,r0,asl #24

;@ Use Dn for count:
  and r2,r8,#0x0e00
  ldr r2,[r7,r2,lsr #7]
  and r2,r2,#63

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Reduce r2 until <0:
Reduce_e030:
  subs r2,r2,#9
  bpl Reduce_e030
  adds r2,r2,#9 ;@ Now r2=0-8
  beq norotx_e030

  mov r0,r0,lsr #24 ;@ Shift down

;@ First get X bit (middle):
  ldr r3,[r7,#0x4c]
  rsb r1,r2,#8
  and r3,r3,#0x20000000
  mov r3,r3,lsr #29
  mov r3,r3,lsl r1
;@ Rotate bits:
  orr r3,r3,r0,lsr r2 ;@ Orr right part
  rsbs r2,r2,#9 ;@ should also clear ARM V
  orrs r0,r3,r0,lsl r2 ;@ Orr left part, set flags

  movs r0,r0,lsl #24 ;@ Shift up and get correct NC flags
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ if not 0, Save X bit
  b nozeroxe030
norotx_e030:
  ldr r2,[r7,#0x4c]
  adds r0,r0,#0 ;@ Define flags
  and r10,r0,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV
  and r2,r2,#0x20000000
  orr r10,r10,r2 ;@ C = old_X
nozeroxe030:

;@ EaWrite: r0 into register[r11]:
  mov r0,r0,lsr #24
  strb r0,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e038] ror.b d0, d0 uses Ope038 ----------
Ope038:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]
  mov r0,r0,asl #24

;@ Use Dn for count:
  and r2,r8,#0x0e00
  ldr r2,[r7,r2,lsr #7]
  and r2,r2,#63

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Mirror value in whole 32 bits:
  orr r0,r0,r0,lsr #8
  orr r0,r0,r0,lsr #16

;@ Rotate register:
  adds r0,r0,#0 ;@ first clear V and C
  movs r0,r0,ror r2
  mrs r10,cpsr ;@ r10=flags

;@ EaWrite: r0 into register[r11]:
  mov r0,r0,lsr #24
  strb r0,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e040] asr.w #8, d0 uses Ope040 ----------
Ope040:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
  mov r11,r11,lsl #2
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11]
  mov r0,r0,asl #16

;@ For shift right, use loworder bits for the operation:
  mov r0,r0,asr #16

;@ Shift register:
  movs r0,r0,asr #8
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ restore after right shift:
  movs r0,r0,lsl #16

;@ EaWrite: r0 into register[r11]:
  mov r0,r0,lsr #16
  strh r0,[r7,r11]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e048] lsr.w #8, d0 uses Ope048 ----------
Ope048:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
  mov r11,r11,lsl #2
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11]
  mov r0,r0,asl #16

;@ For shift right, use loworder bits for the operation:
  mov r0,r0,lsr #16

;@ Shift register:
  movs r0,r0,lsr #8
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ restore after right shift:
  movs r0,r0,lsl #16
  orrmi r10,r10,#0x80000000 ;@ Potentially missed N flag

;@ EaWrite: r0 into register[r11]:
  mov r0,r0,lsr #16
  strh r0,[r7,r11]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e050] roxr.w #8, d0 uses Ope050 ----------
Ope050:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
  mov r11,r11,lsl #2
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11]
  mov r0,r0,asl #16

  mov r2,#8
  mov r0,r0,lsr #16 ;@ Shift down

;@ First get X bit (middle):
  ldr r3,[r7,#0x4c]
  rsb r1,r2,#16
  and r3,r3,#0x20000000
  mov r3,r3,lsr #29
  mov r3,r3,lsl r1
;@ Rotate bits:
  orr r3,r3,r0,lsr r2 ;@ Orr right part
  rsbs r2,r2,#17 ;@ should also clear ARM V
  orrs r0,r3,r0,lsl r2 ;@ Orr left part, set flags

  movs r0,r0,lsl #16 ;@ Shift up and get correct NC flags
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: r0 into register[r11]:
  mov r0,r0,lsr #16
  strh r0,[r7,r11]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e058] ror.w #8, d0 uses Ope058 ----------
Ope058:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
  mov r11,r11,lsl #2
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11]
  mov r0,r0,asl #16

;@ Mirror value in whole 32 bits:
  orr r0,r0,r0,lsr #16

;@ Rotate register:
  adds r0,r0,#0 ;@ first clear V and C
  movs r0,r0,ror #8
  mrs r10,cpsr ;@ r10=flags

;@ EaWrite: r0 into register[r11]:
  mov r0,r0,lsr #16
  strh r0,[r7,r11]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e060] asr.w d0, d0 uses Ope060 ----------
Ope060:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
  mov r11,r11,lsl #2
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11]
  mov r0,r0,asl #16

;@ Use Dn for count:
  and r2,r8,#0x0e00
  ldr r2,[r7,r2,lsr #7]
  and r2,r2,#63

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ For shift right, use loworder bits for the operation:
  mov r0,r0,asr #16

;@ Shift register:
  movs r0,r0,asr r2
  mrs r10,cpsr ;@ r10=flags
  cmp r2,#0 ;@ shifting by 0?
  biceq r10,r10,#0x20000000 ;@ if so, clear carry
  strne r10,[r7,#0x4c] ;@ else Save X bit

;@ restore after right shift:
  movs r0,r0,lsl #16

;@ EaWrite: r0 into register[r11]:
  mov r0,r0,lsr #16
  strh r0,[r7,r11]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e068] lsr.w d0, d0 uses Ope068 ----------
Ope068:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
  mov r11,r11,lsl #2
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11]
  mov r0,r0,asl #16

;@ Use Dn for count:
  and r2,r8,#0x0e00
  ldr r2,[r7,r2,lsr #7]
  and r2,r2,#63

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ For shift right, use loworder bits for the operation:
  mov r0,r0,lsr #16

;@ Shift register:
  movs r0,r0,lsr r2
  mrs r10,cpsr ;@ r10=flags
  cmp r2,#0 ;@ shifting by 0?
  biceq r10,r10,#0x20000000 ;@ if so, clear carry
  strne r10,[r7,#0x4c] ;@ else Save X bit

;@ restore after right shift:
  movs r0,r0,lsl #16
  orrmi r10,r10,#0x80000000 ;@ Potentially missed N flag

;@ EaWrite: r0 into register[r11]:
  mov r0,r0,lsr #16
  strh r0,[r7,r11]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e070] roxr.w d0, d0 uses Ope070 ----------
Ope070:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
  mov r11,r11,lsl #2
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11]
  mov r0,r0,asl #16

;@ Use Dn for count:
  and r2,r8,#0x0e00
  ldr r2,[r7,r2,lsr #7]
  and r2,r2,#63

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Reduce r2 until <0:
Reduce_e070:
  subs r2,r2,#17
  bpl Reduce_e070
  adds r2,r2,#17 ;@ Now r2=0-16
  beq norotx_e070

  mov r0,r0,lsr #16 ;@ Shift down

;@ First get X bit (middle):
  ldr r3,[r7,#0x4c]
  rsb r1,r2,#16
  and r3,r3,#0x20000000
  mov r3,r3,lsr #29
  mov r3,r3,lsl r1
;@ Rotate bits:
  orr r3,r3,r0,lsr r2 ;@ Orr right part
  rsbs r2,r2,#17 ;@ should also clear ARM V
  orrs r0,r3,r0,lsl r2 ;@ Orr left part, set flags

  movs r0,r0,lsl #16 ;@ Shift up and get correct NC flags
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ if not 0, Save X bit
  b nozeroxe070
norotx_e070:
  ldr r2,[r7,#0x4c]
  adds r0,r0,#0 ;@ Define flags
  and r10,r0,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV
  and r2,r2,#0x20000000
  orr r10,r10,r2 ;@ C = old_X
nozeroxe070:

;@ EaWrite: r0 into register[r11]:
  mov r0,r0,lsr #16
  strh r0,[r7,r11]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e078] ror.w d0, d0 uses Ope078 ----------
Ope078:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
  mov r11,r11,lsl #2
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11]
  mov r0,r0,asl #16

;@ Use Dn for count:
  and r2,r8,#0x0e00
  ldr r2,[r7,r2,lsr #7]
  and r2,r2,#63

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Mirror value in whole 32 bits:
  orr r0,r0,r0,lsr #16

;@ Rotate register:
  adds r0,r0,#0 ;@ first clear V and C
  movs r0,r0,ror r2
  mrs r10,cpsr ;@ r10=flags

;@ EaWrite: r0 into register[r11]:
  mov r0,r0,lsr #16
  strh r0,[r7,r11]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e080] asr.l #8, d0 uses Ope080 ----------
Ope080:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

;@ Shift register:
  movs r0,r0,asr #8
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: r0 into register[r11]:
  str r0,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e088] lsr.l #8, d0 uses Ope088 ----------
Ope088:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

;@ Shift register:
  movs r0,r0,lsr #8
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: r0 into register[r11]:
  str r0,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e090] roxr.l #8, d0 uses Ope090 ----------
Ope090:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

  mov r2,#8

;@ First get X bit (middle):
  ldr r3,[r7,#0x4c]
  rsb r1,r2,#32
  and r3,r3,#0x20000000
  mov r3,r3,lsr #29
  mov r3,r3,lsl r1
;@ Rotate bits:
  orr r3,r3,r0,lsr r2 ;@ Orr right part
  rsbs r2,r2,#33 ;@ should also clear ARM V
  orrs r0,r3,r0,lsl r2 ;@ Orr left part, set flags

  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: r0 into register[r11]:
  str r0,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e098] ror.l #8, d0 uses Ope098 ----------
Ope098:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

;@ Rotate register:
  adds r0,r0,#0 ;@ first clear V and C
  movs r0,r0,ror #8
  mrs r10,cpsr ;@ r10=flags

;@ EaWrite: r0 into register[r11]:
  str r0,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e0a0] asr.l d0, d0 uses Ope0a0 ----------
Ope0a0:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

;@ Use Dn for count:
  and r2,r8,#0x0e00
  ldr r2,[r7,r2,lsr #7]
  and r2,r2,#63

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Shift register:
  movs r0,r0,asr r2
  mrs r10,cpsr ;@ r10=flags
  cmp r2,#0 ;@ shifting by 0?
  biceq r10,r10,#0x20000000 ;@ if so, clear carry
  strne r10,[r7,#0x4c] ;@ else Save X bit

;@ EaWrite: r0 into register[r11]:
  str r0,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e0a8] lsr.l d0, d0 uses Ope0a8 ----------
Ope0a8:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

;@ Use Dn for count:
  and r2,r8,#0x0e00
  ldr r2,[r7,r2,lsr #7]
  and r2,r2,#63

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Shift register:
  movs r0,r0,lsr r2
  mrs r10,cpsr ;@ r10=flags
  cmp r2,#0 ;@ shifting by 0?
  biceq r10,r10,#0x20000000 ;@ if so, clear carry
  strne r10,[r7,#0x4c] ;@ else Save X bit

;@ EaWrite: r0 into register[r11]:
  str r0,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e0b0] roxr.l d0, d0 uses Ope0b0 ----------
Ope0b0:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

;@ Use Dn for count:
  and r2,r8,#0x0e00
  ldr r2,[r7,r2,lsr #7]
  and r2,r2,#63

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

  subs r2,r2,#33
  addmis r2,r2,#33 ;@ Now r2=0-32
  beq norotx_e0b0


;@ First get X bit (middle):
  ldr r3,[r7,#0x4c]
  rsb r1,r2,#32
  and r3,r3,#0x20000000
  mov r3,r3,lsr #29
  mov r3,r3,lsl r1
;@ Rotate bits:
  orr r3,r3,r0,lsr r2 ;@ Orr right part
  rsbs r2,r2,#33 ;@ should also clear ARM V
  orrs r0,r3,r0,lsl r2 ;@ Orr left part, set flags

  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ if not 0, Save X bit
  b nozeroxe0b0
norotx_e0b0:
  ldr r2,[r7,#0x4c]
  adds r0,r0,#0 ;@ Define flags
  and r10,r0,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV
  and r2,r2,#0x20000000
  orr r10,r10,r2 ;@ C = old_X
nozeroxe0b0:

;@ EaWrite: r0 into register[r11]:
  str r0,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e0b8] ror.l d0, d0 uses Ope0b8 ----------
Ope0b8:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

;@ Use Dn for count:
  and r2,r8,#0x0e00
  ldr r2,[r7,r2,lsr #7]
  and r2,r2,#63

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Rotate register:
  adds r0,r0,#0 ;@ first clear V and C
  movs r0,r0,ror r2
  mrs r10,cpsr ;@ r10=flags

;@ EaWrite: r0 into register[r11]:
  str r0,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e0d0] asr.w (a0) uses Ope0d0 ----------
Ope0d0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ For shift right, use loworder bits for the operation:
  mov r0,r0,asr #16

;@ Shift register:
  movs r0,r0,asr #1
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ restore after right shift:
  movs r0,r0,lsl #16

;@ EaWrite: Write r0 into '(a0)' (address in r11):
  mov r1,r0,lsr #16
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e0d8] asr.w (a0)+ uses Ope0d8 ----------
Ope0d8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ For shift right, use loworder bits for the operation:
  mov r0,r0,asr #16

;@ Shift register:
  movs r0,r0,asr #1
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ restore after right shift:
  movs r0,r0,lsl #16

;@ EaWrite: Write r0 into '(a0)+' (address in r11):
  mov r1,r0,lsr #16
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e0e0] asr.w -(a0) uses Ope0e0 ----------
Ope0e0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ For shift right, use loworder bits for the operation:
  mov r0,r0,asr #16

;@ Shift register:
  movs r0,r0,asr #1
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ restore after right shift:
  movs r0,r0,lsl #16

;@ EaWrite: Write r0 into '-(a0)' (address in r11):
  mov r1,r0,lsr #16
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e0e8] asr.w ($3333,a0) uses Ope0e8 ----------
Ope0e8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ For shift right, use loworder bits for the operation:
  mov r0,r0,asr #16

;@ Shift register:
  movs r0,r0,asr #1
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ restore after right shift:
  movs r0,r0,lsl #16

;@ EaWrite: Write r0 into '($3333,a0)' (address in r11):
  mov r1,r0,lsr #16
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e0f0] asr.w ($33,a0,d3.w*2) uses Ope0f0 ----------
Ope0f0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ For shift right, use loworder bits for the operation:
  mov r0,r0,asr #16

;@ Shift register:
  movs r0,r0,asr #1
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ restore after right shift:
  movs r0,r0,lsl #16

;@ EaWrite: Write r0 into '($33,a0,d3.w*2)' (address in r11):
  mov r1,r0,lsr #16
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e0f8] asr.w $3333.w uses Ope0f8 ----------
Ope0f8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ For shift right, use loworder bits for the operation:
  mov r0,r0,asr #16

;@ Shift register:
  movs r0,r0,asr #1
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ restore after right shift:
  movs r0,r0,lsl #16

;@ EaWrite: Write r0 into '$3333.w' (address in r11):
  mov r1,r0,lsr #16
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e0f9] asr.w $33333333.l uses Ope0f9 ----------
Ope0f9:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ For shift right, use loworder bits for the operation:
  mov r0,r0,asr #16

;@ Shift register:
  movs r0,r0,asr #1
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ restore after right shift:
  movs r0,r0,lsl #16

;@ EaWrite: Write r0 into '$33333333.l' (address in r11):
  mov r1,r0,lsr #16
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e100] asl.b #8, d0 uses Ope100 ----------
Ope100:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]
  mov r0,r0,asl #24

  adds r3,r0,#0 ;@ save old value for V flag calculation, also clear V
;@ Shift register:
  movs r0,r0,asl #8
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ calculate V flag (set if sign bit changes at anytime):
  mov r1,#0x80000000
  ands r3,r3,r1,asr #8
  cmpne r3,r1,asr #8
  eoreq r1,r0,r3
  tsteq r1,#0x80000000
  orrne r10,r10,#0x10000000

;@ EaWrite: r0 into register[r11]:
  mov r0,r0,lsr #24
  strb r0,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e108] lsl.b #8, d0 uses Ope108 ----------
Ope108:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]
  mov r0,r0,asl #24

;@ Shift register:
  movs r0,r0,lsl #8
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: r0 into register[r11]:
  mov r0,r0,lsr #24
  strb r0,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e110] roxl.b #8, d0 uses Ope110 ----------
Ope110:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]
  mov r0,r0,asl #24

  mov r2,#1 ;@ Reversed
  mov r0,r0,lsr #24 ;@ Shift down

;@ First get X bit (middle):
  ldr r3,[r7,#0x4c]
  rsb r1,r2,#8
  and r3,r3,#0x20000000
  mov r3,r3,lsr #29
  mov r3,r3,lsl r1
;@ Rotate bits:
  orr r3,r3,r0,lsr r2 ;@ Orr right part
  rsbs r2,r2,#9 ;@ should also clear ARM V
  orrs r0,r3,r0,lsl r2 ;@ Orr left part, set flags

  movs r0,r0,lsl #24 ;@ Shift up and get correct NC flags
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: r0 into register[r11]:
  mov r0,r0,lsr #24
  strb r0,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e118] rol.b #8, d0 uses Ope118 ----------
Ope118:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]
  mov r0,r0,asl #24

;@ Mirror value in whole 32 bits:
  orr r0,r0,r0,lsr #8
  orr r0,r0,r0,lsr #16

;@ Rotate register:
  movs r0,r0,ror #24
  mrs r10,cpsr ;@ r10=flags
  bic r10,r10,#0x30000000 ;@ clear CV
;@ Get carry bit from bit 0:
  tst r0,#1
  orrne r10,r10,#0x20000000

;@ EaWrite: r0 into register[r11]:
  mov r0,r0,lsr #24
  strb r0,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e120] asl.b d0, d0 uses Ope120 ----------
Ope120:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]
  mov r0,r0,asl #24

;@ Use Dn for count:
  and r2,r8,#0x0e00
  ldr r2,[r7,r2,lsr #7]
  and r2,r2,#63

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

  adds r3,r0,#0 ;@ save old value for V flag calculation, also clear V
;@ Shift register:
  movs r0,r0,asl r2
  mrs r10,cpsr ;@ r10=flags
  cmp r2,#0 ;@ shifting by 0?
  biceq r10,r10,#0x20000000 ;@ if so, clear carry
  strne r10,[r7,#0x4c] ;@ else Save X bit

;@ calculate V flag (set if sign bit changes at anytime):
  mov r1,#0x80000000
  ands r3,r3,r1,asr r2
  cmpne r3,r1,asr r2
  eoreq r1,r0,r3
  tsteq r1,#0x80000000
  orrne r10,r10,#0x10000000

;@ EaWrite: r0 into register[r11]:
  mov r0,r0,lsr #24
  strb r0,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e128] lsl.b d0, d0 uses Ope128 ----------
Ope128:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]
  mov r0,r0,asl #24

;@ Use Dn for count:
  and r2,r8,#0x0e00
  ldr r2,[r7,r2,lsr #7]
  and r2,r2,#63

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Shift register:
  movs r0,r0,lsl r2
  mrs r10,cpsr ;@ r10=flags
  cmp r2,#0 ;@ shifting by 0?
  biceq r10,r10,#0x20000000 ;@ if so, clear carry
  strne r10,[r7,#0x4c] ;@ else Save X bit

;@ EaWrite: r0 into register[r11]:
  mov r0,r0,lsr #24
  strb r0,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e130] roxl.b d0, d0 uses Ope130 ----------
Ope130:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]
  mov r0,r0,asl #24

;@ Use Dn for count:
  and r2,r8,#0x0e00
  ldr r2,[r7,r2,lsr #7]
  and r2,r2,#63

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Reduce r2 until <0:
Reduce_e130:
  subs r2,r2,#9
  bpl Reduce_e130
  adds r2,r2,#9 ;@ Now r2=0-8
  beq norotx_e130

  rsb r2,r2,#9 ;@ Reverse direction
  mov r0,r0,lsr #24 ;@ Shift down

;@ First get X bit (middle):
  ldr r3,[r7,#0x4c]
  rsb r1,r2,#8
  and r3,r3,#0x20000000
  mov r3,r3,lsr #29
  mov r3,r3,lsl r1
;@ Rotate bits:
  orr r3,r3,r0,lsr r2 ;@ Orr right part
  rsbs r2,r2,#9 ;@ should also clear ARM V
  orrs r0,r3,r0,lsl r2 ;@ Orr left part, set flags

  movs r0,r0,lsl #24 ;@ Shift up and get correct NC flags
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ if not 0, Save X bit
  b nozeroxe130
norotx_e130:
  ldr r2,[r7,#0x4c]
  adds r0,r0,#0 ;@ Define flags
  and r10,r0,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV
  and r2,r2,#0x20000000
  orr r10,r10,r2 ;@ C = old_X
nozeroxe130:

;@ EaWrite: r0 into register[r11]:
  mov r0,r0,lsr #24
  strb r0,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e138] rol.b d0, d0 uses Ope138 ----------
Ope138:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]
  mov r0,r0,asl #24

;@ Use Dn for count:
  and r2,r8,#0x0e00
  ldr r2,[r7,r2,lsr #7]
  and r2,r2,#63

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Mirror value in whole 32 bits:
  orr r0,r0,r0,lsr #8
  orr r0,r0,r0,lsr #16

;@ Rotate register:
  rsb r2,r2,#32
  movs r0,r0,ror r2
  mrs r10,cpsr ;@ r10=flags
  bic r10,r10,#0x30000000 ;@ clear CV
;@ Get carry bit from bit 0:
  cmp r2,#32 ;@ rotating by 0?
  tstne r0,#1 ;@ no, check bit 0
  orrne r10,r10,#0x20000000

;@ EaWrite: r0 into register[r11]:
  mov r0,r0,lsr #24
  strb r0,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e140] asl.w #8, d0 uses Ope140 ----------
Ope140:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
  mov r11,r11,lsl #2
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11]
  mov r0,r0,asl #16

  adds r3,r0,#0 ;@ save old value for V flag calculation, also clear V
;@ Shift register:
  movs r0,r0,asl #8
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ calculate V flag (set if sign bit changes at anytime):
  mov r1,#0x80000000
  ands r3,r3,r1,asr #8
  cmpne r3,r1,asr #8
  eoreq r1,r0,r3
  tsteq r1,#0x80000000
  orrne r10,r10,#0x10000000

;@ EaWrite: r0 into register[r11]:
  mov r0,r0,lsr #16
  strh r0,[r7,r11]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e148] lsl.w #8, d0 uses Ope148 ----------
Ope148:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
  mov r11,r11,lsl #2
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11]
  mov r0,r0,asl #16

;@ Shift register:
  movs r0,r0,lsl #8
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: r0 into register[r11]:
  mov r0,r0,lsr #16
  strh r0,[r7,r11]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e150] roxl.w #8, d0 uses Ope150 ----------
Ope150:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
  mov r11,r11,lsl #2
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11]
  mov r0,r0,asl #16

  mov r2,#9 ;@ Reversed
  mov r0,r0,lsr #16 ;@ Shift down

;@ First get X bit (middle):
  ldr r3,[r7,#0x4c]
  rsb r1,r2,#16
  and r3,r3,#0x20000000
  mov r3,r3,lsr #29
  mov r3,r3,lsl r1
;@ Rotate bits:
  orr r3,r3,r0,lsr r2 ;@ Orr right part
  rsbs r2,r2,#17 ;@ should also clear ARM V
  orrs r0,r3,r0,lsl r2 ;@ Orr left part, set flags

  movs r0,r0,lsl #16 ;@ Shift up and get correct NC flags
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: r0 into register[r11]:
  mov r0,r0,lsr #16
  strh r0,[r7,r11]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e158] rol.w #8, d0 uses Ope158 ----------
Ope158:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
  mov r11,r11,lsl #2
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11]
  mov r0,r0,asl #16

;@ Mirror value in whole 32 bits:
  orr r0,r0,r0,lsr #16

;@ Rotate register:
  movs r0,r0,ror #24
  mrs r10,cpsr ;@ r10=flags
  bic r10,r10,#0x30000000 ;@ clear CV
;@ Get carry bit from bit 0:
  tst r0,#1
  orrne r10,r10,#0x20000000

;@ EaWrite: r0 into register[r11]:
  mov r0,r0,lsr #16
  strh r0,[r7,r11]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#22 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e160] asl.w d0, d0 uses Ope160 ----------
Ope160:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
  mov r11,r11,lsl #2
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11]
  mov r0,r0,asl #16

;@ Use Dn for count:
  and r2,r8,#0x0e00
  ldr r2,[r7,r2,lsr #7]
  and r2,r2,#63

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

  adds r3,r0,#0 ;@ save old value for V flag calculation, also clear V
;@ Shift register:
  movs r0,r0,asl r2
  mrs r10,cpsr ;@ r10=flags
  cmp r2,#0 ;@ shifting by 0?
  biceq r10,r10,#0x20000000 ;@ if so, clear carry
  strne r10,[r7,#0x4c] ;@ else Save X bit

;@ calculate V flag (set if sign bit changes at anytime):
  mov r1,#0x80000000
  ands r3,r3,r1,asr r2
  cmpne r3,r1,asr r2
  eoreq r1,r0,r3
  tsteq r1,#0x80000000
  orrne r10,r10,#0x10000000

;@ EaWrite: r0 into register[r11]:
  mov r0,r0,lsr #16
  strh r0,[r7,r11]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e168] lsl.w d0, d0 uses Ope168 ----------
Ope168:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
  mov r11,r11,lsl #2
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11]
  mov r0,r0,asl #16

;@ Use Dn for count:
  and r2,r8,#0x0e00
  ldr r2,[r7,r2,lsr #7]
  and r2,r2,#63

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Shift register:
  movs r0,r0,lsl r2
  mrs r10,cpsr ;@ r10=flags
  cmp r2,#0 ;@ shifting by 0?
  biceq r10,r10,#0x20000000 ;@ if so, clear carry
  strne r10,[r7,#0x4c] ;@ else Save X bit

;@ EaWrite: r0 into register[r11]:
  mov r0,r0,lsr #16
  strh r0,[r7,r11]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e170] roxl.w d0, d0 uses Ope170 ----------
Ope170:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
  mov r11,r11,lsl #2
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11]
  mov r0,r0,asl #16

;@ Use Dn for count:
  and r2,r8,#0x0e00
  ldr r2,[r7,r2,lsr #7]
  and r2,r2,#63

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Reduce r2 until <0:
Reduce_e170:
  subs r2,r2,#17
  bpl Reduce_e170
  adds r2,r2,#17 ;@ Now r2=0-16
  beq norotx_e170

  rsb r2,r2,#17 ;@ Reverse direction
  mov r0,r0,lsr #16 ;@ Shift down

;@ First get X bit (middle):
  ldr r3,[r7,#0x4c]
  rsb r1,r2,#16
  and r3,r3,#0x20000000
  mov r3,r3,lsr #29
  mov r3,r3,lsl r1
;@ Rotate bits:
  orr r3,r3,r0,lsr r2 ;@ Orr right part
  rsbs r2,r2,#17 ;@ should also clear ARM V
  orrs r0,r3,r0,lsl r2 ;@ Orr left part, set flags

  movs r0,r0,lsl #16 ;@ Shift up and get correct NC flags
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ if not 0, Save X bit
  b nozeroxe170
norotx_e170:
  ldr r2,[r7,#0x4c]
  adds r0,r0,#0 ;@ Define flags
  and r10,r0,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV
  and r2,r2,#0x20000000
  orr r10,r10,r2 ;@ C = old_X
nozeroxe170:

;@ EaWrite: r0 into register[r11]:
  mov r0,r0,lsr #16
  strh r0,[r7,r11]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e178] rol.w d0, d0 uses Ope178 ----------
Ope178:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
  mov r11,r11,lsl #2
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11]
  mov r0,r0,asl #16

;@ Use Dn for count:
  and r2,r8,#0x0e00
  ldr r2,[r7,r2,lsr #7]
  and r2,r2,#63

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Mirror value in whole 32 bits:
  orr r0,r0,r0,lsr #16

;@ Rotate register:
  rsb r2,r2,#32
  movs r0,r0,ror r2
  mrs r10,cpsr ;@ r10=flags
  bic r10,r10,#0x30000000 ;@ clear CV
;@ Get carry bit from bit 0:
  cmp r2,#32 ;@ rotating by 0?
  tstne r0,#1 ;@ no, check bit 0
  orrne r10,r10,#0x20000000

;@ EaWrite: r0 into register[r11]:
  mov r0,r0,lsr #16
  strh r0,[r7,r11]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e180] asl.l #8, d0 uses Ope180 ----------
Ope180:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

  adds r3,r0,#0 ;@ save old value for V flag calculation, also clear V
;@ Shift register:
  movs r0,r0,asl #8
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ calculate V flag (set if sign bit changes at anytime):
  mov r1,#0x80000000
  ands r3,r3,r1,asr #8
  cmpne r3,r1,asr #8
  eoreq r1,r0,r3
  tsteq r1,#0x80000000
  orrne r10,r10,#0x10000000

;@ EaWrite: r0 into register[r11]:
  str r0,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e188] lsl.l #8, d0 uses Ope188 ----------
Ope188:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

;@ Shift register:
  movs r0,r0,lsl #8
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: r0 into register[r11]:
  str r0,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e190] roxl.l #8, d0 uses Ope190 ----------
Ope190:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

  mov r2,#25 ;@ Reversed

;@ First get X bit (middle):
  ldr r3,[r7,#0x4c]
  rsb r1,r2,#32
  and r3,r3,#0x20000000
  mov r3,r3,lsr #29
  mov r3,r3,lsl r1
;@ Rotate bits:
  orr r3,r3,r0,lsr r2 ;@ Orr right part
  rsbs r2,r2,#33 ;@ should also clear ARM V
  orrs r0,r3,r0,lsl r2 ;@ Orr left part, set flags

  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: r0 into register[r11]:
  str r0,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e198] rol.l #8, d0 uses Ope198 ----------
Ope198:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

;@ Rotate register:
  movs r0,r0,ror #24
  mrs r10,cpsr ;@ r10=flags
  bic r10,r10,#0x30000000 ;@ clear CV
;@ Get carry bit from bit 0:
  tst r0,#1
  orrne r10,r10,#0x20000000

;@ EaWrite: r0 into register[r11]:
  str r0,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#24 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e1a0] asl.l d0, d0 uses Ope1a0 ----------
Ope1a0:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

;@ Use Dn for count:
  and r2,r8,#0x0e00
  ldr r2,[r7,r2,lsr #7]
  and r2,r2,#63

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

  adds r3,r0,#0 ;@ save old value for V flag calculation, also clear V
;@ Shift register:
  movs r0,r0,asl r2
  mrs r10,cpsr ;@ r10=flags
  cmp r2,#0 ;@ shifting by 0?
  biceq r10,r10,#0x20000000 ;@ if so, clear carry
  strne r10,[r7,#0x4c] ;@ else Save X bit

;@ calculate V flag (set if sign bit changes at anytime):
  mov r1,#0x80000000
  ands r3,r3,r1,asr r2
  cmpne r3,r1,asr r2
  eoreq r1,r0,r3
  tsteq r1,#0x80000000
  orrne r10,r10,#0x10000000

;@ EaWrite: r0 into register[r11]:
  str r0,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e1a8] lsl.l d0, d0 uses Ope1a8 ----------
Ope1a8:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

;@ Use Dn for count:
  and r2,r8,#0x0e00
  ldr r2,[r7,r2,lsr #7]
  and r2,r2,#63

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Shift register:
  movs r0,r0,lsl r2
  mrs r10,cpsr ;@ r10=flags
  cmp r2,#0 ;@ shifting by 0?
  biceq r10,r10,#0x20000000 ;@ if so, clear carry
  strne r10,[r7,#0x4c] ;@ else Save X bit

;@ EaWrite: r0 into register[r11]:
  str r0,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e1b0] roxl.l d0, d0 uses Ope1b0 ----------
Ope1b0:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

;@ Use Dn for count:
  and r2,r8,#0x0e00
  ldr r2,[r7,r2,lsr #7]
  and r2,r2,#63

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

  subs r2,r2,#33
  addmis r2,r2,#33 ;@ Now r2=0-32
  beq norotx_e1b0

  rsb r2,r2,#33 ;@ Reverse direction

;@ First get X bit (middle):
  ldr r3,[r7,#0x4c]
  rsb r1,r2,#32
  and r3,r3,#0x20000000
  mov r3,r3,lsr #29
  mov r3,r3,lsl r1
;@ Rotate bits:
  orr r3,r3,r0,lsr r2 ;@ Orr right part
  rsbs r2,r2,#33 ;@ should also clear ARM V
  orrs r0,r3,r0,lsl r2 ;@ Orr left part, set flags

  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ if not 0, Save X bit
  b nozeroxe1b0
norotx_e1b0:
  ldr r2,[r7,#0x4c]
  adds r0,r0,#0 ;@ Define flags
  and r10,r0,#0x80000000 ;@ r10=N_flag
  orreq r10,r10,#0x40000000 ;@ get NZ, clear CV
  and r2,r2,#0x20000000
  orr r10,r10,r2 ;@ C = old_X
nozeroxe1b0:

;@ EaWrite: r0 into register[r11]:
  str r0,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e1b8] rol.l d0, d0 uses Ope1b8 ----------
Ope1b8:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

;@ Use Dn for count:
  and r2,r8,#0x0e00
  ldr r2,[r7,r2,lsr #7]
  and r2,r2,#63

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Rotate register:
  rsb r2,r2,#32
  movs r0,r0,ror r2
  mrs r10,cpsr ;@ r10=flags
  bic r10,r10,#0x30000000 ;@ clear CV
;@ Get carry bit from bit 0:
  cmp r2,#32 ;@ rotating by 0?
  tstne r0,#1 ;@ no, check bit 0
  orrne r10,r10,#0x20000000

;@ EaWrite: r0 into register[r11]:
  str r0,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e1d0] asl.w (a0) uses Ope1d0 ----------
Ope1d0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  adds r3,r0,#0 ;@ save old value for V flag calculation, also clear V
;@ Shift register:
  movs r0,r0,asl #1
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ calculate V flag (set if sign bit changes at anytime):
  mov r1,#0x80000000
  ands r3,r3,r1,asr #1
  cmpne r3,r1,asr #1
  eoreq r1,r0,r3
  tsteq r1,#0x80000000
  orrne r10,r10,#0x10000000

;@ EaWrite: Write r0 into '(a0)' (address in r11):
  mov r1,r0,lsr #16
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e1d8] asl.w (a0)+ uses Ope1d8 ----------
Ope1d8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  adds r3,r0,#0 ;@ save old value for V flag calculation, also clear V
;@ Shift register:
  movs r0,r0,asl #1
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ calculate V flag (set if sign bit changes at anytime):
  mov r1,#0x80000000
  ands r3,r3,r1,asr #1
  cmpne r3,r1,asr #1
  eoreq r1,r0,r3
  tsteq r1,#0x80000000
  orrne r10,r10,#0x10000000

;@ EaWrite: Write r0 into '(a0)+' (address in r11):
  mov r1,r0,lsr #16
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e1e0] asl.w -(a0) uses Ope1e0 ----------
Ope1e0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  adds r3,r0,#0 ;@ save old value for V flag calculation, also clear V
;@ Shift register:
  movs r0,r0,asl #1
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ calculate V flag (set if sign bit changes at anytime):
  mov r1,#0x80000000
  ands r3,r3,r1,asr #1
  cmpne r3,r1,asr #1
  eoreq r1,r0,r3
  tsteq r1,#0x80000000
  orrne r10,r10,#0x10000000

;@ EaWrite: Write r0 into '-(a0)' (address in r11):
  mov r1,r0,lsr #16
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e1e8] asl.w ($3333,a0) uses Ope1e8 ----------
Ope1e8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  adds r3,r0,#0 ;@ save old value for V flag calculation, also clear V
;@ Shift register:
  movs r0,r0,asl #1
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ calculate V flag (set if sign bit changes at anytime):
  mov r1,#0x80000000
  ands r3,r3,r1,asr #1
  cmpne r3,r1,asr #1
  eoreq r1,r0,r3
  tsteq r1,#0x80000000
  orrne r10,r10,#0x10000000

;@ EaWrite: Write r0 into '($3333,a0)' (address in r11):
  mov r1,r0,lsr #16
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e1f0] asl.w ($33,a0,d3.w*2) uses Ope1f0 ----------
Ope1f0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  adds r3,r0,#0 ;@ save old value for V flag calculation, also clear V
;@ Shift register:
  movs r0,r0,asl #1
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ calculate V flag (set if sign bit changes at anytime):
  mov r1,#0x80000000
  ands r3,r3,r1,asr #1
  cmpne r3,r1,asr #1
  eoreq r1,r0,r3
  tsteq r1,#0x80000000
  orrne r10,r10,#0x10000000

;@ EaWrite: Write r0 into '($33,a0,d3.w*2)' (address in r11):
  mov r1,r0,lsr #16
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e1f8] asl.w $3333.w uses Ope1f8 ----------
Ope1f8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  adds r3,r0,#0 ;@ save old value for V flag calculation, also clear V
;@ Shift register:
  movs r0,r0,asl #1
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ calculate V flag (set if sign bit changes at anytime):
  mov r1,#0x80000000
  ands r3,r3,r1,asr #1
  cmpne r3,r1,asr #1
  eoreq r1,r0,r3
  tsteq r1,#0x80000000
  orrne r10,r10,#0x10000000

;@ EaWrite: Write r0 into '$3333.w' (address in r11):
  mov r1,r0,lsr #16
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e1f9] asl.w $33333333.l uses Ope1f9 ----------
Ope1f9:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  adds r3,r0,#0 ;@ save old value for V flag calculation, also clear V
;@ Shift register:
  movs r0,r0,asl #1
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ calculate V flag (set if sign bit changes at anytime):
  mov r1,#0x80000000
  ands r3,r3,r1,asr #1
  cmpne r3,r1,asr #1
  eoreq r1,r0,r3
  tsteq r1,#0x80000000
  orrne r10,r10,#0x10000000

;@ EaWrite: Write r0 into '$33333333.l' (address in r11):
  mov r1,r0,lsr #16
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e210] roxr.b #1, d0 uses Ope210 ----------
Ope210:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]
  mov r0,r0,asl #24

  orr r0,r0,r0,lsr #24
  bic r0,r0,#0x1000000
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  tst r2,r2,lsl #3 ;@ Get into Carry

  movs r0,r0,rrx
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit
  bic r10,r10,#0x10000000 ;@ make suve V is clear
;@ EaWrite: r0 into register[r11]:
  mov r0,r0,lsr #24
  strb r0,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e250] roxr.w #1, d0 uses Ope250 ----------
Ope250:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
  mov r11,r11,lsl #2
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11]
  mov r0,r0,asl #16

  orr r0,r0,r0,lsr #16
  bic r0,r0,#0x10000
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  tst r2,r2,lsl #3 ;@ Get into Carry

  movs r0,r0,rrx
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit
  bic r10,r10,#0x10000000 ;@ make suve V is clear
;@ EaWrite: r0 into register[r11]:
  mov r0,r0,lsr #16
  strh r0,[r7,r11]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e290] roxr.l #1, d0 uses Ope290 ----------
Ope290:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

;@ Get X bit:
  ldr r2,[r7,#0x4c]
  tst r2,r2,lsl #3 ;@ Get into Carry

  movs r0,r0,rrx
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit
  bic r10,r10,#0x10000000 ;@ make suve V is clear
;@ EaWrite: r0 into register[r11]:
  str r0,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e2d0] lsr.w (a0) uses Ope2d0 ----------
Ope2d0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ For shift right, use loworder bits for the operation:
  mov r0,r0,lsr #16

;@ Shift register:
  movs r0,r0,lsr #1
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ restore after right shift:
  movs r0,r0,lsl #16
  orrmi r10,r10,#0x80000000 ;@ Potentially missed N flag

;@ EaWrite: Write r0 into '(a0)' (address in r11):
  mov r1,r0,lsr #16
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e2d8] lsr.w (a0)+ uses Ope2d8 ----------
Ope2d8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ For shift right, use loworder bits for the operation:
  mov r0,r0,lsr #16

;@ Shift register:
  movs r0,r0,lsr #1
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ restore after right shift:
  movs r0,r0,lsl #16
  orrmi r10,r10,#0x80000000 ;@ Potentially missed N flag

;@ EaWrite: Write r0 into '(a0)+' (address in r11):
  mov r1,r0,lsr #16
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e2e0] lsr.w -(a0) uses Ope2e0 ----------
Ope2e0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ For shift right, use loworder bits for the operation:
  mov r0,r0,lsr #16

;@ Shift register:
  movs r0,r0,lsr #1
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ restore after right shift:
  movs r0,r0,lsl #16
  orrmi r10,r10,#0x80000000 ;@ Potentially missed N flag

;@ EaWrite: Write r0 into '-(a0)' (address in r11):
  mov r1,r0,lsr #16
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e2e8] lsr.w ($3333,a0) uses Ope2e8 ----------
Ope2e8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ For shift right, use loworder bits for the operation:
  mov r0,r0,lsr #16

;@ Shift register:
  movs r0,r0,lsr #1
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ restore after right shift:
  movs r0,r0,lsl #16
  orrmi r10,r10,#0x80000000 ;@ Potentially missed N flag

;@ EaWrite: Write r0 into '($3333,a0)' (address in r11):
  mov r1,r0,lsr #16
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e2f0] lsr.w ($33,a0,d3.w*2) uses Ope2f0 ----------
Ope2f0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ For shift right, use loworder bits for the operation:
  mov r0,r0,lsr #16

;@ Shift register:
  movs r0,r0,lsr #1
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ restore after right shift:
  movs r0,r0,lsl #16
  orrmi r10,r10,#0x80000000 ;@ Potentially missed N flag

;@ EaWrite: Write r0 into '($33,a0,d3.w*2)' (address in r11):
  mov r1,r0,lsr #16
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e2f8] lsr.w $3333.w uses Ope2f8 ----------
Ope2f8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ For shift right, use loworder bits for the operation:
  mov r0,r0,lsr #16

;@ Shift register:
  movs r0,r0,lsr #1
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ restore after right shift:
  movs r0,r0,lsl #16
  orrmi r10,r10,#0x80000000 ;@ Potentially missed N flag

;@ EaWrite: Write r0 into '$3333.w' (address in r11):
  mov r1,r0,lsr #16
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e2f9] lsr.w $33333333.l uses Ope2f9 ----------
Ope2f9:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ For shift right, use loworder bits for the operation:
  mov r0,r0,lsr #16

;@ Shift register:
  movs r0,r0,lsr #1
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ restore after right shift:
  movs r0,r0,lsl #16
  orrmi r10,r10,#0x80000000 ;@ Potentially missed N flag

;@ EaWrite: Write r0 into '$33333333.l' (address in r11):
  mov r1,r0,lsr #16
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e310] roxl.b #1, d0 uses Ope310 ----------
Ope310:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]
  mov r0,r0,asl #24

  ldr r3,[r7,#0x4c]
  movs r0,r0,lsl #1
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit
  tst r3,#0x20000000
  orrne r0,r0,#0x1000000
  bicne r10,r10,#0x40000000 ;@ clear Z in case it got there
  bic r10,r10,#0x10000000 ;@ make suve V is clear
;@ EaWrite: r0 into register[r11]:
  mov r0,r0,lsr #24
  strb r0,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e350] roxl.w #1, d0 uses Ope350 ----------
Ope350:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
  mov r11,r11,lsl #2
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11]
  mov r0,r0,asl #16

  ldr r3,[r7,#0x4c]
  movs r0,r0,lsl #1
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit
  tst r3,#0x20000000
  orrne r0,r0,#0x10000
  bicne r10,r10,#0x40000000 ;@ clear Z in case it got there
  bic r10,r10,#0x10000000 ;@ make suve V is clear
;@ EaWrite: r0 into register[r11]:
  mov r0,r0,lsr #16
  strh r0,[r7,r11]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e390] roxl.l #1, d0 uses Ope390 ----------
Ope390:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

  ldr r3,[r7,#0x4c]
  movs r0,r0,lsl #1
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit
  tst r3,#0x20000000
  orrne r0,r0,#0x1
  bicne r10,r10,#0x40000000 ;@ clear Z in case it got there
  bic r10,r10,#0x10000000 ;@ make suve V is clear
;@ EaWrite: r0 into register[r11]:
  str r0,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#10 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e3d0] lsl.w (a0) uses Ope3d0 ----------
Ope3d0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Shift register:
  movs r0,r0,lsl #1
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r0 into '(a0)' (address in r11):
  mov r1,r0,lsr #16
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e3d8] lsl.w (a0)+ uses Ope3d8 ----------
Ope3d8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Shift register:
  movs r0,r0,lsl #1
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r0 into '(a0)+' (address in r11):
  mov r1,r0,lsr #16
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e3e0] lsl.w -(a0) uses Ope3e0 ----------
Ope3e0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Shift register:
  movs r0,r0,lsl #1
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r0 into '-(a0)' (address in r11):
  mov r1,r0,lsr #16
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e3e8] lsl.w ($3333,a0) uses Ope3e8 ----------
Ope3e8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Shift register:
  movs r0,r0,lsl #1
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r0 into '($3333,a0)' (address in r11):
  mov r1,r0,lsr #16
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e3f0] lsl.w ($33,a0,d3.w*2) uses Ope3f0 ----------
Ope3f0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Shift register:
  movs r0,r0,lsl #1
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r0 into '($33,a0,d3.w*2)' (address in r11):
  mov r1,r0,lsr #16
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e3f8] lsl.w $3333.w uses Ope3f8 ----------
Ope3f8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Shift register:
  movs r0,r0,lsl #1
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r0 into '$3333.w' (address in r11):
  mov r1,r0,lsr #16
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e3f9] lsl.w $33333333.l uses Ope3f9 ----------
Ope3f9:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Shift register:
  movs r0,r0,lsl #1
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r0 into '$33333333.l' (address in r11):
  mov r1,r0,lsr #16
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e4d0] roxr.w (a0) uses Ope4d0 ----------
Ope4d0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  orr r0,r0,r0,lsr #16
  bic r0,r0,#0x10000
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  tst r2,r2,lsl #3 ;@ Get into Carry

  movs r0,r0,rrx
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit
  bic r10,r10,#0x10000000 ;@ make suve V is clear
;@ EaWrite: Write r0 into '(a0)' (address in r11):
  mov r1,r0,lsr #16
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e4d8] roxr.w (a0)+ uses Ope4d8 ----------
Ope4d8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  orr r0,r0,r0,lsr #16
  bic r0,r0,#0x10000
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  tst r2,r2,lsl #3 ;@ Get into Carry

  movs r0,r0,rrx
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit
  bic r10,r10,#0x10000000 ;@ make suve V is clear
;@ EaWrite: Write r0 into '(a0)+' (address in r11):
  mov r1,r0,lsr #16
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e4e0] roxr.w -(a0) uses Ope4e0 ----------
Ope4e0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  orr r0,r0,r0,lsr #16
  bic r0,r0,#0x10000
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  tst r2,r2,lsl #3 ;@ Get into Carry

  movs r0,r0,rrx
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit
  bic r10,r10,#0x10000000 ;@ make suve V is clear
;@ EaWrite: Write r0 into '-(a0)' (address in r11):
  mov r1,r0,lsr #16
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e4e8] roxr.w ($3333,a0) uses Ope4e8 ----------
Ope4e8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  orr r0,r0,r0,lsr #16
  bic r0,r0,#0x10000
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  tst r2,r2,lsl #3 ;@ Get into Carry

  movs r0,r0,rrx
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit
  bic r10,r10,#0x10000000 ;@ make suve V is clear
;@ EaWrite: Write r0 into '($3333,a0)' (address in r11):
  mov r1,r0,lsr #16
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e4f0] roxr.w ($33,a0,d3.w*2) uses Ope4f0 ----------
Ope4f0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  orr r0,r0,r0,lsr #16
  bic r0,r0,#0x10000
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  tst r2,r2,lsl #3 ;@ Get into Carry

  movs r0,r0,rrx
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit
  bic r10,r10,#0x10000000 ;@ make suve V is clear
;@ EaWrite: Write r0 into '($33,a0,d3.w*2)' (address in r11):
  mov r1,r0,lsr #16
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e4f8] roxr.w $3333.w uses Ope4f8 ----------
Ope4f8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  orr r0,r0,r0,lsr #16
  bic r0,r0,#0x10000
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  tst r2,r2,lsl #3 ;@ Get into Carry

  movs r0,r0,rrx
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit
  bic r10,r10,#0x10000000 ;@ make suve V is clear
;@ EaWrite: Write r0 into '$3333.w' (address in r11):
  mov r1,r0,lsr #16
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e4f9] roxr.w $33333333.l uses Ope4f9 ----------
Ope4f9:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  orr r0,r0,r0,lsr #16
  bic r0,r0,#0x10000
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  tst r2,r2,lsl #3 ;@ Get into Carry

  movs r0,r0,rrx
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit
  bic r10,r10,#0x10000000 ;@ make suve V is clear
;@ EaWrite: Write r0 into '$33333333.l' (address in r11):
  mov r1,r0,lsr #16
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e5d0] roxl.w (a0) uses Ope5d0 ----------
Ope5d0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  ldr r3,[r7,#0x4c]
  movs r0,r0,lsl #1
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit
  tst r3,#0x20000000
  orrne r0,r0,#0x10000
  bicne r10,r10,#0x40000000 ;@ clear Z in case it got there
  bic r10,r10,#0x10000000 ;@ make suve V is clear
;@ EaWrite: Write r0 into '(a0)' (address in r11):
  mov r1,r0,lsr #16
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e5d8] roxl.w (a0)+ uses Ope5d8 ----------
Ope5d8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  ldr r3,[r7,#0x4c]
  movs r0,r0,lsl #1
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit
  tst r3,#0x20000000
  orrne r0,r0,#0x10000
  bicne r10,r10,#0x40000000 ;@ clear Z in case it got there
  bic r10,r10,#0x10000000 ;@ make suve V is clear
;@ EaWrite: Write r0 into '(a0)+' (address in r11):
  mov r1,r0,lsr #16
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e5e0] roxl.w -(a0) uses Ope5e0 ----------
Ope5e0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  ldr r3,[r7,#0x4c]
  movs r0,r0,lsl #1
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit
  tst r3,#0x20000000
  orrne r0,r0,#0x10000
  bicne r10,r10,#0x40000000 ;@ clear Z in case it got there
  bic r10,r10,#0x10000000 ;@ make suve V is clear
;@ EaWrite: Write r0 into '-(a0)' (address in r11):
  mov r1,r0,lsr #16
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e5e8] roxl.w ($3333,a0) uses Ope5e8 ----------
Ope5e8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  ldr r3,[r7,#0x4c]
  movs r0,r0,lsl #1
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit
  tst r3,#0x20000000
  orrne r0,r0,#0x10000
  bicne r10,r10,#0x40000000 ;@ clear Z in case it got there
  bic r10,r10,#0x10000000 ;@ make suve V is clear
;@ EaWrite: Write r0 into '($3333,a0)' (address in r11):
  mov r1,r0,lsr #16
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e5f0] roxl.w ($33,a0,d3.w*2) uses Ope5f0 ----------
Ope5f0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  ldr r3,[r7,#0x4c]
  movs r0,r0,lsl #1
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit
  tst r3,#0x20000000
  orrne r0,r0,#0x10000
  bicne r10,r10,#0x40000000 ;@ clear Z in case it got there
  bic r10,r10,#0x10000000 ;@ make suve V is clear
;@ EaWrite: Write r0 into '($33,a0,d3.w*2)' (address in r11):
  mov r1,r0,lsr #16
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e5f8] roxl.w $3333.w uses Ope5f8 ----------
Ope5f8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  ldr r3,[r7,#0x4c]
  movs r0,r0,lsl #1
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit
  tst r3,#0x20000000
  orrne r0,r0,#0x10000
  bicne r10,r10,#0x40000000 ;@ clear Z in case it got there
  bic r10,r10,#0x10000000 ;@ make suve V is clear
;@ EaWrite: Write r0 into '$3333.w' (address in r11):
  mov r1,r0,lsr #16
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e5f9] roxl.w $33333333.l uses Ope5f9 ----------
Ope5f9:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  ldr r3,[r7,#0x4c]
  movs r0,r0,lsl #1
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit
  tst r3,#0x20000000
  orrne r0,r0,#0x10000
  bicne r10,r10,#0x40000000 ;@ clear Z in case it got there
  bic r10,r10,#0x10000000 ;@ make suve V is clear
;@ EaWrite: Write r0 into '$33333333.l' (address in r11):
  mov r1,r0,lsr #16
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e6d0] ror.w (a0) uses Ope6d0 ----------
Ope6d0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Mirror value in whole 32 bits:
  orr r0,r0,r0,lsr #16

;@ Rotate register:
  adds r0,r0,#0 ;@ first clear V and C
  movs r0,r0,ror #1
  mrs r10,cpsr ;@ r10=flags

;@ EaWrite: Write r0 into '(a0)' (address in r11):
  mov r1,r0,lsr #16
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e6d8] ror.w (a0)+ uses Ope6d8 ----------
Ope6d8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Mirror value in whole 32 bits:
  orr r0,r0,r0,lsr #16

;@ Rotate register:
  adds r0,r0,#0 ;@ first clear V and C
  movs r0,r0,ror #1
  mrs r10,cpsr ;@ r10=flags

;@ EaWrite: Write r0 into '(a0)+' (address in r11):
  mov r1,r0,lsr #16
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e6e0] ror.w -(a0) uses Ope6e0 ----------
Ope6e0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Mirror value in whole 32 bits:
  orr r0,r0,r0,lsr #16

;@ Rotate register:
  adds r0,r0,#0 ;@ first clear V and C
  movs r0,r0,ror #1
  mrs r10,cpsr ;@ r10=flags

;@ EaWrite: Write r0 into '-(a0)' (address in r11):
  mov r1,r0,lsr #16
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e6e8] ror.w ($3333,a0) uses Ope6e8 ----------
Ope6e8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Mirror value in whole 32 bits:
  orr r0,r0,r0,lsr #16

;@ Rotate register:
  adds r0,r0,#0 ;@ first clear V and C
  movs r0,r0,ror #1
  mrs r10,cpsr ;@ r10=flags

;@ EaWrite: Write r0 into '($3333,a0)' (address in r11):
  mov r1,r0,lsr #16
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e6f0] ror.w ($33,a0,d3.w*2) uses Ope6f0 ----------
Ope6f0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Mirror value in whole 32 bits:
  orr r0,r0,r0,lsr #16

;@ Rotate register:
  adds r0,r0,#0 ;@ first clear V and C
  movs r0,r0,ror #1
  mrs r10,cpsr ;@ r10=flags

;@ EaWrite: Write r0 into '($33,a0,d3.w*2)' (address in r11):
  mov r1,r0,lsr #16
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e6f8] ror.w $3333.w uses Ope6f8 ----------
Ope6f8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Mirror value in whole 32 bits:
  orr r0,r0,r0,lsr #16

;@ Rotate register:
  adds r0,r0,#0 ;@ first clear V and C
  movs r0,r0,ror #1
  mrs r10,cpsr ;@ r10=flags

;@ EaWrite: Write r0 into '$3333.w' (address in r11):
  mov r1,r0,lsr #16
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e6f9] ror.w $33333333.l uses Ope6f9 ----------
Ope6f9:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Mirror value in whole 32 bits:
  orr r0,r0,r0,lsr #16

;@ Rotate register:
  adds r0,r0,#0 ;@ first clear V and C
  movs r0,r0,ror #1
  mrs r10,cpsr ;@ r10=flags

;@ EaWrite: Write r0 into '$33333333.l' (address in r11):
  mov r1,r0,lsr #16
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e7d0] rol.w (a0) uses Ope7d0 ----------
Ope7d0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Mirror value in whole 32 bits:
  orr r0,r0,r0,lsr #16

;@ Rotate register:
  movs r0,r0,ror #31
  mrs r10,cpsr ;@ r10=flags
  bic r10,r10,#0x30000000 ;@ clear CV
;@ Get carry bit from bit 0:
  tst r0,#1
  orrne r10,r10,#0x20000000

;@ EaWrite: Write r0 into '(a0)' (address in r11):
  mov r1,r0,lsr #16
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e7d8] rol.w (a0)+ uses Ope7d8 ----------
Ope7d8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Mirror value in whole 32 bits:
  orr r0,r0,r0,lsr #16

;@ Rotate register:
  movs r0,r0,ror #31
  mrs r10,cpsr ;@ r10=flags
  bic r10,r10,#0x30000000 ;@ clear CV
;@ Get carry bit from bit 0:
  tst r0,#1
  orrne r10,r10,#0x20000000

;@ EaWrite: Write r0 into '(a0)+' (address in r11):
  mov r1,r0,lsr #16
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#12 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e7e0] rol.w -(a0) uses Ope7e0 ----------
Ope7e0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Mirror value in whole 32 bits:
  orr r0,r0,r0,lsr #16

;@ Rotate register:
  movs r0,r0,ror #31
  mrs r10,cpsr ;@ r10=flags
  bic r10,r10,#0x30000000 ;@ clear CV
;@ Get carry bit from bit 0:
  tst r0,#1
  orrne r10,r10,#0x20000000

;@ EaWrite: Write r0 into '-(a0)' (address in r11):
  mov r1,r0,lsr #16
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#14 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e7e8] rol.w ($3333,a0) uses Ope7e8 ----------
Ope7e8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Mirror value in whole 32 bits:
  orr r0,r0,r0,lsr #16

;@ Rotate register:
  movs r0,r0,ror #31
  mrs r10,cpsr ;@ r10=flags
  bic r10,r10,#0x30000000 ;@ clear CV
;@ Get carry bit from bit 0:
  tst r0,#1
  orrne r10,r10,#0x20000000

;@ EaWrite: Write r0 into '($3333,a0)' (address in r11):
  mov r1,r0,lsr #16
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e7f0] rol.w ($33,a0,d3.w*2) uses Ope7f0 ----------
Ope7f0:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Mirror value in whole 32 bits:
  orr r0,r0,r0,lsr #16

;@ Rotate register:
  movs r0,r0,ror #31
  mrs r10,cpsr ;@ r10=flags
  bic r10,r10,#0x30000000 ;@ clear CV
;@ Get carry bit from bit 0:
  tst r0,#1
  orrne r10,r10,#0x20000000

;@ EaWrite: Write r0 into '($33,a0,d3.w*2)' (address in r11):
  mov r1,r0,lsr #16
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#18 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e7f8] rol.w $3333.w uses Ope7f8 ----------
Ope7f8:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Mirror value in whole 32 bits:
  orr r0,r0,r0,lsr #16

;@ Rotate register:
  movs r0,r0,ror #31
  mrs r10,cpsr ;@ r10=flags
  bic r10,r10,#0x30000000 ;@ clear CV
;@ Get carry bit from bit 0:
  tst r0,#1
  orrne r10,r10,#0x20000000

;@ EaWrite: Write r0 into '$3333.w' (address in r11):
  mov r1,r0,lsr #16
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#16 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [e7f9] rol.w $33333333.l uses Ope7f9 ----------
Ope7f9:
  str r5,[r7,#0x5c] ;@ Save Cycles

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  mov r0,r11
  bl cyclone_read16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Mirror value in whole 32 bits:
  orr r0,r0,r0,lsr #16

;@ Rotate register:
  movs r0,r0,ror #31
  mrs r10,cpsr ;@ r10=flags
  bic r10,r10,#0x30000000 ;@ clear CV
;@ Get carry bit from bit 0:
  tst r0,#1
  orrne r10,r10,#0x20000000

;@ EaWrite: Write r0 into '$33333333.l' (address in r11):
  mov r1,r0,lsr #16
  mov r0,r11
  bl cyclone_write16 ;@ Call write16(r0,r1) handler

  ldr r5,[r7,#0x5c] ;@ Load Cycles
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#20 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [ee00] asr.b #7, d0 uses Opee00 ----------
Opee00:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]
  mov r0,r0,asl #24

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ For shift right, use loworder bits for the operation:
  mov r0,r0,asr #24

;@ Shift register:
  movs r0,r0,asr r2
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ restore after right shift:
  movs r0,r0,lsl #24

;@ EaWrite: r0 into register[r11]:
  mov r0,r0,lsr #24
  strb r0,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [ee08] lsr.b #7, d0 uses Opee08 ----------
Opee08:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]
  mov r0,r0,asl #24

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ For shift right, use loworder bits for the operation:
  mov r0,r0,lsr #24

;@ Shift register:
  movs r0,r0,lsr r2
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ restore after right shift:
  movs r0,r0,lsl #24
  orrmi r10,r10,#0x80000000 ;@ Potentially missed N flag

;@ EaWrite: r0 into register[r11]:
  mov r0,r0,lsr #24
  strb r0,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [ee10] roxr.b #7, d0 uses Opee10 ----------
Opee10:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]
  mov r0,r0,asl #24

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

  mov r0,r0,lsr #24 ;@ Shift down

;@ First get X bit (middle):
  ldr r3,[r7,#0x4c]
  rsb r1,r2,#8
  and r3,r3,#0x20000000
  mov r3,r3,lsr #29
  mov r3,r3,lsl r1
;@ Rotate bits:
  orr r3,r3,r0,lsr r2 ;@ Orr right part
  rsbs r2,r2,#9 ;@ should also clear ARM V
  orrs r0,r3,r0,lsl r2 ;@ Orr left part, set flags

  movs r0,r0,lsl #24 ;@ Shift up and get correct NC flags
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: r0 into register[r11]:
  mov r0,r0,lsr #24
  strb r0,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [ee18] ror.b #7, d0 uses Opee18 ----------
Opee18:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]
  mov r0,r0,asl #24

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Mirror value in whole 32 bits:
  orr r0,r0,r0,lsr #8
  orr r0,r0,r0,lsr #16

;@ Rotate register:
  adds r0,r0,#0 ;@ first clear V and C
  movs r0,r0,ror r2
  mrs r10,cpsr ;@ r10=flags

;@ EaWrite: r0 into register[r11]:
  mov r0,r0,lsr #24
  strb r0,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [ee40] asr.w #7, d0 uses Opee40 ----------
Opee40:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
  mov r11,r11,lsl #2
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11]
  mov r0,r0,asl #16

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ For shift right, use loworder bits for the operation:
  mov r0,r0,asr #16

;@ Shift register:
  movs r0,r0,asr r2
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ restore after right shift:
  movs r0,r0,lsl #16

;@ EaWrite: r0 into register[r11]:
  mov r0,r0,lsr #16
  strh r0,[r7,r11]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [ee48] lsr.w #7, d0 uses Opee48 ----------
Opee48:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
  mov r11,r11,lsl #2
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11]
  mov r0,r0,asl #16

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ For shift right, use loworder bits for the operation:
  mov r0,r0,lsr #16

;@ Shift register:
  movs r0,r0,lsr r2
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ restore after right shift:
  movs r0,r0,lsl #16
  orrmi r10,r10,#0x80000000 ;@ Potentially missed N flag

;@ EaWrite: r0 into register[r11]:
  mov r0,r0,lsr #16
  strh r0,[r7,r11]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [ee50] roxr.w #7, d0 uses Opee50 ----------
Opee50:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
  mov r11,r11,lsl #2
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11]
  mov r0,r0,asl #16

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

  mov r0,r0,lsr #16 ;@ Shift down

;@ First get X bit (middle):
  ldr r3,[r7,#0x4c]
  rsb r1,r2,#16
  and r3,r3,#0x20000000
  mov r3,r3,lsr #29
  mov r3,r3,lsl r1
;@ Rotate bits:
  orr r3,r3,r0,lsr r2 ;@ Orr right part
  rsbs r2,r2,#17 ;@ should also clear ARM V
  orrs r0,r3,r0,lsl r2 ;@ Orr left part, set flags

  movs r0,r0,lsl #16 ;@ Shift up and get correct NC flags
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: r0 into register[r11]:
  mov r0,r0,lsr #16
  strh r0,[r7,r11]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [ee58] ror.w #7, d0 uses Opee58 ----------
Opee58:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
  mov r11,r11,lsl #2
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11]
  mov r0,r0,asl #16

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Mirror value in whole 32 bits:
  orr r0,r0,r0,lsr #16

;@ Rotate register:
  adds r0,r0,#0 ;@ first clear V and C
  movs r0,r0,ror r2
  mrs r10,cpsr ;@ r10=flags

;@ EaWrite: r0 into register[r11]:
  mov r0,r0,lsr #16
  strh r0,[r7,r11]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [ee80] asr.l #7, d0 uses Opee80 ----------
Opee80:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Shift register:
  movs r0,r0,asr r2
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: r0 into register[r11]:
  str r0,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [ee88] lsr.l #7, d0 uses Opee88 ----------
Opee88:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Shift register:
  movs r0,r0,lsr r2
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: r0 into register[r11]:
  str r0,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [ee90] roxr.l #7, d0 uses Opee90 ----------
Opee90:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles


;@ First get X bit (middle):
  ldr r3,[r7,#0x4c]
  rsb r1,r2,#32
  and r3,r3,#0x20000000
  mov r3,r3,lsr #29
  mov r3,r3,lsl r1
;@ Rotate bits:
  orr r3,r3,r0,lsr r2 ;@ Orr right part
  rsbs r2,r2,#33 ;@ should also clear ARM V
  orrs r0,r3,r0,lsl r2 ;@ Orr left part, set flags

  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: r0 into register[r11]:
  str r0,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [ee98] ror.l #7, d0 uses Opee98 ----------
Opee98:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Rotate register:
  adds r0,r0,#0 ;@ first clear V and C
  movs r0,r0,ror r2
  mrs r10,cpsr ;@ r10=flags

;@ EaWrite: r0 into register[r11]:
  str r0,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [ef00] asl.b #7, d0 uses Opef00 ----------
Opef00:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]
  mov r0,r0,asl #24

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

  adds r3,r0,#0 ;@ save old value for V flag calculation, also clear V
;@ Shift register:
  movs r0,r0,asl r2
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ calculate V flag (set if sign bit changes at anytime):
  mov r1,#0x80000000
  ands r3,r3,r1,asr r2
  cmpne r3,r1,asr r2
  eoreq r1,r0,r3
  tsteq r1,#0x80000000
  orrne r10,r10,#0x10000000

;@ EaWrite: r0 into register[r11]:
  mov r0,r0,lsr #24
  strb r0,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [ef08] lsl.b #7, d0 uses Opef08 ----------
Opef08:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]
  mov r0,r0,asl #24

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Shift register:
  movs r0,r0,lsl r2
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: r0 into register[r11]:
  mov r0,r0,lsr #24
  strb r0,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [ef10] roxl.b #7, d0 uses Opef10 ----------
Opef10:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]
  mov r0,r0,asl #24

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

  rsb r2,r2,#9 ;@ Reverse direction
  mov r0,r0,lsr #24 ;@ Shift down

;@ First get X bit (middle):
  ldr r3,[r7,#0x4c]
  rsb r1,r2,#8
  and r3,r3,#0x20000000
  mov r3,r3,lsr #29
  mov r3,r3,lsl r1
;@ Rotate bits:
  orr r3,r3,r0,lsr r2 ;@ Orr right part
  rsbs r2,r2,#9 ;@ should also clear ARM V
  orrs r0,r3,r0,lsl r2 ;@ Orr left part, set flags

  movs r0,r0,lsl #24 ;@ Shift up and get correct NC flags
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: r0 into register[r11]:
  mov r0,r0,lsr #24
  strb r0,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [ef18] rol.b #7, d0 uses Opef18 ----------
Opef18:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]
  mov r0,r0,asl #24

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Mirror value in whole 32 bits:
  orr r0,r0,r0,lsr #8
  orr r0,r0,r0,lsr #16

;@ Rotate register:
  rsb r2,r2,#32
  movs r0,r0,ror r2
  mrs r10,cpsr ;@ r10=flags
  bic r10,r10,#0x30000000 ;@ clear CV
;@ Get carry bit from bit 0:
  tst r0,#1
  orrne r10,r10,#0x20000000

;@ EaWrite: r0 into register[r11]:
  mov r0,r0,lsr #24
  strb r0,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [ef40] asl.w #7, d0 uses Opef40 ----------
Opef40:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
  mov r11,r11,lsl #2
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11]
  mov r0,r0,asl #16

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

  adds r3,r0,#0 ;@ save old value for V flag calculation, also clear V
;@ Shift register:
  movs r0,r0,asl r2
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ calculate V flag (set if sign bit changes at anytime):
  mov r1,#0x80000000
  ands r3,r3,r1,asr r2
  cmpne r3,r1,asr r2
  eoreq r1,r0,r3
  tsteq r1,#0x80000000
  orrne r10,r10,#0x10000000

;@ EaWrite: r0 into register[r11]:
  mov r0,r0,lsr #16
  strh r0,[r7,r11]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [ef48] lsl.w #7, d0 uses Opef48 ----------
Opef48:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
  mov r11,r11,lsl #2
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11]
  mov r0,r0,asl #16

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Shift register:
  movs r0,r0,lsl r2
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: r0 into register[r11]:
  mov r0,r0,lsr #16
  strh r0,[r7,r11]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [ef50] roxl.w #7, d0 uses Opef50 ----------
Opef50:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
  mov r11,r11,lsl #2
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11]
  mov r0,r0,asl #16

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

  rsb r2,r2,#17 ;@ Reverse direction
  mov r0,r0,lsr #16 ;@ Shift down

;@ First get X bit (middle):
  ldr r3,[r7,#0x4c]
  rsb r1,r2,#16
  and r3,r3,#0x20000000
  mov r3,r3,lsr #29
  mov r3,r3,lsl r1
;@ Rotate bits:
  orr r3,r3,r0,lsr r2 ;@ Orr right part
  rsbs r2,r2,#17 ;@ should also clear ARM V
  orrs r0,r3,r0,lsl r2 ;@ Orr left part, set flags

  movs r0,r0,lsl #16 ;@ Shift up and get correct NC flags
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: r0 into register[r11]:
  mov r0,r0,lsr #16
  strh r0,[r7,r11]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [ef58] rol.w #7, d0 uses Opef58 ----------
Opef58:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
  mov r11,r11,lsl #2
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11]
  mov r0,r0,asl #16

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Mirror value in whole 32 bits:
  orr r0,r0,r0,lsr #16

;@ Rotate register:
  rsb r2,r2,#32
  movs r0,r0,ror r2
  mrs r10,cpsr ;@ r10=flags
  bic r10,r10,#0x30000000 ;@ clear CV
;@ Get carry bit from bit 0:
  tst r0,#1
  orrne r10,r10,#0x20000000

;@ EaWrite: r0 into register[r11]:
  mov r0,r0,lsr #16
  strh r0,[r7,r11]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#6 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [ef80] asl.l #7, d0 uses Opef80 ----------
Opef80:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

  adds r3,r0,#0 ;@ save old value for V flag calculation, also clear V
;@ Shift register:
  movs r0,r0,asl r2
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ calculate V flag (set if sign bit changes at anytime):
  mov r1,#0x80000000
  ands r3,r3,r1,asr r2
  cmpne r3,r1,asr r2
  eoreq r1,r0,r3
  tsteq r1,#0x80000000
  orrne r10,r10,#0x10000000

;@ EaWrite: r0 into register[r11]:
  str r0,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [ef88] lsl.l #7, d0 uses Opef88 ----------
Opef88:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Shift register:
  movs r0,r0,lsl r2
  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: r0 into register[r11]:
  str r0,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [ef90] roxl.l #7, d0 uses Opef90 ----------
Opef90:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

  rsb r2,r2,#33 ;@ Reverse direction

;@ First get X bit (middle):
  ldr r3,[r7,#0x4c]
  rsb r1,r2,#32
  and r3,r3,#0x20000000
  mov r3,r3,lsr #29
  mov r3,r3,lsl r1
;@ Rotate bits:
  orr r3,r3,r0,lsr r2 ;@ Orr right part
  rsbs r2,r2,#33 ;@ should also clear ARM V
  orrs r0,r3,r0,lsl r2 ;@ Orr left part, set flags

  mrs r10,cpsr ;@ r10=flags
  str r10,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: r0 into register[r11]:
  str r0,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ---------- [ef98] rol.l #7, d0 uses Opef98 ----------
Opef98:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Rotate register:
  rsb r2,r2,#32
  movs r0,r0,ror r2
  mrs r10,cpsr ;@ r10=flags
  bic r10,r10,#0x30000000 ;@ clear CV
;@ Get carry bit from bit 0:
  tst r0,#1
  orrne r10,r10,#0x20000000

;@ EaWrite: r0 into register[r11]:
  str r0,[r7,r11,lsl #2]

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#8 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd

;@ ----------
;@ tried execute privileged instruction in user mode
WrongPrivilegeMode:
  ldr r1,[r7,#0x58]
  sub r4,r4,#2 ;@ last opcode wasn't executed - go back
  orr r1,r1,#4 ;@ set activity bit: 'not processing instruction'
  str r1,[r7,#0x58]
  mov r0,#8 ;@ privilege violation
  bl Exception
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#34 ;@ Subtract cycles
  ldrgt pc,[r6,r8,asl #2] ;@ Jump to opcode handler
  b CycloneEnd


;@ -------------------------- Jump Table --------------------------
  .data
  .align 4

CycloneJumpTab:
  .long Op0000,Op0000,Op0000,Op0000,Op0000,Op0000,Op0000,Op0000 ;@ 0000
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0008
  .long Op0010,Op0010,Op0010,Op0010,Op0010,Op0010,Op0010,Op0010 ;@ 0010
  .long Op0018,Op0018,Op0018,Op0018,Op0018,Op0018,Op0018,Op001f ;@ 0018
  .long Op0020,Op0020,Op0020,Op0020,Op0020,Op0020,Op0020,Op0027 ;@ 0020
  .long Op0028,Op0028,Op0028,Op0028,Op0028,Op0028,Op0028,Op0028 ;@ 0028
  .long Op0030,Op0030,Op0030,Op0030,Op0030,Op0030,Op0030,Op0030 ;@ 0030
  .long Op0038,Op0039,Op____,Op____,Op003c,Op____,Op____,Op____ ;@ 0038
  .long Op0040,Op0040,Op0040,Op0040,Op0040,Op0040,Op0040,Op0040 ;@ 0040
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0048
  .long Op0050,Op0050,Op0050,Op0050,Op0050,Op0050,Op0050,Op0050 ;@ 0050
  .long Op0058,Op0058,Op0058,Op0058,Op0058,Op0058,Op0058,Op0058 ;@ 0058
  .long Op0060,Op0060,Op0060,Op0060,Op0060,Op0060,Op0060,Op0060 ;@ 0060
  .long Op0068,Op0068,Op0068,Op0068,Op0068,Op0068,Op0068,Op0068 ;@ 0068
  .long Op0070,Op0070,Op0070,Op0070,Op0070,Op0070,Op0070,Op0070 ;@ 0070
  .long Op0078,Op0079,Op____,Op____,Op007c,Op____,Op____,Op____ ;@ 0078
  .long Op0080,Op0080,Op0080,Op0080,Op0080,Op0080,Op0080,Op0080 ;@ 0080
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0088
  .long Op0090,Op0090,Op0090,Op0090,Op0090,Op0090,Op0090,Op0090 ;@ 0090
  .long Op0098,Op0098,Op0098,Op0098,Op0098,Op0098,Op0098,Op0098 ;@ 0098
  .long Op00a0,Op00a0,Op00a0,Op00a0,Op00a0,Op00a0,Op00a0,Op00a0 ;@ 00a0
  .long Op00a8,Op00a8,Op00a8,Op00a8,Op00a8,Op00a8,Op00a8,Op00a8 ;@ 00a8
  .long Op00b0,Op00b0,Op00b0,Op00b0,Op00b0,Op00b0,Op00b0,Op00b0 ;@ 00b0
  .long Op00b8,Op00b9,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 00b8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 00c0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 00c8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 00d0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 00d8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 00e0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 00e8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 00f0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 00f8
  .long Op0100,Op0100,Op0100,Op0100,Op0100,Op0100,Op0100,Op0100 ;@ 0100
  .long Op0108,Op0108,Op0108,Op0108,Op0108,Op0108,Op0108,Op0108 ;@ 0108
  .long Op0110,Op0110,Op0110,Op0110,Op0110,Op0110,Op0110,Op0110 ;@ 0110
  .long Op0118,Op0118,Op0118,Op0118,Op0118,Op0118,Op0118,Op011f ;@ 0118
  .long Op0120,Op0120,Op0120,Op0120,Op0120,Op0120,Op0120,Op0127 ;@ 0120
  .long Op0128,Op0128,Op0128,Op0128,Op0128,Op0128,Op0128,Op0128 ;@ 0128
  .long Op0130,Op0130,Op0130,Op0130,Op0130,Op0130,Op0130,Op0130 ;@ 0130
  .long Op0138,Op0139,Op013a,Op013b,Op013c,Op____,Op____,Op____ ;@ 0138
  .long Op0140,Op0140,Op0140,Op0140,Op0140,Op0140,Op0140,Op0140 ;@ 0140
  .long Op0148,Op0148,Op0148,Op0148,Op0148,Op0148,Op0148,Op0148 ;@ 0148
  .long Op0150,Op0150,Op0150,Op0150,Op0150,Op0150,Op0150,Op0150 ;@ 0150
  .long Op0158,Op0158,Op0158,Op0158,Op0158,Op0158,Op0158,Op015f ;@ 0158
  .long Op0160,Op0160,Op0160,Op0160,Op0160,Op0160,Op0160,Op0167 ;@ 0160
  .long Op0168,Op0168,Op0168,Op0168,Op0168,Op0168,Op0168,Op0168 ;@ 0168
  .long Op0170,Op0170,Op0170,Op0170,Op0170,Op0170,Op0170,Op0170 ;@ 0170
  .long Op0178,Op0179,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0178
  .long Op0180,Op0180,Op0180,Op0180,Op0180,Op0180,Op0180,Op0180 ;@ 0180
  .long Op0188,Op0188,Op0188,Op0188,Op0188,Op0188,Op0188,Op0188 ;@ 0188
  .long Op0190,Op0190,Op0190,Op0190,Op0190,Op0190,Op0190,Op0190 ;@ 0190
  .long Op0198,Op0198,Op0198,Op0198,Op0198,Op0198,Op0198,Op019f ;@ 0198
  .long Op01a0,Op01a0,Op01a0,Op01a0,Op01a0,Op01a0,Op01a0,Op01a7 ;@ 01a0
  .long Op01a8,Op01a8,Op01a8,Op01a8,Op01a8,Op01a8,Op01a8,Op01a8 ;@ 01a8
  .long Op01b0,Op01b0,Op01b0,Op01b0,Op01b0,Op01b0,Op01b0,Op01b0 ;@ 01b0
  .long Op01b8,Op01b9,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 01b8
  .long Op01c0,Op01c0,Op01c0,Op01c0,Op01c0,Op01c0,Op01c0,Op01c0 ;@ 01c0
  .long Op01c8,Op01c8,Op01c8,Op01c8,Op01c8,Op01c8,Op01c8,Op01c8 ;@ 01c8
  .long Op01d0,Op01d0,Op01d0,Op01d0,Op01d0,Op01d0,Op01d0,Op01d0 ;@ 01d0
  .long Op01d8,Op01d8,Op01d8,Op01d8,Op01d8,Op01d8,Op01d8,Op01df ;@ 01d8
  .long Op01e0,Op01e0,Op01e0,Op01e0,Op01e0,Op01e0,Op01e0,Op01e7 ;@ 01e0
  .long Op01e8,Op01e8,Op01e8,Op01e8,Op01e8,Op01e8,Op01e8,Op01e8 ;@ 01e8
  .long Op01f0,Op01f0,Op01f0,Op01f0,Op01f0,Op01f0,Op01f0,Op01f0 ;@ 01f0
  .long Op01f8,Op01f9,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 01f8
  .long Op0200,Op0200,Op0200,Op0200,Op0200,Op0200,Op0200,Op0200 ;@ 0200
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0208
  .long Op0210,Op0210,Op0210,Op0210,Op0210,Op0210,Op0210,Op0210 ;@ 0210
  .long Op0218,Op0218,Op0218,Op0218,Op0218,Op0218,Op0218,Op021f ;@ 0218
  .long Op0220,Op0220,Op0220,Op0220,Op0220,Op0220,Op0220,Op0227 ;@ 0220
  .long Op0228,Op0228,Op0228,Op0228,Op0228,Op0228,Op0228,Op0228 ;@ 0228
  .long Op0230,Op0230,Op0230,Op0230,Op0230,Op0230,Op0230,Op0230 ;@ 0230
  .long Op0238,Op0239,Op____,Op____,Op023c,Op____,Op____,Op____ ;@ 0238
  .long Op0240,Op0240,Op0240,Op0240,Op0240,Op0240,Op0240,Op0240 ;@ 0240
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0248
  .long Op0250,Op0250,Op0250,Op0250,Op0250,Op0250,Op0250,Op0250 ;@ 0250
  .long Op0258,Op0258,Op0258,Op0258,Op0258,Op0258,Op0258,Op0258 ;@ 0258
  .long Op0260,Op0260,Op0260,Op0260,Op0260,Op0260,Op0260,Op0260 ;@ 0260
  .long Op0268,Op0268,Op0268,Op0268,Op0268,Op0268,Op0268,Op0268 ;@ 0268
  .long Op0270,Op0270,Op0270,Op0270,Op0270,Op0270,Op0270,Op0270 ;@ 0270
  .long Op0278,Op0279,Op____,Op____,Op027c,Op____,Op____,Op____ ;@ 0278
  .long Op0280,Op0280,Op0280,Op0280,Op0280,Op0280,Op0280,Op0280 ;@ 0280
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0288
  .long Op0290,Op0290,Op0290,Op0290,Op0290,Op0290,Op0290,Op0290 ;@ 0290
  .long Op0298,Op0298,Op0298,Op0298,Op0298,Op0298,Op0298,Op0298 ;@ 0298
  .long Op02a0,Op02a0,Op02a0,Op02a0,Op02a0,Op02a0,Op02a0,Op02a0 ;@ 02a0
  .long Op02a8,Op02a8,Op02a8,Op02a8,Op02a8,Op02a8,Op02a8,Op02a8 ;@ 02a8
  .long Op02b0,Op02b0,Op02b0,Op02b0,Op02b0,Op02b0,Op02b0,Op02b0 ;@ 02b0
  .long Op02b8,Op02b9,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 02b8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 02c0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 02c8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 02d0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 02d8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 02e0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 02e8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 02f0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 02f8
  .long Op0100,Op0100,Op0100,Op0100,Op0100,Op0100,Op0100,Op0100 ;@ 0300
  .long Op0108,Op0108,Op0108,Op0108,Op0108,Op0108,Op0108,Op0108 ;@ 0308
  .long Op0110,Op0110,Op0110,Op0110,Op0110,Op0110,Op0110,Op0110 ;@ 0310
  .long Op0118,Op0118,Op0118,Op0118,Op0118,Op0118,Op0118,Op011f ;@ 0318
  .long Op0120,Op0120,Op0120,Op0120,Op0120,Op0120,Op0120,Op0127 ;@ 0320
  .long Op0128,Op0128,Op0128,Op0128,Op0128,Op0128,Op0128,Op0128 ;@ 0328
  .long Op0130,Op0130,Op0130,Op0130,Op0130,Op0130,Op0130,Op0130 ;@ 0330
  .long Op0138,Op0139,Op013a,Op013b,Op013c,Op____,Op____,Op____ ;@ 0338
  .long Op0140,Op0140,Op0140,Op0140,Op0140,Op0140,Op0140,Op0140 ;@ 0340
  .long Op0148,Op0148,Op0148,Op0148,Op0148,Op0148,Op0148,Op0148 ;@ 0348
  .long Op0150,Op0150,Op0150,Op0150,Op0150,Op0150,Op0150,Op0150 ;@ 0350
  .long Op0158,Op0158,Op0158,Op0158,Op0158,Op0158,Op0158,Op015f ;@ 0358
  .long Op0160,Op0160,Op0160,Op0160,Op0160,Op0160,Op0160,Op0167 ;@ 0360
  .long Op0168,Op0168,Op0168,Op0168,Op0168,Op0168,Op0168,Op0168 ;@ 0368
  .long Op0170,Op0170,Op0170,Op0170,Op0170,Op0170,Op0170,Op0170 ;@ 0370
  .long Op0178,Op0179,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0378
  .long Op0180,Op0180,Op0180,Op0180,Op0180,Op0180,Op0180,Op0180 ;@ 0380
  .long Op0188,Op0188,Op0188,Op0188,Op0188,Op0188,Op0188,Op0188 ;@ 0388
  .long Op0190,Op0190,Op0190,Op0190,Op0190,Op0190,Op0190,Op0190 ;@ 0390
  .long Op0198,Op0198,Op0198,Op0198,Op0198,Op0198,Op0198,Op019f ;@ 0398
  .long Op01a0,Op01a0,Op01a0,Op01a0,Op01a0,Op01a0,Op01a0,Op01a7 ;@ 03a0
  .long Op01a8,Op01a8,Op01a8,Op01a8,Op01a8,Op01a8,Op01a8,Op01a8 ;@ 03a8
  .long Op01b0,Op01b0,Op01b0,Op01b0,Op01b0,Op01b0,Op01b0,Op01b0 ;@ 03b0
  .long Op01b8,Op01b9,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 03b8
  .long Op01c0,Op01c0,Op01c0,Op01c0,Op01c0,Op01c0,Op01c0,Op01c0 ;@ 03c0
  .long Op01c8,Op01c8,Op01c8,Op01c8,Op01c8,Op01c8,Op01c8,Op01c8 ;@ 03c8
  .long Op01d0,Op01d0,Op01d0,Op01d0,Op01d0,Op01d0,Op01d0,Op01d0 ;@ 03d0
  .long Op01d8,Op01d8,Op01d8,Op01d8,Op01d8,Op01d8,Op01d8,Op01df ;@ 03d8
  .long Op01e0,Op01e0,Op01e0,Op01e0,Op01e0,Op01e0,Op01e0,Op01e7 ;@ 03e0
  .long Op01e8,Op01e8,Op01e8,Op01e8,Op01e8,Op01e8,Op01e8,Op01e8 ;@ 03e8
  .long Op01f0,Op01f0,Op01f0,Op01f0,Op01f0,Op01f0,Op01f0,Op01f0 ;@ 03f0
  .long Op01f8,Op01f9,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 03f8
  .long Op0400,Op0400,Op0400,Op0400,Op0400,Op0400,Op0400,Op0400 ;@ 0400
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0408
  .long Op0410,Op0410,Op0410,Op0410,Op0410,Op0410,Op0410,Op0410 ;@ 0410
  .long Op0418,Op0418,Op0418,Op0418,Op0418,Op0418,Op0418,Op041f ;@ 0418
  .long Op0420,Op0420,Op0420,Op0420,Op0420,Op0420,Op0420,Op0427 ;@ 0420
  .long Op0428,Op0428,Op0428,Op0428,Op0428,Op0428,Op0428,Op0428 ;@ 0428
  .long Op0430,Op0430,Op0430,Op0430,Op0430,Op0430,Op0430,Op0430 ;@ 0430
  .long Op0438,Op0439,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0438
  .long Op0440,Op0440,Op0440,Op0440,Op0440,Op0440,Op0440,Op0440 ;@ 0440
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0448
  .long Op0450,Op0450,Op0450,Op0450,Op0450,Op0450,Op0450,Op0450 ;@ 0450
  .long Op0458,Op0458,Op0458,Op0458,Op0458,Op0458,Op0458,Op0458 ;@ 0458
  .long Op0460,Op0460,Op0460,Op0460,Op0460,Op0460,Op0460,Op0460 ;@ 0460
  .long Op0468,Op0468,Op0468,Op0468,Op0468,Op0468,Op0468,Op0468 ;@ 0468
  .long Op0470,Op0470,Op0470,Op0470,Op0470,Op0470,Op0470,Op0470 ;@ 0470
  .long Op0478,Op0479,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0478
  .long Op0480,Op0480,Op0480,Op0480,Op0480,Op0480,Op0480,Op0480 ;@ 0480
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0488
  .long Op0490,Op0490,Op0490,Op0490,Op0490,Op0490,Op0490,Op0490 ;@ 0490
  .long Op0498,Op0498,Op0498,Op0498,Op0498,Op0498,Op0498,Op0498 ;@ 0498
  .long Op04a0,Op04a0,Op04a0,Op04a0,Op04a0,Op04a0,Op04a0,Op04a0 ;@ 04a0
  .long Op04a8,Op04a8,Op04a8,Op04a8,Op04a8,Op04a8,Op04a8,Op04a8 ;@ 04a8
  .long Op04b0,Op04b0,Op04b0,Op04b0,Op04b0,Op04b0,Op04b0,Op04b0 ;@ 04b0
  .long Op04b8,Op04b9,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 04b8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 04c0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 04c8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 04d0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 04d8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 04e0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 04e8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 04f0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 04f8
  .long Op0100,Op0100,Op0100,Op0100,Op0100,Op0100,Op0100,Op0100 ;@ 0500
  .long Op0108,Op0108,Op0108,Op0108,Op0108,Op0108,Op0108,Op0108 ;@ 0508
  .long Op0110,Op0110,Op0110,Op0110,Op0110,Op0110,Op0110,Op0110 ;@ 0510
  .long Op0118,Op0118,Op0118,Op0118,Op0118,Op0118,Op0118,Op011f ;@ 0518
  .long Op0120,Op0120,Op0120,Op0120,Op0120,Op0120,Op0120,Op0127 ;@ 0520
  .long Op0128,Op0128,Op0128,Op0128,Op0128,Op0128,Op0128,Op0128 ;@ 0528
  .long Op0130,Op0130,Op0130,Op0130,Op0130,Op0130,Op0130,Op0130 ;@ 0530
  .long Op0138,Op0139,Op013a,Op013b,Op013c,Op____,Op____,Op____ ;@ 0538
  .long Op0140,Op0140,Op0140,Op0140,Op0140,Op0140,Op0140,Op0140 ;@ 0540
  .long Op0148,Op0148,Op0148,Op0148,Op0148,Op0148,Op0148,Op0148 ;@ 0548
  .long Op0150,Op0150,Op0150,Op0150,Op0150,Op0150,Op0150,Op0150 ;@ 0550
  .long Op0158,Op0158,Op0158,Op0158,Op0158,Op0158,Op0158,Op015f ;@ 0558
  .long Op0160,Op0160,Op0160,Op0160,Op0160,Op0160,Op0160,Op0167 ;@ 0560
  .long Op0168,Op0168,Op0168,Op0168,Op0168,Op0168,Op0168,Op0168 ;@ 0568
  .long Op0170,Op0170,Op0170,Op0170,Op0170,Op0170,Op0170,Op0170 ;@ 0570
  .long Op0178,Op0179,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0578
  .long Op0180,Op0180,Op0180,Op0180,Op0180,Op0180,Op0180,Op0180 ;@ 0580
  .long Op0188,Op0188,Op0188,Op0188,Op0188,Op0188,Op0188,Op0188 ;@ 0588
  .long Op0190,Op0190,Op0190,Op0190,Op0190,Op0190,Op0190,Op0190 ;@ 0590
  .long Op0198,Op0198,Op0198,Op0198,Op0198,Op0198,Op0198,Op019f ;@ 0598
  .long Op01a0,Op01a0,Op01a0,Op01a0,Op01a0,Op01a0,Op01a0,Op01a7 ;@ 05a0
  .long Op01a8,Op01a8,Op01a8,Op01a8,Op01a8,Op01a8,Op01a8,Op01a8 ;@ 05a8
  .long Op01b0,Op01b0,Op01b0,Op01b0,Op01b0,Op01b0,Op01b0,Op01b0 ;@ 05b0
  .long Op01b8,Op01b9,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 05b8
  .long Op01c0,Op01c0,Op01c0,Op01c0,Op01c0,Op01c0,Op01c0,Op01c0 ;@ 05c0
  .long Op01c8,Op01c8,Op01c8,Op01c8,Op01c8,Op01c8,Op01c8,Op01c8 ;@ 05c8
  .long Op01d0,Op01d0,Op01d0,Op01d0,Op01d0,Op01d0,Op01d0,Op01d0 ;@ 05d0
  .long Op01d8,Op01d8,Op01d8,Op01d8,Op01d8,Op01d8,Op01d8,Op01df ;@ 05d8
  .long Op01e0,Op01e0,Op01e0,Op01e0,Op01e0,Op01e0,Op01e0,Op01e7 ;@ 05e0
  .long Op01e8,Op01e8,Op01e8,Op01e8,Op01e8,Op01e8,Op01e8,Op01e8 ;@ 05e8
  .long Op01f0,Op01f0,Op01f0,Op01f0,Op01f0,Op01f0,Op01f0,Op01f0 ;@ 05f0
  .long Op01f8,Op01f9,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 05f8
  .long Op0600,Op0600,Op0600,Op0600,Op0600,Op0600,Op0600,Op0600 ;@ 0600
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0608
  .long Op0610,Op0610,Op0610,Op0610,Op0610,Op0610,Op0610,Op0610 ;@ 0610
  .long Op0618,Op0618,Op0618,Op0618,Op0618,Op0618,Op0618,Op061f ;@ 0618
  .long Op0620,Op0620,Op0620,Op0620,Op0620,Op0620,Op0620,Op0627 ;@ 0620
  .long Op0628,Op0628,Op0628,Op0628,Op0628,Op0628,Op0628,Op0628 ;@ 0628
  .long Op0630,Op0630,Op0630,Op0630,Op0630,Op0630,Op0630,Op0630 ;@ 0630
  .long Op0638,Op0639,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0638
  .long Op0640,Op0640,Op0640,Op0640,Op0640,Op0640,Op0640,Op0640 ;@ 0640
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0648
  .long Op0650,Op0650,Op0650,Op0650,Op0650,Op0650,Op0650,Op0650 ;@ 0650
  .long Op0658,Op0658,Op0658,Op0658,Op0658,Op0658,Op0658,Op0658 ;@ 0658
  .long Op0660,Op0660,Op0660,Op0660,Op0660,Op0660,Op0660,Op0660 ;@ 0660
  .long Op0668,Op0668,Op0668,Op0668,Op0668,Op0668,Op0668,Op0668 ;@ 0668
  .long Op0670,Op0670,Op0670,Op0670,Op0670,Op0670,Op0670,Op0670 ;@ 0670
  .long Op0678,Op0679,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0678
  .long Op0680,Op0680,Op0680,Op0680,Op0680,Op0680,Op0680,Op0680 ;@ 0680
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0688
  .long Op0690,Op0690,Op0690,Op0690,Op0690,Op0690,Op0690,Op0690 ;@ 0690
  .long Op0698,Op0698,Op0698,Op0698,Op0698,Op0698,Op0698,Op0698 ;@ 0698
  .long Op06a0,Op06a0,Op06a0,Op06a0,Op06a0,Op06a0,Op06a0,Op06a0 ;@ 06a0
  .long Op06a8,Op06a8,Op06a8,Op06a8,Op06a8,Op06a8,Op06a8,Op06a8 ;@ 06a8
  .long Op06b0,Op06b0,Op06b0,Op06b0,Op06b0,Op06b0,Op06b0,Op06b0 ;@ 06b0
  .long Op06b8,Op06b9,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 06b8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 06c0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 06c8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 06d0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 06d8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 06e0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 06e8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 06f0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 06f8
  .long Op0100,Op0100,Op0100,Op0100,Op0100,Op0100,Op0100,Op0100 ;@ 0700
  .long Op0108,Op0108,Op0108,Op0108,Op0108,Op0108,Op0108,Op0108 ;@ 0708
  .long Op0110,Op0110,Op0110,Op0110,Op0110,Op0110,Op0110,Op0110 ;@ 0710
  .long Op0118,Op0118,Op0118,Op0118,Op0118,Op0118,Op0118,Op011f ;@ 0718
  .long Op0120,Op0120,Op0120,Op0120,Op0120,Op0120,Op0120,Op0127 ;@ 0720
  .long Op0128,Op0128,Op0128,Op0128,Op0128,Op0128,Op0128,Op0128 ;@ 0728
  .long Op0130,Op0130,Op0130,Op0130,Op0130,Op0130,Op0130,Op0130 ;@ 0730
  .long Op0138,Op0139,Op013a,Op013b,Op013c,Op____,Op____,Op____ ;@ 0738
  .long Op0140,Op0140,Op0140,Op0140,Op0140,Op0140,Op0140,Op0140 ;@ 0740
  .long Op0148,Op0148,Op0148,Op0148,Op0148,Op0148,Op0148,Op0148 ;@ 0748
  .long Op0150,Op0150,Op0150,Op0150,Op0150,Op0150,Op0150,Op0150 ;@ 0750
  .long Op0158,Op0158,Op0158,Op0158,Op0158,Op0158,Op0158,Op015f ;@ 0758
  .long Op0160,Op0160,Op0160,Op0160,Op0160,Op0160,Op0160,Op0167 ;@ 0760
  .long Op0168,Op0168,Op0168,Op0168,Op0168,Op0168,Op0168,Op0168 ;@ 0768
  .long Op0170,Op0170,Op0170,Op0170,Op0170,Op0170,Op0170,Op0170 ;@ 0770
  .long Op0178,Op0179,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0778
  .long Op0180,Op0180,Op0180,Op0180,Op0180,Op0180,Op0180,Op0180 ;@ 0780
  .long Op0188,Op0188,Op0188,Op0188,Op0188,Op0188,Op0188,Op0188 ;@ 0788
  .long Op0190,Op0190,Op0190,Op0190,Op0190,Op0190,Op0190,Op0190 ;@ 0790
  .long Op0198,Op0198,Op0198,Op0198,Op0198,Op0198,Op0198,Op019f ;@ 0798
  .long Op01a0,Op01a0,Op01a0,Op01a0,Op01a0,Op01a0,Op01a0,Op01a7 ;@ 07a0
  .long Op01a8,Op01a8,Op01a8,Op01a8,Op01a8,Op01a8,Op01a8,Op01a8 ;@ 07a8
  .long Op01b0,Op01b0,Op01b0,Op01b0,Op01b0,Op01b0,Op01b0,Op01b0 ;@ 07b0
  .long Op01b8,Op01b9,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 07b8
  .long Op01c0,Op01c0,Op01c0,Op01c0,Op01c0,Op01c0,Op01c0,Op01c0 ;@ 07c0
  .long Op01c8,Op01c8,Op01c8,Op01c8,Op01c8,Op01c8,Op01c8,Op01c8 ;@ 07c8
  .long Op01d0,Op01d0,Op01d0,Op01d0,Op01d0,Op01d0,Op01d0,Op01d0 ;@ 07d0
  .long Op01d8,Op01d8,Op01d8,Op01d8,Op01d8,Op01d8,Op01d8,Op01df ;@ 07d8
  .long Op01e0,Op01e0,Op01e0,Op01e0,Op01e0,Op01e0,Op01e0,Op01e7 ;@ 07e0
  .long Op01e8,Op01e8,Op01e8,Op01e8,Op01e8,Op01e8,Op01e8,Op01e8 ;@ 07e8
  .long Op01f0,Op01f0,Op01f0,Op01f0,Op01f0,Op01f0,Op01f0,Op01f0 ;@ 07f0
  .long Op01f8,Op01f9,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 07f8
  .long Op0800,Op0800,Op0800,Op0800,Op0800,Op0800,Op0800,Op0800 ;@ 0800
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0808
  .long Op0810,Op0810,Op0810,Op0810,Op0810,Op0810,Op0810,Op0810 ;@ 0810
  .long Op0818,Op0818,Op0818,Op0818,Op0818,Op0818,Op0818,Op081f ;@ 0818
  .long Op0820,Op0820,Op0820,Op0820,Op0820,Op0820,Op0820,Op0827 ;@ 0820
  .long Op0828,Op0828,Op0828,Op0828,Op0828,Op0828,Op0828,Op0828 ;@ 0828
  .long Op0830,Op0830,Op0830,Op0830,Op0830,Op0830,Op0830,Op0830 ;@ 0830
  .long Op0838,Op0839,Op083a,Op083b,Op____,Op____,Op____,Op____ ;@ 0838
  .long Op0840,Op0840,Op0840,Op0840,Op0840,Op0840,Op0840,Op0840 ;@ 0840
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0848
  .long Op0850,Op0850,Op0850,Op0850,Op0850,Op0850,Op0850,Op0850 ;@ 0850
  .long Op0858,Op0858,Op0858,Op0858,Op0858,Op0858,Op0858,Op085f ;@ 0858
  .long Op0860,Op0860,Op0860,Op0860,Op0860,Op0860,Op0860,Op0867 ;@ 0860
  .long Op0868,Op0868,Op0868,Op0868,Op0868,Op0868,Op0868,Op0868 ;@ 0868
  .long Op0870,Op0870,Op0870,Op0870,Op0870,Op0870,Op0870,Op0870 ;@ 0870
  .long Op0878,Op0879,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0878
  .long Op0880,Op0880,Op0880,Op0880,Op0880,Op0880,Op0880,Op0880 ;@ 0880
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0888
  .long Op0890,Op0890,Op0890,Op0890,Op0890,Op0890,Op0890,Op0890 ;@ 0890
  .long Op0898,Op0898,Op0898,Op0898,Op0898,Op0898,Op0898,Op089f ;@ 0898
  .long Op08a0,Op08a0,Op08a0,Op08a0,Op08a0,Op08a0,Op08a0,Op08a7 ;@ 08a0
  .long Op08a8,Op08a8,Op08a8,Op08a8,Op08a8,Op08a8,Op08a8,Op08a8 ;@ 08a8
  .long Op08b0,Op08b0,Op08b0,Op08b0,Op08b0,Op08b0,Op08b0,Op08b0 ;@ 08b0
  .long Op08b8,Op08b9,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 08b8
  .long Op08c0,Op08c0,Op08c0,Op08c0,Op08c0,Op08c0,Op08c0,Op08c0 ;@ 08c0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 08c8
  .long Op08d0,Op08d0,Op08d0,Op08d0,Op08d0,Op08d0,Op08d0,Op08d0 ;@ 08d0
  .long Op08d8,Op08d8,Op08d8,Op08d8,Op08d8,Op08d8,Op08d8,Op08df ;@ 08d8
  .long Op08e0,Op08e0,Op08e0,Op08e0,Op08e0,Op08e0,Op08e0,Op08e7 ;@ 08e0
  .long Op08e8,Op08e8,Op08e8,Op08e8,Op08e8,Op08e8,Op08e8,Op08e8 ;@ 08e8
  .long Op08f0,Op08f0,Op08f0,Op08f0,Op08f0,Op08f0,Op08f0,Op08f0 ;@ 08f0
  .long Op08f8,Op08f9,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 08f8
  .long Op0100,Op0100,Op0100,Op0100,Op0100,Op0100,Op0100,Op0100 ;@ 0900
  .long Op0108,Op0108,Op0108,Op0108,Op0108,Op0108,Op0108,Op0108 ;@ 0908
  .long Op0110,Op0110,Op0110,Op0110,Op0110,Op0110,Op0110,Op0110 ;@ 0910
  .long Op0118,Op0118,Op0118,Op0118,Op0118,Op0118,Op0118,Op011f ;@ 0918
  .long Op0120,Op0120,Op0120,Op0120,Op0120,Op0120,Op0120,Op0127 ;@ 0920
  .long Op0128,Op0128,Op0128,Op0128,Op0128,Op0128,Op0128,Op0128 ;@ 0928
  .long Op0130,Op0130,Op0130,Op0130,Op0130,Op0130,Op0130,Op0130 ;@ 0930
  .long Op0138,Op0139,Op013a,Op013b,Op013c,Op____,Op____,Op____ ;@ 0938
  .long Op0140,Op0140,Op0140,Op0140,Op0140,Op0140,Op0140,Op0140 ;@ 0940
  .long Op0148,Op0148,Op0148,Op0148,Op0148,Op0148,Op0148,Op0148 ;@ 0948
  .long Op0150,Op0150,Op0150,Op0150,Op0150,Op0150,Op0150,Op0150 ;@ 0950
  .long Op0158,Op0158,Op0158,Op0158,Op0158,Op0158,Op0158,Op015f ;@ 0958
  .long Op0160,Op0160,Op0160,Op0160,Op0160,Op0160,Op0160,Op0167 ;@ 0960
  .long Op0168,Op0168,Op0168,Op0168,Op0168,Op0168,Op0168,Op0168 ;@ 0968
  .long Op0170,Op0170,Op0170,Op0170,Op0170,Op0170,Op0170,Op0170 ;@ 0970
  .long Op0178,Op0179,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0978
  .long Op0180,Op0180,Op0180,Op0180,Op0180,Op0180,Op0180,Op0180 ;@ 0980
  .long Op0188,Op0188,Op0188,Op0188,Op0188,Op0188,Op0188,Op0188 ;@ 0988
  .long Op0190,Op0190,Op0190,Op0190,Op0190,Op0190,Op0190,Op0190 ;@ 0990
  .long Op0198,Op0198,Op0198,Op0198,Op0198,Op0198,Op0198,Op019f ;@ 0998
  .long Op01a0,Op01a0,Op01a0,Op01a0,Op01a0,Op01a0,Op01a0,Op01a7 ;@ 09a0
  .long Op01a8,Op01a8,Op01a8,Op01a8,Op01a8,Op01a8,Op01a8,Op01a8 ;@ 09a8
  .long Op01b0,Op01b0,Op01b0,Op01b0,Op01b0,Op01b0,Op01b0,Op01b0 ;@ 09b0
  .long Op01b8,Op01b9,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 09b8
  .long Op01c0,Op01c0,Op01c0,Op01c0,Op01c0,Op01c0,Op01c0,Op01c0 ;@ 09c0
  .long Op01c8,Op01c8,Op01c8,Op01c8,Op01c8,Op01c8,Op01c8,Op01c8 ;@ 09c8
  .long Op01d0,Op01d0,Op01d0,Op01d0,Op01d0,Op01d0,Op01d0,Op01d0 ;@ 09d0
  .long Op01d8,Op01d8,Op01d8,Op01d8,Op01d8,Op01d8,Op01d8,Op01df ;@ 09d8
  .long Op01e0,Op01e0,Op01e0,Op01e0,Op01e0,Op01e0,Op01e0,Op01e7 ;@ 09e0
  .long Op01e8,Op01e8,Op01e8,Op01e8,Op01e8,Op01e8,Op01e8,Op01e8 ;@ 09e8
  .long Op01f0,Op01f0,Op01f0,Op01f0,Op01f0,Op01f0,Op01f0,Op01f0 ;@ 09f0
  .long Op01f8,Op01f9,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 09f8
  .long Op0a00,Op0a00,Op0a00,Op0a00,Op0a00,Op0a00,Op0a00,Op0a00 ;@ 0a00
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0a08
  .long Op0a10,Op0a10,Op0a10,Op0a10,Op0a10,Op0a10,Op0a10,Op0a10 ;@ 0a10
  .long Op0a18,Op0a18,Op0a18,Op0a18,Op0a18,Op0a18,Op0a18,Op0a1f ;@ 0a18
  .long Op0a20,Op0a20,Op0a20,Op0a20,Op0a20,Op0a20,Op0a20,Op0a27 ;@ 0a20
  .long Op0a28,Op0a28,Op0a28,Op0a28,Op0a28,Op0a28,Op0a28,Op0a28 ;@ 0a28
  .long Op0a30,Op0a30,Op0a30,Op0a30,Op0a30,Op0a30,Op0a30,Op0a30 ;@ 0a30
  .long Op0a38,Op0a39,Op____,Op____,Op0a3c,Op____,Op____,Op____ ;@ 0a38
  .long Op0a40,Op0a40,Op0a40,Op0a40,Op0a40,Op0a40,Op0a40,Op0a40 ;@ 0a40
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0a48
  .long Op0a50,Op0a50,Op0a50,Op0a50,Op0a50,Op0a50,Op0a50,Op0a50 ;@ 0a50
  .long Op0a58,Op0a58,Op0a58,Op0a58,Op0a58,Op0a58,Op0a58,Op0a58 ;@ 0a58
  .long Op0a60,Op0a60,Op0a60,Op0a60,Op0a60,Op0a60,Op0a60,Op0a60 ;@ 0a60
  .long Op0a68,Op0a68,Op0a68,Op0a68,Op0a68,Op0a68,Op0a68,Op0a68 ;@ 0a68
  .long Op0a70,Op0a70,Op0a70,Op0a70,Op0a70,Op0a70,Op0a70,Op0a70 ;@ 0a70
  .long Op0a78,Op0a79,Op____,Op____,Op0a7c,Op____,Op____,Op____ ;@ 0a78
  .long Op0a80,Op0a80,Op0a80,Op0a80,Op0a80,Op0a80,Op0a80,Op0a80 ;@ 0a80
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0a88
  .long Op0a90,Op0a90,Op0a90,Op0a90,Op0a90,Op0a90,Op0a90,Op0a90 ;@ 0a90
  .long Op0a98,Op0a98,Op0a98,Op0a98,Op0a98,Op0a98,Op0a98,Op0a98 ;@ 0a98
  .long Op0aa0,Op0aa0,Op0aa0,Op0aa0,Op0aa0,Op0aa0,Op0aa0,Op0aa0 ;@ 0aa0
  .long Op0aa8,Op0aa8,Op0aa8,Op0aa8,Op0aa8,Op0aa8,Op0aa8,Op0aa8 ;@ 0aa8
  .long Op0ab0,Op0ab0,Op0ab0,Op0ab0,Op0ab0,Op0ab0,Op0ab0,Op0ab0 ;@ 0ab0
  .long Op0ab8,Op0ab9,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0ab8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0ac0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0ac8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0ad0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0ad8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0ae0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0ae8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0af0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0af8
  .long Op0100,Op0100,Op0100,Op0100,Op0100,Op0100,Op0100,Op0100 ;@ 0b00
  .long Op0108,Op0108,Op0108,Op0108,Op0108,Op0108,Op0108,Op0108 ;@ 0b08
  .long Op0110,Op0110,Op0110,Op0110,Op0110,Op0110,Op0110,Op0110 ;@ 0b10
  .long Op0118,Op0118,Op0118,Op0118,Op0118,Op0118,Op0118,Op011f ;@ 0b18
  .long Op0120,Op0120,Op0120,Op0120,Op0120,Op0120,Op0120,Op0127 ;@ 0b20
  .long Op0128,Op0128,Op0128,Op0128,Op0128,Op0128,Op0128,Op0128 ;@ 0b28
  .long Op0130,Op0130,Op0130,Op0130,Op0130,Op0130,Op0130,Op0130 ;@ 0b30
  .long Op0138,Op0139,Op013a,Op013b,Op013c,Op____,Op____,Op____ ;@ 0b38
  .long Op0140,Op0140,Op0140,Op0140,Op0140,Op0140,Op0140,Op0140 ;@ 0b40
  .long Op0148,Op0148,Op0148,Op0148,Op0148,Op0148,Op0148,Op0148 ;@ 0b48
  .long Op0150,Op0150,Op0150,Op0150,Op0150,Op0150,Op0150,Op0150 ;@ 0b50
  .long Op0158,Op0158,Op0158,Op0158,Op0158,Op0158,Op0158,Op015f ;@ 0b58
  .long Op0160,Op0160,Op0160,Op0160,Op0160,Op0160,Op0160,Op0167 ;@ 0b60
  .long Op0168,Op0168,Op0168,Op0168,Op0168,Op0168,Op0168,Op0168 ;@ 0b68
  .long Op0170,Op0170,Op0170,Op0170,Op0170,Op0170,Op0170,Op0170 ;@ 0b70
  .long Op0178,Op0179,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0b78
  .long Op0180,Op0180,Op0180,Op0180,Op0180,Op0180,Op0180,Op0180 ;@ 0b80
  .long Op0188,Op0188,Op0188,Op0188,Op0188,Op0188,Op0188,Op0188 ;@ 0b88
  .long Op0190,Op0190,Op0190,Op0190,Op0190,Op0190,Op0190,Op0190 ;@ 0b90
  .long Op0198,Op0198,Op0198,Op0198,Op0198,Op0198,Op0198,Op019f ;@ 0b98
  .long Op01a0,Op01a0,Op01a0,Op01a0,Op01a0,Op01a0,Op01a0,Op01a7 ;@ 0ba0
  .long Op01a8,Op01a8,Op01a8,Op01a8,Op01a8,Op01a8,Op01a8,Op01a8 ;@ 0ba8
  .long Op01b0,Op01b0,Op01b0,Op01b0,Op01b0,Op01b0,Op01b0,Op01b0 ;@ 0bb0
  .long Op01b8,Op01b9,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0bb8
  .long Op01c0,Op01c0,Op01c0,Op01c0,Op01c0,Op01c0,Op01c0,Op01c0 ;@ 0bc0
  .long Op01c8,Op01c8,Op01c8,Op01c8,Op01c8,Op01c8,Op01c8,Op01c8 ;@ 0bc8
  .long Op01d0,Op01d0,Op01d0,Op01d0,Op01d0,Op01d0,Op01d0,Op01d0 ;@ 0bd0
  .long Op01d8,Op01d8,Op01d8,Op01d8,Op01d8,Op01d8,Op01d8,Op01df ;@ 0bd8
  .long Op01e0,Op01e0,Op01e0,Op01e0,Op01e0,Op01e0,Op01e0,Op01e7 ;@ 0be0
  .long Op01e8,Op01e8,Op01e8,Op01e8,Op01e8,Op01e8,Op01e8,Op01e8 ;@ 0be8
  .long Op01f0,Op01f0,Op01f0,Op01f0,Op01f0,Op01f0,Op01f0,Op01f0 ;@ 0bf0
  .long Op01f8,Op01f9,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0bf8
  .long Op0c00,Op0c00,Op0c00,Op0c00,Op0c00,Op0c00,Op0c00,Op0c00 ;@ 0c00
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0c08
  .long Op0c10,Op0c10,Op0c10,Op0c10,Op0c10,Op0c10,Op0c10,Op0c10 ;@ 0c10
  .long Op0c18,Op0c18,Op0c18,Op0c18,Op0c18,Op0c18,Op0c18,Op0c1f ;@ 0c18
  .long Op0c20,Op0c20,Op0c20,Op0c20,Op0c20,Op0c20,Op0c20,Op0c27 ;@ 0c20
  .long Op0c28,Op0c28,Op0c28,Op0c28,Op0c28,Op0c28,Op0c28,Op0c28 ;@ 0c28
  .long Op0c30,Op0c30,Op0c30,Op0c30,Op0c30,Op0c30,Op0c30,Op0c30 ;@ 0c30
  .long Op0c38,Op0c39,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0c38
  .long Op0c40,Op0c40,Op0c40,Op0c40,Op0c40,Op0c40,Op0c40,Op0c40 ;@ 0c40
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0c48
  .long Op0c50,Op0c50,Op0c50,Op0c50,Op0c50,Op0c50,Op0c50,Op0c50 ;@ 0c50
  .long Op0c58,Op0c58,Op0c58,Op0c58,Op0c58,Op0c58,Op0c58,Op0c58 ;@ 0c58
  .long Op0c60,Op0c60,Op0c60,Op0c60,Op0c60,Op0c60,Op0c60,Op0c60 ;@ 0c60
  .long Op0c68,Op0c68,Op0c68,Op0c68,Op0c68,Op0c68,Op0c68,Op0c68 ;@ 0c68
  .long Op0c70,Op0c70,Op0c70,Op0c70,Op0c70,Op0c70,Op0c70,Op0c70 ;@ 0c70
  .long Op0c78,Op0c79,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0c78
  .long Op0c80,Op0c80,Op0c80,Op0c80,Op0c80,Op0c80,Op0c80,Op0c80 ;@ 0c80
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0c88
  .long Op0c90,Op0c90,Op0c90,Op0c90,Op0c90,Op0c90,Op0c90,Op0c90 ;@ 0c90
  .long Op0c98,Op0c98,Op0c98,Op0c98,Op0c98,Op0c98,Op0c98,Op0c98 ;@ 0c98
  .long Op0ca0,Op0ca0,Op0ca0,Op0ca0,Op0ca0,Op0ca0,Op0ca0,Op0ca0 ;@ 0ca0
  .long Op0ca8,Op0ca8,Op0ca8,Op0ca8,Op0ca8,Op0ca8,Op0ca8,Op0ca8 ;@ 0ca8
  .long Op0cb0,Op0cb0,Op0cb0,Op0cb0,Op0cb0,Op0cb0,Op0cb0,Op0cb0 ;@ 0cb0
  .long Op0cb8,Op0cb9,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0cb8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0cc0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0cc8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0cd0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0cd8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0ce0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0ce8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0cf0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0cf8
  .long Op0100,Op0100,Op0100,Op0100,Op0100,Op0100,Op0100,Op0100 ;@ 0d00
  .long Op0108,Op0108,Op0108,Op0108,Op0108,Op0108,Op0108,Op0108 ;@ 0d08
  .long Op0110,Op0110,Op0110,Op0110,Op0110,Op0110,Op0110,Op0110 ;@ 0d10
  .long Op0118,Op0118,Op0118,Op0118,Op0118,Op0118,Op0118,Op011f ;@ 0d18
  .long Op0120,Op0120,Op0120,Op0120,Op0120,Op0120,Op0120,Op0127 ;@ 0d20
  .long Op0128,Op0128,Op0128,Op0128,Op0128,Op0128,Op0128,Op0128 ;@ 0d28
  .long Op0130,Op0130,Op0130,Op0130,Op0130,Op0130,Op0130,Op0130 ;@ 0d30
  .long Op0138,Op0139,Op013a,Op013b,Op013c,Op____,Op____,Op____ ;@ 0d38
  .long Op0140,Op0140,Op0140,Op0140,Op0140,Op0140,Op0140,Op0140 ;@ 0d40
  .long Op0148,Op0148,Op0148,Op0148,Op0148,Op0148,Op0148,Op0148 ;@ 0d48
  .long Op0150,Op0150,Op0150,Op0150,Op0150,Op0150,Op0150,Op0150 ;@ 0d50
  .long Op0158,Op0158,Op0158,Op0158,Op0158,Op0158,Op0158,Op015f ;@ 0d58
  .long Op0160,Op0160,Op0160,Op0160,Op0160,Op0160,Op0160,Op0167 ;@ 0d60
  .long Op0168,Op0168,Op0168,Op0168,Op0168,Op0168,Op0168,Op0168 ;@ 0d68
  .long Op0170,Op0170,Op0170,Op0170,Op0170,Op0170,Op0170,Op0170 ;@ 0d70
  .long Op0178,Op0179,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0d78
  .long Op0180,Op0180,Op0180,Op0180,Op0180,Op0180,Op0180,Op0180 ;@ 0d80
  .long Op0188,Op0188,Op0188,Op0188,Op0188,Op0188,Op0188,Op0188 ;@ 0d88
  .long Op0190,Op0190,Op0190,Op0190,Op0190,Op0190,Op0190,Op0190 ;@ 0d90
  .long Op0198,Op0198,Op0198,Op0198,Op0198,Op0198,Op0198,Op019f ;@ 0d98
  .long Op01a0,Op01a0,Op01a0,Op01a0,Op01a0,Op01a0,Op01a0,Op01a7 ;@ 0da0
  .long Op01a8,Op01a8,Op01a8,Op01a8,Op01a8,Op01a8,Op01a8,Op01a8 ;@ 0da8
  .long Op01b0,Op01b0,Op01b0,Op01b0,Op01b0,Op01b0,Op01b0,Op01b0 ;@ 0db0
  .long Op01b8,Op01b9,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0db8
  .long Op01c0,Op01c0,Op01c0,Op01c0,Op01c0,Op01c0,Op01c0,Op01c0 ;@ 0dc0
  .long Op01c8,Op01c8,Op01c8,Op01c8,Op01c8,Op01c8,Op01c8,Op01c8 ;@ 0dc8
  .long Op01d0,Op01d0,Op01d0,Op01d0,Op01d0,Op01d0,Op01d0,Op01d0 ;@ 0dd0
  .long Op01d8,Op01d8,Op01d8,Op01d8,Op01d8,Op01d8,Op01d8,Op01df ;@ 0dd8
  .long Op01e0,Op01e0,Op01e0,Op01e0,Op01e0,Op01e0,Op01e0,Op01e7 ;@ 0de0
  .long Op01e8,Op01e8,Op01e8,Op01e8,Op01e8,Op01e8,Op01e8,Op01e8 ;@ 0de8
  .long Op01f0,Op01f0,Op01f0,Op01f0,Op01f0,Op01f0,Op01f0,Op01f0 ;@ 0df0
  .long Op01f8,Op01f9,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0df8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0e00
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0e08
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0e10
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0e18
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0e20
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0e28
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0e30
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0e38
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0e40
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0e48
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0e50
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0e58
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0e60
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0e68
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0e70
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0e78
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0e80
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0e88
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0e90
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0e98
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0ea0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0ea8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0eb0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0eb8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0ec0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0ec8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0ed0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0ed8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0ee0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0ee8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0ef0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0ef8
  .long Op0100,Op0100,Op0100,Op0100,Op0100,Op0100,Op0100,Op0100 ;@ 0f00
  .long Op0108,Op0108,Op0108,Op0108,Op0108,Op0108,Op0108,Op0108 ;@ 0f08
  .long Op0110,Op0110,Op0110,Op0110,Op0110,Op0110,Op0110,Op0110 ;@ 0f10
  .long Op0118,Op0118,Op0118,Op0118,Op0118,Op0118,Op0118,Op011f ;@ 0f18
  .long Op0120,Op0120,Op0120,Op0120,Op0120,Op0120,Op0120,Op0127 ;@ 0f20
  .long Op0128,Op0128,Op0128,Op0128,Op0128,Op0128,Op0128,Op0128 ;@ 0f28
  .long Op0130,Op0130,Op0130,Op0130,Op0130,Op0130,Op0130,Op0130 ;@ 0f30
  .long Op0138,Op0139,Op013a,Op013b,Op013c,Op____,Op____,Op____ ;@ 0f38
  .long Op0140,Op0140,Op0140,Op0140,Op0140,Op0140,Op0140,Op0140 ;@ 0f40
  .long Op0148,Op0148,Op0148,Op0148,Op0148,Op0148,Op0148,Op0148 ;@ 0f48
  .long Op0150,Op0150,Op0150,Op0150,Op0150,Op0150,Op0150,Op0150 ;@ 0f50
  .long Op0158,Op0158,Op0158,Op0158,Op0158,Op0158,Op0158,Op015f ;@ 0f58
  .long Op0160,Op0160,Op0160,Op0160,Op0160,Op0160,Op0160,Op0167 ;@ 0f60
  .long Op0168,Op0168,Op0168,Op0168,Op0168,Op0168,Op0168,Op0168 ;@ 0f68
  .long Op0170,Op0170,Op0170,Op0170,Op0170,Op0170,Op0170,Op0170 ;@ 0f70
  .long Op0178,Op0179,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0f78
  .long Op0180,Op0180,Op0180,Op0180,Op0180,Op0180,Op0180,Op0180 ;@ 0f80
  .long Op0188,Op0188,Op0188,Op0188,Op0188,Op0188,Op0188,Op0188 ;@ 0f88
  .long Op0190,Op0190,Op0190,Op0190,Op0190,Op0190,Op0190,Op0190 ;@ 0f90
  .long Op0198,Op0198,Op0198,Op0198,Op0198,Op0198,Op0198,Op019f ;@ 0f98
  .long Op01a0,Op01a0,Op01a0,Op01a0,Op01a0,Op01a0,Op01a0,Op01a7 ;@ 0fa0
  .long Op01a8,Op01a8,Op01a8,Op01a8,Op01a8,Op01a8,Op01a8,Op01a8 ;@ 0fa8
  .long Op01b0,Op01b0,Op01b0,Op01b0,Op01b0,Op01b0,Op01b0,Op01b0 ;@ 0fb0
  .long Op01b8,Op01b9,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0fb8
  .long Op01c0,Op01c0,Op01c0,Op01c0,Op01c0,Op01c0,Op01c0,Op01c0 ;@ 0fc0
  .long Op01c8,Op01c8,Op01c8,Op01c8,Op01c8,Op01c8,Op01c8,Op01c8 ;@ 0fc8
  .long Op01d0,Op01d0,Op01d0,Op01d0,Op01d0,Op01d0,Op01d0,Op01d0 ;@ 0fd0
  .long Op01d8,Op01d8,Op01d8,Op01d8,Op01d8,Op01d8,Op01d8,Op01df ;@ 0fd8
  .long Op01e0,Op01e0,Op01e0,Op01e0,Op01e0,Op01e0,Op01e0,Op01e7 ;@ 0fe0
  .long Op01e8,Op01e8,Op01e8,Op01e8,Op01e8,Op01e8,Op01e8,Op01e8 ;@ 0fe8
  .long Op01f0,Op01f0,Op01f0,Op01f0,Op01f0,Op01f0,Op01f0,Op01f0 ;@ 0ff0
  .long Op01f8,Op01f9,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0ff8
  .long Op1000,Op1000,Op1000,Op1000,Op1000,Op1000,Op1000,Op1000 ;@ 1000
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1008
  .long Op1010,Op1010,Op1010,Op1010,Op1010,Op1010,Op1010,Op1010 ;@ 1010
  .long Op1018,Op1018,Op1018,Op1018,Op1018,Op1018,Op1018,Op101f ;@ 1018
  .long Op1020,Op1020,Op1020,Op1020,Op1020,Op1020,Op1020,Op1027 ;@ 1020
  .long Op1028,Op1028,Op1028,Op1028,Op1028,Op1028,Op1028,Op1028 ;@ 1028
  .long Op1030,Op1030,Op1030,Op1030,Op1030,Op1030,Op1030,Op1030 ;@ 1030
  .long Op1038,Op1039,Op103a,Op103b,Op103c,Op____,Op____,Op____ ;@ 1038
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1040
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1048
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1050
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1058
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1060
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1068
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1070
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1078
  .long Op1080,Op1080,Op1080,Op1080,Op1080,Op1080,Op1080,Op1080 ;@ 1080
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1088
  .long Op1090,Op1090,Op1090,Op1090,Op1090,Op1090,Op1090,Op1090 ;@ 1090
  .long Op1098,Op1098,Op1098,Op1098,Op1098,Op1098,Op1098,Op109f ;@ 1098
  .long Op10a0,Op10a0,Op10a0,Op10a0,Op10a0,Op10a0,Op10a0,Op10a7 ;@ 10a0
  .long Op10a8,Op10a8,Op10a8,Op10a8,Op10a8,Op10a8,Op10a8,Op10a8 ;@ 10a8
  .long Op10b0,Op10b0,Op10b0,Op10b0,Op10b0,Op10b0,Op10b0,Op10b0 ;@ 10b0
  .long Op10b8,Op10b9,Op10ba,Op10bb,Op10bc,Op____,Op____,Op____ ;@ 10b8
  .long Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0 ;@ 10c0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 10c8
  .long Op10d0,Op10d0,Op10d0,Op10d0,Op10d0,Op10d0,Op10d0,Op10d0 ;@ 10d0
  .long Op10d8,Op10d8,Op10d8,Op10d8,Op10d8,Op10d8,Op10d8,Op10df ;@ 10d8
  .long Op10e0,Op10e0,Op10e0,Op10e0,Op10e0,Op10e0,Op10e0,Op10e7 ;@ 10e0
  .long Op10e8,Op10e8,Op10e8,Op10e8,Op10e8,Op10e8,Op10e8,Op10e8 ;@ 10e8
  .long Op10f0,Op10f0,Op10f0,Op10f0,Op10f0,Op10f0,Op10f0,Op10f0 ;@ 10f0
  .long Op10f8,Op10f9,Op10fa,Op10fb,Op10fc,Op____,Op____,Op____ ;@ 10f8
  .long Op1100,Op1100,Op1100,Op1100,Op1100,Op1100,Op1100,Op1100 ;@ 1100
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1108
  .long Op1110,Op1110,Op1110,Op1110,Op1110,Op1110,Op1110,Op1110 ;@ 1110
  .long Op1118,Op1118,Op1118,Op1118,Op1118,Op1118,Op1118,Op111f ;@ 1118
  .long Op1120,Op1120,Op1120,Op1120,Op1120,Op1120,Op1120,Op1127 ;@ 1120
  .long Op1128,Op1128,Op1128,Op1128,Op1128,Op1128,Op1128,Op1128 ;@ 1128
  .long Op1130,Op1130,Op1130,Op1130,Op1130,Op1130,Op1130,Op1130 ;@ 1130
  .long Op1138,Op1139,Op113a,Op113b,Op113c,Op____,Op____,Op____ ;@ 1138
  .long Op1140,Op1140,Op1140,Op1140,Op1140,Op1140,Op1140,Op1140 ;@ 1140
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1148
  .long Op1150,Op1150,Op1150,Op1150,Op1150,Op1150,Op1150,Op1150 ;@ 1150
  .long Op1158,Op1158,Op1158,Op1158,Op1158,Op1158,Op1158,Op115f ;@ 1158
  .long Op1160,Op1160,Op1160,Op1160,Op1160,Op1160,Op1160,Op1167 ;@ 1160
  .long Op1168,Op1168,Op1168,Op1168,Op1168,Op1168,Op1168,Op1168 ;@ 1168
  .long Op1170,Op1170,Op1170,Op1170,Op1170,Op1170,Op1170,Op1170 ;@ 1170
  .long Op1178,Op1179,Op117a,Op117b,Op117c,Op____,Op____,Op____ ;@ 1178
  .long Op1180,Op1180,Op1180,Op1180,Op1180,Op1180,Op1180,Op1180 ;@ 1180
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1188
  .long Op1190,Op1190,Op1190,Op1190,Op1190,Op1190,Op1190,Op1190 ;@ 1190
  .long Op1198,Op1198,Op1198,Op1198,Op1198,Op1198,Op1198,Op119f ;@ 1198
  .long Op11a0,Op11a0,Op11a0,Op11a0,Op11a0,Op11a0,Op11a0,Op11a7 ;@ 11a0
  .long Op11a8,Op11a8,Op11a8,Op11a8,Op11a8,Op11a8,Op11a8,Op11a8 ;@ 11a8
  .long Op11b0,Op11b0,Op11b0,Op11b0,Op11b0,Op11b0,Op11b0,Op11b0 ;@ 11b0
  .long Op11b8,Op11b9,Op11ba,Op11bb,Op11bc,Op____,Op____,Op____ ;@ 11b8
  .long Op11c0,Op11c0,Op11c0,Op11c0,Op11c0,Op11c0,Op11c0,Op11c0 ;@ 11c0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 11c8
  .long Op11d0,Op11d0,Op11d0,Op11d0,Op11d0,Op11d0,Op11d0,Op11d0 ;@ 11d0
  .long Op11d8,Op11d8,Op11d8,Op11d8,Op11d8,Op11d8,Op11d8,Op11df ;@ 11d8
  .long Op11e0,Op11e0,Op11e0,Op11e0,Op11e0,Op11e0,Op11e0,Op11e7 ;@ 11e0
  .long Op11e8,Op11e8,Op11e8,Op11e8,Op11e8,Op11e8,Op11e8,Op11e8 ;@ 11e8
  .long Op11f0,Op11f0,Op11f0,Op11f0,Op11f0,Op11f0,Op11f0,Op11f0 ;@ 11f0
  .long Op11f8,Op11f9,Op11fa,Op11fb,Op11fc,Op____,Op____,Op____ ;@ 11f8
  .long Op1000,Op1000,Op1000,Op1000,Op1000,Op1000,Op1000,Op1000 ;@ 1200
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1208
  .long Op1010,Op1010,Op1010,Op1010,Op1010,Op1010,Op1010,Op1010 ;@ 1210
  .long Op1018,Op1018,Op1018,Op1018,Op1018,Op1018,Op1018,Op101f ;@ 1218
  .long Op1020,Op1020,Op1020,Op1020,Op1020,Op1020,Op1020,Op1027 ;@ 1220
  .long Op1028,Op1028,Op1028,Op1028,Op1028,Op1028,Op1028,Op1028 ;@ 1228
  .long Op1030,Op1030,Op1030,Op1030,Op1030,Op1030,Op1030,Op1030 ;@ 1230
  .long Op1038,Op1039,Op103a,Op103b,Op103c,Op____,Op____,Op____ ;@ 1238
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1240
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1248
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1250
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1258
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1260
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1268
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1270
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1278
  .long Op1080,Op1080,Op1080,Op1080,Op1080,Op1080,Op1080,Op1080 ;@ 1280
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1288
  .long Op1090,Op1090,Op1090,Op1090,Op1090,Op1090,Op1090,Op1090 ;@ 1290
  .long Op1098,Op1098,Op1098,Op1098,Op1098,Op1098,Op1098,Op109f ;@ 1298
  .long Op10a0,Op10a0,Op10a0,Op10a0,Op10a0,Op10a0,Op10a0,Op10a7 ;@ 12a0
  .long Op10a8,Op10a8,Op10a8,Op10a8,Op10a8,Op10a8,Op10a8,Op10a8 ;@ 12a8
  .long Op10b0,Op10b0,Op10b0,Op10b0,Op10b0,Op10b0,Op10b0,Op10b0 ;@ 12b0
  .long Op10b8,Op10b9,Op10ba,Op10bb,Op10bc,Op____,Op____,Op____ ;@ 12b8
  .long Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0 ;@ 12c0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 12c8
  .long Op10d0,Op10d0,Op10d0,Op10d0,Op10d0,Op10d0,Op10d0,Op10d0 ;@ 12d0
  .long Op10d8,Op10d8,Op10d8,Op10d8,Op10d8,Op10d8,Op10d8,Op10df ;@ 12d8
  .long Op10e0,Op10e0,Op10e0,Op10e0,Op10e0,Op10e0,Op10e0,Op10e7 ;@ 12e0
  .long Op10e8,Op10e8,Op10e8,Op10e8,Op10e8,Op10e8,Op10e8,Op10e8 ;@ 12e8
  .long Op10f0,Op10f0,Op10f0,Op10f0,Op10f0,Op10f0,Op10f0,Op10f0 ;@ 12f0
  .long Op10f8,Op10f9,Op10fa,Op10fb,Op10fc,Op____,Op____,Op____ ;@ 12f8
  .long Op1100,Op1100,Op1100,Op1100,Op1100,Op1100,Op1100,Op1100 ;@ 1300
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1308
  .long Op1110,Op1110,Op1110,Op1110,Op1110,Op1110,Op1110,Op1110 ;@ 1310
  .long Op1118,Op1118,Op1118,Op1118,Op1118,Op1118,Op1118,Op111f ;@ 1318
  .long Op1120,Op1120,Op1120,Op1120,Op1120,Op1120,Op1120,Op1127 ;@ 1320
  .long Op1128,Op1128,Op1128,Op1128,Op1128,Op1128,Op1128,Op1128 ;@ 1328
  .long Op1130,Op1130,Op1130,Op1130,Op1130,Op1130,Op1130,Op1130 ;@ 1330
  .long Op1138,Op1139,Op113a,Op113b,Op113c,Op____,Op____,Op____ ;@ 1338
  .long Op1140,Op1140,Op1140,Op1140,Op1140,Op1140,Op1140,Op1140 ;@ 1340
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1348
  .long Op1150,Op1150,Op1150,Op1150,Op1150,Op1150,Op1150,Op1150 ;@ 1350
  .long Op1158,Op1158,Op1158,Op1158,Op1158,Op1158,Op1158,Op115f ;@ 1358
  .long Op1160,Op1160,Op1160,Op1160,Op1160,Op1160,Op1160,Op1167 ;@ 1360
  .long Op1168,Op1168,Op1168,Op1168,Op1168,Op1168,Op1168,Op1168 ;@ 1368
  .long Op1170,Op1170,Op1170,Op1170,Op1170,Op1170,Op1170,Op1170 ;@ 1370
  .long Op1178,Op1179,Op117a,Op117b,Op117c,Op____,Op____,Op____ ;@ 1378
  .long Op1180,Op1180,Op1180,Op1180,Op1180,Op1180,Op1180,Op1180 ;@ 1380
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1388
  .long Op1190,Op1190,Op1190,Op1190,Op1190,Op1190,Op1190,Op1190 ;@ 1390
  .long Op1198,Op1198,Op1198,Op1198,Op1198,Op1198,Op1198,Op119f ;@ 1398
  .long Op11a0,Op11a0,Op11a0,Op11a0,Op11a0,Op11a0,Op11a0,Op11a7 ;@ 13a0
  .long Op11a8,Op11a8,Op11a8,Op11a8,Op11a8,Op11a8,Op11a8,Op11a8 ;@ 13a8
  .long Op11b0,Op11b0,Op11b0,Op11b0,Op11b0,Op11b0,Op11b0,Op11b0 ;@ 13b0
  .long Op11b8,Op11b9,Op11ba,Op11bb,Op11bc,Op____,Op____,Op____ ;@ 13b8
  .long Op13c0,Op13c0,Op13c0,Op13c0,Op13c0,Op13c0,Op13c0,Op13c0 ;@ 13c0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 13c8
  .long Op13d0,Op13d0,Op13d0,Op13d0,Op13d0,Op13d0,Op13d0,Op13d0 ;@ 13d0
  .long Op13d8,Op13d8,Op13d8,Op13d8,Op13d8,Op13d8,Op13d8,Op13df ;@ 13d8
  .long Op13e0,Op13e0,Op13e0,Op13e0,Op13e0,Op13e0,Op13e0,Op13e7 ;@ 13e0
  .long Op13e8,Op13e8,Op13e8,Op13e8,Op13e8,Op13e8,Op13e8,Op13e8 ;@ 13e8
  .long Op13f0,Op13f0,Op13f0,Op13f0,Op13f0,Op13f0,Op13f0,Op13f0 ;@ 13f0
  .long Op13f8,Op13f9,Op13fa,Op13fb,Op13fc,Op____,Op____,Op____ ;@ 13f8
  .long Op1000,Op1000,Op1000,Op1000,Op1000,Op1000,Op1000,Op1000 ;@ 1400
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1408
  .long Op1010,Op1010,Op1010,Op1010,Op1010,Op1010,Op1010,Op1010 ;@ 1410
  .long Op1018,Op1018,Op1018,Op1018,Op1018,Op1018,Op1018,Op101f ;@ 1418
  .long Op1020,Op1020,Op1020,Op1020,Op1020,Op1020,Op1020,Op1027 ;@ 1420
  .long Op1028,Op1028,Op1028,Op1028,Op1028,Op1028,Op1028,Op1028 ;@ 1428
  .long Op1030,Op1030,Op1030,Op1030,Op1030,Op1030,Op1030,Op1030 ;@ 1430
  .long Op1038,Op1039,Op103a,Op103b,Op103c,Op____,Op____,Op____ ;@ 1438
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1440
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1448
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1450
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1458
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1460
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1468
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1470
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1478
  .long Op1080,Op1080,Op1080,Op1080,Op1080,Op1080,Op1080,Op1080 ;@ 1480
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1488
  .long Op1090,Op1090,Op1090,Op1090,Op1090,Op1090,Op1090,Op1090 ;@ 1490
  .long Op1098,Op1098,Op1098,Op1098,Op1098,Op1098,Op1098,Op109f ;@ 1498
  .long Op10a0,Op10a0,Op10a0,Op10a0,Op10a0,Op10a0,Op10a0,Op10a7 ;@ 14a0
  .long Op10a8,Op10a8,Op10a8,Op10a8,Op10a8,Op10a8,Op10a8,Op10a8 ;@ 14a8
  .long Op10b0,Op10b0,Op10b0,Op10b0,Op10b0,Op10b0,Op10b0,Op10b0 ;@ 14b0
  .long Op10b8,Op10b9,Op10ba,Op10bb,Op10bc,Op____,Op____,Op____ ;@ 14b8
  .long Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0 ;@ 14c0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 14c8
  .long Op10d0,Op10d0,Op10d0,Op10d0,Op10d0,Op10d0,Op10d0,Op10d0 ;@ 14d0
  .long Op10d8,Op10d8,Op10d8,Op10d8,Op10d8,Op10d8,Op10d8,Op10df ;@ 14d8
  .long Op10e0,Op10e0,Op10e0,Op10e0,Op10e0,Op10e0,Op10e0,Op10e7 ;@ 14e0
  .long Op10e8,Op10e8,Op10e8,Op10e8,Op10e8,Op10e8,Op10e8,Op10e8 ;@ 14e8
  .long Op10f0,Op10f0,Op10f0,Op10f0,Op10f0,Op10f0,Op10f0,Op10f0 ;@ 14f0
  .long Op10f8,Op10f9,Op10fa,Op10fb,Op10fc,Op____,Op____,Op____ ;@ 14f8
  .long Op1100,Op1100,Op1100,Op1100,Op1100,Op1100,Op1100,Op1100 ;@ 1500
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1508
  .long Op1110,Op1110,Op1110,Op1110,Op1110,Op1110,Op1110,Op1110 ;@ 1510
  .long Op1118,Op1118,Op1118,Op1118,Op1118,Op1118,Op1118,Op111f ;@ 1518
  .long Op1120,Op1120,Op1120,Op1120,Op1120,Op1120,Op1120,Op1127 ;@ 1520
  .long Op1128,Op1128,Op1128,Op1128,Op1128,Op1128,Op1128,Op1128 ;@ 1528
  .long Op1130,Op1130,Op1130,Op1130,Op1130,Op1130,Op1130,Op1130 ;@ 1530
  .long Op1138,Op1139,Op113a,Op113b,Op113c,Op____,Op____,Op____ ;@ 1538
  .long Op1140,Op1140,Op1140,Op1140,Op1140,Op1140,Op1140,Op1140 ;@ 1540
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1548
  .long Op1150,Op1150,Op1150,Op1150,Op1150,Op1150,Op1150,Op1150 ;@ 1550
  .long Op1158,Op1158,Op1158,Op1158,Op1158,Op1158,Op1158,Op115f ;@ 1558
  .long Op1160,Op1160,Op1160,Op1160,Op1160,Op1160,Op1160,Op1167 ;@ 1560
  .long Op1168,Op1168,Op1168,Op1168,Op1168,Op1168,Op1168,Op1168 ;@ 1568
  .long Op1170,Op1170,Op1170,Op1170,Op1170,Op1170,Op1170,Op1170 ;@ 1570
  .long Op1178,Op1179,Op117a,Op117b,Op117c,Op____,Op____,Op____ ;@ 1578
  .long Op1180,Op1180,Op1180,Op1180,Op1180,Op1180,Op1180,Op1180 ;@ 1580
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1588
  .long Op1190,Op1190,Op1190,Op1190,Op1190,Op1190,Op1190,Op1190 ;@ 1590
  .long Op1198,Op1198,Op1198,Op1198,Op1198,Op1198,Op1198,Op119f ;@ 1598
  .long Op11a0,Op11a0,Op11a0,Op11a0,Op11a0,Op11a0,Op11a0,Op11a7 ;@ 15a0
  .long Op11a8,Op11a8,Op11a8,Op11a8,Op11a8,Op11a8,Op11a8,Op11a8 ;@ 15a8
  .long Op11b0,Op11b0,Op11b0,Op11b0,Op11b0,Op11b0,Op11b0,Op11b0 ;@ 15b0
  .long Op11b8,Op11b9,Op11ba,Op11bb,Op11bc,Op____,Op____,Op____ ;@ 15b8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 15c0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 15c8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 15d0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 15d8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 15e0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 15e8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 15f0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 15f8
  .long Op1000,Op1000,Op1000,Op1000,Op1000,Op1000,Op1000,Op1000 ;@ 1600
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1608
  .long Op1010,Op1010,Op1010,Op1010,Op1010,Op1010,Op1010,Op1010 ;@ 1610
  .long Op1018,Op1018,Op1018,Op1018,Op1018,Op1018,Op1018,Op101f ;@ 1618
  .long Op1020,Op1020,Op1020,Op1020,Op1020,Op1020,Op1020,Op1027 ;@ 1620
  .long Op1028,Op1028,Op1028,Op1028,Op1028,Op1028,Op1028,Op1028 ;@ 1628
  .long Op1030,Op1030,Op1030,Op1030,Op1030,Op1030,Op1030,Op1030 ;@ 1630
  .long Op1038,Op1039,Op103a,Op103b,Op103c,Op____,Op____,Op____ ;@ 1638
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1640
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1648
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1650
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1658
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1660
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1668
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1670
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1678
  .long Op1080,Op1080,Op1080,Op1080,Op1080,Op1080,Op1080,Op1080 ;@ 1680
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1688
  .long Op1090,Op1090,Op1090,Op1090,Op1090,Op1090,Op1090,Op1090 ;@ 1690
  .long Op1098,Op1098,Op1098,Op1098,Op1098,Op1098,Op1098,Op109f ;@ 1698
  .long Op10a0,Op10a0,Op10a0,Op10a0,Op10a0,Op10a0,Op10a0,Op10a7 ;@ 16a0
  .long Op10a8,Op10a8,Op10a8,Op10a8,Op10a8,Op10a8,Op10a8,Op10a8 ;@ 16a8
  .long Op10b0,Op10b0,Op10b0,Op10b0,Op10b0,Op10b0,Op10b0,Op10b0 ;@ 16b0
  .long Op10b8,Op10b9,Op10ba,Op10bb,Op10bc,Op____,Op____,Op____ ;@ 16b8
  .long Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0 ;@ 16c0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 16c8
  .long Op10d0,Op10d0,Op10d0,Op10d0,Op10d0,Op10d0,Op10d0,Op10d0 ;@ 16d0
  .long Op10d8,Op10d8,Op10d8,Op10d8,Op10d8,Op10d8,Op10d8,Op10df ;@ 16d8
  .long Op10e0,Op10e0,Op10e0,Op10e0,Op10e0,Op10e0,Op10e0,Op10e7 ;@ 16e0
  .long Op10e8,Op10e8,Op10e8,Op10e8,Op10e8,Op10e8,Op10e8,Op10e8 ;@ 16e8
  .long Op10f0,Op10f0,Op10f0,Op10f0,Op10f0,Op10f0,Op10f0,Op10f0 ;@ 16f0
  .long Op10f8,Op10f9,Op10fa,Op10fb,Op10fc,Op____,Op____,Op____ ;@ 16f8
  .long Op1100,Op1100,Op1100,Op1100,Op1100,Op1100,Op1100,Op1100 ;@ 1700
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1708
  .long Op1110,Op1110,Op1110,Op1110,Op1110,Op1110,Op1110,Op1110 ;@ 1710
  .long Op1118,Op1118,Op1118,Op1118,Op1118,Op1118,Op1118,Op111f ;@ 1718
  .long Op1120,Op1120,Op1120,Op1120,Op1120,Op1120,Op1120,Op1127 ;@ 1720
  .long Op1128,Op1128,Op1128,Op1128,Op1128,Op1128,Op1128,Op1128 ;@ 1728
  .long Op1130,Op1130,Op1130,Op1130,Op1130,Op1130,Op1130,Op1130 ;@ 1730
  .long Op1138,Op1139,Op113a,Op113b,Op113c,Op____,Op____,Op____ ;@ 1738
  .long Op1140,Op1140,Op1140,Op1140,Op1140,Op1140,Op1140,Op1140 ;@ 1740
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1748
  .long Op1150,Op1150,Op1150,Op1150,Op1150,Op1150,Op1150,Op1150 ;@ 1750
  .long Op1158,Op1158,Op1158,Op1158,Op1158,Op1158,Op1158,Op115f ;@ 1758
  .long Op1160,Op1160,Op1160,Op1160,Op1160,Op1160,Op1160,Op1167 ;@ 1760
  .long Op1168,Op1168,Op1168,Op1168,Op1168,Op1168,Op1168,Op1168 ;@ 1768
  .long Op1170,Op1170,Op1170,Op1170,Op1170,Op1170,Op1170,Op1170 ;@ 1770
  .long Op1178,Op1179,Op117a,Op117b,Op117c,Op____,Op____,Op____ ;@ 1778
  .long Op1180,Op1180,Op1180,Op1180,Op1180,Op1180,Op1180,Op1180 ;@ 1780
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1788
  .long Op1190,Op1190,Op1190,Op1190,Op1190,Op1190,Op1190,Op1190 ;@ 1790
  .long Op1198,Op1198,Op1198,Op1198,Op1198,Op1198,Op1198,Op119f ;@ 1798
  .long Op11a0,Op11a0,Op11a0,Op11a0,Op11a0,Op11a0,Op11a0,Op11a7 ;@ 17a0
  .long Op11a8,Op11a8,Op11a8,Op11a8,Op11a8,Op11a8,Op11a8,Op11a8 ;@ 17a8
  .long Op11b0,Op11b0,Op11b0,Op11b0,Op11b0,Op11b0,Op11b0,Op11b0 ;@ 17b0
  .long Op11b8,Op11b9,Op11ba,Op11bb,Op11bc,Op____,Op____,Op____ ;@ 17b8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 17c0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 17c8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 17d0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 17d8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 17e0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 17e8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 17f0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 17f8
  .long Op1000,Op1000,Op1000,Op1000,Op1000,Op1000,Op1000,Op1000 ;@ 1800
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1808
  .long Op1010,Op1010,Op1010,Op1010,Op1010,Op1010,Op1010,Op1010 ;@ 1810
  .long Op1018,Op1018,Op1018,Op1018,Op1018,Op1018,Op1018,Op101f ;@ 1818
  .long Op1020,Op1020,Op1020,Op1020,Op1020,Op1020,Op1020,Op1027 ;@ 1820
  .long Op1028,Op1028,Op1028,Op1028,Op1028,Op1028,Op1028,Op1028 ;@ 1828
  .long Op1030,Op1030,Op1030,Op1030,Op1030,Op1030,Op1030,Op1030 ;@ 1830
  .long Op1038,Op1039,Op103a,Op103b,Op103c,Op____,Op____,Op____ ;@ 1838
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1840
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1848
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1850
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1858
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1860
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1868
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1870
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1878
  .long Op1080,Op1080,Op1080,Op1080,Op1080,Op1080,Op1080,Op1080 ;@ 1880
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1888
  .long Op1090,Op1090,Op1090,Op1090,Op1090,Op1090,Op1090,Op1090 ;@ 1890
  .long Op1098,Op1098,Op1098,Op1098,Op1098,Op1098,Op1098,Op109f ;@ 1898
  .long Op10a0,Op10a0,Op10a0,Op10a0,Op10a0,Op10a0,Op10a0,Op10a7 ;@ 18a0
  .long Op10a8,Op10a8,Op10a8,Op10a8,Op10a8,Op10a8,Op10a8,Op10a8 ;@ 18a8
  .long Op10b0,Op10b0,Op10b0,Op10b0,Op10b0,Op10b0,Op10b0,Op10b0 ;@ 18b0
  .long Op10b8,Op10b9,Op10ba,Op10bb,Op10bc,Op____,Op____,Op____ ;@ 18b8
  .long Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0 ;@ 18c0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 18c8
  .long Op10d0,Op10d0,Op10d0,Op10d0,Op10d0,Op10d0,Op10d0,Op10d0 ;@ 18d0
  .long Op10d8,Op10d8,Op10d8,Op10d8,Op10d8,Op10d8,Op10d8,Op10df ;@ 18d8
  .long Op10e0,Op10e0,Op10e0,Op10e0,Op10e0,Op10e0,Op10e0,Op10e7 ;@ 18e0
  .long Op10e8,Op10e8,Op10e8,Op10e8,Op10e8,Op10e8,Op10e8,Op10e8 ;@ 18e8
  .long Op10f0,Op10f0,Op10f0,Op10f0,Op10f0,Op10f0,Op10f0,Op10f0 ;@ 18f0
  .long Op10f8,Op10f9,Op10fa,Op10fb,Op10fc,Op____,Op____,Op____ ;@ 18f8
  .long Op1100,Op1100,Op1100,Op1100,Op1100,Op1100,Op1100,Op1100 ;@ 1900
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1908
  .long Op1110,Op1110,Op1110,Op1110,Op1110,Op1110,Op1110,Op1110 ;@ 1910
  .long Op1118,Op1118,Op1118,Op1118,Op1118,Op1118,Op1118,Op111f ;@ 1918
  .long Op1120,Op1120,Op1120,Op1120,Op1120,Op1120,Op1120,Op1127 ;@ 1920
  .long Op1128,Op1128,Op1128,Op1128,Op1128,Op1128,Op1128,Op1128 ;@ 1928
  .long Op1130,Op1130,Op1130,Op1130,Op1130,Op1130,Op1130,Op1130 ;@ 1930
  .long Op1138,Op1139,Op113a,Op113b,Op113c,Op____,Op____,Op____ ;@ 1938
  .long Op1140,Op1140,Op1140,Op1140,Op1140,Op1140,Op1140,Op1140 ;@ 1940
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1948
  .long Op1150,Op1150,Op1150,Op1150,Op1150,Op1150,Op1150,Op1150 ;@ 1950
  .long Op1158,Op1158,Op1158,Op1158,Op1158,Op1158,Op1158,Op115f ;@ 1958
  .long Op1160,Op1160,Op1160,Op1160,Op1160,Op1160,Op1160,Op1167 ;@ 1960
  .long Op1168,Op1168,Op1168,Op1168,Op1168,Op1168,Op1168,Op1168 ;@ 1968
  .long Op1170,Op1170,Op1170,Op1170,Op1170,Op1170,Op1170,Op1170 ;@ 1970
  .long Op1178,Op1179,Op117a,Op117b,Op117c,Op____,Op____,Op____ ;@ 1978
  .long Op1180,Op1180,Op1180,Op1180,Op1180,Op1180,Op1180,Op1180 ;@ 1980
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1988
  .long Op1190,Op1190,Op1190,Op1190,Op1190,Op1190,Op1190,Op1190 ;@ 1990
  .long Op1198,Op1198,Op1198,Op1198,Op1198,Op1198,Op1198,Op119f ;@ 1998
  .long Op11a0,Op11a0,Op11a0,Op11a0,Op11a0,Op11a0,Op11a0,Op11a7 ;@ 19a0
  .long Op11a8,Op11a8,Op11a8,Op11a8,Op11a8,Op11a8,Op11a8,Op11a8 ;@ 19a8
  .long Op11b0,Op11b0,Op11b0,Op11b0,Op11b0,Op11b0,Op11b0,Op11b0 ;@ 19b0
  .long Op11b8,Op11b9,Op11ba,Op11bb,Op11bc,Op____,Op____,Op____ ;@ 19b8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 19c0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 19c8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 19d0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 19d8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 19e0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 19e8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 19f0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 19f8
  .long Op1000,Op1000,Op1000,Op1000,Op1000,Op1000,Op1000,Op1000 ;@ 1a00
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1a08
  .long Op1010,Op1010,Op1010,Op1010,Op1010,Op1010,Op1010,Op1010 ;@ 1a10
  .long Op1018,Op1018,Op1018,Op1018,Op1018,Op1018,Op1018,Op101f ;@ 1a18
  .long Op1020,Op1020,Op1020,Op1020,Op1020,Op1020,Op1020,Op1027 ;@ 1a20
  .long Op1028,Op1028,Op1028,Op1028,Op1028,Op1028,Op1028,Op1028 ;@ 1a28
  .long Op1030,Op1030,Op1030,Op1030,Op1030,Op1030,Op1030,Op1030 ;@ 1a30
  .long Op1038,Op1039,Op103a,Op103b,Op103c,Op____,Op____,Op____ ;@ 1a38
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1a40
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1a48
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1a50
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1a58
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1a60
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1a68
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1a70
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1a78
  .long Op1080,Op1080,Op1080,Op1080,Op1080,Op1080,Op1080,Op1080 ;@ 1a80
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1a88
  .long Op1090,Op1090,Op1090,Op1090,Op1090,Op1090,Op1090,Op1090 ;@ 1a90
  .long Op1098,Op1098,Op1098,Op1098,Op1098,Op1098,Op1098,Op109f ;@ 1a98
  .long Op10a0,Op10a0,Op10a0,Op10a0,Op10a0,Op10a0,Op10a0,Op10a7 ;@ 1aa0
  .long Op10a8,Op10a8,Op10a8,Op10a8,Op10a8,Op10a8,Op10a8,Op10a8 ;@ 1aa8
  .long Op10b0,Op10b0,Op10b0,Op10b0,Op10b0,Op10b0,Op10b0,Op10b0 ;@ 1ab0
  .long Op10b8,Op10b9,Op10ba,Op10bb,Op10bc,Op____,Op____,Op____ ;@ 1ab8
  .long Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0 ;@ 1ac0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1ac8
  .long Op10d0,Op10d0,Op10d0,Op10d0,Op10d0,Op10d0,Op10d0,Op10d0 ;@ 1ad0
  .long Op10d8,Op10d8,Op10d8,Op10d8,Op10d8,Op10d8,Op10d8,Op10df ;@ 1ad8
  .long Op10e0,Op10e0,Op10e0,Op10e0,Op10e0,Op10e0,Op10e0,Op10e7 ;@ 1ae0
  .long Op10e8,Op10e8,Op10e8,Op10e8,Op10e8,Op10e8,Op10e8,Op10e8 ;@ 1ae8
  .long Op10f0,Op10f0,Op10f0,Op10f0,Op10f0,Op10f0,Op10f0,Op10f0 ;@ 1af0
  .long Op10f8,Op10f9,Op10fa,Op10fb,Op10fc,Op____,Op____,Op____ ;@ 1af8
  .long Op1100,Op1100,Op1100,Op1100,Op1100,Op1100,Op1100,Op1100 ;@ 1b00
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1b08
  .long Op1110,Op1110,Op1110,Op1110,Op1110,Op1110,Op1110,Op1110 ;@ 1b10
  .long Op1118,Op1118,Op1118,Op1118,Op1118,Op1118,Op1118,Op111f ;@ 1b18
  .long Op1120,Op1120,Op1120,Op1120,Op1120,Op1120,Op1120,Op1127 ;@ 1b20
  .long Op1128,Op1128,Op1128,Op1128,Op1128,Op1128,Op1128,Op1128 ;@ 1b28
  .long Op1130,Op1130,Op1130,Op1130,Op1130,Op1130,Op1130,Op1130 ;@ 1b30
  .long Op1138,Op1139,Op113a,Op113b,Op113c,Op____,Op____,Op____ ;@ 1b38
  .long Op1140,Op1140,Op1140,Op1140,Op1140,Op1140,Op1140,Op1140 ;@ 1b40
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1b48
  .long Op1150,Op1150,Op1150,Op1150,Op1150,Op1150,Op1150,Op1150 ;@ 1b50
  .long Op1158,Op1158,Op1158,Op1158,Op1158,Op1158,Op1158,Op115f ;@ 1b58
  .long Op1160,Op1160,Op1160,Op1160,Op1160,Op1160,Op1160,Op1167 ;@ 1b60
  .long Op1168,Op1168,Op1168,Op1168,Op1168,Op1168,Op1168,Op1168 ;@ 1b68
  .long Op1170,Op1170,Op1170,Op1170,Op1170,Op1170,Op1170,Op1170 ;@ 1b70
  .long Op1178,Op1179,Op117a,Op117b,Op117c,Op____,Op____,Op____ ;@ 1b78
  .long Op1180,Op1180,Op1180,Op1180,Op1180,Op1180,Op1180,Op1180 ;@ 1b80
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1b88
  .long Op1190,Op1190,Op1190,Op1190,Op1190,Op1190,Op1190,Op1190 ;@ 1b90
  .long Op1198,Op1198,Op1198,Op1198,Op1198,Op1198,Op1198,Op119f ;@ 1b98
  .long Op11a0,Op11a0,Op11a0,Op11a0,Op11a0,Op11a0,Op11a0,Op11a7 ;@ 1ba0
  .long Op11a8,Op11a8,Op11a8,Op11a8,Op11a8,Op11a8,Op11a8,Op11a8 ;@ 1ba8
  .long Op11b0,Op11b0,Op11b0,Op11b0,Op11b0,Op11b0,Op11b0,Op11b0 ;@ 1bb0
  .long Op11b8,Op11b9,Op11ba,Op11bb,Op11bc,Op____,Op____,Op____ ;@ 1bb8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1bc0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1bc8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1bd0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1bd8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1be0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1be8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1bf0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1bf8
  .long Op1000,Op1000,Op1000,Op1000,Op1000,Op1000,Op1000,Op1000 ;@ 1c00
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1c08
  .long Op1010,Op1010,Op1010,Op1010,Op1010,Op1010,Op1010,Op1010 ;@ 1c10
  .long Op1018,Op1018,Op1018,Op1018,Op1018,Op1018,Op1018,Op101f ;@ 1c18
  .long Op1020,Op1020,Op1020,Op1020,Op1020,Op1020,Op1020,Op1027 ;@ 1c20
  .long Op1028,Op1028,Op1028,Op1028,Op1028,Op1028,Op1028,Op1028 ;@ 1c28
  .long Op1030,Op1030,Op1030,Op1030,Op1030,Op1030,Op1030,Op1030 ;@ 1c30
  .long Op1038,Op1039,Op103a,Op103b,Op103c,Op____,Op____,Op____ ;@ 1c38
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1c40
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1c48
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1c50
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1c58
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1c60
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1c68
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1c70
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1c78
  .long Op1080,Op1080,Op1080,Op1080,Op1080,Op1080,Op1080,Op1080 ;@ 1c80
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1c88
  .long Op1090,Op1090,Op1090,Op1090,Op1090,Op1090,Op1090,Op1090 ;@ 1c90
  .long Op1098,Op1098,Op1098,Op1098,Op1098,Op1098,Op1098,Op109f ;@ 1c98
  .long Op10a0,Op10a0,Op10a0,Op10a0,Op10a0,Op10a0,Op10a0,Op10a7 ;@ 1ca0
  .long Op10a8,Op10a8,Op10a8,Op10a8,Op10a8,Op10a8,Op10a8,Op10a8 ;@ 1ca8
  .long Op10b0,Op10b0,Op10b0,Op10b0,Op10b0,Op10b0,Op10b0,Op10b0 ;@ 1cb0
  .long Op10b8,Op10b9,Op10ba,Op10bb,Op10bc,Op____,Op____,Op____ ;@ 1cb8
  .long Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0,Op10c0 ;@ 1cc0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1cc8
  .long Op10d0,Op10d0,Op10d0,Op10d0,Op10d0,Op10d0,Op10d0,Op10d0 ;@ 1cd0
  .long Op10d8,Op10d8,Op10d8,Op10d8,Op10d8,Op10d8,Op10d8,Op10df ;@ 1cd8
  .long Op10e0,Op10e0,Op10e0,Op10e0,Op10e0,Op10e0,Op10e0,Op10e7 ;@ 1ce0
  .long Op10e8,Op10e8,Op10e8,Op10e8,Op10e8,Op10e8,Op10e8,Op10e8 ;@ 1ce8
  .long Op10f0,Op10f0,Op10f0,Op10f0,Op10f0,Op10f0,Op10f0,Op10f0 ;@ 1cf0
  .long Op10f8,Op10f9,Op10fa,Op10fb,Op10fc,Op____,Op____,Op____ ;@ 1cf8
  .long Op1100,Op1100,Op1100,Op1100,Op1100,Op1100,Op1100,Op1100 ;@ 1d00
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1d08
  .long Op1110,Op1110,Op1110,Op1110,Op1110,Op1110,Op1110,Op1110 ;@ 1d10
  .long Op1118,Op1118,Op1118,Op1118,Op1118,Op1118,Op1118,Op111f ;@ 1d18
  .long Op1120,Op1120,Op1120,Op1120,Op1120,Op1120,Op1120,Op1127 ;@ 1d20
  .long Op1128,Op1128,Op1128,Op1128,Op1128,Op1128,Op1128,Op1128 ;@ 1d28
  .long Op1130,Op1130,Op1130,Op1130,Op1130,Op1130,Op1130,Op1130 ;@ 1d30
  .long Op1138,Op1139,Op113a,Op113b,Op113c,Op____,Op____,Op____ ;@ 1d38
  .long Op1140,Op1140,Op1140,Op1140,Op1140,Op1140,Op1140,Op1140 ;@ 1d40
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1d48
  .long Op1150,Op1150,Op1150,Op1150,Op1150,Op1150,Op1150,Op1150 ;@ 1d50
  .long Op1158,Op1158,Op1158,Op1158,Op1158,Op1158,Op1158,Op115f ;@ 1d58
  .long Op1160,Op1160,Op1160,Op1160,Op1160,Op1160,Op1160,Op1167 ;@ 1d60
  .long Op1168,Op1168,Op1168,Op1168,Op1168,Op1168,Op1168,Op1168 ;@ 1d68
  .long Op1170,Op1170,Op1170,Op1170,Op1170,Op1170,Op1170,Op1170 ;@ 1d70
  .long Op1178,Op1179,Op117a,Op117b,Op117c,Op____,Op____,Op____ ;@ 1d78
  .long Op1180,Op1180,Op1180,Op1180,Op1180,Op1180,Op1180,Op1180 ;@ 1d80
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1d88
  .long Op1190,Op1190,Op1190,Op1190,Op1190,Op1190,Op1190,Op1190 ;@ 1d90
  .long Op1198,Op1198,Op1198,Op1198,Op1198,Op1198,Op1198,Op119f ;@ 1d98
  .long Op11a0,Op11a0,Op11a0,Op11a0,Op11a0,Op11a0,Op11a0,Op11a7 ;@ 1da0
  .long Op11a8,Op11a8,Op11a8,Op11a8,Op11a8,Op11a8,Op11a8,Op11a8 ;@ 1da8
  .long Op11b0,Op11b0,Op11b0,Op11b0,Op11b0,Op11b0,Op11b0,Op11b0 ;@ 1db0
  .long Op11b8,Op11b9,Op11ba,Op11bb,Op11bc,Op____,Op____,Op____ ;@ 1db8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1dc0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1dc8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1dd0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1dd8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1de0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1de8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1df0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1df8
  .long Op1000,Op1000,Op1000,Op1000,Op1000,Op1000,Op1000,Op1000 ;@ 1e00
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1e08
  .long Op1010,Op1010,Op1010,Op1010,Op1010,Op1010,Op1010,Op1010 ;@ 1e10
  .long Op1018,Op1018,Op1018,Op1018,Op1018,Op1018,Op1018,Op101f ;@ 1e18
  .long Op1020,Op1020,Op1020,Op1020,Op1020,Op1020,Op1020,Op1027 ;@ 1e20
  .long Op1028,Op1028,Op1028,Op1028,Op1028,Op1028,Op1028,Op1028 ;@ 1e28
  .long Op1030,Op1030,Op1030,Op1030,Op1030,Op1030,Op1030,Op1030 ;@ 1e30
  .long Op1038,Op1039,Op103a,Op103b,Op103c,Op____,Op____,Op____ ;@ 1e38
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1e40
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1e48
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1e50
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1e58
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1e60
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1e68
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1e70
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1e78
  .long Op1080,Op1080,Op1080,Op1080,Op1080,Op1080,Op1080,Op1080 ;@ 1e80
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1e88
  .long Op1090,Op1090,Op1090,Op1090,Op1090,Op1090,Op1090,Op1090 ;@ 1e90
  .long Op1098,Op1098,Op1098,Op1098,Op1098,Op1098,Op1098,Op109f ;@ 1e98
  .long Op10a0,Op10a0,Op10a0,Op10a0,Op10a0,Op10a0,Op10a0,Op10a7 ;@ 1ea0
  .long Op10a8,Op10a8,Op10a8,Op10a8,Op10a8,Op10a8,Op10a8,Op10a8 ;@ 1ea8
  .long Op10b0,Op10b0,Op10b0,Op10b0,Op10b0,Op10b0,Op10b0,Op10b0 ;@ 1eb0
  .long Op10b8,Op10b9,Op10ba,Op10bb,Op10bc,Op____,Op____,Op____ ;@ 1eb8
  .long Op1ec0,Op1ec0,Op1ec0,Op1ec0,Op1ec0,Op1ec0,Op1ec0,Op1ec0 ;@ 1ec0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1ec8
  .long Op1ed0,Op1ed0,Op1ed0,Op1ed0,Op1ed0,Op1ed0,Op1ed0,Op1ed0 ;@ 1ed0
  .long Op1ed8,Op1ed8,Op1ed8,Op1ed8,Op1ed8,Op1ed8,Op1ed8,Op1edf ;@ 1ed8
  .long Op1ee0,Op1ee0,Op1ee0,Op1ee0,Op1ee0,Op1ee0,Op1ee0,Op1ee7 ;@ 1ee0
  .long Op1ee8,Op1ee8,Op1ee8,Op1ee8,Op1ee8,Op1ee8,Op1ee8,Op1ee8 ;@ 1ee8
  .long Op1ef0,Op1ef0,Op1ef0,Op1ef0,Op1ef0,Op1ef0,Op1ef0,Op1ef0 ;@ 1ef0
  .long Op1ef8,Op1ef9,Op1efa,Op1efb,Op1efc,Op____,Op____,Op____ ;@ 1ef8
  .long Op1f00,Op1f00,Op1f00,Op1f00,Op1f00,Op1f00,Op1f00,Op1f00 ;@ 1f00
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1f08
  .long Op1f10,Op1f10,Op1f10,Op1f10,Op1f10,Op1f10,Op1f10,Op1f10 ;@ 1f10
  .long Op1f18,Op1f18,Op1f18,Op1f18,Op1f18,Op1f18,Op1f18,Op1f1f ;@ 1f18
  .long Op1f20,Op1f20,Op1f20,Op1f20,Op1f20,Op1f20,Op1f20,Op1f27 ;@ 1f20
  .long Op1f28,Op1f28,Op1f28,Op1f28,Op1f28,Op1f28,Op1f28,Op1f28 ;@ 1f28
  .long Op1f30,Op1f30,Op1f30,Op1f30,Op1f30,Op1f30,Op1f30,Op1f30 ;@ 1f30
  .long Op1f38,Op1f39,Op1f3a,Op1f3b,Op1f3c,Op____,Op____,Op____ ;@ 1f38
  .long Op1140,Op1140,Op1140,Op1140,Op1140,Op1140,Op1140,Op1140 ;@ 1f40
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1f48
  .long Op1150,Op1150,Op1150,Op1150,Op1150,Op1150,Op1150,Op1150 ;@ 1f50
  .long Op1158,Op1158,Op1158,Op1158,Op1158,Op1158,Op1158,Op115f ;@ 1f58
  .long Op1160,Op1160,Op1160,Op1160,Op1160,Op1160,Op1160,Op1167 ;@ 1f60
  .long Op1168,Op1168,Op1168,Op1168,Op1168,Op1168,Op1168,Op1168 ;@ 1f68
  .long Op1170,Op1170,Op1170,Op1170,Op1170,Op1170,Op1170,Op1170 ;@ 1f70
  .long Op1178,Op1179,Op117a,Op117b,Op117c,Op____,Op____,Op____ ;@ 1f78
  .long Op1180,Op1180,Op1180,Op1180,Op1180,Op1180,Op1180,Op1180 ;@ 1f80
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1f88
  .long Op1190,Op1190,Op1190,Op1190,Op1190,Op1190,Op1190,Op1190 ;@ 1f90
  .long Op1198,Op1198,Op1198,Op1198,Op1198,Op1198,Op1198,Op119f ;@ 1f98
  .long Op11a0,Op11a0,Op11a0,Op11a0,Op11a0,Op11a0,Op11a0,Op11a7 ;@ 1fa0
  .long Op11a8,Op11a8,Op11a8,Op11a8,Op11a8,Op11a8,Op11a8,Op11a8 ;@ 1fa8
  .long Op11b0,Op11b0,Op11b0,Op11b0,Op11b0,Op11b0,Op11b0,Op11b0 ;@ 1fb0
  .long Op11b8,Op11b9,Op11ba,Op11bb,Op11bc,Op____,Op____,Op____ ;@ 1fb8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1fc0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1fc8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1fd0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1fd8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1fe0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1fe8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1ff0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1ff8
  .long Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000 ;@ 2000
  .long Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000 ;@ 2008
  .long Op2010,Op2010,Op2010,Op2010,Op2010,Op2010,Op2010,Op2010 ;@ 2010
  .long Op2018,Op2018,Op2018,Op2018,Op2018,Op2018,Op2018,Op2018 ;@ 2018
  .long Op2020,Op2020,Op2020,Op2020,Op2020,Op2020,Op2020,Op2020 ;@ 2020
  .long Op2028,Op2028,Op2028,Op2028,Op2028,Op2028,Op2028,Op2028 ;@ 2028
  .long Op2030,Op2030,Op2030,Op2030,Op2030,Op2030,Op2030,Op2030 ;@ 2030
  .long Op2038,Op2039,Op203a,Op203b,Op203c,Op____,Op____,Op____ ;@ 2038
  .long Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040 ;@ 2040
  .long Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040 ;@ 2048
  .long Op2050,Op2050,Op2050,Op2050,Op2050,Op2050,Op2050,Op2050 ;@ 2050
  .long Op2058,Op2058,Op2058,Op2058,Op2058,Op2058,Op2058,Op2058 ;@ 2058
  .long Op2060,Op2060,Op2060,Op2060,Op2060,Op2060,Op2060,Op2060 ;@ 2060
  .long Op2068,Op2068,Op2068,Op2068,Op2068,Op2068,Op2068,Op2068 ;@ 2068
  .long Op2070,Op2070,Op2070,Op2070,Op2070,Op2070,Op2070,Op2070 ;@ 2070
  .long Op2078,Op2079,Op207a,Op207b,Op207c,Op____,Op____,Op____ ;@ 2078
  .long Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080 ;@ 2080
  .long Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080 ;@ 2088
  .long Op2090,Op2090,Op2090,Op2090,Op2090,Op2090,Op2090,Op2090 ;@ 2090
  .long Op2098,Op2098,Op2098,Op2098,Op2098,Op2098,Op2098,Op2098 ;@ 2098
  .long Op20a0,Op20a0,Op20a0,Op20a0,Op20a0,Op20a0,Op20a0,Op20a0 ;@ 20a0
  .long Op20a8,Op20a8,Op20a8,Op20a8,Op20a8,Op20a8,Op20a8,Op20a8 ;@ 20a8
  .long Op20b0,Op20b0,Op20b0,Op20b0,Op20b0,Op20b0,Op20b0,Op20b0 ;@ 20b0
  .long Op20b8,Op20b9,Op20ba,Op20bb,Op20bc,Op____,Op____,Op____ ;@ 20b8
  .long Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0 ;@ 20c0
  .long Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0 ;@ 20c8
  .long Op20d0,Op20d0,Op20d0,Op20d0,Op20d0,Op20d0,Op20d0,Op20d0 ;@ 20d0
  .long Op20d8,Op20d8,Op20d8,Op20d8,Op20d8,Op20d8,Op20d8,Op20d8 ;@ 20d8
  .long Op20e0,Op20e0,Op20e0,Op20e0,Op20e0,Op20e0,Op20e0,Op20e0 ;@ 20e0
  .long Op20e8,Op20e8,Op20e8,Op20e8,Op20e8,Op20e8,Op20e8,Op20e8 ;@ 20e8
  .long Op20f0,Op20f0,Op20f0,Op20f0,Op20f0,Op20f0,Op20f0,Op20f0 ;@ 20f0
  .long Op20f8,Op20f9,Op20fa,Op20fb,Op20fc,Op____,Op____,Op____ ;@ 20f8
  .long Op2100,Op2100,Op2100,Op2100,Op2100,Op2100,Op2100,Op2100 ;@ 2100
  .long Op2100,Op2100,Op2100,Op2100,Op2100,Op2100,Op2100,Op2100 ;@ 2108
  .long Op2110,Op2110,Op2110,Op2110,Op2110,Op2110,Op2110,Op2110 ;@ 2110
  .long Op2118,Op2118,Op2118,Op2118,Op2118,Op2118,Op2118,Op2118 ;@ 2118
  .long Op2120,Op2120,Op2120,Op2120,Op2120,Op2120,Op2120,Op2120 ;@ 2120
  .long Op2128,Op2128,Op2128,Op2128,Op2128,Op2128,Op2128,Op2128 ;@ 2128
  .long Op2130,Op2130,Op2130,Op2130,Op2130,Op2130,Op2130,Op2130 ;@ 2130
  .long Op2138,Op2139,Op213a,Op213b,Op213c,Op____,Op____,Op____ ;@ 2138
  .long Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140 ;@ 2140
  .long Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140 ;@ 2148
  .long Op2150,Op2150,Op2150,Op2150,Op2150,Op2150,Op2150,Op2150 ;@ 2150
  .long Op2158,Op2158,Op2158,Op2158,Op2158,Op2158,Op2158,Op2158 ;@ 2158
  .long Op2160,Op2160,Op2160,Op2160,Op2160,Op2160,Op2160,Op2160 ;@ 2160
  .long Op2168,Op2168,Op2168,Op2168,Op2168,Op2168,Op2168,Op2168 ;@ 2168
  .long Op2170,Op2170,Op2170,Op2170,Op2170,Op2170,Op2170,Op2170 ;@ 2170
  .long Op2178,Op2179,Op217a,Op217b,Op217c,Op____,Op____,Op____ ;@ 2178
  .long Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180 ;@ 2180
  .long Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180 ;@ 2188
  .long Op2190,Op2190,Op2190,Op2190,Op2190,Op2190,Op2190,Op2190 ;@ 2190
  .long Op2198,Op2198,Op2198,Op2198,Op2198,Op2198,Op2198,Op2198 ;@ 2198
  .long Op21a0,Op21a0,Op21a0,Op21a0,Op21a0,Op21a0,Op21a0,Op21a0 ;@ 21a0
  .long Op21a8,Op21a8,Op21a8,Op21a8,Op21a8,Op21a8,Op21a8,Op21a8 ;@ 21a8
  .long Op21b0,Op21b0,Op21b0,Op21b0,Op21b0,Op21b0,Op21b0,Op21b0 ;@ 21b0
  .long Op21b8,Op21b9,Op21ba,Op21bb,Op21bc,Op____,Op____,Op____ ;@ 21b8
  .long Op21c0,Op21c0,Op21c0,Op21c0,Op21c0,Op21c0,Op21c0,Op21c0 ;@ 21c0
  .long Op21c0,Op21c0,Op21c0,Op21c0,Op21c0,Op21c0,Op21c0,Op21c0 ;@ 21c8
  .long Op21d0,Op21d0,Op21d0,Op21d0,Op21d0,Op21d0,Op21d0,Op21d0 ;@ 21d0
  .long Op21d8,Op21d8,Op21d8,Op21d8,Op21d8,Op21d8,Op21d8,Op21d8 ;@ 21d8
  .long Op21e0,Op21e0,Op21e0,Op21e0,Op21e0,Op21e0,Op21e0,Op21e0 ;@ 21e0
  .long Op21e8,Op21e8,Op21e8,Op21e8,Op21e8,Op21e8,Op21e8,Op21e8 ;@ 21e8
  .long Op21f0,Op21f0,Op21f0,Op21f0,Op21f0,Op21f0,Op21f0,Op21f0 ;@ 21f0
  .long Op21f8,Op21f9,Op21fa,Op21fb,Op21fc,Op____,Op____,Op____ ;@ 21f8
  .long Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000 ;@ 2200
  .long Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000 ;@ 2208
  .long Op2010,Op2010,Op2010,Op2010,Op2010,Op2010,Op2010,Op2010 ;@ 2210
  .long Op2018,Op2018,Op2018,Op2018,Op2018,Op2018,Op2018,Op2018 ;@ 2218
  .long Op2020,Op2020,Op2020,Op2020,Op2020,Op2020,Op2020,Op2020 ;@ 2220
  .long Op2028,Op2028,Op2028,Op2028,Op2028,Op2028,Op2028,Op2028 ;@ 2228
  .long Op2030,Op2030,Op2030,Op2030,Op2030,Op2030,Op2030,Op2030 ;@ 2230
  .long Op2038,Op2039,Op203a,Op203b,Op203c,Op____,Op____,Op____ ;@ 2238
  .long Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040 ;@ 2240
  .long Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040 ;@ 2248
  .long Op2050,Op2050,Op2050,Op2050,Op2050,Op2050,Op2050,Op2050 ;@ 2250
  .long Op2058,Op2058,Op2058,Op2058,Op2058,Op2058,Op2058,Op2058 ;@ 2258
  .long Op2060,Op2060,Op2060,Op2060,Op2060,Op2060,Op2060,Op2060 ;@ 2260
  .long Op2068,Op2068,Op2068,Op2068,Op2068,Op2068,Op2068,Op2068 ;@ 2268
  .long Op2070,Op2070,Op2070,Op2070,Op2070,Op2070,Op2070,Op2070 ;@ 2270
  .long Op2078,Op2079,Op207a,Op207b,Op207c,Op____,Op____,Op____ ;@ 2278
  .long Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080 ;@ 2280
  .long Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080 ;@ 2288
  .long Op2090,Op2090,Op2090,Op2090,Op2090,Op2090,Op2090,Op2090 ;@ 2290
  .long Op2098,Op2098,Op2098,Op2098,Op2098,Op2098,Op2098,Op2098 ;@ 2298
  .long Op20a0,Op20a0,Op20a0,Op20a0,Op20a0,Op20a0,Op20a0,Op20a0 ;@ 22a0
  .long Op20a8,Op20a8,Op20a8,Op20a8,Op20a8,Op20a8,Op20a8,Op20a8 ;@ 22a8
  .long Op20b0,Op20b0,Op20b0,Op20b0,Op20b0,Op20b0,Op20b0,Op20b0 ;@ 22b0
  .long Op20b8,Op20b9,Op20ba,Op20bb,Op20bc,Op____,Op____,Op____ ;@ 22b8
  .long Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0 ;@ 22c0
  .long Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0 ;@ 22c8
  .long Op20d0,Op20d0,Op20d0,Op20d0,Op20d0,Op20d0,Op20d0,Op20d0 ;@ 22d0
  .long Op20d8,Op20d8,Op20d8,Op20d8,Op20d8,Op20d8,Op20d8,Op20d8 ;@ 22d8
  .long Op20e0,Op20e0,Op20e0,Op20e0,Op20e0,Op20e0,Op20e0,Op20e0 ;@ 22e0
  .long Op20e8,Op20e8,Op20e8,Op20e8,Op20e8,Op20e8,Op20e8,Op20e8 ;@ 22e8
  .long Op20f0,Op20f0,Op20f0,Op20f0,Op20f0,Op20f0,Op20f0,Op20f0 ;@ 22f0
  .long Op20f8,Op20f9,Op20fa,Op20fb,Op20fc,Op____,Op____,Op____ ;@ 22f8
  .long Op2100,Op2100,Op2100,Op2100,Op2100,Op2100,Op2100,Op2100 ;@ 2300
  .long Op2100,Op2100,Op2100,Op2100,Op2100,Op2100,Op2100,Op2100 ;@ 2308
  .long Op2110,Op2110,Op2110,Op2110,Op2110,Op2110,Op2110,Op2110 ;@ 2310
  .long Op2118,Op2118,Op2118,Op2118,Op2118,Op2118,Op2118,Op2118 ;@ 2318
  .long Op2120,Op2120,Op2120,Op2120,Op2120,Op2120,Op2120,Op2120 ;@ 2320
  .long Op2128,Op2128,Op2128,Op2128,Op2128,Op2128,Op2128,Op2128 ;@ 2328
  .long Op2130,Op2130,Op2130,Op2130,Op2130,Op2130,Op2130,Op2130 ;@ 2330
  .long Op2138,Op2139,Op213a,Op213b,Op213c,Op____,Op____,Op____ ;@ 2338
  .long Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140 ;@ 2340
  .long Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140 ;@ 2348
  .long Op2150,Op2150,Op2150,Op2150,Op2150,Op2150,Op2150,Op2150 ;@ 2350
  .long Op2158,Op2158,Op2158,Op2158,Op2158,Op2158,Op2158,Op2158 ;@ 2358
  .long Op2160,Op2160,Op2160,Op2160,Op2160,Op2160,Op2160,Op2160 ;@ 2360
  .long Op2168,Op2168,Op2168,Op2168,Op2168,Op2168,Op2168,Op2168 ;@ 2368
  .long Op2170,Op2170,Op2170,Op2170,Op2170,Op2170,Op2170,Op2170 ;@ 2370
  .long Op2178,Op2179,Op217a,Op217b,Op217c,Op____,Op____,Op____ ;@ 2378
  .long Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180 ;@ 2380
  .long Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180 ;@ 2388
  .long Op2190,Op2190,Op2190,Op2190,Op2190,Op2190,Op2190,Op2190 ;@ 2390
  .long Op2198,Op2198,Op2198,Op2198,Op2198,Op2198,Op2198,Op2198 ;@ 2398
  .long Op21a0,Op21a0,Op21a0,Op21a0,Op21a0,Op21a0,Op21a0,Op21a0 ;@ 23a0
  .long Op21a8,Op21a8,Op21a8,Op21a8,Op21a8,Op21a8,Op21a8,Op21a8 ;@ 23a8
  .long Op21b0,Op21b0,Op21b0,Op21b0,Op21b0,Op21b0,Op21b0,Op21b0 ;@ 23b0
  .long Op21b8,Op21b9,Op21ba,Op21bb,Op21bc,Op____,Op____,Op____ ;@ 23b8
  .long Op23c0,Op23c0,Op23c0,Op23c0,Op23c0,Op23c0,Op23c0,Op23c0 ;@ 23c0
  .long Op23c0,Op23c0,Op23c0,Op23c0,Op23c0,Op23c0,Op23c0,Op23c0 ;@ 23c8
  .long Op23d0,Op23d0,Op23d0,Op23d0,Op23d0,Op23d0,Op23d0,Op23d0 ;@ 23d0
  .long Op23d8,Op23d8,Op23d8,Op23d8,Op23d8,Op23d8,Op23d8,Op23d8 ;@ 23d8
  .long Op23e0,Op23e0,Op23e0,Op23e0,Op23e0,Op23e0,Op23e0,Op23e0 ;@ 23e0
  .long Op23e8,Op23e8,Op23e8,Op23e8,Op23e8,Op23e8,Op23e8,Op23e8 ;@ 23e8
  .long Op23f0,Op23f0,Op23f0,Op23f0,Op23f0,Op23f0,Op23f0,Op23f0 ;@ 23f0
  .long Op23f8,Op23f9,Op23fa,Op23fb,Op23fc,Op____,Op____,Op____ ;@ 23f8
  .long Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000 ;@ 2400
  .long Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000 ;@ 2408
  .long Op2010,Op2010,Op2010,Op2010,Op2010,Op2010,Op2010,Op2010 ;@ 2410
  .long Op2018,Op2018,Op2018,Op2018,Op2018,Op2018,Op2018,Op2018 ;@ 2418
  .long Op2020,Op2020,Op2020,Op2020,Op2020,Op2020,Op2020,Op2020 ;@ 2420
  .long Op2028,Op2028,Op2028,Op2028,Op2028,Op2028,Op2028,Op2028 ;@ 2428
  .long Op2030,Op2030,Op2030,Op2030,Op2030,Op2030,Op2030,Op2030 ;@ 2430
  .long Op2038,Op2039,Op203a,Op203b,Op203c,Op____,Op____,Op____ ;@ 2438
  .long Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040 ;@ 2440
  .long Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040 ;@ 2448
  .long Op2050,Op2050,Op2050,Op2050,Op2050,Op2050,Op2050,Op2050 ;@ 2450
  .long Op2058,Op2058,Op2058,Op2058,Op2058,Op2058,Op2058,Op2058 ;@ 2458
  .long Op2060,Op2060,Op2060,Op2060,Op2060,Op2060,Op2060,Op2060 ;@ 2460
  .long Op2068,Op2068,Op2068,Op2068,Op2068,Op2068,Op2068,Op2068 ;@ 2468
  .long Op2070,Op2070,Op2070,Op2070,Op2070,Op2070,Op2070,Op2070 ;@ 2470
  .long Op2078,Op2079,Op207a,Op207b,Op207c,Op____,Op____,Op____ ;@ 2478
  .long Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080 ;@ 2480
  .long Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080 ;@ 2488
  .long Op2090,Op2090,Op2090,Op2090,Op2090,Op2090,Op2090,Op2090 ;@ 2490
  .long Op2098,Op2098,Op2098,Op2098,Op2098,Op2098,Op2098,Op2098 ;@ 2498
  .long Op20a0,Op20a0,Op20a0,Op20a0,Op20a0,Op20a0,Op20a0,Op20a0 ;@ 24a0
  .long Op20a8,Op20a8,Op20a8,Op20a8,Op20a8,Op20a8,Op20a8,Op20a8 ;@ 24a8
  .long Op20b0,Op20b0,Op20b0,Op20b0,Op20b0,Op20b0,Op20b0,Op20b0 ;@ 24b0
  .long Op20b8,Op20b9,Op20ba,Op20bb,Op20bc,Op____,Op____,Op____ ;@ 24b8
  .long Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0 ;@ 24c0
  .long Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0 ;@ 24c8
  .long Op20d0,Op20d0,Op20d0,Op20d0,Op20d0,Op20d0,Op20d0,Op20d0 ;@ 24d0
  .long Op20d8,Op20d8,Op20d8,Op20d8,Op20d8,Op20d8,Op20d8,Op20d8 ;@ 24d8
  .long Op20e0,Op20e0,Op20e0,Op20e0,Op20e0,Op20e0,Op20e0,Op20e0 ;@ 24e0
  .long Op20e8,Op20e8,Op20e8,Op20e8,Op20e8,Op20e8,Op20e8,Op20e8 ;@ 24e8
  .long Op20f0,Op20f0,Op20f0,Op20f0,Op20f0,Op20f0,Op20f0,Op20f0 ;@ 24f0
  .long Op20f8,Op20f9,Op20fa,Op20fb,Op20fc,Op____,Op____,Op____ ;@ 24f8
  .long Op2100,Op2100,Op2100,Op2100,Op2100,Op2100,Op2100,Op2100 ;@ 2500
  .long Op2100,Op2100,Op2100,Op2100,Op2100,Op2100,Op2100,Op2100 ;@ 2508
  .long Op2110,Op2110,Op2110,Op2110,Op2110,Op2110,Op2110,Op2110 ;@ 2510
  .long Op2118,Op2118,Op2118,Op2118,Op2118,Op2118,Op2118,Op2118 ;@ 2518
  .long Op2120,Op2120,Op2120,Op2120,Op2120,Op2120,Op2120,Op2120 ;@ 2520
  .long Op2128,Op2128,Op2128,Op2128,Op2128,Op2128,Op2128,Op2128 ;@ 2528
  .long Op2130,Op2130,Op2130,Op2130,Op2130,Op2130,Op2130,Op2130 ;@ 2530
  .long Op2138,Op2139,Op213a,Op213b,Op213c,Op____,Op____,Op____ ;@ 2538
  .long Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140 ;@ 2540
  .long Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140 ;@ 2548
  .long Op2150,Op2150,Op2150,Op2150,Op2150,Op2150,Op2150,Op2150 ;@ 2550
  .long Op2158,Op2158,Op2158,Op2158,Op2158,Op2158,Op2158,Op2158 ;@ 2558
  .long Op2160,Op2160,Op2160,Op2160,Op2160,Op2160,Op2160,Op2160 ;@ 2560
  .long Op2168,Op2168,Op2168,Op2168,Op2168,Op2168,Op2168,Op2168 ;@ 2568
  .long Op2170,Op2170,Op2170,Op2170,Op2170,Op2170,Op2170,Op2170 ;@ 2570
  .long Op2178,Op2179,Op217a,Op217b,Op217c,Op____,Op____,Op____ ;@ 2578
  .long Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180 ;@ 2580
  .long Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180 ;@ 2588
  .long Op2190,Op2190,Op2190,Op2190,Op2190,Op2190,Op2190,Op2190 ;@ 2590
  .long Op2198,Op2198,Op2198,Op2198,Op2198,Op2198,Op2198,Op2198 ;@ 2598
  .long Op21a0,Op21a0,Op21a0,Op21a0,Op21a0,Op21a0,Op21a0,Op21a0 ;@ 25a0
  .long Op21a8,Op21a8,Op21a8,Op21a8,Op21a8,Op21a8,Op21a8,Op21a8 ;@ 25a8
  .long Op21b0,Op21b0,Op21b0,Op21b0,Op21b0,Op21b0,Op21b0,Op21b0 ;@ 25b0
  .long Op21b8,Op21b9,Op21ba,Op21bb,Op21bc,Op____,Op____,Op____ ;@ 25b8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 25c0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 25c8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 25d0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 25d8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 25e0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 25e8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 25f0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 25f8
  .long Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000 ;@ 2600
  .long Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000 ;@ 2608
  .long Op2010,Op2010,Op2010,Op2010,Op2010,Op2010,Op2010,Op2010 ;@ 2610
  .long Op2018,Op2018,Op2018,Op2018,Op2018,Op2018,Op2018,Op2018 ;@ 2618
  .long Op2020,Op2020,Op2020,Op2020,Op2020,Op2020,Op2020,Op2020 ;@ 2620
  .long Op2028,Op2028,Op2028,Op2028,Op2028,Op2028,Op2028,Op2028 ;@ 2628
  .long Op2030,Op2030,Op2030,Op2030,Op2030,Op2030,Op2030,Op2030 ;@ 2630
  .long Op2038,Op2039,Op203a,Op203b,Op203c,Op____,Op____,Op____ ;@ 2638
  .long Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040 ;@ 2640
  .long Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040 ;@ 2648
  .long Op2050,Op2050,Op2050,Op2050,Op2050,Op2050,Op2050,Op2050 ;@ 2650
  .long Op2058,Op2058,Op2058,Op2058,Op2058,Op2058,Op2058,Op2058 ;@ 2658
  .long Op2060,Op2060,Op2060,Op2060,Op2060,Op2060,Op2060,Op2060 ;@ 2660
  .long Op2068,Op2068,Op2068,Op2068,Op2068,Op2068,Op2068,Op2068 ;@ 2668
  .long Op2070,Op2070,Op2070,Op2070,Op2070,Op2070,Op2070,Op2070 ;@ 2670
  .long Op2078,Op2079,Op207a,Op207b,Op207c,Op____,Op____,Op____ ;@ 2678
  .long Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080 ;@ 2680
  .long Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080 ;@ 2688
  .long Op2090,Op2090,Op2090,Op2090,Op2090,Op2090,Op2090,Op2090 ;@ 2690
  .long Op2098,Op2098,Op2098,Op2098,Op2098,Op2098,Op2098,Op2098 ;@ 2698
  .long Op20a0,Op20a0,Op20a0,Op20a0,Op20a0,Op20a0,Op20a0,Op20a0 ;@ 26a0
  .long Op20a8,Op20a8,Op20a8,Op20a8,Op20a8,Op20a8,Op20a8,Op20a8 ;@ 26a8
  .long Op20b0,Op20b0,Op20b0,Op20b0,Op20b0,Op20b0,Op20b0,Op20b0 ;@ 26b0
  .long Op20b8,Op20b9,Op20ba,Op20bb,Op20bc,Op____,Op____,Op____ ;@ 26b8
  .long Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0 ;@ 26c0
  .long Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0 ;@ 26c8
  .long Op20d0,Op20d0,Op20d0,Op20d0,Op20d0,Op20d0,Op20d0,Op20d0 ;@ 26d0
  .long Op20d8,Op20d8,Op20d8,Op20d8,Op20d8,Op20d8,Op20d8,Op20d8 ;@ 26d8
  .long Op20e0,Op20e0,Op20e0,Op20e0,Op20e0,Op20e0,Op20e0,Op20e0 ;@ 26e0
  .long Op20e8,Op20e8,Op20e8,Op20e8,Op20e8,Op20e8,Op20e8,Op20e8 ;@ 26e8
  .long Op20f0,Op20f0,Op20f0,Op20f0,Op20f0,Op20f0,Op20f0,Op20f0 ;@ 26f0
  .long Op20f8,Op20f9,Op20fa,Op20fb,Op20fc,Op____,Op____,Op____ ;@ 26f8
  .long Op2100,Op2100,Op2100,Op2100,Op2100,Op2100,Op2100,Op2100 ;@ 2700
  .long Op2100,Op2100,Op2100,Op2100,Op2100,Op2100,Op2100,Op2100 ;@ 2708
  .long Op2110,Op2110,Op2110,Op2110,Op2110,Op2110,Op2110,Op2110 ;@ 2710
  .long Op2118,Op2118,Op2118,Op2118,Op2118,Op2118,Op2118,Op2118 ;@ 2718
  .long Op2120,Op2120,Op2120,Op2120,Op2120,Op2120,Op2120,Op2120 ;@ 2720
  .long Op2128,Op2128,Op2128,Op2128,Op2128,Op2128,Op2128,Op2128 ;@ 2728
  .long Op2130,Op2130,Op2130,Op2130,Op2130,Op2130,Op2130,Op2130 ;@ 2730
  .long Op2138,Op2139,Op213a,Op213b,Op213c,Op____,Op____,Op____ ;@ 2738
  .long Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140 ;@ 2740
  .long Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140 ;@ 2748
  .long Op2150,Op2150,Op2150,Op2150,Op2150,Op2150,Op2150,Op2150 ;@ 2750
  .long Op2158,Op2158,Op2158,Op2158,Op2158,Op2158,Op2158,Op2158 ;@ 2758
  .long Op2160,Op2160,Op2160,Op2160,Op2160,Op2160,Op2160,Op2160 ;@ 2760
  .long Op2168,Op2168,Op2168,Op2168,Op2168,Op2168,Op2168,Op2168 ;@ 2768
  .long Op2170,Op2170,Op2170,Op2170,Op2170,Op2170,Op2170,Op2170 ;@ 2770
  .long Op2178,Op2179,Op217a,Op217b,Op217c,Op____,Op____,Op____ ;@ 2778
  .long Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180 ;@ 2780
  .long Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180 ;@ 2788
  .long Op2190,Op2190,Op2190,Op2190,Op2190,Op2190,Op2190,Op2190 ;@ 2790
  .long Op2198,Op2198,Op2198,Op2198,Op2198,Op2198,Op2198,Op2198 ;@ 2798
  .long Op21a0,Op21a0,Op21a0,Op21a0,Op21a0,Op21a0,Op21a0,Op21a0 ;@ 27a0
  .long Op21a8,Op21a8,Op21a8,Op21a8,Op21a8,Op21a8,Op21a8,Op21a8 ;@ 27a8
  .long Op21b0,Op21b0,Op21b0,Op21b0,Op21b0,Op21b0,Op21b0,Op21b0 ;@ 27b0
  .long Op21b8,Op21b9,Op21ba,Op21bb,Op21bc,Op____,Op____,Op____ ;@ 27b8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 27c0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 27c8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 27d0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 27d8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 27e0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 27e8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 27f0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 27f8
  .long Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000 ;@ 2800
  .long Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000 ;@ 2808
  .long Op2010,Op2010,Op2010,Op2010,Op2010,Op2010,Op2010,Op2010 ;@ 2810
  .long Op2018,Op2018,Op2018,Op2018,Op2018,Op2018,Op2018,Op2018 ;@ 2818
  .long Op2020,Op2020,Op2020,Op2020,Op2020,Op2020,Op2020,Op2020 ;@ 2820
  .long Op2028,Op2028,Op2028,Op2028,Op2028,Op2028,Op2028,Op2028 ;@ 2828
  .long Op2030,Op2030,Op2030,Op2030,Op2030,Op2030,Op2030,Op2030 ;@ 2830
  .long Op2038,Op2039,Op203a,Op203b,Op203c,Op____,Op____,Op____ ;@ 2838
  .long Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040 ;@ 2840
  .long Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040 ;@ 2848
  .long Op2050,Op2050,Op2050,Op2050,Op2050,Op2050,Op2050,Op2050 ;@ 2850
  .long Op2058,Op2058,Op2058,Op2058,Op2058,Op2058,Op2058,Op2058 ;@ 2858
  .long Op2060,Op2060,Op2060,Op2060,Op2060,Op2060,Op2060,Op2060 ;@ 2860
  .long Op2068,Op2068,Op2068,Op2068,Op2068,Op2068,Op2068,Op2068 ;@ 2868
  .long Op2070,Op2070,Op2070,Op2070,Op2070,Op2070,Op2070,Op2070 ;@ 2870
  .long Op2078,Op2079,Op207a,Op207b,Op207c,Op____,Op____,Op____ ;@ 2878
  .long Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080 ;@ 2880
  .long Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080 ;@ 2888
  .long Op2090,Op2090,Op2090,Op2090,Op2090,Op2090,Op2090,Op2090 ;@ 2890
  .long Op2098,Op2098,Op2098,Op2098,Op2098,Op2098,Op2098,Op2098 ;@ 2898
  .long Op20a0,Op20a0,Op20a0,Op20a0,Op20a0,Op20a0,Op20a0,Op20a0 ;@ 28a0
  .long Op20a8,Op20a8,Op20a8,Op20a8,Op20a8,Op20a8,Op20a8,Op20a8 ;@ 28a8
  .long Op20b0,Op20b0,Op20b0,Op20b0,Op20b0,Op20b0,Op20b0,Op20b0 ;@ 28b0
  .long Op20b8,Op20b9,Op20ba,Op20bb,Op20bc,Op____,Op____,Op____ ;@ 28b8
  .long Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0 ;@ 28c0
  .long Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0 ;@ 28c8
  .long Op20d0,Op20d0,Op20d0,Op20d0,Op20d0,Op20d0,Op20d0,Op20d0 ;@ 28d0
  .long Op20d8,Op20d8,Op20d8,Op20d8,Op20d8,Op20d8,Op20d8,Op20d8 ;@ 28d8
  .long Op20e0,Op20e0,Op20e0,Op20e0,Op20e0,Op20e0,Op20e0,Op20e0 ;@ 28e0
  .long Op20e8,Op20e8,Op20e8,Op20e8,Op20e8,Op20e8,Op20e8,Op20e8 ;@ 28e8
  .long Op20f0,Op20f0,Op20f0,Op20f0,Op20f0,Op20f0,Op20f0,Op20f0 ;@ 28f0
  .long Op20f8,Op20f9,Op20fa,Op20fb,Op20fc,Op____,Op____,Op____ ;@ 28f8
  .long Op2100,Op2100,Op2100,Op2100,Op2100,Op2100,Op2100,Op2100 ;@ 2900
  .long Op2100,Op2100,Op2100,Op2100,Op2100,Op2100,Op2100,Op2100 ;@ 2908
  .long Op2110,Op2110,Op2110,Op2110,Op2110,Op2110,Op2110,Op2110 ;@ 2910
  .long Op2118,Op2118,Op2118,Op2118,Op2118,Op2118,Op2118,Op2118 ;@ 2918
  .long Op2120,Op2120,Op2120,Op2120,Op2120,Op2120,Op2120,Op2120 ;@ 2920
  .long Op2128,Op2128,Op2128,Op2128,Op2128,Op2128,Op2128,Op2128 ;@ 2928
  .long Op2130,Op2130,Op2130,Op2130,Op2130,Op2130,Op2130,Op2130 ;@ 2930
  .long Op2138,Op2139,Op213a,Op213b,Op213c,Op____,Op____,Op____ ;@ 2938
  .long Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140 ;@ 2940
  .long Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140 ;@ 2948
  .long Op2150,Op2150,Op2150,Op2150,Op2150,Op2150,Op2150,Op2150 ;@ 2950
  .long Op2158,Op2158,Op2158,Op2158,Op2158,Op2158,Op2158,Op2158 ;@ 2958
  .long Op2160,Op2160,Op2160,Op2160,Op2160,Op2160,Op2160,Op2160 ;@ 2960
  .long Op2168,Op2168,Op2168,Op2168,Op2168,Op2168,Op2168,Op2168 ;@ 2968
  .long Op2170,Op2170,Op2170,Op2170,Op2170,Op2170,Op2170,Op2170 ;@ 2970
  .long Op2178,Op2179,Op217a,Op217b,Op217c,Op____,Op____,Op____ ;@ 2978
  .long Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180 ;@ 2980
  .long Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180 ;@ 2988
  .long Op2190,Op2190,Op2190,Op2190,Op2190,Op2190,Op2190,Op2190 ;@ 2990
  .long Op2198,Op2198,Op2198,Op2198,Op2198,Op2198,Op2198,Op2198 ;@ 2998
  .long Op21a0,Op21a0,Op21a0,Op21a0,Op21a0,Op21a0,Op21a0,Op21a0 ;@ 29a0
  .long Op21a8,Op21a8,Op21a8,Op21a8,Op21a8,Op21a8,Op21a8,Op21a8 ;@ 29a8
  .long Op21b0,Op21b0,Op21b0,Op21b0,Op21b0,Op21b0,Op21b0,Op21b0 ;@ 29b0
  .long Op21b8,Op21b9,Op21ba,Op21bb,Op21bc,Op____,Op____,Op____ ;@ 29b8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 29c0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 29c8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 29d0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 29d8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 29e0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 29e8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 29f0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 29f8
  .long Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000 ;@ 2a00
  .long Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000 ;@ 2a08
  .long Op2010,Op2010,Op2010,Op2010,Op2010,Op2010,Op2010,Op2010 ;@ 2a10
  .long Op2018,Op2018,Op2018,Op2018,Op2018,Op2018,Op2018,Op2018 ;@ 2a18
  .long Op2020,Op2020,Op2020,Op2020,Op2020,Op2020,Op2020,Op2020 ;@ 2a20
  .long Op2028,Op2028,Op2028,Op2028,Op2028,Op2028,Op2028,Op2028 ;@ 2a28
  .long Op2030,Op2030,Op2030,Op2030,Op2030,Op2030,Op2030,Op2030 ;@ 2a30
  .long Op2038,Op2039,Op203a,Op203b,Op203c,Op____,Op____,Op____ ;@ 2a38
  .long Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040 ;@ 2a40
  .long Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040 ;@ 2a48
  .long Op2050,Op2050,Op2050,Op2050,Op2050,Op2050,Op2050,Op2050 ;@ 2a50
  .long Op2058,Op2058,Op2058,Op2058,Op2058,Op2058,Op2058,Op2058 ;@ 2a58
  .long Op2060,Op2060,Op2060,Op2060,Op2060,Op2060,Op2060,Op2060 ;@ 2a60
  .long Op2068,Op2068,Op2068,Op2068,Op2068,Op2068,Op2068,Op2068 ;@ 2a68
  .long Op2070,Op2070,Op2070,Op2070,Op2070,Op2070,Op2070,Op2070 ;@ 2a70
  .long Op2078,Op2079,Op207a,Op207b,Op207c,Op____,Op____,Op____ ;@ 2a78
  .long Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080 ;@ 2a80
  .long Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080 ;@ 2a88
  .long Op2090,Op2090,Op2090,Op2090,Op2090,Op2090,Op2090,Op2090 ;@ 2a90
  .long Op2098,Op2098,Op2098,Op2098,Op2098,Op2098,Op2098,Op2098 ;@ 2a98
  .long Op20a0,Op20a0,Op20a0,Op20a0,Op20a0,Op20a0,Op20a0,Op20a0 ;@ 2aa0
  .long Op20a8,Op20a8,Op20a8,Op20a8,Op20a8,Op20a8,Op20a8,Op20a8 ;@ 2aa8
  .long Op20b0,Op20b0,Op20b0,Op20b0,Op20b0,Op20b0,Op20b0,Op20b0 ;@ 2ab0
  .long Op20b8,Op20b9,Op20ba,Op20bb,Op20bc,Op____,Op____,Op____ ;@ 2ab8
  .long Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0 ;@ 2ac0
  .long Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0 ;@ 2ac8
  .long Op20d0,Op20d0,Op20d0,Op20d0,Op20d0,Op20d0,Op20d0,Op20d0 ;@ 2ad0
  .long Op20d8,Op20d8,Op20d8,Op20d8,Op20d8,Op20d8,Op20d8,Op20d8 ;@ 2ad8
  .long Op20e0,Op20e0,Op20e0,Op20e0,Op20e0,Op20e0,Op20e0,Op20e0 ;@ 2ae0
  .long Op20e8,Op20e8,Op20e8,Op20e8,Op20e8,Op20e8,Op20e8,Op20e8 ;@ 2ae8
  .long Op20f0,Op20f0,Op20f0,Op20f0,Op20f0,Op20f0,Op20f0,Op20f0 ;@ 2af0
  .long Op20f8,Op20f9,Op20fa,Op20fb,Op20fc,Op____,Op____,Op____ ;@ 2af8
  .long Op2100,Op2100,Op2100,Op2100,Op2100,Op2100,Op2100,Op2100 ;@ 2b00
  .long Op2100,Op2100,Op2100,Op2100,Op2100,Op2100,Op2100,Op2100 ;@ 2b08
  .long Op2110,Op2110,Op2110,Op2110,Op2110,Op2110,Op2110,Op2110 ;@ 2b10
  .long Op2118,Op2118,Op2118,Op2118,Op2118,Op2118,Op2118,Op2118 ;@ 2b18
  .long Op2120,Op2120,Op2120,Op2120,Op2120,Op2120,Op2120,Op2120 ;@ 2b20
  .long Op2128,Op2128,Op2128,Op2128,Op2128,Op2128,Op2128,Op2128 ;@ 2b28
  .long Op2130,Op2130,Op2130,Op2130,Op2130,Op2130,Op2130,Op2130 ;@ 2b30
  .long Op2138,Op2139,Op213a,Op213b,Op213c,Op____,Op____,Op____ ;@ 2b38
  .long Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140 ;@ 2b40
  .long Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140 ;@ 2b48
  .long Op2150,Op2150,Op2150,Op2150,Op2150,Op2150,Op2150,Op2150 ;@ 2b50
  .long Op2158,Op2158,Op2158,Op2158,Op2158,Op2158,Op2158,Op2158 ;@ 2b58
  .long Op2160,Op2160,Op2160,Op2160,Op2160,Op2160,Op2160,Op2160 ;@ 2b60
  .long Op2168,Op2168,Op2168,Op2168,Op2168,Op2168,Op2168,Op2168 ;@ 2b68
  .long Op2170,Op2170,Op2170,Op2170,Op2170,Op2170,Op2170,Op2170 ;@ 2b70
  .long Op2178,Op2179,Op217a,Op217b,Op217c,Op____,Op____,Op____ ;@ 2b78
  .long Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180 ;@ 2b80
  .long Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180 ;@ 2b88
  .long Op2190,Op2190,Op2190,Op2190,Op2190,Op2190,Op2190,Op2190 ;@ 2b90
  .long Op2198,Op2198,Op2198,Op2198,Op2198,Op2198,Op2198,Op2198 ;@ 2b98
  .long Op21a0,Op21a0,Op21a0,Op21a0,Op21a0,Op21a0,Op21a0,Op21a0 ;@ 2ba0
  .long Op21a8,Op21a8,Op21a8,Op21a8,Op21a8,Op21a8,Op21a8,Op21a8 ;@ 2ba8
  .long Op21b0,Op21b0,Op21b0,Op21b0,Op21b0,Op21b0,Op21b0,Op21b0 ;@ 2bb0
  .long Op21b8,Op21b9,Op21ba,Op21bb,Op21bc,Op____,Op____,Op____ ;@ 2bb8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 2bc0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 2bc8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 2bd0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 2bd8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 2be0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 2be8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 2bf0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 2bf8
  .long Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000 ;@ 2c00
  .long Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000 ;@ 2c08
  .long Op2010,Op2010,Op2010,Op2010,Op2010,Op2010,Op2010,Op2010 ;@ 2c10
  .long Op2018,Op2018,Op2018,Op2018,Op2018,Op2018,Op2018,Op2018 ;@ 2c18
  .long Op2020,Op2020,Op2020,Op2020,Op2020,Op2020,Op2020,Op2020 ;@ 2c20
  .long Op2028,Op2028,Op2028,Op2028,Op2028,Op2028,Op2028,Op2028 ;@ 2c28
  .long Op2030,Op2030,Op2030,Op2030,Op2030,Op2030,Op2030,Op2030 ;@ 2c30
  .long Op2038,Op2039,Op203a,Op203b,Op203c,Op____,Op____,Op____ ;@ 2c38
  .long Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040 ;@ 2c40
  .long Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040 ;@ 2c48
  .long Op2050,Op2050,Op2050,Op2050,Op2050,Op2050,Op2050,Op2050 ;@ 2c50
  .long Op2058,Op2058,Op2058,Op2058,Op2058,Op2058,Op2058,Op2058 ;@ 2c58
  .long Op2060,Op2060,Op2060,Op2060,Op2060,Op2060,Op2060,Op2060 ;@ 2c60
  .long Op2068,Op2068,Op2068,Op2068,Op2068,Op2068,Op2068,Op2068 ;@ 2c68
  .long Op2070,Op2070,Op2070,Op2070,Op2070,Op2070,Op2070,Op2070 ;@ 2c70
  .long Op2078,Op2079,Op207a,Op207b,Op207c,Op____,Op____,Op____ ;@ 2c78
  .long Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080 ;@ 2c80
  .long Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080 ;@ 2c88
  .long Op2090,Op2090,Op2090,Op2090,Op2090,Op2090,Op2090,Op2090 ;@ 2c90
  .long Op2098,Op2098,Op2098,Op2098,Op2098,Op2098,Op2098,Op2098 ;@ 2c98
  .long Op20a0,Op20a0,Op20a0,Op20a0,Op20a0,Op20a0,Op20a0,Op20a0 ;@ 2ca0
  .long Op20a8,Op20a8,Op20a8,Op20a8,Op20a8,Op20a8,Op20a8,Op20a8 ;@ 2ca8
  .long Op20b0,Op20b0,Op20b0,Op20b0,Op20b0,Op20b0,Op20b0,Op20b0 ;@ 2cb0
  .long Op20b8,Op20b9,Op20ba,Op20bb,Op20bc,Op____,Op____,Op____ ;@ 2cb8
  .long Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0 ;@ 2cc0
  .long Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0,Op20c0 ;@ 2cc8
  .long Op20d0,Op20d0,Op20d0,Op20d0,Op20d0,Op20d0,Op20d0,Op20d0 ;@ 2cd0
  .long Op20d8,Op20d8,Op20d8,Op20d8,Op20d8,Op20d8,Op20d8,Op20d8 ;@ 2cd8
  .long Op20e0,Op20e0,Op20e0,Op20e0,Op20e0,Op20e0,Op20e0,Op20e0 ;@ 2ce0
  .long Op20e8,Op20e8,Op20e8,Op20e8,Op20e8,Op20e8,Op20e8,Op20e8 ;@ 2ce8
  .long Op20f0,Op20f0,Op20f0,Op20f0,Op20f0,Op20f0,Op20f0,Op20f0 ;@ 2cf0
  .long Op20f8,Op20f9,Op20fa,Op20fb,Op20fc,Op____,Op____,Op____ ;@ 2cf8
  .long Op2100,Op2100,Op2100,Op2100,Op2100,Op2100,Op2100,Op2100 ;@ 2d00
  .long Op2100,Op2100,Op2100,Op2100,Op2100,Op2100,Op2100,Op2100 ;@ 2d08
  .long Op2110,Op2110,Op2110,Op2110,Op2110,Op2110,Op2110,Op2110 ;@ 2d10
  .long Op2118,Op2118,Op2118,Op2118,Op2118,Op2118,Op2118,Op2118 ;@ 2d18
  .long Op2120,Op2120,Op2120,Op2120,Op2120,Op2120,Op2120,Op2120 ;@ 2d20
  .long Op2128,Op2128,Op2128,Op2128,Op2128,Op2128,Op2128,Op2128 ;@ 2d28
  .long Op2130,Op2130,Op2130,Op2130,Op2130,Op2130,Op2130,Op2130 ;@ 2d30
  .long Op2138,Op2139,Op213a,Op213b,Op213c,Op____,Op____,Op____ ;@ 2d38
  .long Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140 ;@ 2d40
  .long Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140 ;@ 2d48
  .long Op2150,Op2150,Op2150,Op2150,Op2150,Op2150,Op2150,Op2150 ;@ 2d50
  .long Op2158,Op2158,Op2158,Op2158,Op2158,Op2158,Op2158,Op2158 ;@ 2d58
  .long Op2160,Op2160,Op2160,Op2160,Op2160,Op2160,Op2160,Op2160 ;@ 2d60
  .long Op2168,Op2168,Op2168,Op2168,Op2168,Op2168,Op2168,Op2168 ;@ 2d68
  .long Op2170,Op2170,Op2170,Op2170,Op2170,Op2170,Op2170,Op2170 ;@ 2d70
  .long Op2178,Op2179,Op217a,Op217b,Op217c,Op____,Op____,Op____ ;@ 2d78
  .long Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180 ;@ 2d80
  .long Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180 ;@ 2d88
  .long Op2190,Op2190,Op2190,Op2190,Op2190,Op2190,Op2190,Op2190 ;@ 2d90
  .long Op2198,Op2198,Op2198,Op2198,Op2198,Op2198,Op2198,Op2198 ;@ 2d98
  .long Op21a0,Op21a0,Op21a0,Op21a0,Op21a0,Op21a0,Op21a0,Op21a0 ;@ 2da0
  .long Op21a8,Op21a8,Op21a8,Op21a8,Op21a8,Op21a8,Op21a8,Op21a8 ;@ 2da8
  .long Op21b0,Op21b0,Op21b0,Op21b0,Op21b0,Op21b0,Op21b0,Op21b0 ;@ 2db0
  .long Op21b8,Op21b9,Op21ba,Op21bb,Op21bc,Op____,Op____,Op____ ;@ 2db8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 2dc0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 2dc8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 2dd0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 2dd8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 2de0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 2de8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 2df0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 2df8
  .long Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000 ;@ 2e00
  .long Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000,Op2000 ;@ 2e08
  .long Op2010,Op2010,Op2010,Op2010,Op2010,Op2010,Op2010,Op2010 ;@ 2e10
  .long Op2018,Op2018,Op2018,Op2018,Op2018,Op2018,Op2018,Op2018 ;@ 2e18
  .long Op2020,Op2020,Op2020,Op2020,Op2020,Op2020,Op2020,Op2020 ;@ 2e20
  .long Op2028,Op2028,Op2028,Op2028,Op2028,Op2028,Op2028,Op2028 ;@ 2e28
  .long Op2030,Op2030,Op2030,Op2030,Op2030,Op2030,Op2030,Op2030 ;@ 2e30
  .long Op2038,Op2039,Op203a,Op203b,Op203c,Op____,Op____,Op____ ;@ 2e38
  .long Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040 ;@ 2e40
  .long Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040,Op2040 ;@ 2e48
  .long Op2050,Op2050,Op2050,Op2050,Op2050,Op2050,Op2050,Op2050 ;@ 2e50
  .long Op2058,Op2058,Op2058,Op2058,Op2058,Op2058,Op2058,Op2058 ;@ 2e58
  .long Op2060,Op2060,Op2060,Op2060,Op2060,Op2060,Op2060,Op2060 ;@ 2e60
  .long Op2068,Op2068,Op2068,Op2068,Op2068,Op2068,Op2068,Op2068 ;@ 2e68
  .long Op2070,Op2070,Op2070,Op2070,Op2070,Op2070,Op2070,Op2070 ;@ 2e70
  .long Op2078,Op2079,Op207a,Op207b,Op207c,Op____,Op____,Op____ ;@ 2e78
  .long Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080 ;@ 2e80
  .long Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080,Op2080 ;@ 2e88
  .long Op2090,Op2090,Op2090,Op2090,Op2090,Op2090,Op2090,Op2090 ;@ 2e90
  .long Op2098,Op2098,Op2098,Op2098,Op2098,Op2098,Op2098,Op2098 ;@ 2e98
  .long Op20a0,Op20a0,Op20a0,Op20a0,Op20a0,Op20a0,Op20a0,Op20a0 ;@ 2ea0
  .long Op20a8,Op20a8,Op20a8,Op20a8,Op20a8,Op20a8,Op20a8,Op20a8 ;@ 2ea8
  .long Op20b0,Op20b0,Op20b0,Op20b0,Op20b0,Op20b0,Op20b0,Op20b0 ;@ 2eb0
  .long Op20b8,Op20b9,Op20ba,Op20bb,Op20bc,Op____,Op____,Op____ ;@ 2eb8
  .long Op2ec0,Op2ec0,Op2ec0,Op2ec0,Op2ec0,Op2ec0,Op2ec0,Op2ec0 ;@ 2ec0
  .long Op2ec0,Op2ec0,Op2ec0,Op2ec0,Op2ec0,Op2ec0,Op2ec0,Op2ec0 ;@ 2ec8
  .long Op2ed0,Op2ed0,Op2ed0,Op2ed0,Op2ed0,Op2ed0,Op2ed0,Op2ed0 ;@ 2ed0
  .long Op2ed8,Op2ed8,Op2ed8,Op2ed8,Op2ed8,Op2ed8,Op2ed8,Op2ed8 ;@ 2ed8
  .long Op2ee0,Op2ee0,Op2ee0,Op2ee0,Op2ee0,Op2ee0,Op2ee0,Op2ee0 ;@ 2ee0
  .long Op2ee8,Op2ee8,Op2ee8,Op2ee8,Op2ee8,Op2ee8,Op2ee8,Op2ee8 ;@ 2ee8
  .long Op2ef0,Op2ef0,Op2ef0,Op2ef0,Op2ef0,Op2ef0,Op2ef0,Op2ef0 ;@ 2ef0
  .long Op2ef8,Op2ef9,Op2efa,Op2efb,Op2efc,Op____,Op____,Op____ ;@ 2ef8
  .long Op2f00,Op2f00,Op2f00,Op2f00,Op2f00,Op2f00,Op2f00,Op2f00 ;@ 2f00
  .long Op2f00,Op2f00,Op2f00,Op2f00,Op2f00,Op2f00,Op2f00,Op2f00 ;@ 2f08
  .long Op2f10,Op2f10,Op2f10,Op2f10,Op2f10,Op2f10,Op2f10,Op2f10 ;@ 2f10
  .long Op2f18,Op2f18,Op2f18,Op2f18,Op2f18,Op2f18,Op2f18,Op2f18 ;@ 2f18
  .long Op2f20,Op2f20,Op2f20,Op2f20,Op2f20,Op2f20,Op2f20,Op2f20 ;@ 2f20
  .long Op2f28,Op2f28,Op2f28,Op2f28,Op2f28,Op2f28,Op2f28,Op2f28 ;@ 2f28
  .long Op2f30,Op2f30,Op2f30,Op2f30,Op2f30,Op2f30,Op2f30,Op2f30 ;@ 2f30
  .long Op2f38,Op2f39,Op2f3a,Op2f3b,Op2f3c,Op____,Op____,Op____ ;@ 2f38
  .long Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140 ;@ 2f40
  .long Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140,Op2140 ;@ 2f48
  .long Op2150,Op2150,Op2150,Op2150,Op2150,Op2150,Op2150,Op2150 ;@ 2f50
  .long Op2158,Op2158,Op2158,Op2158,Op2158,Op2158,Op2158,Op2158 ;@ 2f58
  .long Op2160,Op2160,Op2160,Op2160,Op2160,Op2160,Op2160,Op2160 ;@ 2f60
  .long Op2168,Op2168,Op2168,Op2168,Op2168,Op2168,Op2168,Op2168 ;@ 2f68
  .long Op2170,Op2170,Op2170,Op2170,Op2170,Op2170,Op2170,Op2170 ;@ 2f70
  .long Op2178,Op2179,Op217a,Op217b,Op217c,Op____,Op____,Op____ ;@ 2f78
  .long Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180 ;@ 2f80
  .long Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180,Op2180 ;@ 2f88
  .long Op2190,Op2190,Op2190,Op2190,Op2190,Op2190,Op2190,Op2190 ;@ 2f90
  .long Op2198,Op2198,Op2198,Op2198,Op2198,Op2198,Op2198,Op2198 ;@ 2f98
  .long Op21a0,Op21a0,Op21a0,Op21a0,Op21a0,Op21a0,Op21a0,Op21a0 ;@ 2fa0
  .long Op21a8,Op21a8,Op21a8,Op21a8,Op21a8,Op21a8,Op21a8,Op21a8 ;@ 2fa8
  .long Op21b0,Op21b0,Op21b0,Op21b0,Op21b0,Op21b0,Op21b0,Op21b0 ;@ 2fb0
  .long Op21b8,Op21b9,Op21ba,Op21bb,Op21bc,Op____,Op____,Op____ ;@ 2fb8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 2fc0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 2fc8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 2fd0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 2fd8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 2fe0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 2fe8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 2ff0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 2ff8
  .long Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000 ;@ 3000
  .long Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000 ;@ 3008
  .long Op3010,Op3010,Op3010,Op3010,Op3010,Op3010,Op3010,Op3010 ;@ 3010
  .long Op3018,Op3018,Op3018,Op3018,Op3018,Op3018,Op3018,Op3018 ;@ 3018
  .long Op3020,Op3020,Op3020,Op3020,Op3020,Op3020,Op3020,Op3020 ;@ 3020
  .long Op3028,Op3028,Op3028,Op3028,Op3028,Op3028,Op3028,Op3028 ;@ 3028
  .long Op3030,Op3030,Op3030,Op3030,Op3030,Op3030,Op3030,Op3030 ;@ 3030
  .long Op3038,Op3039,Op303a,Op303b,Op303c,Op____,Op____,Op____ ;@ 3038
  .long Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040 ;@ 3040
  .long Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040 ;@ 3048
  .long Op3050,Op3050,Op3050,Op3050,Op3050,Op3050,Op3050,Op3050 ;@ 3050
  .long Op3058,Op3058,Op3058,Op3058,Op3058,Op3058,Op3058,Op3058 ;@ 3058
  .long Op3060,Op3060,Op3060,Op3060,Op3060,Op3060,Op3060,Op3060 ;@ 3060
  .long Op3068,Op3068,Op3068,Op3068,Op3068,Op3068,Op3068,Op3068 ;@ 3068
  .long Op3070,Op3070,Op3070,Op3070,Op3070,Op3070,Op3070,Op3070 ;@ 3070
  .long Op3078,Op3079,Op307a,Op307b,Op307c,Op____,Op____,Op____ ;@ 3078
  .long Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080 ;@ 3080
  .long Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080 ;@ 3088
  .long Op3090,Op3090,Op3090,Op3090,Op3090,Op3090,Op3090,Op3090 ;@ 3090
  .long Op3098,Op3098,Op3098,Op3098,Op3098,Op3098,Op3098,Op3098 ;@ 3098
  .long Op30a0,Op30a0,Op30a0,Op30a0,Op30a0,Op30a0,Op30a0,Op30a0 ;@ 30a0
  .long Op30a8,Op30a8,Op30a8,Op30a8,Op30a8,Op30a8,Op30a8,Op30a8 ;@ 30a8
  .long Op30b0,Op30b0,Op30b0,Op30b0,Op30b0,Op30b0,Op30b0,Op30b0 ;@ 30b0
  .long Op30b8,Op30b9,Op30ba,Op30bb,Op30bc,Op____,Op____,Op____ ;@ 30b8
  .long Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0 ;@ 30c0
  .long Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0 ;@ 30c8
  .long Op30d0,Op30d0,Op30d0,Op30d0,Op30d0,Op30d0,Op30d0,Op30d0 ;@ 30d0
  .long Op30d8,Op30d8,Op30d8,Op30d8,Op30d8,Op30d8,Op30d8,Op30d8 ;@ 30d8
  .long Op30e0,Op30e0,Op30e0,Op30e0,Op30e0,Op30e0,Op30e0,Op30e0 ;@ 30e0
  .long Op30e8,Op30e8,Op30e8,Op30e8,Op30e8,Op30e8,Op30e8,Op30e8 ;@ 30e8
  .long Op30f0,Op30f0,Op30f0,Op30f0,Op30f0,Op30f0,Op30f0,Op30f0 ;@ 30f0
  .long Op30f8,Op30f9,Op30fa,Op30fb,Op30fc,Op____,Op____,Op____ ;@ 30f8
  .long Op3100,Op3100,Op3100,Op3100,Op3100,Op3100,Op3100,Op3100 ;@ 3100
  .long Op3100,Op3100,Op3100,Op3100,Op3100,Op3100,Op3100,Op3100 ;@ 3108
  .long Op3110,Op3110,Op3110,Op3110,Op3110,Op3110,Op3110,Op3110 ;@ 3110
  .long Op3118,Op3118,Op3118,Op3118,Op3118,Op3118,Op3118,Op3118 ;@ 3118
  .long Op3120,Op3120,Op3120,Op3120,Op3120,Op3120,Op3120,Op3120 ;@ 3120
  .long Op3128,Op3128,Op3128,Op3128,Op3128,Op3128,Op3128,Op3128 ;@ 3128
  .long Op3130,Op3130,Op3130,Op3130,Op3130,Op3130,Op3130,Op3130 ;@ 3130
  .long Op3138,Op3139,Op313a,Op313b,Op313c,Op____,Op____,Op____ ;@ 3138
  .long Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140 ;@ 3140
  .long Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140 ;@ 3148
  .long Op3150,Op3150,Op3150,Op3150,Op3150,Op3150,Op3150,Op3150 ;@ 3150
  .long Op3158,Op3158,Op3158,Op3158,Op3158,Op3158,Op3158,Op3158 ;@ 3158
  .long Op3160,Op3160,Op3160,Op3160,Op3160,Op3160,Op3160,Op3160 ;@ 3160
  .long Op3168,Op3168,Op3168,Op3168,Op3168,Op3168,Op3168,Op3168 ;@ 3168
  .long Op3170,Op3170,Op3170,Op3170,Op3170,Op3170,Op3170,Op3170 ;@ 3170
  .long Op3178,Op3179,Op317a,Op317b,Op317c,Op____,Op____,Op____ ;@ 3178
  .long Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180 ;@ 3180
  .long Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180 ;@ 3188
  .long Op3190,Op3190,Op3190,Op3190,Op3190,Op3190,Op3190,Op3190 ;@ 3190
  .long Op3198,Op3198,Op3198,Op3198,Op3198,Op3198,Op3198,Op3198 ;@ 3198
  .long Op31a0,Op31a0,Op31a0,Op31a0,Op31a0,Op31a0,Op31a0,Op31a0 ;@ 31a0
  .long Op31a8,Op31a8,Op31a8,Op31a8,Op31a8,Op31a8,Op31a8,Op31a8 ;@ 31a8
  .long Op31b0,Op31b0,Op31b0,Op31b0,Op31b0,Op31b0,Op31b0,Op31b0 ;@ 31b0
  .long Op31b8,Op31b9,Op31ba,Op31bb,Op31bc,Op____,Op____,Op____ ;@ 31b8
  .long Op31c0,Op31c0,Op31c0,Op31c0,Op31c0,Op31c0,Op31c0,Op31c0 ;@ 31c0
  .long Op31c0,Op31c0,Op31c0,Op31c0,Op31c0,Op31c0,Op31c0,Op31c0 ;@ 31c8
  .long Op31d0,Op31d0,Op31d0,Op31d0,Op31d0,Op31d0,Op31d0,Op31d0 ;@ 31d0
  .long Op31d8,Op31d8,Op31d8,Op31d8,Op31d8,Op31d8,Op31d8,Op31d8 ;@ 31d8
  .long Op31e0,Op31e0,Op31e0,Op31e0,Op31e0,Op31e0,Op31e0,Op31e0 ;@ 31e0
  .long Op31e8,Op31e8,Op31e8,Op31e8,Op31e8,Op31e8,Op31e8,Op31e8 ;@ 31e8
  .long Op31f0,Op31f0,Op31f0,Op31f0,Op31f0,Op31f0,Op31f0,Op31f0 ;@ 31f0
  .long Op31f8,Op31f9,Op31fa,Op31fb,Op31fc,Op____,Op____,Op____ ;@ 31f8
  .long Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000 ;@ 3200
  .long Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000 ;@ 3208
  .long Op3010,Op3010,Op3010,Op3010,Op3010,Op3010,Op3010,Op3010 ;@ 3210
  .long Op3018,Op3018,Op3018,Op3018,Op3018,Op3018,Op3018,Op3018 ;@ 3218
  .long Op3020,Op3020,Op3020,Op3020,Op3020,Op3020,Op3020,Op3020 ;@ 3220
  .long Op3028,Op3028,Op3028,Op3028,Op3028,Op3028,Op3028,Op3028 ;@ 3228
  .long Op3030,Op3030,Op3030,Op3030,Op3030,Op3030,Op3030,Op3030 ;@ 3230
  .long Op3038,Op3039,Op303a,Op303b,Op303c,Op____,Op____,Op____ ;@ 3238
  .long Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040 ;@ 3240
  .long Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040 ;@ 3248
  .long Op3050,Op3050,Op3050,Op3050,Op3050,Op3050,Op3050,Op3050 ;@ 3250
  .long Op3058,Op3058,Op3058,Op3058,Op3058,Op3058,Op3058,Op3058 ;@ 3258
  .long Op3060,Op3060,Op3060,Op3060,Op3060,Op3060,Op3060,Op3060 ;@ 3260
  .long Op3068,Op3068,Op3068,Op3068,Op3068,Op3068,Op3068,Op3068 ;@ 3268
  .long Op3070,Op3070,Op3070,Op3070,Op3070,Op3070,Op3070,Op3070 ;@ 3270
  .long Op3078,Op3079,Op307a,Op307b,Op307c,Op____,Op____,Op____ ;@ 3278
  .long Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080 ;@ 3280
  .long Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080 ;@ 3288
  .long Op3090,Op3090,Op3090,Op3090,Op3090,Op3090,Op3090,Op3090 ;@ 3290
  .long Op3098,Op3098,Op3098,Op3098,Op3098,Op3098,Op3098,Op3098 ;@ 3298
  .long Op30a0,Op30a0,Op30a0,Op30a0,Op30a0,Op30a0,Op30a0,Op30a0 ;@ 32a0
  .long Op30a8,Op30a8,Op30a8,Op30a8,Op30a8,Op30a8,Op30a8,Op30a8 ;@ 32a8
  .long Op30b0,Op30b0,Op30b0,Op30b0,Op30b0,Op30b0,Op30b0,Op30b0 ;@ 32b0
  .long Op30b8,Op30b9,Op30ba,Op30bb,Op30bc,Op____,Op____,Op____ ;@ 32b8
  .long Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0 ;@ 32c0
  .long Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0 ;@ 32c8
  .long Op30d0,Op30d0,Op30d0,Op30d0,Op30d0,Op30d0,Op30d0,Op30d0 ;@ 32d0
  .long Op30d8,Op30d8,Op30d8,Op30d8,Op30d8,Op30d8,Op30d8,Op30d8 ;@ 32d8
  .long Op30e0,Op30e0,Op30e0,Op30e0,Op30e0,Op30e0,Op30e0,Op30e0 ;@ 32e0
  .long Op30e8,Op30e8,Op30e8,Op30e8,Op30e8,Op30e8,Op30e8,Op30e8 ;@ 32e8
  .long Op30f0,Op30f0,Op30f0,Op30f0,Op30f0,Op30f0,Op30f0,Op30f0 ;@ 32f0
  .long Op30f8,Op30f9,Op30fa,Op30fb,Op30fc,Op____,Op____,Op____ ;@ 32f8
  .long Op3100,Op3100,Op3100,Op3100,Op3100,Op3100,Op3100,Op3100 ;@ 3300
  .long Op3100,Op3100,Op3100,Op3100,Op3100,Op3100,Op3100,Op3100 ;@ 3308
  .long Op3110,Op3110,Op3110,Op3110,Op3110,Op3110,Op3110,Op3110 ;@ 3310
  .long Op3118,Op3118,Op3118,Op3118,Op3118,Op3118,Op3118,Op3118 ;@ 3318
  .long Op3120,Op3120,Op3120,Op3120,Op3120,Op3120,Op3120,Op3120 ;@ 3320
  .long Op3128,Op3128,Op3128,Op3128,Op3128,Op3128,Op3128,Op3128 ;@ 3328
  .long Op3130,Op3130,Op3130,Op3130,Op3130,Op3130,Op3130,Op3130 ;@ 3330
  .long Op3138,Op3139,Op313a,Op313b,Op313c,Op____,Op____,Op____ ;@ 3338
  .long Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140 ;@ 3340
  .long Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140 ;@ 3348
  .long Op3150,Op3150,Op3150,Op3150,Op3150,Op3150,Op3150,Op3150 ;@ 3350
  .long Op3158,Op3158,Op3158,Op3158,Op3158,Op3158,Op3158,Op3158 ;@ 3358
  .long Op3160,Op3160,Op3160,Op3160,Op3160,Op3160,Op3160,Op3160 ;@ 3360
  .long Op3168,Op3168,Op3168,Op3168,Op3168,Op3168,Op3168,Op3168 ;@ 3368
  .long Op3170,Op3170,Op3170,Op3170,Op3170,Op3170,Op3170,Op3170 ;@ 3370
  .long Op3178,Op3179,Op317a,Op317b,Op317c,Op____,Op____,Op____ ;@ 3378
  .long Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180 ;@ 3380
  .long Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180 ;@ 3388
  .long Op3190,Op3190,Op3190,Op3190,Op3190,Op3190,Op3190,Op3190 ;@ 3390
  .long Op3198,Op3198,Op3198,Op3198,Op3198,Op3198,Op3198,Op3198 ;@ 3398
  .long Op31a0,Op31a0,Op31a0,Op31a0,Op31a0,Op31a0,Op31a0,Op31a0 ;@ 33a0
  .long Op31a8,Op31a8,Op31a8,Op31a8,Op31a8,Op31a8,Op31a8,Op31a8 ;@ 33a8
  .long Op31b0,Op31b0,Op31b0,Op31b0,Op31b0,Op31b0,Op31b0,Op31b0 ;@ 33b0
  .long Op31b8,Op31b9,Op31ba,Op31bb,Op31bc,Op____,Op____,Op____ ;@ 33b8
  .long Op33c0,Op33c0,Op33c0,Op33c0,Op33c0,Op33c0,Op33c0,Op33c0 ;@ 33c0
  .long Op33c0,Op33c0,Op33c0,Op33c0,Op33c0,Op33c0,Op33c0,Op33c0 ;@ 33c8
  .long Op33d0,Op33d0,Op33d0,Op33d0,Op33d0,Op33d0,Op33d0,Op33d0 ;@ 33d0
  .long Op33d8,Op33d8,Op33d8,Op33d8,Op33d8,Op33d8,Op33d8,Op33d8 ;@ 33d8
  .long Op33e0,Op33e0,Op33e0,Op33e0,Op33e0,Op33e0,Op33e0,Op33e0 ;@ 33e0
  .long Op33e8,Op33e8,Op33e8,Op33e8,Op33e8,Op33e8,Op33e8,Op33e8 ;@ 33e8
  .long Op33f0,Op33f0,Op33f0,Op33f0,Op33f0,Op33f0,Op33f0,Op33f0 ;@ 33f0
  .long Op33f8,Op33f9,Op33fa,Op33fb,Op33fc,Op____,Op____,Op____ ;@ 33f8
  .long Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000 ;@ 3400
  .long Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000 ;@ 3408
  .long Op3010,Op3010,Op3010,Op3010,Op3010,Op3010,Op3010,Op3010 ;@ 3410
  .long Op3018,Op3018,Op3018,Op3018,Op3018,Op3018,Op3018,Op3018 ;@ 3418
  .long Op3020,Op3020,Op3020,Op3020,Op3020,Op3020,Op3020,Op3020 ;@ 3420
  .long Op3028,Op3028,Op3028,Op3028,Op3028,Op3028,Op3028,Op3028 ;@ 3428
  .long Op3030,Op3030,Op3030,Op3030,Op3030,Op3030,Op3030,Op3030 ;@ 3430
  .long Op3038,Op3039,Op303a,Op303b,Op303c,Op____,Op____,Op____ ;@ 3438
  .long Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040 ;@ 3440
  .long Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040 ;@ 3448
  .long Op3050,Op3050,Op3050,Op3050,Op3050,Op3050,Op3050,Op3050 ;@ 3450
  .long Op3058,Op3058,Op3058,Op3058,Op3058,Op3058,Op3058,Op3058 ;@ 3458
  .long Op3060,Op3060,Op3060,Op3060,Op3060,Op3060,Op3060,Op3060 ;@ 3460
  .long Op3068,Op3068,Op3068,Op3068,Op3068,Op3068,Op3068,Op3068 ;@ 3468
  .long Op3070,Op3070,Op3070,Op3070,Op3070,Op3070,Op3070,Op3070 ;@ 3470
  .long Op3078,Op3079,Op307a,Op307b,Op307c,Op____,Op____,Op____ ;@ 3478
  .long Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080 ;@ 3480
  .long Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080 ;@ 3488
  .long Op3090,Op3090,Op3090,Op3090,Op3090,Op3090,Op3090,Op3090 ;@ 3490
  .long Op3098,Op3098,Op3098,Op3098,Op3098,Op3098,Op3098,Op3098 ;@ 3498
  .long Op30a0,Op30a0,Op30a0,Op30a0,Op30a0,Op30a0,Op30a0,Op30a0 ;@ 34a0
  .long Op30a8,Op30a8,Op30a8,Op30a8,Op30a8,Op30a8,Op30a8,Op30a8 ;@ 34a8
  .long Op30b0,Op30b0,Op30b0,Op30b0,Op30b0,Op30b0,Op30b0,Op30b0 ;@ 34b0
  .long Op30b8,Op30b9,Op30ba,Op30bb,Op30bc,Op____,Op____,Op____ ;@ 34b8
  .long Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0 ;@ 34c0
  .long Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0 ;@ 34c8
  .long Op30d0,Op30d0,Op30d0,Op30d0,Op30d0,Op30d0,Op30d0,Op30d0 ;@ 34d0
  .long Op30d8,Op30d8,Op30d8,Op30d8,Op30d8,Op30d8,Op30d8,Op30d8 ;@ 34d8
  .long Op30e0,Op30e0,Op30e0,Op30e0,Op30e0,Op30e0,Op30e0,Op30e0 ;@ 34e0
  .long Op30e8,Op30e8,Op30e8,Op30e8,Op30e8,Op30e8,Op30e8,Op30e8 ;@ 34e8
  .long Op30f0,Op30f0,Op30f0,Op30f0,Op30f0,Op30f0,Op30f0,Op30f0 ;@ 34f0
  .long Op30f8,Op30f9,Op30fa,Op30fb,Op30fc,Op____,Op____,Op____ ;@ 34f8
  .long Op3100,Op3100,Op3100,Op3100,Op3100,Op3100,Op3100,Op3100 ;@ 3500
  .long Op3100,Op3100,Op3100,Op3100,Op3100,Op3100,Op3100,Op3100 ;@ 3508
  .long Op3110,Op3110,Op3110,Op3110,Op3110,Op3110,Op3110,Op3110 ;@ 3510
  .long Op3118,Op3118,Op3118,Op3118,Op3118,Op3118,Op3118,Op3118 ;@ 3518
  .long Op3120,Op3120,Op3120,Op3120,Op3120,Op3120,Op3120,Op3120 ;@ 3520
  .long Op3128,Op3128,Op3128,Op3128,Op3128,Op3128,Op3128,Op3128 ;@ 3528
  .long Op3130,Op3130,Op3130,Op3130,Op3130,Op3130,Op3130,Op3130 ;@ 3530
  .long Op3138,Op3139,Op313a,Op313b,Op313c,Op____,Op____,Op____ ;@ 3538
  .long Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140 ;@ 3540
  .long Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140 ;@ 3548
  .long Op3150,Op3150,Op3150,Op3150,Op3150,Op3150,Op3150,Op3150 ;@ 3550
  .long Op3158,Op3158,Op3158,Op3158,Op3158,Op3158,Op3158,Op3158 ;@ 3558
  .long Op3160,Op3160,Op3160,Op3160,Op3160,Op3160,Op3160,Op3160 ;@ 3560
  .long Op3168,Op3168,Op3168,Op3168,Op3168,Op3168,Op3168,Op3168 ;@ 3568
  .long Op3170,Op3170,Op3170,Op3170,Op3170,Op3170,Op3170,Op3170 ;@ 3570
  .long Op3178,Op3179,Op317a,Op317b,Op317c,Op____,Op____,Op____ ;@ 3578
  .long Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180 ;@ 3580
  .long Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180 ;@ 3588
  .long Op3190,Op3190,Op3190,Op3190,Op3190,Op3190,Op3190,Op3190 ;@ 3590
  .long Op3198,Op3198,Op3198,Op3198,Op3198,Op3198,Op3198,Op3198 ;@ 3598
  .long Op31a0,Op31a0,Op31a0,Op31a0,Op31a0,Op31a0,Op31a0,Op31a0 ;@ 35a0
  .long Op31a8,Op31a8,Op31a8,Op31a8,Op31a8,Op31a8,Op31a8,Op31a8 ;@ 35a8
  .long Op31b0,Op31b0,Op31b0,Op31b0,Op31b0,Op31b0,Op31b0,Op31b0 ;@ 35b0
  .long Op31b8,Op31b9,Op31ba,Op31bb,Op31bc,Op____,Op____,Op____ ;@ 35b8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 35c0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 35c8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 35d0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 35d8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 35e0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 35e8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 35f0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 35f8
  .long Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000 ;@ 3600
  .long Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000 ;@ 3608
  .long Op3010,Op3010,Op3010,Op3010,Op3010,Op3010,Op3010,Op3010 ;@ 3610
  .long Op3018,Op3018,Op3018,Op3018,Op3018,Op3018,Op3018,Op3018 ;@ 3618
  .long Op3020,Op3020,Op3020,Op3020,Op3020,Op3020,Op3020,Op3020 ;@ 3620
  .long Op3028,Op3028,Op3028,Op3028,Op3028,Op3028,Op3028,Op3028 ;@ 3628
  .long Op3030,Op3030,Op3030,Op3030,Op3030,Op3030,Op3030,Op3030 ;@ 3630
  .long Op3038,Op3039,Op303a,Op303b,Op303c,Op____,Op____,Op____ ;@ 3638
  .long Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040 ;@ 3640
  .long Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040 ;@ 3648
  .long Op3050,Op3050,Op3050,Op3050,Op3050,Op3050,Op3050,Op3050 ;@ 3650
  .long Op3058,Op3058,Op3058,Op3058,Op3058,Op3058,Op3058,Op3058 ;@ 3658
  .long Op3060,Op3060,Op3060,Op3060,Op3060,Op3060,Op3060,Op3060 ;@ 3660
  .long Op3068,Op3068,Op3068,Op3068,Op3068,Op3068,Op3068,Op3068 ;@ 3668
  .long Op3070,Op3070,Op3070,Op3070,Op3070,Op3070,Op3070,Op3070 ;@ 3670
  .long Op3078,Op3079,Op307a,Op307b,Op307c,Op____,Op____,Op____ ;@ 3678
  .long Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080 ;@ 3680
  .long Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080 ;@ 3688
  .long Op3090,Op3090,Op3090,Op3090,Op3090,Op3090,Op3090,Op3090 ;@ 3690
  .long Op3098,Op3098,Op3098,Op3098,Op3098,Op3098,Op3098,Op3098 ;@ 3698
  .long Op30a0,Op30a0,Op30a0,Op30a0,Op30a0,Op30a0,Op30a0,Op30a0 ;@ 36a0
  .long Op30a8,Op30a8,Op30a8,Op30a8,Op30a8,Op30a8,Op30a8,Op30a8 ;@ 36a8
  .long Op30b0,Op30b0,Op30b0,Op30b0,Op30b0,Op30b0,Op30b0,Op30b0 ;@ 36b0
  .long Op30b8,Op30b9,Op30ba,Op30bb,Op30bc,Op____,Op____,Op____ ;@ 36b8
  .long Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0 ;@ 36c0
  .long Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0 ;@ 36c8
  .long Op30d0,Op30d0,Op30d0,Op30d0,Op30d0,Op30d0,Op30d0,Op30d0 ;@ 36d0
  .long Op30d8,Op30d8,Op30d8,Op30d8,Op30d8,Op30d8,Op30d8,Op30d8 ;@ 36d8
  .long Op30e0,Op30e0,Op30e0,Op30e0,Op30e0,Op30e0,Op30e0,Op30e0 ;@ 36e0
  .long Op30e8,Op30e8,Op30e8,Op30e8,Op30e8,Op30e8,Op30e8,Op30e8 ;@ 36e8
  .long Op30f0,Op30f0,Op30f0,Op30f0,Op30f0,Op30f0,Op30f0,Op30f0 ;@ 36f0
  .long Op30f8,Op30f9,Op30fa,Op30fb,Op30fc,Op____,Op____,Op____ ;@ 36f8
  .long Op3100,Op3100,Op3100,Op3100,Op3100,Op3100,Op3100,Op3100 ;@ 3700
  .long Op3100,Op3100,Op3100,Op3100,Op3100,Op3100,Op3100,Op3100 ;@ 3708
  .long Op3110,Op3110,Op3110,Op3110,Op3110,Op3110,Op3110,Op3110 ;@ 3710
  .long Op3118,Op3118,Op3118,Op3118,Op3118,Op3118,Op3118,Op3118 ;@ 3718
  .long Op3120,Op3120,Op3120,Op3120,Op3120,Op3120,Op3120,Op3120 ;@ 3720
  .long Op3128,Op3128,Op3128,Op3128,Op3128,Op3128,Op3128,Op3128 ;@ 3728
  .long Op3130,Op3130,Op3130,Op3130,Op3130,Op3130,Op3130,Op3130 ;@ 3730
  .long Op3138,Op3139,Op313a,Op313b,Op313c,Op____,Op____,Op____ ;@ 3738
  .long Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140 ;@ 3740
  .long Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140 ;@ 3748
  .long Op3150,Op3150,Op3150,Op3150,Op3150,Op3150,Op3150,Op3150 ;@ 3750
  .long Op3158,Op3158,Op3158,Op3158,Op3158,Op3158,Op3158,Op3158 ;@ 3758
  .long Op3160,Op3160,Op3160,Op3160,Op3160,Op3160,Op3160,Op3160 ;@ 3760
  .long Op3168,Op3168,Op3168,Op3168,Op3168,Op3168,Op3168,Op3168 ;@ 3768
  .long Op3170,Op3170,Op3170,Op3170,Op3170,Op3170,Op3170,Op3170 ;@ 3770
  .long Op3178,Op3179,Op317a,Op317b,Op317c,Op____,Op____,Op____ ;@ 3778
  .long Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180 ;@ 3780
  .long Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180 ;@ 3788
  .long Op3190,Op3190,Op3190,Op3190,Op3190,Op3190,Op3190,Op3190 ;@ 3790
  .long Op3198,Op3198,Op3198,Op3198,Op3198,Op3198,Op3198,Op3198 ;@ 3798
  .long Op31a0,Op31a0,Op31a0,Op31a0,Op31a0,Op31a0,Op31a0,Op31a0 ;@ 37a0
  .long Op31a8,Op31a8,Op31a8,Op31a8,Op31a8,Op31a8,Op31a8,Op31a8 ;@ 37a8
  .long Op31b0,Op31b0,Op31b0,Op31b0,Op31b0,Op31b0,Op31b0,Op31b0 ;@ 37b0
  .long Op31b8,Op31b9,Op31ba,Op31bb,Op31bc,Op____,Op____,Op____ ;@ 37b8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 37c0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 37c8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 37d0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 37d8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 37e0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 37e8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 37f0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 37f8
  .long Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000 ;@ 3800
  .long Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000 ;@ 3808
  .long Op3010,Op3010,Op3010,Op3010,Op3010,Op3010,Op3010,Op3010 ;@ 3810
  .long Op3018,Op3018,Op3018,Op3018,Op3018,Op3018,Op3018,Op3018 ;@ 3818
  .long Op3020,Op3020,Op3020,Op3020,Op3020,Op3020,Op3020,Op3020 ;@ 3820
  .long Op3028,Op3028,Op3028,Op3028,Op3028,Op3028,Op3028,Op3028 ;@ 3828
  .long Op3030,Op3030,Op3030,Op3030,Op3030,Op3030,Op3030,Op3030 ;@ 3830
  .long Op3038,Op3039,Op303a,Op303b,Op303c,Op____,Op____,Op____ ;@ 3838
  .long Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040 ;@ 3840
  .long Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040 ;@ 3848
  .long Op3050,Op3050,Op3050,Op3050,Op3050,Op3050,Op3050,Op3050 ;@ 3850
  .long Op3058,Op3058,Op3058,Op3058,Op3058,Op3058,Op3058,Op3058 ;@ 3858
  .long Op3060,Op3060,Op3060,Op3060,Op3060,Op3060,Op3060,Op3060 ;@ 3860
  .long Op3068,Op3068,Op3068,Op3068,Op3068,Op3068,Op3068,Op3068 ;@ 3868
  .long Op3070,Op3070,Op3070,Op3070,Op3070,Op3070,Op3070,Op3070 ;@ 3870
  .long Op3078,Op3079,Op307a,Op307b,Op307c,Op____,Op____,Op____ ;@ 3878
  .long Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080 ;@ 3880
  .long Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080 ;@ 3888
  .long Op3090,Op3090,Op3090,Op3090,Op3090,Op3090,Op3090,Op3090 ;@ 3890
  .long Op3098,Op3098,Op3098,Op3098,Op3098,Op3098,Op3098,Op3098 ;@ 3898
  .long Op30a0,Op30a0,Op30a0,Op30a0,Op30a0,Op30a0,Op30a0,Op30a0 ;@ 38a0
  .long Op30a8,Op30a8,Op30a8,Op30a8,Op30a8,Op30a8,Op30a8,Op30a8 ;@ 38a8
  .long Op30b0,Op30b0,Op30b0,Op30b0,Op30b0,Op30b0,Op30b0,Op30b0 ;@ 38b0
  .long Op30b8,Op30b9,Op30ba,Op30bb,Op30bc,Op____,Op____,Op____ ;@ 38b8
  .long Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0 ;@ 38c0
  .long Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0 ;@ 38c8
  .long Op30d0,Op30d0,Op30d0,Op30d0,Op30d0,Op30d0,Op30d0,Op30d0 ;@ 38d0
  .long Op30d8,Op30d8,Op30d8,Op30d8,Op30d8,Op30d8,Op30d8,Op30d8 ;@ 38d8
  .long Op30e0,Op30e0,Op30e0,Op30e0,Op30e0,Op30e0,Op30e0,Op30e0 ;@ 38e0
  .long Op30e8,Op30e8,Op30e8,Op30e8,Op30e8,Op30e8,Op30e8,Op30e8 ;@ 38e8
  .long Op30f0,Op30f0,Op30f0,Op30f0,Op30f0,Op30f0,Op30f0,Op30f0 ;@ 38f0
  .long Op30f8,Op30f9,Op30fa,Op30fb,Op30fc,Op____,Op____,Op____ ;@ 38f8
  .long Op3100,Op3100,Op3100,Op3100,Op3100,Op3100,Op3100,Op3100 ;@ 3900
  .long Op3100,Op3100,Op3100,Op3100,Op3100,Op3100,Op3100,Op3100 ;@ 3908
  .long Op3110,Op3110,Op3110,Op3110,Op3110,Op3110,Op3110,Op3110 ;@ 3910
  .long Op3118,Op3118,Op3118,Op3118,Op3118,Op3118,Op3118,Op3118 ;@ 3918
  .long Op3120,Op3120,Op3120,Op3120,Op3120,Op3120,Op3120,Op3120 ;@ 3920
  .long Op3128,Op3128,Op3128,Op3128,Op3128,Op3128,Op3128,Op3128 ;@ 3928
  .long Op3130,Op3130,Op3130,Op3130,Op3130,Op3130,Op3130,Op3130 ;@ 3930
  .long Op3138,Op3139,Op313a,Op313b,Op313c,Op____,Op____,Op____ ;@ 3938
  .long Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140 ;@ 3940
  .long Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140 ;@ 3948
  .long Op3150,Op3150,Op3150,Op3150,Op3150,Op3150,Op3150,Op3150 ;@ 3950
  .long Op3158,Op3158,Op3158,Op3158,Op3158,Op3158,Op3158,Op3158 ;@ 3958
  .long Op3160,Op3160,Op3160,Op3160,Op3160,Op3160,Op3160,Op3160 ;@ 3960
  .long Op3168,Op3168,Op3168,Op3168,Op3168,Op3168,Op3168,Op3168 ;@ 3968
  .long Op3170,Op3170,Op3170,Op3170,Op3170,Op3170,Op3170,Op3170 ;@ 3970
  .long Op3178,Op3179,Op317a,Op317b,Op317c,Op____,Op____,Op____ ;@ 3978
  .long Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180 ;@ 3980
  .long Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180 ;@ 3988
  .long Op3190,Op3190,Op3190,Op3190,Op3190,Op3190,Op3190,Op3190 ;@ 3990
  .long Op3198,Op3198,Op3198,Op3198,Op3198,Op3198,Op3198,Op3198 ;@ 3998
  .long Op31a0,Op31a0,Op31a0,Op31a0,Op31a0,Op31a0,Op31a0,Op31a0 ;@ 39a0
  .long Op31a8,Op31a8,Op31a8,Op31a8,Op31a8,Op31a8,Op31a8,Op31a8 ;@ 39a8
  .long Op31b0,Op31b0,Op31b0,Op31b0,Op31b0,Op31b0,Op31b0,Op31b0 ;@ 39b0
  .long Op31b8,Op31b9,Op31ba,Op31bb,Op31bc,Op____,Op____,Op____ ;@ 39b8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 39c0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 39c8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 39d0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 39d8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 39e0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 39e8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 39f0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 39f8
  .long Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000 ;@ 3a00
  .long Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000 ;@ 3a08
  .long Op3010,Op3010,Op3010,Op3010,Op3010,Op3010,Op3010,Op3010 ;@ 3a10
  .long Op3018,Op3018,Op3018,Op3018,Op3018,Op3018,Op3018,Op3018 ;@ 3a18
  .long Op3020,Op3020,Op3020,Op3020,Op3020,Op3020,Op3020,Op3020 ;@ 3a20
  .long Op3028,Op3028,Op3028,Op3028,Op3028,Op3028,Op3028,Op3028 ;@ 3a28
  .long Op3030,Op3030,Op3030,Op3030,Op3030,Op3030,Op3030,Op3030 ;@ 3a30
  .long Op3038,Op3039,Op303a,Op303b,Op303c,Op____,Op____,Op____ ;@ 3a38
  .long Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040 ;@ 3a40
  .long Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040 ;@ 3a48
  .long Op3050,Op3050,Op3050,Op3050,Op3050,Op3050,Op3050,Op3050 ;@ 3a50
  .long Op3058,Op3058,Op3058,Op3058,Op3058,Op3058,Op3058,Op3058 ;@ 3a58
  .long Op3060,Op3060,Op3060,Op3060,Op3060,Op3060,Op3060,Op3060 ;@ 3a60
  .long Op3068,Op3068,Op3068,Op3068,Op3068,Op3068,Op3068,Op3068 ;@ 3a68
  .long Op3070,Op3070,Op3070,Op3070,Op3070,Op3070,Op3070,Op3070 ;@ 3a70
  .long Op3078,Op3079,Op307a,Op307b,Op307c,Op____,Op____,Op____ ;@ 3a78
  .long Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080 ;@ 3a80
  .long Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080 ;@ 3a88
  .long Op3090,Op3090,Op3090,Op3090,Op3090,Op3090,Op3090,Op3090 ;@ 3a90
  .long Op3098,Op3098,Op3098,Op3098,Op3098,Op3098,Op3098,Op3098 ;@ 3a98
  .long Op30a0,Op30a0,Op30a0,Op30a0,Op30a0,Op30a0,Op30a0,Op30a0 ;@ 3aa0
  .long Op30a8,Op30a8,Op30a8,Op30a8,Op30a8,Op30a8,Op30a8,Op30a8 ;@ 3aa8
  .long Op30b0,Op30b0,Op30b0,Op30b0,Op30b0,Op30b0,Op30b0,Op30b0 ;@ 3ab0
  .long Op30b8,Op30b9,Op30ba,Op30bb,Op30bc,Op____,Op____,Op____ ;@ 3ab8
  .long Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0 ;@ 3ac0
  .long Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0 ;@ 3ac8
  .long Op30d0,Op30d0,Op30d0,Op30d0,Op30d0,Op30d0,Op30d0,Op30d0 ;@ 3ad0
  .long Op30d8,Op30d8,Op30d8,Op30d8,Op30d8,Op30d8,Op30d8,Op30d8 ;@ 3ad8
  .long Op30e0,Op30e0,Op30e0,Op30e0,Op30e0,Op30e0,Op30e0,Op30e0 ;@ 3ae0
  .long Op30e8,Op30e8,Op30e8,Op30e8,Op30e8,Op30e8,Op30e8,Op30e8 ;@ 3ae8
  .long Op30f0,Op30f0,Op30f0,Op30f0,Op30f0,Op30f0,Op30f0,Op30f0 ;@ 3af0
  .long Op30f8,Op30f9,Op30fa,Op30fb,Op30fc,Op____,Op____,Op____ ;@ 3af8
  .long Op3100,Op3100,Op3100,Op3100,Op3100,Op3100,Op3100,Op3100 ;@ 3b00
  .long Op3100,Op3100,Op3100,Op3100,Op3100,Op3100,Op3100,Op3100 ;@ 3b08
  .long Op3110,Op3110,Op3110,Op3110,Op3110,Op3110,Op3110,Op3110 ;@ 3b10
  .long Op3118,Op3118,Op3118,Op3118,Op3118,Op3118,Op3118,Op3118 ;@ 3b18
  .long Op3120,Op3120,Op3120,Op3120,Op3120,Op3120,Op3120,Op3120 ;@ 3b20
  .long Op3128,Op3128,Op3128,Op3128,Op3128,Op3128,Op3128,Op3128 ;@ 3b28
  .long Op3130,Op3130,Op3130,Op3130,Op3130,Op3130,Op3130,Op3130 ;@ 3b30
  .long Op3138,Op3139,Op313a,Op313b,Op313c,Op____,Op____,Op____ ;@ 3b38
  .long Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140 ;@ 3b40
  .long Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140 ;@ 3b48
  .long Op3150,Op3150,Op3150,Op3150,Op3150,Op3150,Op3150,Op3150 ;@ 3b50
  .long Op3158,Op3158,Op3158,Op3158,Op3158,Op3158,Op3158,Op3158 ;@ 3b58
  .long Op3160,Op3160,Op3160,Op3160,Op3160,Op3160,Op3160,Op3160 ;@ 3b60
  .long Op3168,Op3168,Op3168,Op3168,Op3168,Op3168,Op3168,Op3168 ;@ 3b68
  .long Op3170,Op3170,Op3170,Op3170,Op3170,Op3170,Op3170,Op3170 ;@ 3b70
  .long Op3178,Op3179,Op317a,Op317b,Op317c,Op____,Op____,Op____ ;@ 3b78
  .long Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180 ;@ 3b80
  .long Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180 ;@ 3b88
  .long Op3190,Op3190,Op3190,Op3190,Op3190,Op3190,Op3190,Op3190 ;@ 3b90
  .long Op3198,Op3198,Op3198,Op3198,Op3198,Op3198,Op3198,Op3198 ;@ 3b98
  .long Op31a0,Op31a0,Op31a0,Op31a0,Op31a0,Op31a0,Op31a0,Op31a0 ;@ 3ba0
  .long Op31a8,Op31a8,Op31a8,Op31a8,Op31a8,Op31a8,Op31a8,Op31a8 ;@ 3ba8
  .long Op31b0,Op31b0,Op31b0,Op31b0,Op31b0,Op31b0,Op31b0,Op31b0 ;@ 3bb0
  .long Op31b8,Op31b9,Op31ba,Op31bb,Op31bc,Op____,Op____,Op____ ;@ 3bb8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 3bc0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 3bc8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 3bd0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 3bd8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 3be0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 3be8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 3bf0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 3bf8
  .long Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000 ;@ 3c00
  .long Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000 ;@ 3c08
  .long Op3010,Op3010,Op3010,Op3010,Op3010,Op3010,Op3010,Op3010 ;@ 3c10
  .long Op3018,Op3018,Op3018,Op3018,Op3018,Op3018,Op3018,Op3018 ;@ 3c18
  .long Op3020,Op3020,Op3020,Op3020,Op3020,Op3020,Op3020,Op3020 ;@ 3c20
  .long Op3028,Op3028,Op3028,Op3028,Op3028,Op3028,Op3028,Op3028 ;@ 3c28
  .long Op3030,Op3030,Op3030,Op3030,Op3030,Op3030,Op3030,Op3030 ;@ 3c30
  .long Op3038,Op3039,Op303a,Op303b,Op303c,Op____,Op____,Op____ ;@ 3c38
  .long Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040 ;@ 3c40
  .long Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040 ;@ 3c48
  .long Op3050,Op3050,Op3050,Op3050,Op3050,Op3050,Op3050,Op3050 ;@ 3c50
  .long Op3058,Op3058,Op3058,Op3058,Op3058,Op3058,Op3058,Op3058 ;@ 3c58
  .long Op3060,Op3060,Op3060,Op3060,Op3060,Op3060,Op3060,Op3060 ;@ 3c60
  .long Op3068,Op3068,Op3068,Op3068,Op3068,Op3068,Op3068,Op3068 ;@ 3c68
  .long Op3070,Op3070,Op3070,Op3070,Op3070,Op3070,Op3070,Op3070 ;@ 3c70
  .long Op3078,Op3079,Op307a,Op307b,Op307c,Op____,Op____,Op____ ;@ 3c78
  .long Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080 ;@ 3c80
  .long Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080 ;@ 3c88
  .long Op3090,Op3090,Op3090,Op3090,Op3090,Op3090,Op3090,Op3090 ;@ 3c90
  .long Op3098,Op3098,Op3098,Op3098,Op3098,Op3098,Op3098,Op3098 ;@ 3c98
  .long Op30a0,Op30a0,Op30a0,Op30a0,Op30a0,Op30a0,Op30a0,Op30a0 ;@ 3ca0
  .long Op30a8,Op30a8,Op30a8,Op30a8,Op30a8,Op30a8,Op30a8,Op30a8 ;@ 3ca8
  .long Op30b0,Op30b0,Op30b0,Op30b0,Op30b0,Op30b0,Op30b0,Op30b0 ;@ 3cb0
  .long Op30b8,Op30b9,Op30ba,Op30bb,Op30bc,Op____,Op____,Op____ ;@ 3cb8
  .long Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0 ;@ 3cc0
  .long Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0,Op30c0 ;@ 3cc8
  .long Op30d0,Op30d0,Op30d0,Op30d0,Op30d0,Op30d0,Op30d0,Op30d0 ;@ 3cd0
  .long Op30d8,Op30d8,Op30d8,Op30d8,Op30d8,Op30d8,Op30d8,Op30d8 ;@ 3cd8
  .long Op30e0,Op30e0,Op30e0,Op30e0,Op30e0,Op30e0,Op30e0,Op30e0 ;@ 3ce0
  .long Op30e8,Op30e8,Op30e8,Op30e8,Op30e8,Op30e8,Op30e8,Op30e8 ;@ 3ce8
  .long Op30f0,Op30f0,Op30f0,Op30f0,Op30f0,Op30f0,Op30f0,Op30f0 ;@ 3cf0
  .long Op30f8,Op30f9,Op30fa,Op30fb,Op30fc,Op____,Op____,Op____ ;@ 3cf8
  .long Op3100,Op3100,Op3100,Op3100,Op3100,Op3100,Op3100,Op3100 ;@ 3d00
  .long Op3100,Op3100,Op3100,Op3100,Op3100,Op3100,Op3100,Op3100 ;@ 3d08
  .long Op3110,Op3110,Op3110,Op3110,Op3110,Op3110,Op3110,Op3110 ;@ 3d10
  .long Op3118,Op3118,Op3118,Op3118,Op3118,Op3118,Op3118,Op3118 ;@ 3d18
  .long Op3120,Op3120,Op3120,Op3120,Op3120,Op3120,Op3120,Op3120 ;@ 3d20
  .long Op3128,Op3128,Op3128,Op3128,Op3128,Op3128,Op3128,Op3128 ;@ 3d28
  .long Op3130,Op3130,Op3130,Op3130,Op3130,Op3130,Op3130,Op3130 ;@ 3d30
  .long Op3138,Op3139,Op313a,Op313b,Op313c,Op____,Op____,Op____ ;@ 3d38
  .long Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140 ;@ 3d40
  .long Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140 ;@ 3d48
  .long Op3150,Op3150,Op3150,Op3150,Op3150,Op3150,Op3150,Op3150 ;@ 3d50
  .long Op3158,Op3158,Op3158,Op3158,Op3158,Op3158,Op3158,Op3158 ;@ 3d58
  .long Op3160,Op3160,Op3160,Op3160,Op3160,Op3160,Op3160,Op3160 ;@ 3d60
  .long Op3168,Op3168,Op3168,Op3168,Op3168,Op3168,Op3168,Op3168 ;@ 3d68
  .long Op3170,Op3170,Op3170,Op3170,Op3170,Op3170,Op3170,Op3170 ;@ 3d70
  .long Op3178,Op3179,Op317a,Op317b,Op317c,Op____,Op____,Op____ ;@ 3d78
  .long Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180 ;@ 3d80
  .long Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180 ;@ 3d88
  .long Op3190,Op3190,Op3190,Op3190,Op3190,Op3190,Op3190,Op3190 ;@ 3d90
  .long Op3198,Op3198,Op3198,Op3198,Op3198,Op3198,Op3198,Op3198 ;@ 3d98
  .long Op31a0,Op31a0,Op31a0,Op31a0,Op31a0,Op31a0,Op31a0,Op31a0 ;@ 3da0
  .long Op31a8,Op31a8,Op31a8,Op31a8,Op31a8,Op31a8,Op31a8,Op31a8 ;@ 3da8
  .long Op31b0,Op31b0,Op31b0,Op31b0,Op31b0,Op31b0,Op31b0,Op31b0 ;@ 3db0
  .long Op31b8,Op31b9,Op31ba,Op31bb,Op31bc,Op____,Op____,Op____ ;@ 3db8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 3dc0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 3dc8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 3dd0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 3dd8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 3de0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 3de8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 3df0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 3df8
  .long Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000 ;@ 3e00
  .long Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000,Op3000 ;@ 3e08
  .long Op3010,Op3010,Op3010,Op3010,Op3010,Op3010,Op3010,Op3010 ;@ 3e10
  .long Op3018,Op3018,Op3018,Op3018,Op3018,Op3018,Op3018,Op3018 ;@ 3e18
  .long Op3020,Op3020,Op3020,Op3020,Op3020,Op3020,Op3020,Op3020 ;@ 3e20
  .long Op3028,Op3028,Op3028,Op3028,Op3028,Op3028,Op3028,Op3028 ;@ 3e28
  .long Op3030,Op3030,Op3030,Op3030,Op3030,Op3030,Op3030,Op3030 ;@ 3e30
  .long Op3038,Op3039,Op303a,Op303b,Op303c,Op____,Op____,Op____ ;@ 3e38
  .long Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040 ;@ 3e40
  .long Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040,Op3040 ;@ 3e48
  .long Op3050,Op3050,Op3050,Op3050,Op3050,Op3050,Op3050,Op3050 ;@ 3e50
  .long Op3058,Op3058,Op3058,Op3058,Op3058,Op3058,Op3058,Op3058 ;@ 3e58
  .long Op3060,Op3060,Op3060,Op3060,Op3060,Op3060,Op3060,Op3060 ;@ 3e60
  .long Op3068,Op3068,Op3068,Op3068,Op3068,Op3068,Op3068,Op3068 ;@ 3e68
  .long Op3070,Op3070,Op3070,Op3070,Op3070,Op3070,Op3070,Op3070 ;@ 3e70
  .long Op3078,Op3079,Op307a,Op307b,Op307c,Op____,Op____,Op____ ;@ 3e78
  .long Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080 ;@ 3e80
  .long Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080,Op3080 ;@ 3e88
  .long Op3090,Op3090,Op3090,Op3090,Op3090,Op3090,Op3090,Op3090 ;@ 3e90
  .long Op3098,Op3098,Op3098,Op3098,Op3098,Op3098,Op3098,Op3098 ;@ 3e98
  .long Op30a0,Op30a0,Op30a0,Op30a0,Op30a0,Op30a0,Op30a0,Op30a0 ;@ 3ea0
  .long Op30a8,Op30a8,Op30a8,Op30a8,Op30a8,Op30a8,Op30a8,Op30a8 ;@ 3ea8
  .long Op30b0,Op30b0,Op30b0,Op30b0,Op30b0,Op30b0,Op30b0,Op30b0 ;@ 3eb0
  .long Op30b8,Op30b9,Op30ba,Op30bb,Op30bc,Op____,Op____,Op____ ;@ 3eb8
  .long Op3ec0,Op3ec0,Op3ec0,Op3ec0,Op3ec0,Op3ec0,Op3ec0,Op3ec0 ;@ 3ec0
  .long Op3ec0,Op3ec0,Op3ec0,Op3ec0,Op3ec0,Op3ec0,Op3ec0,Op3ec0 ;@ 3ec8
  .long Op3ed0,Op3ed0,Op3ed0,Op3ed0,Op3ed0,Op3ed0,Op3ed0,Op3ed0 ;@ 3ed0
  .long Op3ed8,Op3ed8,Op3ed8,Op3ed8,Op3ed8,Op3ed8,Op3ed8,Op3ed8 ;@ 3ed8
  .long Op3ee0,Op3ee0,Op3ee0,Op3ee0,Op3ee0,Op3ee0,Op3ee0,Op3ee0 ;@ 3ee0
  .long Op3ee8,Op3ee8,Op3ee8,Op3ee8,Op3ee8,Op3ee8,Op3ee8,Op3ee8 ;@ 3ee8
  .long Op3ef0,Op3ef0,Op3ef0,Op3ef0,Op3ef0,Op3ef0,Op3ef0,Op3ef0 ;@ 3ef0
  .long Op3ef8,Op3ef9,Op3efa,Op3efb,Op3efc,Op____,Op____,Op____ ;@ 3ef8
  .long Op3f00,Op3f00,Op3f00,Op3f00,Op3f00,Op3f00,Op3f00,Op3f00 ;@ 3f00
  .long Op3f00,Op3f00,Op3f00,Op3f00,Op3f00,Op3f00,Op3f00,Op3f00 ;@ 3f08
  .long Op3f10,Op3f10,Op3f10,Op3f10,Op3f10,Op3f10,Op3f10,Op3f10 ;@ 3f10
  .long Op3f18,Op3f18,Op3f18,Op3f18,Op3f18,Op3f18,Op3f18,Op3f18 ;@ 3f18
  .long Op3f20,Op3f20,Op3f20,Op3f20,Op3f20,Op3f20,Op3f20,Op3f20 ;@ 3f20
  .long Op3f28,Op3f28,Op3f28,Op3f28,Op3f28,Op3f28,Op3f28,Op3f28 ;@ 3f28
  .long Op3f30,Op3f30,Op3f30,Op3f30,Op3f30,Op3f30,Op3f30,Op3f30 ;@ 3f30
  .long Op3f38,Op3f39,Op3f3a,Op3f3b,Op3f3c,Op____,Op____,Op____ ;@ 3f38
  .long Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140 ;@ 3f40
  .long Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140,Op3140 ;@ 3f48
  .long Op3150,Op3150,Op3150,Op3150,Op3150,Op3150,Op3150,Op3150 ;@ 3f50
  .long Op3158,Op3158,Op3158,Op3158,Op3158,Op3158,Op3158,Op3158 ;@ 3f58
  .long Op3160,Op3160,Op3160,Op3160,Op3160,Op3160,Op3160,Op3160 ;@ 3f60
  .long Op3168,Op3168,Op3168,Op3168,Op3168,Op3168,Op3168,Op3168 ;@ 3f68
  .long Op3170,Op3170,Op3170,Op3170,Op3170,Op3170,Op3170,Op3170 ;@ 3f70
  .long Op3178,Op3179,Op317a,Op317b,Op317c,Op____,Op____,Op____ ;@ 3f78
  .long Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180 ;@ 3f80
  .long Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180,Op3180 ;@ 3f88
  .long Op3190,Op3190,Op3190,Op3190,Op3190,Op3190,Op3190,Op3190 ;@ 3f90
  .long Op3198,Op3198,Op3198,Op3198,Op3198,Op3198,Op3198,Op3198 ;@ 3f98
  .long Op31a0,Op31a0,Op31a0,Op31a0,Op31a0,Op31a0,Op31a0,Op31a0 ;@ 3fa0
  .long Op31a8,Op31a8,Op31a8,Op31a8,Op31a8,Op31a8,Op31a8,Op31a8 ;@ 3fa8
  .long Op31b0,Op31b0,Op31b0,Op31b0,Op31b0,Op31b0,Op31b0,Op31b0 ;@ 3fb0
  .long Op31b8,Op31b9,Op31ba,Op31bb,Op31bc,Op____,Op____,Op____ ;@ 3fb8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 3fc0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 3fc8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 3fd0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 3fd8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 3fe0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 3fe8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 3ff0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 3ff8
  .long Op4000,Op4000,Op4000,Op4000,Op4000,Op4000,Op4000,Op4000 ;@ 4000
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4008
  .long Op4010,Op4010,Op4010,Op4010,Op4010,Op4010,Op4010,Op4010 ;@ 4010
  .long Op4018,Op4018,Op4018,Op4018,Op4018,Op4018,Op4018,Op401f ;@ 4018
  .long Op4020,Op4020,Op4020,Op4020,Op4020,Op4020,Op4020,Op4027 ;@ 4020
  .long Op4028,Op4028,Op4028,Op4028,Op4028,Op4028,Op4028,Op4028 ;@ 4028
  .long Op4030,Op4030,Op4030,Op4030,Op4030,Op4030,Op4030,Op4030 ;@ 4030
  .long Op4038,Op4039,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4038
  .long Op4040,Op4040,Op4040,Op4040,Op4040,Op4040,Op4040,Op4040 ;@ 4040
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4048
  .long Op4050,Op4050,Op4050,Op4050,Op4050,Op4050,Op4050,Op4050 ;@ 4050
  .long Op4058,Op4058,Op4058,Op4058,Op4058,Op4058,Op4058,Op4058 ;@ 4058
  .long Op4060,Op4060,Op4060,Op4060,Op4060,Op4060,Op4060,Op4060 ;@ 4060
  .long Op4068,Op4068,Op4068,Op4068,Op4068,Op4068,Op4068,Op4068 ;@ 4068
  .long Op4070,Op4070,Op4070,Op4070,Op4070,Op4070,Op4070,Op4070 ;@ 4070
  .long Op4078,Op4079,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4078
  .long Op4080,Op4080,Op4080,Op4080,Op4080,Op4080,Op4080,Op4080 ;@ 4080
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4088
  .long Op4090,Op4090,Op4090,Op4090,Op4090,Op4090,Op4090,Op4090 ;@ 4090
  .long Op4098,Op4098,Op4098,Op4098,Op4098,Op4098,Op4098,Op4098 ;@ 4098
  .long Op40a0,Op40a0,Op40a0,Op40a0,Op40a0,Op40a0,Op40a0,Op40a0 ;@ 40a0
  .long Op40a8,Op40a8,Op40a8,Op40a8,Op40a8,Op40a8,Op40a8,Op40a8 ;@ 40a8
  .long Op40b0,Op40b0,Op40b0,Op40b0,Op40b0,Op40b0,Op40b0,Op40b0 ;@ 40b0
  .long Op40b8,Op40b9,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 40b8
  .long Op40c0,Op40c0,Op40c0,Op40c0,Op40c0,Op40c0,Op40c0,Op40c0 ;@ 40c0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 40c8
  .long Op40d0,Op40d0,Op40d0,Op40d0,Op40d0,Op40d0,Op40d0,Op40d0 ;@ 40d0
  .long Op40d8,Op40d8,Op40d8,Op40d8,Op40d8,Op40d8,Op40d8,Op40d8 ;@ 40d8
  .long Op40e0,Op40e0,Op40e0,Op40e0,Op40e0,Op40e0,Op40e0,Op40e0 ;@ 40e0
  .long Op40e8,Op40e8,Op40e8,Op40e8,Op40e8,Op40e8,Op40e8,Op40e8 ;@ 40e8
  .long Op40f0,Op40f0,Op40f0,Op40f0,Op40f0,Op40f0,Op40f0,Op40f0 ;@ 40f0
  .long Op40f8,Op40f9,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 40f8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4100
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4108
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4110
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4118
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4120
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4128
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4130
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4138
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4140
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4148
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4150
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4158
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4160
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4168
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4170
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4178
  .long Op4180,Op4180,Op4180,Op4180,Op4180,Op4180,Op4180,Op4180 ;@ 4180
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4188
  .long Op4190,Op4190,Op4190,Op4190,Op4190,Op4190,Op4190,Op4190 ;@ 4190
  .long Op4198,Op4198,Op4198,Op4198,Op4198,Op4198,Op4198,Op4198 ;@ 4198
  .long Op41a0,Op41a0,Op41a0,Op41a0,Op41a0,Op41a0,Op41a0,Op41a0 ;@ 41a0
  .long Op41a8,Op41a8,Op41a8,Op41a8,Op41a8,Op41a8,Op41a8,Op41a8 ;@ 41a8
  .long Op41b0,Op41b0,Op41b0,Op41b0,Op41b0,Op41b0,Op41b0,Op41b0 ;@ 41b0
  .long Op41b8,Op41b9,Op41ba,Op41bb,Op41bc,Op____,Op____,Op____ ;@ 41b8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 41c0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 41c8
  .long Op41d0,Op41d0,Op41d0,Op41d0,Op41d0,Op41d0,Op41d0,Op41d0 ;@ 41d0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 41d8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 41e0
  .long Op41e8,Op41e8,Op41e8,Op41e8,Op41e8,Op41e8,Op41e8,Op41e8 ;@ 41e8
  .long Op41f0,Op41f0,Op41f0,Op41f0,Op41f0,Op41f0,Op41f0,Op41f0 ;@ 41f0
  .long Op41f8,Op41f9,Op41fa,Op41fb,Op____,Op____,Op____,Op____ ;@ 41f8
  .long Op4200,Op4200,Op4200,Op4200,Op4200,Op4200,Op4200,Op4200 ;@ 4200
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4208
  .long Op4210,Op4210,Op4210,Op4210,Op4210,Op4210,Op4210,Op4210 ;@ 4210
  .long Op4218,Op4218,Op4218,Op4218,Op4218,Op4218,Op4218,Op421f ;@ 4218
  .long Op4220,Op4220,Op4220,Op4220,Op4220,Op4220,Op4220,Op4227 ;@ 4220
  .long Op4228,Op4228,Op4228,Op4228,Op4228,Op4228,Op4228,Op4228 ;@ 4228
  .long Op4230,Op4230,Op4230,Op4230,Op4230,Op4230,Op4230,Op4230 ;@ 4230
  .long Op4238,Op4239,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4238
  .long Op4240,Op4240,Op4240,Op4240,Op4240,Op4240,Op4240,Op4240 ;@ 4240
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4248
  .long Op4250,Op4250,Op4250,Op4250,Op4250,Op4250,Op4250,Op4250 ;@ 4250
  .long Op4258,Op4258,Op4258,Op4258,Op4258,Op4258,Op4258,Op4258 ;@ 4258
  .long Op4260,Op4260,Op4260,Op4260,Op4260,Op4260,Op4260,Op4260 ;@ 4260
  .long Op4268,Op4268,Op4268,Op4268,Op4268,Op4268,Op4268,Op4268 ;@ 4268
  .long Op4270,Op4270,Op4270,Op4270,Op4270,Op4270,Op4270,Op4270 ;@ 4270
  .long Op4278,Op4279,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4278
  .long Op4280,Op4280,Op4280,Op4280,Op4280,Op4280,Op4280,Op4280 ;@ 4280
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4288
  .long Op4290,Op4290,Op4290,Op4290,Op4290,Op4290,Op4290,Op4290 ;@ 4290
  .long Op4298,Op4298,Op4298,Op4298,Op4298,Op4298,Op4298,Op4298 ;@ 4298
  .long Op42a0,Op42a0,Op42a0,Op42a0,Op42a0,Op42a0,Op42a0,Op42a0 ;@ 42a0
  .long Op42a8,Op42a8,Op42a8,Op42a8,Op42a8,Op42a8,Op42a8,Op42a8 ;@ 42a8
  .long Op42b0,Op42b0,Op42b0,Op42b0,Op42b0,Op42b0,Op42b0,Op42b0 ;@ 42b0
  .long Op42b8,Op42b9,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 42b8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 42c0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 42c8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 42d0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 42d8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 42e0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 42e8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 42f0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 42f8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4300
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4308
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4310
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4318
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4320
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4328
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4330
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4338
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4340
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4348
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4350
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4358
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4360
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4368
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4370
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4378
  .long Op4180,Op4180,Op4180,Op4180,Op4180,Op4180,Op4180,Op4180 ;@ 4380
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4388
  .long Op4190,Op4190,Op4190,Op4190,Op4190,Op4190,Op4190,Op4190 ;@ 4390
  .long Op4198,Op4198,Op4198,Op4198,Op4198,Op4198,Op4198,Op4198 ;@ 4398
  .long Op41a0,Op41a0,Op41a0,Op41a0,Op41a0,Op41a0,Op41a0,Op41a0 ;@ 43a0
  .long Op41a8,Op41a8,Op41a8,Op41a8,Op41a8,Op41a8,Op41a8,Op41a8 ;@ 43a8
  .long Op41b0,Op41b0,Op41b0,Op41b0,Op41b0,Op41b0,Op41b0,Op41b0 ;@ 43b0
  .long Op41b8,Op41b9,Op41ba,Op41bb,Op41bc,Op____,Op____,Op____ ;@ 43b8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 43c0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 43c8
  .long Op41d0,Op41d0,Op41d0,Op41d0,Op41d0,Op41d0,Op41d0,Op41d0 ;@ 43d0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 43d8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 43e0
  .long Op41e8,Op41e8,Op41e8,Op41e8,Op41e8,Op41e8,Op41e8,Op41e8 ;@ 43e8
  .long Op41f0,Op41f0,Op41f0,Op41f0,Op41f0,Op41f0,Op41f0,Op41f0 ;@ 43f0
  .long Op41f8,Op41f9,Op41fa,Op41fb,Op____,Op____,Op____,Op____ ;@ 43f8
  .long Op4400,Op4400,Op4400,Op4400,Op4400,Op4400,Op4400,Op4400 ;@ 4400
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4408
  .long Op4410,Op4410,Op4410,Op4410,Op4410,Op4410,Op4410,Op4410 ;@ 4410
  .long Op4418,Op4418,Op4418,Op4418,Op4418,Op4418,Op4418,Op441f ;@ 4418
  .long Op4420,Op4420,Op4420,Op4420,Op4420,Op4420,Op4420,Op4427 ;@ 4420
  .long Op4428,Op4428,Op4428,Op4428,Op4428,Op4428,Op4428,Op4428 ;@ 4428
  .long Op4430,Op4430,Op4430,Op4430,Op4430,Op4430,Op4430,Op4430 ;@ 4430
  .long Op4438,Op4439,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4438
  .long Op4440,Op4440,Op4440,Op4440,Op4440,Op4440,Op4440,Op4440 ;@ 4440
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4448
  .long Op4450,Op4450,Op4450,Op4450,Op4450,Op4450,Op4450,Op4450 ;@ 4450
  .long Op4458,Op4458,Op4458,Op4458,Op4458,Op4458,Op4458,Op4458 ;@ 4458
  .long Op4460,Op4460,Op4460,Op4460,Op4460,Op4460,Op4460,Op4460 ;@ 4460
  .long Op4468,Op4468,Op4468,Op4468,Op4468,Op4468,Op4468,Op4468 ;@ 4468
  .long Op4470,Op4470,Op4470,Op4470,Op4470,Op4470,Op4470,Op4470 ;@ 4470
  .long Op4478,Op4479,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4478
  .long Op4480,Op4480,Op4480,Op4480,Op4480,Op4480,Op4480,Op4480 ;@ 4480
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4488
  .long Op4490,Op4490,Op4490,Op4490,Op4490,Op4490,Op4490,Op4490 ;@ 4490
  .long Op4498,Op4498,Op4498,Op4498,Op4498,Op4498,Op4498,Op4498 ;@ 4498
  .long Op44a0,Op44a0,Op44a0,Op44a0,Op44a0,Op44a0,Op44a0,Op44a0 ;@ 44a0
  .long Op44a8,Op44a8,Op44a8,Op44a8,Op44a8,Op44a8,Op44a8,Op44a8 ;@ 44a8
  .long Op44b0,Op44b0,Op44b0,Op44b0,Op44b0,Op44b0,Op44b0,Op44b0 ;@ 44b0
  .long Op44b8,Op44b9,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 44b8
  .long Op44c0,Op44c0,Op44c0,Op44c0,Op44c0,Op44c0,Op44c0,Op44c0 ;@ 44c0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 44c8
  .long Op44d0,Op44d0,Op44d0,Op44d0,Op44d0,Op44d0,Op44d0,Op44d0 ;@ 44d0
  .long Op44d8,Op44d8,Op44d8,Op44d8,Op44d8,Op44d8,Op44d8,Op44d8 ;@ 44d8
  .long Op44e0,Op44e0,Op44e0,Op44e0,Op44e0,Op44e0,Op44e0,Op44e0 ;@ 44e0
  .long Op44e8,Op44e8,Op44e8,Op44e8,Op44e8,Op44e8,Op44e8,Op44e8 ;@ 44e8
  .long Op44f0,Op44f0,Op44f0,Op44f0,Op44f0,Op44f0,Op44f0,Op44f0 ;@ 44f0
  .long Op44f8,Op44f9,Op44fa,Op44fb,Op44fc,Op____,Op____,Op____ ;@ 44f8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4500
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4508
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4510
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4518
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4520
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4528
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4530
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4538
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4540
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4548
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4550
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4558
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4560
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4568
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4570
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4578
  .long Op4180,Op4180,Op4180,Op4180,Op4180,Op4180,Op4180,Op4180 ;@ 4580
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4588
  .long Op4190,Op4190,Op4190,Op4190,Op4190,Op4190,Op4190,Op4190 ;@ 4590
  .long Op4198,Op4198,Op4198,Op4198,Op4198,Op4198,Op4198,Op4198 ;@ 4598
  .long Op41a0,Op41a0,Op41a0,Op41a0,Op41a0,Op41a0,Op41a0,Op41a0 ;@ 45a0
  .long Op41a8,Op41a8,Op41a8,Op41a8,Op41a8,Op41a8,Op41a8,Op41a8 ;@ 45a8
  .long Op41b0,Op41b0,Op41b0,Op41b0,Op41b0,Op41b0,Op41b0,Op41b0 ;@ 45b0
  .long Op41b8,Op41b9,Op41ba,Op41bb,Op41bc,Op____,Op____,Op____ ;@ 45b8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 45c0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 45c8
  .long Op41d0,Op41d0,Op41d0,Op41d0,Op41d0,Op41d0,Op41d0,Op41d0 ;@ 45d0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 45d8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 45e0
  .long Op41e8,Op41e8,Op41e8,Op41e8,Op41e8,Op41e8,Op41e8,Op41e8 ;@ 45e8
  .long Op41f0,Op41f0,Op41f0,Op41f0,Op41f0,Op41f0,Op41f0,Op41f0 ;@ 45f0
  .long Op41f8,Op41f9,Op41fa,Op41fb,Op____,Op____,Op____,Op____ ;@ 45f8
  .long Op4600,Op4600,Op4600,Op4600,Op4600,Op4600,Op4600,Op4600 ;@ 4600
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4608
  .long Op4610,Op4610,Op4610,Op4610,Op4610,Op4610,Op4610,Op4610 ;@ 4610
  .long Op4618,Op4618,Op4618,Op4618,Op4618,Op4618,Op4618,Op461f ;@ 4618
  .long Op4620,Op4620,Op4620,Op4620,Op4620,Op4620,Op4620,Op4627 ;@ 4620
  .long Op4628,Op4628,Op4628,Op4628,Op4628,Op4628,Op4628,Op4628 ;@ 4628
  .long Op4630,Op4630,Op4630,Op4630,Op4630,Op4630,Op4630,Op4630 ;@ 4630
  .long Op4638,Op4639,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4638
  .long Op4640,Op4640,Op4640,Op4640,Op4640,Op4640,Op4640,Op4640 ;@ 4640
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4648
  .long Op4650,Op4650,Op4650,Op4650,Op4650,Op4650,Op4650,Op4650 ;@ 4650
  .long Op4658,Op4658,Op4658,Op4658,Op4658,Op4658,Op4658,Op4658 ;@ 4658
  .long Op4660,Op4660,Op4660,Op4660,Op4660,Op4660,Op4660,Op4660 ;@ 4660
  .long Op4668,Op4668,Op4668,Op4668,Op4668,Op4668,Op4668,Op4668 ;@ 4668
  .long Op4670,Op4670,Op4670,Op4670,Op4670,Op4670,Op4670,Op4670 ;@ 4670
  .long Op4678,Op4679,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4678
  .long Op4680,Op4680,Op4680,Op4680,Op4680,Op4680,Op4680,Op4680 ;@ 4680
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4688
  .long Op4690,Op4690,Op4690,Op4690,Op4690,Op4690,Op4690,Op4690 ;@ 4690
  .long Op4698,Op4698,Op4698,Op4698,Op4698,Op4698,Op4698,Op4698 ;@ 4698
  .long Op46a0,Op46a0,Op46a0,Op46a0,Op46a0,Op46a0,Op46a0,Op46a0 ;@ 46a0
  .long Op46a8,Op46a8,Op46a8,Op46a8,Op46a8,Op46a8,Op46a8,Op46a8 ;@ 46a8
  .long Op46b0,Op46b0,Op46b0,Op46b0,Op46b0,Op46b0,Op46b0,Op46b0 ;@ 46b0
  .long Op46b8,Op46b9,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 46b8
  .long Op46c0,Op46c0,Op46c0,Op46c0,Op46c0,Op46c0,Op46c0,Op46c0 ;@ 46c0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 46c8
  .long Op46d0,Op46d0,Op46d0,Op46d0,Op46d0,Op46d0,Op46d0,Op46d0 ;@ 46d0
  .long Op46d8,Op46d8,Op46d8,Op46d8,Op46d8,Op46d8,Op46d8,Op46d8 ;@ 46d8
  .long Op46e0,Op46e0,Op46e0,Op46e0,Op46e0,Op46e0,Op46e0,Op46e0 ;@ 46e0
  .long Op46e8,Op46e8,Op46e8,Op46e8,Op46e8,Op46e8,Op46e8,Op46e8 ;@ 46e8
  .long Op46f0,Op46f0,Op46f0,Op46f0,Op46f0,Op46f0,Op46f0,Op46f0 ;@ 46f0
  .long Op46f8,Op46f9,Op46fa,Op46fb,Op46fc,Op____,Op____,Op____ ;@ 46f8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4700
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4708
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4710
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4718
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4720
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4728
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4730
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4738
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4740
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4748
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4750
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4758
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4760
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4768
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4770
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4778
  .long Op4180,Op4180,Op4180,Op4180,Op4180,Op4180,Op4180,Op4180 ;@ 4780
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4788
  .long Op4190,Op4190,Op4190,Op4190,Op4190,Op4190,Op4190,Op4190 ;@ 4790
  .long Op4198,Op4198,Op4198,Op4198,Op4198,Op4198,Op4198,Op4198 ;@ 4798
  .long Op41a0,Op41a0,Op41a0,Op41a0,Op41a0,Op41a0,Op41a0,Op41a0 ;@ 47a0
  .long Op41a8,Op41a8,Op41a8,Op41a8,Op41a8,Op41a8,Op41a8,Op41a8 ;@ 47a8
  .long Op41b0,Op41b0,Op41b0,Op41b0,Op41b0,Op41b0,Op41b0,Op41b0 ;@ 47b0
  .long Op41b8,Op41b9,Op41ba,Op41bb,Op41bc,Op____,Op____,Op____ ;@ 47b8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 47c0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 47c8
  .long Op41d0,Op41d0,Op41d0,Op41d0,Op41d0,Op41d0,Op41d0,Op41d0 ;@ 47d0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 47d8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 47e0
  .long Op41e8,Op41e8,Op41e8,Op41e8,Op41e8,Op41e8,Op41e8,Op41e8 ;@ 47e8
  .long Op41f0,Op41f0,Op41f0,Op41f0,Op41f0,Op41f0,Op41f0,Op41f0 ;@ 47f0
  .long Op41f8,Op41f9,Op41fa,Op41fb,Op____,Op____,Op____,Op____ ;@ 47f8
  .long Op4800,Op4800,Op4800,Op4800,Op4800,Op4800,Op4800,Op4800 ;@ 4800
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4808
  .long Op4810,Op4810,Op4810,Op4810,Op4810,Op4810,Op4810,Op4810 ;@ 4810
  .long Op4818,Op4818,Op4818,Op4818,Op4818,Op4818,Op4818,Op481f ;@ 4818
  .long Op4820,Op4820,Op4820,Op4820,Op4820,Op4820,Op4820,Op4827 ;@ 4820
  .long Op4828,Op4828,Op4828,Op4828,Op4828,Op4828,Op4828,Op4828 ;@ 4828
  .long Op4830,Op4830,Op4830,Op4830,Op4830,Op4830,Op4830,Op4830 ;@ 4830
  .long Op4838,Op4839,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4838
  .long Op4840,Op4840,Op4840,Op4840,Op4840,Op4840,Op4840,Op4840 ;@ 4840
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4848
  .long Op4850,Op4850,Op4850,Op4850,Op4850,Op4850,Op4850,Op4850 ;@ 4850
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4858
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4860
  .long Op4868,Op4868,Op4868,Op4868,Op4868,Op4868,Op4868,Op4868 ;@ 4868
  .long Op4870,Op4870,Op4870,Op4870,Op4870,Op4870,Op4870,Op4870 ;@ 4870
  .long Op4878,Op4879,Op487a,Op487b,Op____,Op____,Op____,Op____ ;@ 4878
  .long Op4880,Op4880,Op4880,Op4880,Op4880,Op4880,Op4880,Op4880 ;@ 4880
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4888
  .long Op4890,Op4890,Op4890,Op4890,Op4890,Op4890,Op4890,Op4890 ;@ 4890
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4898
  .long Op48a0,Op48a0,Op48a0,Op48a0,Op48a0,Op48a0,Op48a0,Op48a0 ;@ 48a0
  .long Op48a8,Op48a8,Op48a8,Op48a8,Op48a8,Op48a8,Op48a8,Op48a8 ;@ 48a8
  .long Op48b0,Op48b0,Op48b0,Op48b0,Op48b0,Op48b0,Op48b0,Op48b0 ;@ 48b0
  .long Op48b8,Op48b9,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 48b8
  .long Op48c0,Op48c0,Op48c0,Op48c0,Op48c0,Op48c0,Op48c0,Op48c0 ;@ 48c0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 48c8
  .long Op48d0,Op48d0,Op48d0,Op48d0,Op48d0,Op48d0,Op48d0,Op48d0 ;@ 48d0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 48d8
  .long Op48e0,Op48e0,Op48e0,Op48e0,Op48e0,Op48e0,Op48e0,Op48e0 ;@ 48e0
  .long Op48e8,Op48e8,Op48e8,Op48e8,Op48e8,Op48e8,Op48e8,Op48e8 ;@ 48e8
  .long Op48f0,Op48f0,Op48f0,Op48f0,Op48f0,Op48f0,Op48f0,Op48f0 ;@ 48f0
  .long Op48f8,Op48f9,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 48f8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4900
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4908
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4910
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4918
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4920
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4928
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4930
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4938
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4940
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4948
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4950
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4958
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4960
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4968
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4970
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4978
  .long Op4180,Op4180,Op4180,Op4180,Op4180,Op4180,Op4180,Op4180 ;@ 4980
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4988
  .long Op4190,Op4190,Op4190,Op4190,Op4190,Op4190,Op4190,Op4190 ;@ 4990
  .long Op4198,Op4198,Op4198,Op4198,Op4198,Op4198,Op4198,Op4198 ;@ 4998
  .long Op41a0,Op41a0,Op41a0,Op41a0,Op41a0,Op41a0,Op41a0,Op41a0 ;@ 49a0
  .long Op41a8,Op41a8,Op41a8,Op41a8,Op41a8,Op41a8,Op41a8,Op41a8 ;@ 49a8
  .long Op41b0,Op41b0,Op41b0,Op41b0,Op41b0,Op41b0,Op41b0,Op41b0 ;@ 49b0
  .long Op41b8,Op41b9,Op41ba,Op41bb,Op41bc,Op____,Op____,Op____ ;@ 49b8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 49c0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 49c8
  .long Op41d0,Op41d0,Op41d0,Op41d0,Op41d0,Op41d0,Op41d0,Op41d0 ;@ 49d0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 49d8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 49e0
  .long Op41e8,Op41e8,Op41e8,Op41e8,Op41e8,Op41e8,Op41e8,Op41e8 ;@ 49e8
  .long Op41f0,Op41f0,Op41f0,Op41f0,Op41f0,Op41f0,Op41f0,Op41f0 ;@ 49f0
  .long Op41f8,Op41f9,Op41fa,Op41fb,Op____,Op____,Op____,Op____ ;@ 49f8
  .long Op4a00,Op4a00,Op4a00,Op4a00,Op4a00,Op4a00,Op4a00,Op4a00 ;@ 4a00
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4a08
  .long Op4a10,Op4a10,Op4a10,Op4a10,Op4a10,Op4a10,Op4a10,Op4a10 ;@ 4a10
  .long Op4a18,Op4a18,Op4a18,Op4a18,Op4a18,Op4a18,Op4a18,Op4a1f ;@ 4a18
  .long Op4a20,Op4a20,Op4a20,Op4a20,Op4a20,Op4a20,Op4a20,Op4a27 ;@ 4a20
  .long Op4a28,Op4a28,Op4a28,Op4a28,Op4a28,Op4a28,Op4a28,Op4a28 ;@ 4a28
  .long Op4a30,Op4a30,Op4a30,Op4a30,Op4a30,Op4a30,Op4a30,Op4a30 ;@ 4a30
  .long Op4a38,Op4a39,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4a38
  .long Op4a40,Op4a40,Op4a40,Op4a40,Op4a40,Op4a40,Op4a40,Op4a40 ;@ 4a40
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4a48
  .long Op4a50,Op4a50,Op4a50,Op4a50,Op4a50,Op4a50,Op4a50,Op4a50 ;@ 4a50
  .long Op4a58,Op4a58,Op4a58,Op4a58,Op4a58,Op4a58,Op4a58,Op4a58 ;@ 4a58
  .long Op4a60,Op4a60,Op4a60,Op4a60,Op4a60,Op4a60,Op4a60,Op4a60 ;@ 4a60
  .long Op4a68,Op4a68,Op4a68,Op4a68,Op4a68,Op4a68,Op4a68,Op4a68 ;@ 4a68
  .long Op4a70,Op4a70,Op4a70,Op4a70,Op4a70,Op4a70,Op4a70,Op4a70 ;@ 4a70
  .long Op4a78,Op4a79,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4a78
  .long Op4a80,Op4a80,Op4a80,Op4a80,Op4a80,Op4a80,Op4a80,Op4a80 ;@ 4a80
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4a88
  .long Op4a90,Op4a90,Op4a90,Op4a90,Op4a90,Op4a90,Op4a90,Op4a90 ;@ 4a90
  .long Op4a98,Op4a98,Op4a98,Op4a98,Op4a98,Op4a98,Op4a98,Op4a98 ;@ 4a98
  .long Op4aa0,Op4aa0,Op4aa0,Op4aa0,Op4aa0,Op4aa0,Op4aa0,Op4aa0 ;@ 4aa0
  .long Op4aa8,Op4aa8,Op4aa8,Op4aa8,Op4aa8,Op4aa8,Op4aa8,Op4aa8 ;@ 4aa8
  .long Op4ab0,Op4ab0,Op4ab0,Op4ab0,Op4ab0,Op4ab0,Op4ab0,Op4ab0 ;@ 4ab0
  .long Op4ab8,Op4ab9,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4ab8
  .long Op4ac0,Op4ac0,Op4ac0,Op4ac0,Op4ac0,Op4ac0,Op4ac0,Op4ac0 ;@ 4ac0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4ac8
  .long Op4ad0,Op4ad0,Op4ad0,Op4ad0,Op4ad0,Op4ad0,Op4ad0,Op4ad0 ;@ 4ad0
  .long Op4ad8,Op4ad8,Op4ad8,Op4ad8,Op4ad8,Op4ad8,Op4ad8,Op4adf ;@ 4ad8
  .long Op4ae0,Op4ae0,Op4ae0,Op4ae0,Op4ae0,Op4ae0,Op4ae0,Op4ae7 ;@ 4ae0
  .long Op4ae8,Op4ae8,Op4ae8,Op4ae8,Op4ae8,Op4ae8,Op4ae8,Op4ae8 ;@ 4ae8
  .long Op4af0,Op4af0,Op4af0,Op4af0,Op4af0,Op4af0,Op4af0,Op4af0 ;@ 4af0
  .long Op4af8,Op4af9,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4af8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4b00
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4b08
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4b10
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4b18
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4b20
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4b28
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4b30
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4b38
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4b40
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4b48
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4b50
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4b58
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4b60
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4b68
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4b70
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4b78
  .long Op4180,Op4180,Op4180,Op4180,Op4180,Op4180,Op4180,Op4180 ;@ 4b80
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4b88
  .long Op4190,Op4190,Op4190,Op4190,Op4190,Op4190,Op4190,Op4190 ;@ 4b90
  .long Op4198,Op4198,Op4198,Op4198,Op4198,Op4198,Op4198,Op4198 ;@ 4b98
  .long Op41a0,Op41a0,Op41a0,Op41a0,Op41a0,Op41a0,Op41a0,Op41a0 ;@ 4ba0
  .long Op41a8,Op41a8,Op41a8,Op41a8,Op41a8,Op41a8,Op41a8,Op41a8 ;@ 4ba8
  .long Op41b0,Op41b0,Op41b0,Op41b0,Op41b0,Op41b0,Op41b0,Op41b0 ;@ 4bb0
  .long Op41b8,Op41b9,Op41ba,Op41bb,Op41bc,Op____,Op____,Op____ ;@ 4bb8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4bc0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4bc8
  .long Op41d0,Op41d0,Op41d0,Op41d0,Op41d0,Op41d0,Op41d0,Op41d0 ;@ 4bd0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4bd8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4be0
  .long Op41e8,Op41e8,Op41e8,Op41e8,Op41e8,Op41e8,Op41e8,Op41e8 ;@ 4be8
  .long Op41f0,Op41f0,Op41f0,Op41f0,Op41f0,Op41f0,Op41f0,Op41f0 ;@ 4bf0
  .long Op41f8,Op41f9,Op41fa,Op41fb,Op____,Op____,Op____,Op____ ;@ 4bf8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4c00
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4c08
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4c10
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4c18
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4c20
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4c28
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4c30
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4c38
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4c40
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4c48
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4c50
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4c58
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4c60
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4c68
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4c70
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4c78
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4c80
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4c88
  .long Op4c90,Op4c90,Op4c90,Op4c90,Op4c90,Op4c90,Op4c90,Op4c90 ;@ 4c90
  .long Op4c98,Op4c98,Op4c98,Op4c98,Op4c98,Op4c98,Op4c98,Op4c98 ;@ 4c98
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4ca0
  .long Op4ca8,Op4ca8,Op4ca8,Op4ca8,Op4ca8,Op4ca8,Op4ca8,Op4ca8 ;@ 4ca8
  .long Op4cb0,Op4cb0,Op4cb0,Op4cb0,Op4cb0,Op4cb0,Op4cb0,Op4cb0 ;@ 4cb0
  .long Op4cb8,Op4cb9,Op4cba,Op4cbb,Op____,Op____,Op____,Op____ ;@ 4cb8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4cc0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4cc8
  .long Op4cd0,Op4cd0,Op4cd0,Op4cd0,Op4cd0,Op4cd0,Op4cd0,Op4cd0 ;@ 4cd0
  .long Op4cd8,Op4cd8,Op4cd8,Op4cd8,Op4cd8,Op4cd8,Op4cd8,Op4cd8 ;@ 4cd8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4ce0
  .long Op4ce8,Op4ce8,Op4ce8,Op4ce8,Op4ce8,Op4ce8,Op4ce8,Op4ce8 ;@ 4ce8
  .long Op4cf0,Op4cf0,Op4cf0,Op4cf0,Op4cf0,Op4cf0,Op4cf0,Op4cf0 ;@ 4cf0
  .long Op4cf8,Op4cf9,Op4cfa,Op4cfb,Op____,Op____,Op____,Op____ ;@ 4cf8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4d00
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4d08
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4d10
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4d18
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4d20
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4d28
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4d30
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4d38
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4d40
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4d48
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4d50
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4d58
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4d60
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4d68
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4d70
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4d78
  .long Op4180,Op4180,Op4180,Op4180,Op4180,Op4180,Op4180,Op4180 ;@ 4d80
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4d88
  .long Op4190,Op4190,Op4190,Op4190,Op4190,Op4190,Op4190,Op4190 ;@ 4d90
  .long Op4198,Op4198,Op4198,Op4198,Op4198,Op4198,Op4198,Op4198 ;@ 4d98
  .long Op41a0,Op41a0,Op41a0,Op41a0,Op41a0,Op41a0,Op41a0,Op41a0 ;@ 4da0
  .long Op41a8,Op41a8,Op41a8,Op41a8,Op41a8,Op41a8,Op41a8,Op41a8 ;@ 4da8
  .long Op41b0,Op41b0,Op41b0,Op41b0,Op41b0,Op41b0,Op41b0,Op41b0 ;@ 4db0
  .long Op41b8,Op41b9,Op41ba,Op41bb,Op41bc,Op____,Op____,Op____ ;@ 4db8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4dc0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4dc8
  .long Op41d0,Op41d0,Op41d0,Op41d0,Op41d0,Op41d0,Op41d0,Op41d0 ;@ 4dd0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4dd8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4de0
  .long Op41e8,Op41e8,Op41e8,Op41e8,Op41e8,Op41e8,Op41e8,Op41e8 ;@ 4de8
  .long Op41f0,Op41f0,Op41f0,Op41f0,Op41f0,Op41f0,Op41f0,Op41f0 ;@ 4df0
  .long Op41f8,Op41f9,Op41fa,Op41fb,Op____,Op____,Op____,Op____ ;@ 4df8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4e00
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4e08
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4e10
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4e18
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4e20
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4e28
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4e30
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4e38
  .long Op4e40,Op4e40,Op4e40,Op4e40,Op4e40,Op4e40,Op4e40,Op4e40 ;@ 4e40
  .long Op4e40,Op4e40,Op4e40,Op4e40,Op4e40,Op4e40,Op4e40,Op4e40 ;@ 4e48
  .long Op4e50,Op4e50,Op4e50,Op4e50,Op4e50,Op4e50,Op4e50,Op4e57 ;@ 4e50
  .long Op4e58,Op4e58,Op4e58,Op4e58,Op4e58,Op4e58,Op4e58,Op4e58 ;@ 4e58
  .long Op4e60,Op4e60,Op4e60,Op4e60,Op4e60,Op4e60,Op4e60,Op4e60 ;@ 4e60
  .long Op4e68,Op4e68,Op4e68,Op4e68,Op4e68,Op4e68,Op4e68,Op4e68 ;@ 4e68
  .long Op4e70,Op4e71,Op4e72,Op4e73,Op____,Op4e75,Op4e76,Op4e77 ;@ 4e70
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4e78
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4e80
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4e88
  .long Op4e90,Op4e90,Op4e90,Op4e90,Op4e90,Op4e90,Op4e90,Op4e90 ;@ 4e90
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4e98
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4ea0
  .long Op4ea8,Op4ea8,Op4ea8,Op4ea8,Op4ea8,Op4ea8,Op4ea8,Op4ea8 ;@ 4ea8
  .long Op4eb0,Op4eb0,Op4eb0,Op4eb0,Op4eb0,Op4eb0,Op4eb0,Op4eb0 ;@ 4eb0
  .long Op4eb8,Op4eb9,Op4eba,Op4ebb,Op____,Op____,Op____,Op____ ;@ 4eb8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4ec0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4ec8
  .long Op4ed0,Op4ed0,Op4ed0,Op4ed0,Op4ed0,Op4ed0,Op4ed0,Op4ed0 ;@ 4ed0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4ed8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4ee0
  .long Op4ee8,Op4ee8,Op4ee8,Op4ee8,Op4ee8,Op4ee8,Op4ee8,Op4ee8 ;@ 4ee8
  .long Op4ef0,Op4ef0,Op4ef0,Op4ef0,Op4ef0,Op4ef0,Op4ef0,Op4ef0 ;@ 4ef0
  .long Op4ef8,Op4ef9,Op4efa,Op4efb,Op____,Op____,Op____,Op____ ;@ 4ef8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4f00
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4f08
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4f10
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4f18
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4f20
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4f28
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4f30
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4f38
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4f40
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4f48
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4f50
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4f58
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4f60
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4f68
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4f70
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4f78
  .long Op4180,Op4180,Op4180,Op4180,Op4180,Op4180,Op4180,Op4180 ;@ 4f80
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4f88
  .long Op4190,Op4190,Op4190,Op4190,Op4190,Op4190,Op4190,Op4190 ;@ 4f90
  .long Op4198,Op4198,Op4198,Op4198,Op4198,Op4198,Op4198,Op4198 ;@ 4f98
  .long Op41a0,Op41a0,Op41a0,Op41a0,Op41a0,Op41a0,Op41a0,Op41a0 ;@ 4fa0
  .long Op41a8,Op41a8,Op41a8,Op41a8,Op41a8,Op41a8,Op41a8,Op41a8 ;@ 4fa8
  .long Op41b0,Op41b0,Op41b0,Op41b0,Op41b0,Op41b0,Op41b0,Op41b0 ;@ 4fb0
  .long Op41b8,Op41b9,Op41ba,Op41bb,Op41bc,Op____,Op____,Op____ ;@ 4fb8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4fc0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4fc8
  .long Op41d0,Op41d0,Op41d0,Op41d0,Op41d0,Op41d0,Op41d0,Op41d0 ;@ 4fd0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4fd8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4fe0
  .long Op41e8,Op41e8,Op41e8,Op41e8,Op41e8,Op41e8,Op41e8,Op41e8 ;@ 4fe8
  .long Op41f0,Op41f0,Op41f0,Op41f0,Op41f0,Op41f0,Op41f0,Op41f0 ;@ 4ff0
  .long Op41f8,Op41f9,Op41fa,Op41fb,Op____,Op____,Op____,Op____ ;@ 4ff8
  .long Op5000,Op5000,Op5000,Op5000,Op5000,Op5000,Op5000,Op5000 ;@ 5000
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 5008
  .long Op5010,Op5010,Op5010,Op5010,Op5010,Op5010,Op5010,Op5010 ;@ 5010
  .long Op5018,Op5018,Op5018,Op5018,Op5018,Op5018,Op5018,Op501f ;@ 5018
  .long Op5020,Op5020,Op5020,Op5020,Op5020,Op5020,Op5020,Op5027 ;@ 5020
  .long Op5028,Op5028,Op5028,Op5028,Op5028,Op5028,Op5028,Op5028 ;@ 5028
  .long Op5030,Op5030,Op5030,Op5030,Op5030,Op5030,Op5030,Op5030 ;@ 5030
  .long Op5038,Op5039,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 5038
  .long Op5040,Op5040,Op5040,Op5040,Op5040,Op5040,Op5040,Op5040 ;@ 5040
  .long Op5048,Op5048,Op5048,Op5048,Op5048,Op5048,Op5048,Op5048 ;@ 5048
  .long Op5050,Op5050,Op5050,Op5050,Op5050,Op5050,Op5050,Op5050 ;@ 5050
  .long Op5058,Op5058,Op5058,Op5058,Op5058,Op5058,Op5058,Op5058 ;@ 5058
  .long Op5060,Op5060,Op5060,Op5060,Op5060,Op5060,Op5060,Op5060 ;@ 5060
  .long Op5068,Op5068,Op5068,Op5068,Op5068,Op5068,Op5068,Op5068 ;@ 5068
  .long Op5070,Op5070,Op5070,Op5070,Op5070,Op5070,Op5070,Op5070 ;@ 5070
  .long Op5078,Op5079,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 5078
  .long Op5080,Op5080,Op5080,Op5080,Op5080,Op5080,Op5080,Op5080 ;@ 5080
  .long Op5088,Op5088,Op5088,Op5088,Op5088,Op5088,Op5088,Op5088 ;@ 5088
  .long Op5090,Op5090,Op5090,Op5090,Op5090,Op5090,Op5090,Op5090 ;@ 5090
  .long Op5098,Op5098,Op5098,Op5098,Op5098,Op5098,Op5098,Op5098 ;@ 5098
  .long Op50a0,Op50a0,Op50a0,Op50a0,Op50a0,Op50a0,Op50a0,Op50a0 ;@ 50a0
  .long Op50a8,Op50a8,Op50a8,Op50a8,Op50a8,Op50a8,Op50a8,Op50a8 ;@ 50a8
  .long Op50b0,Op50b0,Op50b0,Op50b0,Op50b0,Op50b0,Op50b0,Op50b0 ;@ 50b0
  .long Op50b8,Op50b9,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 50b8
  .long Op50c0,Op50c0,Op50c0,Op50c0,Op50c0,Op50c0,Op50c0,Op50c0 ;@ 50c0
  .long Op50c8,Op50c8,Op50c8,Op50c8,Op50c8,Op50c8,Op50c8,Op50c8 ;@ 50c8
  .long Op50d0,Op50d0,Op50d0,Op50d0,Op50d0,Op50d0,Op50d0,Op50d0 ;@ 50d0
  .long Op50d8,Op50d8,Op50d8,Op50d8,Op50d8,Op50d8,Op50d8,Op50df ;@ 50d8
  .long Op50e0,Op50e0,Op50e0,Op50e0,Op50e0,Op50e0,Op50e0,Op50e7 ;@ 50e0
  .long Op50e8,Op50e8,Op50e8,Op50e8,Op50e8,Op50e8,Op50e8,Op50e8 ;@ 50e8
  .long Op50f0,Op50f0,Op50f0,Op50f0,Op50f0,Op50f0,Op50f0,Op50f0 ;@ 50f0
  .long Op50f8,Op50f9,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 50f8
  .long Op5100,Op5100,Op5100,Op5100,Op5100,Op5100,Op5100,Op5100 ;@ 5100
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 5108
  .long Op5110,Op5110,Op5110,Op5110,Op5110,Op5110,Op5110,Op5110 ;@ 5110
  .long Op5118,Op5118,Op5118,Op5118,Op5118,Op5118,Op5118,Op511f ;@ 5118
  .long Op5120,Op5120,Op5120,Op5120,Op5120,Op5120,Op5120,Op5127 ;@ 5120
  .long Op5128,Op5128,Op5128,Op5128,Op5128,Op5128,Op5128,Op5128 ;@ 5128
  .long Op5130,Op5130,Op5130,Op5130,Op5130,Op5130,Op5130,Op5130 ;@ 5130
  .long Op5138,Op5139,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 5138
  .long Op5140,Op5140,Op5140,Op5140,Op5140,Op5140,Op5140,Op5140 ;@ 5140
  .long Op5148,Op5148,Op5148,Op5148,Op5148,Op5148,Op5148,Op5148 ;@ 5148
  .long Op5150,Op5150,Op5150,Op5150,Op5150,Op5150,Op5150,Op5150 ;@ 5150
  .long Op5158,Op5158,Op5158,Op5158,Op5158,Op5158,Op5158,Op5158 ;@ 5158
  .long Op5160,Op5160,Op5160,Op5160,Op5160,Op5160,Op5160,Op5160 ;@ 5160
  .long Op5168,Op5168,Op5168,Op5168,Op5168,Op5168,Op5168,Op5168 ;@ 5168
  .long Op5170,Op5170,Op5170,Op5170,Op5170,Op5170,Op5170,Op5170 ;@ 5170
  .long Op5178,Op5179,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 5178
  .long Op5180,Op5180,Op5180,Op5180,Op5180,Op5180,Op5180,Op5180 ;@ 5180
  .long Op5188,Op5188,Op5188,Op5188,Op5188,Op5188,Op5188,Op5188 ;@ 5188
  .long Op5190,Op5190,Op5190,Op5190,Op5190,Op5190,Op5190,Op5190 ;@ 5190
  .long Op5198,Op5198,Op5198,Op5198,Op5198,Op5198,Op5198,Op5198 ;@ 5198
  .long Op51a0,Op51a0,Op51a0,Op51a0,Op51a0,Op51a0,Op51a0,Op51a0 ;@ 51a0
  .long Op51a8,Op51a8,Op51a8,Op51a8,Op51a8,Op51a8,Op51a8,Op51a8 ;@ 51a8
  .long Op51b0,Op51b0,Op51b0,Op51b0,Op51b0,Op51b0,Op51b0,Op51b0 ;@ 51b0
  .long Op51b8,Op51b9,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 51b8
  .long Op51c0,Op51c0,Op51c0,Op51c0,Op51c0,Op51c0,Op51c0,Op51c0 ;@ 51c0
  .long Op51c8,Op51c8,Op51c8,Op51c8,Op51c8,Op51c8,Op51c8,Op51c8 ;@ 51c8
  .long Op51d0,Op51d0,Op51d0,Op51d0,Op51d0,Op51d0,Op51d0,Op51d0 ;@ 51d0
  .long Op51d8,Op51d8,Op51d8,Op51d8,Op51d8,Op51d8,Op51d8,Op51df ;@ 51d8
  .long Op51e0,Op51e0,Op51e0,Op51e0,Op51e0,Op51e0,Op51e0,Op51e7 ;@ 51e0
  .long Op51e8,Op51e8,Op51e8,Op51e8,Op51e8,Op51e8,Op51e8,Op51e8 ;@ 51e8
  .long Op51f0,Op51f0,Op51f0,Op51f0,Op51f0,Op51f0,Op51f0,Op51f0 ;@ 51f0
  .long Op51f8,Op51f9,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 51f8
  .long Op5e00,Op5e00,Op5e00,Op5e00,Op5e00,Op5e00,Op5e00,Op5e00 ;@ 5200
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 5208
  .long Op5e10,Op5e10,Op5e10,Op5e10,Op5e10,Op5e10,Op5e10,Op5e10 ;@ 5210
  .long Op5e18,Op5e18,Op5e18,Op5e18,Op5e18,Op5e18,Op5e18,Op5e1f ;@ 5218
  .long Op5e20,Op5e20,Op5e20,Op5e20,Op5e20,Op5e20,Op5e20,Op5e27 ;@ 5220
  .long Op5e28,Op5e28,Op5e28,Op5e28,Op5e28,Op5e28,Op5e28,Op5e28 ;@ 5228
  .long Op5e30,Op5e30,Op5e30,Op5e30,Op5e30,Op5e30,Op5e30,Op5e30 ;@ 5230
  .long Op5e38,Op5e39,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 5238
  .long Op5e40,Op5e40,Op5e40,Op5e40,Op5e40,Op5e40,Op5e40,Op5e40 ;@ 5240
  .long Op5e48,Op5e48,Op5e48,Op5e48,Op5e48,Op5e48,Op5e48,Op5e48 ;@ 5248
  .long Op5e50,Op5e50,Op5e50,Op5e50,Op5e50,Op5e50,Op5e50,Op5e50 ;@ 5250
  .long Op5e58,Op5e58,Op5e58,Op5e58,Op5e58,Op5e58,Op5e58,Op5e58 ;@ 5258
  .long Op5e60,Op5e60,Op5e60,Op5e60,Op5e60,Op5e60,Op5e60,Op5e60 ;@ 5260
  .long Op5e68,Op5e68,Op5e68,Op5e68,Op5e68,Op5e68,Op5e68,Op5e68 ;@ 5268
  .long Op5e70,Op5e70,Op5e70,Op5e70,Op5e70,Op5e70,Op5e70,Op5e70 ;@ 5270
  .long Op5e78,Op5e79,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 5278
  .long Op5e80,Op5e80,Op5e80,Op5e80,Op5e80,Op5e80,Op5e80,Op5e80 ;@ 5280
  .long Op5e88,Op5e88,Op5e88,Op5e88,Op5e88,Op5e88,Op5e88,Op5e88 ;@ 5288
  .long Op5e90,Op5e90,Op5e90,Op5e90,Op5e90,Op5e90,Op5e90,Op5e90 ;@ 5290
  .long Op5e98,Op5e98,Op5e98,Op5e98,Op5e98,Op5e98,Op5e98,Op5e98 ;@ 5298
  .long Op5ea0,Op5ea0,Op5ea0,Op5ea0,Op5ea0,Op5ea0,Op5ea0,Op5ea0 ;@ 52a0
  .long Op5ea8,Op5ea8,Op5ea8,Op5ea8,Op5ea8,Op5ea8,Op5ea8,Op5ea8 ;@ 52a8
  .long Op5eb0,Op5eb0,Op5eb0,Op5eb0,Op5eb0,Op5eb0,Op5eb0,Op5eb0 ;@ 52b0
  .long Op5eb8,Op5eb9,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 52b8
  .long Op52c0,Op52c0,Op52c0,Op52c0,Op52c0,Op52c0,Op52c0,Op52c0 ;@ 52c0
  .long Op52c8,Op52c8,Op52c8,Op52c8,Op52c8,Op52c8,Op52c8,Op52c8 ;@ 52c8
  .long Op52d0,Op52d0,Op52d0,Op52d0,Op52d0,Op52d0,Op52d0,Op52d0 ;@ 52d0
  .long Op52d8,Op52d8,Op52d8,Op52d8,Op52d8,Op52d8,Op52d8,Op52df ;@ 52d8
  .long Op52e0,Op52e0,Op52e0,Op52e0,Op52e0,Op52e0,Op52e0,Op52e7 ;@ 52e0
  .long Op52e8,Op52e8,Op52e8,Op52e8,Op52e8,Op52e8,Op52e8,Op52e8 ;@ 52e8
  .long Op52f0,Op52f0,Op52f0,Op52f0,Op52f0,Op52f0,Op52f0,Op52f0 ;@ 52f0
  .long Op52f8,Op52f9,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 52f8
  .long Op5f00,Op5f00,Op5f00,Op5f00,Op5f00,Op5f00,Op5f00,Op5f00 ;@ 5300
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 5308
  .long Op5f10,Op5f10,Op5f10,Op5f10,Op5f10,Op5f10,Op5f10,Op5f10 ;@ 5310
  .long Op5f18,Op5f18,Op5f18,Op5f18,Op5f18,Op5f18,Op5f18,Op5f1f ;@ 5318
  .long Op5f20,Op5f20,Op5f20,Op5f20,Op5f20,Op5f20,Op5f20,Op5f27 ;@ 5320
  .long Op5f28,Op5f28,Op5f28,Op5f28,Op5f28,Op5f28,Op5f28,Op5f28 ;@ 5328
  .long Op5f30,Op5f30,Op5f30,Op5f30,Op5f30,Op5f30,Op5f30,Op5f30 ;@ 5330
  .long Op5f38,Op5f39,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 5338
  .long Op5f40,Op5f40,Op5f40,Op5f40,Op5f40,Op5f40,Op5f40,Op5f40 ;@ 5340
  .long Op5f48,Op5f48,Op5f48,Op5f48,Op5f48,Op5f48,Op5f48,Op5f48 ;@ 5348
  .long Op5f50,Op5f50,Op5f50,Op5f50,Op5f50,Op5f50,Op5f50,Op5f50 ;@ 5350
  .long Op5f58,Op5f58,Op5f58,Op5f58,Op5f58,Op5f58,Op5f58,Op5f58 ;@ 5358
  .long Op5f60,Op5f60,Op5f60,Op5f60,Op5f60,Op5f60,Op5f60,Op5f60 ;@ 5360
  .long Op5f68,Op5f68,Op5f68,Op5f68,Op5f68,Op5f68,Op5f68,Op5f68 ;@ 5368
  .long Op5f70,Op5f70,Op5f70,Op5f70,Op5f70,Op5f70,Op5f70,Op5f70 ;@ 5370
  .long Op5f78,Op5f79,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 5378
  .long Op5f80,Op5f80,Op5f80,Op5f80,Op5f80,Op5f80,Op5f80,Op5f80 ;@ 5380
  .long Op5f88,Op5f88,Op5f88,Op5f88,Op5f88,Op5f88,Op5f88,Op5f88 ;@ 5388
  .long Op5f90,Op5f90,Op5f90,Op5f90,Op5f90,Op5f90,Op5f90,Op5f90 ;@ 5390
  .long Op5f98,Op5f98,Op5f98,Op5f98,Op5f98,Op5f98,Op5f98,Op5f98 ;@ 5398
  .long Op5fa0,Op5fa0,Op5fa0,Op5fa0,Op5fa0,Op5fa0,Op5fa0,Op5fa0 ;@ 53a0
  .long Op5fa8,Op5fa8,Op5fa8,Op5fa8,Op5fa8,Op5fa8,Op5fa8,Op5fa8 ;@ 53a8
  .long Op5fb0,Op5fb0,Op5fb0,Op5fb0,Op5fb0,Op5fb0,Op5fb0,Op5fb0 ;@ 53b0
  .long Op5fb8,Op5fb9,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 53b8
  .long Op53c0,Op53c0,Op53c0,Op53c0,Op53c0,Op53c0,Op53c0,Op53c0 ;@ 53c0
  .long Op53c8,Op53c8,Op53c8,Op53c8,Op53c8,Op53c8,Op53c8,Op53c8 ;@ 53c8
  .long Op53d0,Op53d0,Op53d0,Op53d0,Op53d0,Op53d0,Op53d0,Op53d0 ;@ 53d0
  .long Op53d8,Op53d8,Op53d8,Op53d8,Op53d8,Op53d8,Op53d8,Op53df ;@ 53d8
  .long Op53e0,Op53e0,Op53e0,Op53e0,Op53e0,Op53e0,Op53e0,Op53e7 ;@ 53e0
  .long Op53e8,Op53e8,Op53e8,Op53e8,Op53e8,Op53e8,Op53e8,Op53e8 ;@ 53e8
  .long Op53f0,Op53f0,Op53f0,Op53f0,Op53f0,Op53f0,Op53f0,Op53f0 ;@ 53f0
  .long Op53f8,Op53f9,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 53f8
  .long Op5e00,Op5e00,Op5e00,Op5e00,Op5e00,Op5e00,Op5e00,Op5e00 ;@ 5400
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 5408
  .long Op5e10,Op5e10,Op5e10,Op5e10,Op5e10,Op5e10,Op5e10,Op5e10 ;@ 5410
  .long Op5e18,Op5e18,Op5e18,Op5e18,Op5e18,Op5e18,Op5e18,Op5e1f ;@ 5418
  .long Op5e20,Op5e20,Op5e20,Op5e20,Op5e20,Op5e20,Op5e20,Op5e27 ;@ 5420
  .long Op5e28,Op5e28,Op5e28,Op5e28,Op5e28,Op5e28,Op5e28,Op5e28 ;@ 5428
  .long Op5e30,Op5e30,Op5e30,Op5e30,Op5e30,Op5e30,Op5e30,Op5e30 ;@ 5430
  .long Op5e38,Op5e39,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 5438
  .long Op5e40,Op5e40,Op5e40,Op5e40,Op5e40,Op5e40,Op5e40,Op5e40 ;@ 5440
  .long Op5e48,Op5e48,Op5e48,Op5e48,Op5e48,Op5e48,Op5e48,Op5e48 ;@ 5448
  .long Op5e50,Op5e50,Op5e50,Op5e50,Op5e50,Op5e50,Op5e50,Op5e50 ;@ 5450
  .long Op5e58,Op5e58,Op5e58,Op5e58,Op5e58,Op5e58,Op5e58,Op5e58 ;@ 5458
  .long Op5e60,Op5e60,Op5e60,Op5e60,Op5e60,Op5e60,Op5e60,Op5e60 ;@ 5460
  .long Op5e68,Op5e68,Op5e68,Op5e68,Op5e68,Op5e68,Op5e68,Op5e68 ;@ 5468
  .long Op5e70,Op5e70,Op5e70,Op5e70,Op5e70,Op5e70,Op5e70,Op5e70 ;@ 5470
  .long Op5e78,Op5e79,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 5478
  .long Op5e80,Op5e80,Op5e80,Op5e80,Op5e80,Op5e80,Op5e80,Op5e80 ;@ 5480
  .long Op5e88,Op5e88,Op5e88,Op5e88,Op5e88,Op5e88,Op5e88,Op5e88 ;@ 5488
  .long Op5e90,Op5e90,Op5e90,Op5e90,Op5e90,Op5e90,Op5e90,Op5e90 ;@ 5490
  .long Op5e98,Op5e98,Op5e98,Op5e98,Op5e98,Op5e98,Op5e98,Op5e98 ;@ 5498
  .long Op5ea0,Op5ea0,Op5ea0,Op5ea0,Op5ea0,Op5ea0,Op5ea0,Op5ea0 ;@ 54a0
  .long Op5ea8,Op5ea8,Op5ea8,Op5ea8,Op5ea8,Op5ea8,Op5ea8,Op5ea8 ;@ 54a8
  .long Op5eb0,Op5eb0,Op5eb0,Op5eb0,Op5eb0,Op5eb0,Op5eb0,Op5eb0 ;@ 54b0
  .long Op5eb8,Op5eb9,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 54b8
  .long Op54c0,Op54c0,Op54c0,Op54c0,Op54c0,Op54c0,Op54c0,Op54c0 ;@ 54c0
  .long Op54c8,Op54c8,Op54c8,Op54c8,Op54c8,Op54c8,Op54c8,Op54c8 ;@ 54c8
  .long Op54d0,Op54d0,Op54d0,Op54d0,Op54d0,Op54d0,Op54d0,Op54d0 ;@ 54d0
  .long Op54d8,Op54d8,Op54d8,Op54d8,Op54d8,Op54d8,Op54d8,Op54df ;@ 54d8
  .long Op54e0,Op54e0,Op54e0,Op54e0,Op54e0,Op54e0,Op54e0,Op54e7 ;@ 54e0
  .long Op54e8,Op54e8,Op54e8,Op54e8,Op54e8,Op54e8,Op54e8,Op54e8 ;@ 54e8
  .long Op54f0,Op54f0,Op54f0,Op54f0,Op54f0,Op54f0,Op54f0,Op54f0 ;@ 54f0
  .long Op54f8,Op54f9,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 54f8
  .long Op5f00,Op5f00,Op5f00,Op5f00,Op5f00,Op5f00,Op5f00,Op5f00 ;@ 5500
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 5508
  .long Op5f10,Op5f10,Op5f10,Op5f10,Op5f10,Op5f10,Op5f10,Op5f10 ;@ 5510
  .long Op5f18,Op5f18,Op5f18,Op5f18,Op5f18,Op5f18,Op5f18,Op5f1f ;@ 5518
  .long Op5f20,Op5f20,Op5f20,Op5f20,Op5f20,Op5f20,Op5f20,Op5f27 ;@ 5520
  .long Op5f28,Op5f28,Op5f28,Op5f28,Op5f28,Op5f28,Op5f28,Op5f28 ;@ 5528
  .long Op5f30,Op5f30,Op5f30,Op5f30,Op5f30,Op5f30,Op5f30,Op5f30 ;@ 5530
  .long Op5f38,Op5f39,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 5538
  .long Op5f40,Op5f40,Op5f40,Op5f40,Op5f40,Op5f40,Op5f40,Op5f40 ;@ 5540
  .long Op5f48,Op5f48,Op5f48,Op5f48,Op5f48,Op5f48,Op5f48,Op5f48 ;@ 5548
  .long Op5f50,Op5f50,Op5f50,Op5f50,Op5f50,Op5f50,Op5f50,Op5f50 ;@ 5550
  .long Op5f58,Op5f58,Op5f58,Op5f58,Op5f58,Op5f58,Op5f58,Op5f58 ;@ 5558
  .long Op5f60,Op5f60,Op5f60,Op5f60,Op5f60,Op5f60,Op5f60,Op5f60 ;@ 5560
  .long Op5f68,Op5f68,Op5f68,Op5f68,Op5f68,Op5f68,Op5f68,Op5f68 ;@ 5568
  .long Op5f70,Op5f70,Op5f70,Op5f70,Op5f70,Op5f70,Op5f70,Op5f70 ;@ 5570
  .long Op5f78,Op5f79,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 5578
  .long Op5f80,Op5f80,Op5f80,Op5f80,Op5f80,Op5f80,Op5f80,Op5f80 ;@ 5580
  .long Op5f88,Op5f88,Op5f88,Op5f88,Op5f88,Op5f88,Op5f88,Op5f88 ;@ 5588
  .long Op5f90,Op5f90,Op5f90,Op5f90,Op5f90,Op5f90,Op5f90,Op5f90 ;@ 5590
  .long Op5f98,Op5f98,Op5f98,Op5f98,Op5f98,Op5f98,Op5f98,Op5f98 ;@ 5598
  .long Op5fa0,Op5fa0,Op5fa0,Op5fa0,Op5fa0,Op5fa0,Op5fa0,Op5fa0 ;@ 55a0
  .long Op5fa8,Op5fa8,Op5fa8,Op5fa8,Op5fa8,Op5fa8,Op5fa8,Op5fa8 ;@ 55a8
  .long Op5fb0,Op5fb0,Op5fb0,Op5fb0,Op5fb0,Op5fb0,Op5fb0,Op5fb0 ;@ 55b0
  .long Op5fb8,Op5fb9,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 55b8
  .long Op55c0,Op55c0,Op55c0,Op55c0,Op55c0,Op55c0,Op55c0,Op55c0 ;@ 55c0
  .long Op55c8,Op55c8,Op55c8,Op55c8,Op55c8,Op55c8,Op55c8,Op55c8 ;@ 55c8
  .long Op55d0,Op55d0,Op55d0,Op55d0,Op55d0,Op55d0,Op55d0,Op55d0 ;@ 55d0
  .long Op55d8,Op55d8,Op55d8,Op55d8,Op55d8,Op55d8,Op55d8,Op55df ;@ 55d8
  .long Op55e0,Op55e0,Op55e0,Op55e0,Op55e0,Op55e0,Op55e0,Op55e7 ;@ 55e0
  .long Op55e8,Op55e8,Op55e8,Op55e8,Op55e8,Op55e8,Op55e8,Op55e8 ;@ 55e8
  .long Op55f0,Op55f0,Op55f0,Op55f0,Op55f0,Op55f0,Op55f0,Op55f0 ;@ 55f0
  .long Op55f8,Op55f9,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 55f8
  .long Op5e00,Op5e00,Op5e00,Op5e00,Op5e00,Op5e00,Op5e00,Op5e00 ;@ 5600
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 5608
  .long Op5e10,Op5e10,Op5e10,Op5e10,Op5e10,Op5e10,Op5e10,Op5e10 ;@ 5610
  .long Op5e18,Op5e18,Op5e18,Op5e18,Op5e18,Op5e18,Op5e18,Op5e1f ;@ 5618
  .long Op5e20,Op5e20,Op5e20,Op5e20,Op5e20,Op5e20,Op5e20,Op5e27 ;@ 5620
  .long Op5e28,Op5e28,Op5e28,Op5e28,Op5e28,Op5e28,Op5e28,Op5e28 ;@ 5628
  .long Op5e30,Op5e30,Op5e30,Op5e30,Op5e30,Op5e30,Op5e30,Op5e30 ;@ 5630
  .long Op5e38,Op5e39,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 5638
  .long Op5e40,Op5e40,Op5e40,Op5e40,Op5e40,Op5e40,Op5e40,Op5e40 ;@ 5640
  .long Op5e48,Op5e48,Op5e48,Op5e48,Op5e48,Op5e48,Op5e48,Op5e48 ;@ 5648
  .long Op5e50,Op5e50,Op5e50,Op5e50,Op5e50,Op5e50,Op5e50,Op5e50 ;@ 5650
  .long Op5e58,Op5e58,Op5e58,Op5e58,Op5e58,Op5e58,Op5e58,Op5e58 ;@ 5658
  .long Op5e60,Op5e60,Op5e60,Op5e60,Op5e60,Op5e60,Op5e60,Op5e60 ;@ 5660
  .long Op5e68,Op5e68,Op5e68,Op5e68,Op5e68,Op5e68,Op5e68,Op5e68 ;@ 5668
  .long Op5e70,Op5e70,Op5e70,Op5e70,Op5e70,Op5e70,Op5e70,Op5e70 ;@ 5670
  .long Op5e78,Op5e79,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 5678
  .long Op5e80,Op5e80,Op5e80,Op5e80,Op5e80,Op5e80,Op5e80,Op5e80 ;@ 5680
  .long Op5e88,Op5e88,Op5e88,Op5e88,Op5e88,Op5e88,Op5e88,Op5e88 ;@ 5688
  .long Op5e90,Op5e90,Op5e90,Op5e90,Op5e90,Op5e90,Op5e90,Op5e90 ;@ 5690
  .long Op5e98,Op5e98,Op5e98,Op5e98,Op5e98,Op5e98,Op5e98,Op5e98 ;@ 5698
  .long Op5ea0,Op5ea0,Op5ea0,Op5ea0,Op5ea0,Op5ea0,Op5ea0,Op5ea0 ;@ 56a0
  .long Op5ea8,Op5ea8,Op5ea8,Op5ea8,Op5ea8,Op5ea8,Op5ea8,Op5ea8 ;@ 56a8
  .long Op5eb0,Op5eb0,Op5eb0,Op5eb0,Op5eb0,Op5eb0,Op5eb0,Op5eb0 ;@ 56b0
  .long Op5eb8,Op5eb9,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 56b8
  .long Op56c0,Op56c0,Op56c0,Op56c0,Op56c0,Op56c0,Op56c0,Op56c0 ;@ 56c0
  .long Op56c8,Op56c8,Op56c8,Op56c8,Op56c8,Op56c8,Op56c8,Op56c8 ;@ 56c8
  .long Op56d0,Op56d0,Op56d0,Op56d0,Op56d0,Op56d0,Op56d0,Op56d0 ;@ 56d0
  .long Op56d8,Op56d8,Op56d8,Op56d8,Op56d8,Op56d8,Op56d8,Op56df ;@ 56d8
  .long Op56e0,Op56e0,Op56e0,Op56e0,Op56e0,Op56e0,Op56e0,Op56e7 ;@ 56e0
  .long Op56e8,Op56e8,Op56e8,Op56e8,Op56e8,Op56e8,Op56e8,Op56e8 ;@ 56e8
  .long Op56f0,Op56f0,Op56f0,Op56f0,Op56f0,Op56f0,Op56f0,Op56f0 ;@ 56f0
  .long Op56f8,Op56f9,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 56f8
  .long Op5f00,Op5f00,Op5f00,Op5f00,Op5f00,Op5f00,Op5f00,Op5f00 ;@ 5700
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 5708
  .long Op5f10,Op5f10,Op5f10,Op5f10,Op5f10,Op5f10,Op5f10,Op5f10 ;@ 5710
  .long Op5f18,Op5f18,Op5f18,Op5f18,Op5f18,Op5f18,Op5f18,Op5f1f ;@ 5718
  .long Op5f20,Op5f20,Op5f20,Op5f20,Op5f20,Op5f20,Op5f20,Op5f27 ;@ 5720
  .long Op5f28,Op5f28,Op5f28,Op5f28,Op5f28,Op5f28,Op5f28,Op5f28 ;@ 5728
  .long Op5f30,Op5f30,Op5f30,Op5f30,Op5f30,Op5f30,Op5f30,Op5f30 ;@ 5730
  .long Op5f38,Op5f39,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 5738
  .long Op5f40,Op5f40,Op5f40,Op5f40,Op5f40,Op5f40,Op5f40,Op5f40 ;@ 5740
  .long Op5f48,Op5f48,Op5f48,Op5f48,Op5f48,Op5f48,Op5f48,Op5f48 ;@ 5748
  .long Op5f50,Op5f50,Op5f50,Op5f50,Op5f50,Op5f50,Op5f50,Op5f50 ;@ 5750
  .long Op5f58,Op5f58,Op5f58,Op5f58,Op5f58,Op5f58,Op5f58,Op5f58 ;@ 5758
  .long Op5f60,Op5f60,Op5f60,Op5f60,Op5f60,Op5f60,Op5f60,Op5f60 ;@ 5760
  .long Op5f68,Op5f68,Op5f68,Op5f68,Op5f68,Op5f68,Op5f68,Op5f68 ;@ 5768
  .long Op5f70,Op5f70,Op5f70,Op5f70,Op5f70,Op5f70,Op5f70,Op5f70 ;@ 5770
  .long Op5f78,Op5f79,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 5778
  .long Op5f80,Op5f80,Op5f80,Op5f80,Op5f80,Op5f80,Op5f80,Op5f80 ;@ 5780
  .long Op5f88,Op5f88,Op5f88,Op5f88,Op5f88,Op5f88,Op5f88,Op5f88 ;@ 5788
  .long Op5f90,Op5f90,Op5f90,Op5f90,Op5f90,Op5f90,Op5f90,Op5f90 ;@ 5790
  .long Op5f98,Op5f98,Op5f98,Op5f98,Op5f98,Op5f98,Op5f98,Op5f98 ;@ 5798
  .long Op5fa0,Op5fa0,Op5fa0,Op5fa0,Op5fa0,Op5fa0,Op5fa0,Op5fa0 ;@ 57a0
  .long Op5fa8,Op5fa8,Op5fa8,Op5fa8,Op5fa8,Op5fa8,Op5fa8,Op5fa8 ;@ 57a8
  .long Op5fb0,Op5fb0,Op5fb0,Op5fb0,Op5fb0,Op5fb0,Op5fb0,Op5fb0 ;@ 57b0
  .long Op5fb8,Op5fb9,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 57b8
  .long Op57c0,Op57c0,Op57c0,Op57c0,Op57c0,Op57c0,Op57c0,Op57c0 ;@ 57c0
  .long Op57c8,Op57c8,Op57c8,Op57c8,Op57c8,Op57c8,Op57c8,Op57c8 ;@ 57c8
  .long Op57d0,Op57d0,Op57d0,Op57d0,Op57d0,Op57d0,Op57d0,Op57d0 ;@ 57d0
  .long Op57d8,Op57d8,Op57d8,Op57d8,Op57d8,Op57d8,Op57d8,Op57df ;@ 57d8
  .long Op57e0,Op57e0,Op57e0,Op57e0,Op57e0,Op57e0,Op57e0,Op57e7 ;@ 57e0
  .long Op57e8,Op57e8,Op57e8,Op57e8,Op57e8,Op57e8,Op57e8,Op57e8 ;@ 57e8
  .long Op57f0,Op57f0,Op57f0,Op57f0,Op57f0,Op57f0,Op57f0,Op57f0 ;@ 57f0
  .long Op57f8,Op57f9,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 57f8
  .long Op5e00,Op5e00,Op5e00,Op5e00,Op5e00,Op5e00,Op5e00,Op5e00 ;@ 5800
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 5808
  .long Op5e10,Op5e10,Op5e10,Op5e10,Op5e10,Op5e10,Op5e10,Op5e10 ;@ 5810
  .long Op5e18,Op5e18,Op5e18,Op5e18,Op5e18,Op5e18,Op5e18,Op5e1f ;@ 5818
  .long Op5e20,Op5e20,Op5e20,Op5e20,Op5e20,Op5e20,Op5e20,Op5e27 ;@ 5820
  .long Op5e28,Op5e28,Op5e28,Op5e28,Op5e28,Op5e28,Op5e28,Op5e28 ;@ 5828
  .long Op5e30,Op5e30,Op5e30,Op5e30,Op5e30,Op5e30,Op5e30,Op5e30 ;@ 5830
  .long Op5e38,Op5e39,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 5838
  .long Op5e40,Op5e40,Op5e40,Op5e40,Op5e40,Op5e40,Op5e40,Op5e40 ;@ 5840
  .long Op5e48,Op5e48,Op5e48,Op5e48,Op5e48,Op5e48,Op5e48,Op5e48 ;@ 5848
  .long Op5e50,Op5e50,Op5e50,Op5e50,Op5e50,Op5e50,Op5e50,Op5e50 ;@ 5850
  .long Op5e58,Op5e58,Op5e58,Op5e58,Op5e58,Op5e58,Op5e58,Op5e58 ;@ 5858
  .long Op5e60,Op5e60,Op5e60,Op5e60,Op5e60,Op5e60,Op5e60,Op5e60 ;@ 5860
  .long Op5e68,Op5e68,Op5e68,Op5e68,Op5e68,Op5e68,Op5e68,Op5e68 ;@ 5868
  .long Op5e70,Op5e70,Op5e70,Op5e70,Op5e70,Op5e70,Op5e70,Op5e70 ;@ 5870
  .long Op5e78,Op5e79,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 5878
  .long Op5e80,Op5e80,Op5e80,Op5e80,Op5e80,Op5e80,Op5e80,Op5e80 ;@ 5880
  .long Op5e88,Op5e88,Op5e88,Op5e88,Op5e88,Op5e88,Op5e88,Op5e88 ;@ 5888
  .long Op5e90,Op5e90,Op5e90,Op5e90,Op5e90,Op5e90,Op5e90,Op5e90 ;@ 5890
  .long Op5e98,Op5e98,Op5e98,Op5e98,Op5e98,Op5e98,Op5e98,Op5e98 ;@ 5898
  .long Op5ea0,Op5ea0,Op5ea0,Op5ea0,Op5ea0,Op5ea0,Op5ea0,Op5ea0 ;@ 58a0
  .long Op5ea8,Op5ea8,Op5ea8,Op5ea8,Op5ea8,Op5ea8,Op5ea8,Op5ea8 ;@ 58a8
  .long Op5eb0,Op5eb0,Op5eb0,Op5eb0,Op5eb0,Op5eb0,Op5eb0,Op5eb0 ;@ 58b0
  .long Op5eb8,Op5eb9,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 58b8
  .long Op58c0,Op58c0,Op58c0,Op58c0,Op58c0,Op58c0,Op58c0,Op58c0 ;@ 58c0
  .long Op58c8,Op58c8,Op58c8,Op58c8,Op58c8,Op58c8,Op58c8,Op58c8 ;@ 58c8
  .long Op58d0,Op58d0,Op58d0,Op58d0,Op58d0,Op58d0,Op58d0,Op58d0 ;@ 58d0
  .long Op58d8,Op58d8,Op58d8,Op58d8,Op58d8,Op58d8,Op58d8,Op58df ;@ 58d8
  .long Op58e0,Op58e0,Op58e0,Op58e0,Op58e0,Op58e0,Op58e0,Op58e7 ;@ 58e0
  .long Op58e8,Op58e8,Op58e8,Op58e8,Op58e8,Op58e8,Op58e8,Op58e8 ;@ 58e8
  .long Op58f0,Op58f0,Op58f0,Op58f0,Op58f0,Op58f0,Op58f0,Op58f0 ;@ 58f0
  .long Op58f8,Op58f9,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 58f8
  .long Op5f00,Op5f00,Op5f00,Op5f00,Op5f00,Op5f00,Op5f00,Op5f00 ;@ 5900
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 5908
  .long Op5f10,Op5f10,Op5f10,Op5f10,Op5f10,Op5f10,Op5f10,Op5f10 ;@ 5910
  .long Op5f18,Op5f18,Op5f18,Op5f18,Op5f18,Op5f18,Op5f18,Op5f1f ;@ 5918
  .long Op5f20,Op5f20,Op5f20,Op5f20,Op5f20,Op5f20,Op5f20,Op5f27 ;@ 5920
  .long Op5f28,Op5f28,Op5f28,Op5f28,Op5f28,Op5f28,Op5f28,Op5f28 ;@ 5928
  .long Op5f30,Op5f30,Op5f30,Op5f30,Op5f30,Op5f30,Op5f30,Op5f30 ;@ 5930
  .long Op5f38,Op5f39,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 5938
  .long Op5f40,Op5f40,Op5f40,Op5f40,Op5f40,Op5f40,Op5f40,Op5f40 ;@ 5940
  .long Op5f48,Op5f48,Op5f48,Op5f48,Op5f48,Op5f48,Op5f48,Op5f48 ;@ 5948
  .long Op5f50,Op5f50,Op5f50,Op5f50,Op5f50,Op5f50,Op5f50,Op5f50 ;@ 5950
  .long Op5f58,Op5f58,Op5f58,Op5f58,Op5f58,Op5f58,Op5f58,Op5f58 ;@ 5958
  .long Op5f60,Op5f60,Op5f60,Op5f60,Op5f60,Op5f60,Op5f60,Op5f60 ;@ 5960
  .long Op5f68,Op5f68,Op5f68,Op5f68,Op5f68,Op5f68,Op5f68,Op5f68 ;@ 5968
  .long Op5f70,Op5f70,Op5f70,Op5f70,Op5f70,Op5f70,Op5f70,Op5f70 ;@ 5970
  .long Op5f78,Op5f79,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 5978
  .long Op5f80,Op5f80,Op5f80,Op5f80,Op5f80,Op5f80,Op5f80,Op5f80 ;@ 5980
  .long Op5f88,Op5f88,Op5f88,Op5f88,Op5f88,Op5f88,Op5f88,Op5f88 ;@ 5988
  .long Op5f90,Op5f90,Op5f90,Op5f90,Op5f90,Op5f90,Op5f90,Op5f90 ;@ 5990
  .long Op5f98,Op5f98,Op5f98,Op5f98,Op5f98,Op5f98,Op5f98,Op5f98 ;@ 5998
  .long Op5fa0,Op5fa0,Op5fa0,Op5fa0,Op5fa0,Op5fa0,Op5fa0,Op5fa0 ;@ 59a0
  .long Op5fa8,Op5fa8,Op5fa8,Op5fa8,Op5fa8,Op5fa8,Op5fa8,Op5fa8 ;@ 59a8
  .long Op5fb0,Op5fb0,Op5fb0,Op5fb0,Op5fb0,Op5fb0,Op5fb0,Op5fb0 ;@ 59b0
  .long Op5fb8,Op5fb9,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 59b8
  .long Op59c0,Op59c0,Op59c0,Op59c0,Op59c0,Op59c0,Op59c0,Op59c0 ;@ 59c0
  .long Op59c8,Op59c8,Op59c8,Op59c8,Op59c8,Op59c8,Op59c8,Op59c8 ;@ 59c8
  .long Op59d0,Op59d0,Op59d0,Op59d0,Op59d0,Op59d0,Op59d0,Op59d0 ;@ 59d0
  .long Op59d8,Op59d8,Op59d8,Op59d8,Op59d8,Op59d8,Op59d8,Op59df ;@ 59d8
  .long Op59e0,Op59e0,Op59e0,Op59e0,Op59e0,Op59e0,Op59e0,Op59e7 ;@ 59e0
  .long Op59e8,Op59e8,Op59e8,Op59e8,Op59e8,Op59e8,Op59e8,Op59e8 ;@ 59e8
  .long Op59f0,Op59f0,Op59f0,Op59f0,Op59f0,Op59f0,Op59f0,Op59f0 ;@ 59f0
  .long Op59f8,Op59f9,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 59f8
  .long Op5e00,Op5e00,Op5e00,Op5e00,Op5e00,Op5e00,Op5e00,Op5e00 ;@ 5a00
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 5a08
  .long Op5e10,Op5e10,Op5e10,Op5e10,Op5e10,Op5e10,Op5e10,Op5e10 ;@ 5a10
  .long Op5e18,Op5e18,Op5e18,Op5e18,Op5e18,Op5e18,Op5e18,Op5e1f ;@ 5a18
  .long Op5e20,Op5e20,Op5e20,Op5e20,Op5e20,Op5e20,Op5e20,Op5e27 ;@ 5a20
  .long Op5e28,Op5e28,Op5e28,Op5e28,Op5e28,Op5e28,Op5e28,Op5e28 ;@ 5a28
  .long Op5e30,Op5e30,Op5e30,Op5e30,Op5e30,Op5e30,Op5e30,Op5e30 ;@ 5a30
  .long Op5e38,Op5e39,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 5a38
  .long Op5e40,Op5e40,Op5e40,Op5e40,Op5e40,Op5e40,Op5e40,Op5e40 ;@ 5a40
  .long Op5e48,Op5e48,Op5e48,Op5e48,Op5e48,Op5e48,Op5e48,Op5e48 ;@ 5a48
  .long Op5e50,Op5e50,Op5e50,Op5e50,Op5e50,Op5e50,Op5e50,Op5e50 ;@ 5a50
  .long Op5e58,Op5e58,Op5e58,Op5e58,Op5e58,Op5e58,Op5e58,Op5e58 ;@ 5a58
  .long Op5e60,Op5e60,Op5e60,Op5e60,Op5e60,Op5e60,Op5e60,Op5e60 ;@ 5a60
  .long Op5e68,Op5e68,Op5e68,Op5e68,Op5e68,Op5e68,Op5e68,Op5e68 ;@ 5a68
  .long Op5e70,Op5e70,Op5e70,Op5e70,Op5e70,Op5e70,Op5e70,Op5e70 ;@ 5a70
  .long Op5e78,Op5e79,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 5a78
  .long Op5e80,Op5e80,Op5e80,Op5e80,Op5e80,Op5e80,Op5e80,Op5e80 ;@ 5a80
  .long Op5e88,Op5e88,Op5e88,Op5e88,Op5e88,Op5e88,Op5e88,Op5e88 ;@ 5a88
  .long Op5e90,Op5e90,Op5e90,Op5e90,Op5e90,Op5e90,Op5e90,Op5e90 ;@ 5a90
  .long Op5e98,Op5e98,Op5e98,Op5e98,Op5e98,Op5e98,Op5e98,Op5e98 ;@ 5a98
  .long Op5ea0,Op5ea0,Op5ea0,Op5ea0,Op5ea0,Op5ea0,Op5ea0,Op5ea0 ;@ 5aa0
  .long Op5ea8,Op5ea8,Op5ea8,Op5ea8,Op5ea8,Op5ea8,Op5ea8,Op5ea8 ;@ 5aa8
  .long Op5eb0,Op5eb0,Op5eb0,Op5eb0,Op5eb0,Op5eb0,Op5eb0,Op5eb0 ;@ 5ab0
  .long Op5eb8,Op5eb9,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 5ab8
  .long Op5ac0,Op5ac0,Op5ac0,Op5ac0,Op5ac0,Op5ac0,Op5ac0,Op5ac0 ;@ 5ac0
  .long Op5ac8,Op5ac8,Op5ac8,Op5ac8,Op5ac8,Op5ac8,Op5ac8,Op5ac8 ;@ 5ac8
  .long Op5ad0,Op5ad0,Op5ad0,Op5ad0,Op5ad0,Op5ad0,Op5ad0,Op5ad0 ;@ 5ad0
  .long Op5ad8,Op5ad8,Op5ad8,Op5ad8,Op5ad8,Op5ad8,Op5ad8,Op5adf ;@ 5ad8
  .long Op5ae0,Op5ae0,Op5ae0,Op5ae0,Op5ae0,Op5ae0,Op5ae0,Op5ae7 ;@ 5ae0
  .long Op5ae8,Op5ae8,Op5ae8,Op5ae8,Op5ae8,Op5ae8,Op5ae8,Op5ae8 ;@ 5ae8
  .long Op5af0,Op5af0,Op5af0,Op5af0,Op5af0,Op5af0,Op5af0,Op5af0 ;@ 5af0
  .long Op5af8,Op5af9,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 5af8
  .long Op5f00,Op5f00,Op5f00,Op5f00,Op5f00,Op5f00,Op5f00,Op5f00 ;@ 5b00
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 5b08
  .long Op5f10,Op5f10,Op5f10,Op5f10,Op5f10,Op5f10,Op5f10,Op5f10 ;@ 5b10
  .long Op5f18,Op5f18,Op5f18,Op5f18,Op5f18,Op5f18,Op5f18,Op5f1f ;@ 5b18
  .long Op5f20,Op5f20,Op5f20,Op5f20,Op5f20,Op5f20,Op5f20,Op5f27 ;@ 5b20
  .long Op5f28,Op5f28,Op5f28,Op5f28,Op5f28,Op5f28,Op5f28,Op5f28 ;@ 5b28
  .long Op5f30,Op5f30,Op5f30,Op5f30,Op5f30,Op5f30,Op5f30,Op5f30 ;@ 5b30
  .long Op5f38,Op5f39,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 5b38
  .long Op5f40,Op5f40,Op5f40,Op5f40,Op5f40,Op5f40,Op5f40,Op5f40 ;@ 5b40
  .long Op5f48,Op5f48,Op5f48,Op5f48,Op5f48,Op5f48,Op5f48,Op5f48 ;@ 5b48
  .long Op5f50,Op5f50,Op5f50,Op5f50,Op5f50,Op5f50,Op5f50,Op5f50 ;@ 5b50
  .long Op5f58,Op5f58,Op5f58,Op5f58,Op5f58,Op5f58,Op5f58,Op5f58 ;@ 5b58
  .long Op5f60,Op5f60,Op5f60,Op5f60,Op5f60,Op5f60,Op5f60,Op5f60 ;@ 5b60
  .long Op5f68,Op5f68,Op5f68,Op5f68,Op5f68,Op5f68,Op5f68,Op5f68 ;@ 5b68
  .long Op5f70,Op5f70,Op5f70,Op5f70,Op5f70,Op5f70,Op5f70,Op5f70 ;@ 5b70
  .long Op5f78,Op5f79,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 5b78
  .long Op5f80,Op5f80,Op5f80,Op5f80,Op5f80,Op5f80,Op5f80,Op5f80 ;@ 5b80
  .long Op5f88,Op5f88,Op5f88,Op5f88,Op5f88,Op5f88,Op5f88,Op5f88 ;@ 5b88
  .long Op5f90,Op5f90,Op5f90,Op5f90,Op5f90,Op5f90,Op5f90,Op5f90 ;@ 5b90
  .long Op5f98,Op5f98,Op5f98,Op5f98,Op5f98,Op5f98,Op5f98,Op5f98 ;@ 5b98
  .long Op5fa0,Op5fa0,Op5fa0,Op5fa0,Op5fa0,Op5fa0,Op5fa0,Op5fa0 ;@ 5ba0
  .long Op5fa8,Op5fa8,Op5fa8,Op5fa8,Op5fa8,Op5fa8,Op5fa8,Op5fa8 ;@ 5ba8
  .long Op5fb0,Op5fb0,Op5fb0,Op5fb0,Op5fb0,Op5fb0,Op5fb0,Op5fb0 ;@ 5bb0
  .long Op5fb8,Op5fb9,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 5bb8
  .long Op5bc0,Op5bc0,Op5bc0,Op5bc0,Op5bc0,Op5bc0,Op5bc0,Op5bc0 ;@ 5bc0
  .long Op5bc8,Op5bc8,Op5bc8,Op5bc8,Op5bc8,Op5bc8,Op5bc8,Op5bc8 ;@ 5bc8
  .long Op5bd0,Op5bd0,Op5bd0,Op5bd0,Op5bd0,Op5bd0,Op5bd0,Op5bd0 ;@ 5bd0
  .long Op5bd8,Op5bd8,Op5bd8,Op5bd8,Op5bd8,Op5bd8,Op5bd8,Op5bdf ;@ 5bd8
  .long Op5be0,Op5be0,Op5be0,Op5be0,Op5be0,Op5be0,Op5be0,Op5be7 ;@ 5be0
  .long Op5be8,Op5be8,Op5be8,Op5be8,Op5be8,Op5be8,Op5be8,Op5be8 ;@ 5be8
  .long Op5bf0,Op5bf0,Op5bf0,Op5bf0,Op5bf0,Op5bf0,Op5bf0,Op5bf0 ;@ 5bf0
  .long Op5bf8,Op5bf9,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 5bf8
  .long Op5e00,Op5e00,Op5e00,Op5e00,Op5e00,Op5e00,Op5e00,Op5e00 ;@ 5c00
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 5c08
  .long Op5e10,Op5e10,Op5e10,Op5e10,Op5e10,Op5e10,Op5e10,Op5e10 ;@ 5c10
  .long Op5e18,Op5e18,Op5e18,Op5e18,Op5e18,Op5e18,Op5e18,Op5e1f ;@ 5c18
  .long Op5e20,Op5e20,Op5e20,Op5e20,Op5e20,Op5e20,Op5e20,Op5e27 ;@ 5c20
  .long Op5e28,Op5e28,Op5e28,Op5e28,Op5e28,Op5e28,Op5e28,Op5e28 ;@ 5c28
  .long Op5e30,Op5e30,Op5e30,Op5e30,Op5e30,Op5e30,Op5e30,Op5e30 ;@ 5c30
  .long Op5e38,Op5e39,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 5c38
  .long Op5e40,Op5e40,Op5e40,Op5e40,Op5e40,Op5e40,Op5e40,Op5e40 ;@ 5c40
  .long Op5e48,Op5e48,Op5e48,Op5e48,Op5e48,Op5e48,Op5e48,Op5e48 ;@ 5c48
  .long Op5e50,Op5e50,Op5e50,Op5e50,Op5e50,Op5e50,Op5e50,Op5e50 ;@ 5c50
  .long Op5e58,Op5e58,Op5e58,Op5e58,Op5e58,Op5e58,Op5e58,Op5e58 ;@ 5c58
  .long Op5e60,Op5e60,Op5e60,Op5e60,Op5e60,Op5e60,Op5e60,Op5e60 ;@ 5c60
  .long Op5e68,Op5e68,Op5e68,Op5e68,Op5e68,Op5e68,Op5e68,Op5e68 ;@ 5c68
  .long Op5e70,Op5e70,Op5e70,Op5e70,Op5e70,Op5e70,Op5e70,Op5e70 ;@ 5c70
  .long Op5e78,Op5e79,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 5c78
  .long Op5e80,Op5e80,Op5e80,Op5e80,Op5e80,Op5e80,Op5e80,Op5e80 ;@ 5c80
  .long Op5e88,Op5e88,Op5e88,Op5e88,Op5e88,Op5e88,Op5e88,Op5e88 ;@ 5c88
  .long Op5e90,Op5e90,Op5e90,Op5e90,Op5e90,Op5e90,Op5e90,Op5e90 ;@ 5c90
  .long Op5e98,Op5e98,Op5e98,Op5e98,Op5e98,Op5e98,Op5e98,Op5e98 ;@ 5c98
  .long Op5ea0,Op5ea0,Op5ea0,Op5ea0,Op5ea0,Op5ea0,Op5ea0,Op5ea0 ;@ 5ca0
  .long Op5ea8,Op5ea8,Op5ea8,Op5ea8,Op5ea8,Op5ea8,Op5ea8,Op5ea8 ;@ 5ca8
  .long Op5eb0,Op5eb0,Op5eb0,Op5eb0,Op5eb0,Op5eb0,Op5eb0,Op5eb0 ;@ 5cb0
  .long Op5eb8,Op5eb9,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 5cb8
  .long Op5cc0,Op5cc0,Op5cc0,Op5cc0,Op5cc0,Op5cc0,Op5cc0,Op5cc0 ;@ 5cc0
  .long Op5cc8,Op5cc8,Op5cc8,Op5cc8,Op5cc8,Op5cc8,Op5cc8,Op5cc8 ;@ 5cc8
  .long Op5cd0,Op5cd0,Op5cd0,Op5cd0,Op5cd0,Op5cd0,Op5cd0,Op5cd0 ;@ 5cd0
  .long Op5cd8,Op5cd8,Op5cd8,Op5cd8,Op5cd8,Op5cd8,Op5cd8,Op5cdf ;@ 5cd8
  .long Op5ce0,Op5ce0,Op5ce0,Op5ce0,Op5ce0,Op5ce0,Op5ce0,Op5ce7 ;@ 5ce0
  .long Op5ce8,Op5ce8,Op5ce8,Op5ce8,Op5ce8,Op5ce8,Op5ce8,Op5ce8 ;@ 5ce8
  .long Op5cf0,Op5cf0,Op5cf0,Op5cf0,Op5cf0,Op5cf0,Op5cf0,Op5cf0 ;@ 5cf0
  .long Op5cf8,Op5cf9,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 5cf8
  .long Op5f00,Op5f00,Op5f00,Op5f00,Op5f00,Op5f00,Op5f00,Op5f00 ;@ 5d00
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 5d08
  .long Op5f10,Op5f10,Op5f10,Op5f10,Op5f10,Op5f10,Op5f10,Op5f10 ;@ 5d10
  .long Op5f18,Op5f18,Op5f18,Op5f18,Op5f18,Op5f18,Op5f18,Op5f1f ;@ 5d18
  .long Op5f20,Op5f20,Op5f20,Op5f20,Op5f20,Op5f20,Op5f20,Op5f27 ;@ 5d20
  .long Op5f28,Op5f28,Op5f28,Op5f28,Op5f28,Op5f28,Op5f28,Op5f28 ;@ 5d28
  .long Op5f30,Op5f30,Op5f30,Op5f30,Op5f30,Op5f30,Op5f30,Op5f30 ;@ 5d30
  .long Op5f38,Op5f39,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 5d38
  .long Op5f40,Op5f40,Op5f40,Op5f40,Op5f40,Op5f40,Op5f40,Op5f40 ;@ 5d40
  .long Op5f48,Op5f48,Op5f48,Op5f48,Op5f48,Op5f48,Op5f48,Op5f48 ;@ 5d48
  .long Op5f50,Op5f50,Op5f50,Op5f50,Op5f50,Op5f50,Op5f50,Op5f50 ;@ 5d50
  .long Op5f58,Op5f58,Op5f58,Op5f58,Op5f58,Op5f58,Op5f58,Op5f58 ;@ 5d58
  .long Op5f60,Op5f60,Op5f60,Op5f60,Op5f60,Op5f60,Op5f60,Op5f60 ;@ 5d60
  .long Op5f68,Op5f68,Op5f68,Op5f68,Op5f68,Op5f68,Op5f68,Op5f68 ;@ 5d68
  .long Op5f70,Op5f70,Op5f70,Op5f70,Op5f70,Op5f70,Op5f70,Op5f70 ;@ 5d70
  .long Op5f78,Op5f79,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 5d78
  .long Op5f80,Op5f80,Op5f80,Op5f80,Op5f80,Op5f80,Op5f80,Op5f80 ;@ 5d80
  .long Op5f88,Op5f88,Op5f88,Op5f88,Op5f88,Op5f88,Op5f88,Op5f88 ;@ 5d88
  .long Op5f90,Op5f90,Op5f90,Op5f90,Op5f90,Op5f90,Op5f90,Op5f90 ;@ 5d90
  .long Op5f98,Op5f98,Op5f98,Op5f98,Op5f98,Op5f98,Op5f98,Op5f98 ;@ 5d98
  .long Op5fa0,Op5fa0,Op5fa0,Op5fa0,Op5fa0,Op5fa0,Op5fa0,Op5fa0 ;@ 5da0
  .long Op5fa8,Op5fa8,Op5fa8,Op5fa8,Op5fa8,Op5fa8,Op5fa8,Op5fa8 ;@ 5da8
  .long Op5fb0,Op5fb0,Op5fb0,Op5fb0,Op5fb0,Op5fb0,Op5fb0,Op5fb0 ;@ 5db0
  .long Op5fb8,Op5fb9,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 5db8
  .long Op5dc0,Op5dc0,Op5dc0,Op5dc0,Op5dc0,Op5dc0,Op5dc0,Op5dc0 ;@ 5dc0
  .long Op5dc8,Op5dc8,Op5dc8,Op5dc8,Op5dc8,Op5dc8,Op5dc8,Op5dc8 ;@ 5dc8
  .long Op5dd0,Op5dd0,Op5dd0,Op5dd0,Op5dd0,Op5dd0,Op5dd0,Op5dd0 ;@ 5dd0
  .long Op5dd8,Op5dd8,Op5dd8,Op5dd8,Op5dd8,Op5dd8,Op5dd8,Op5ddf ;@ 5dd8
  .long Op5de0,Op5de0,Op5de0,Op5de0,Op5de0,Op5de0,Op5de0,Op5de7 ;@ 5de0
  .long Op5de8,Op5de8,Op5de8,Op5de8,Op5de8,Op5de8,Op5de8,Op5de8 ;@ 5de8
  .long Op5df0,Op5df0,Op5df0,Op5df0,Op5df0,Op5df0,Op5df0,Op5df0 ;@ 5df0
  .long Op5df8,Op5df9,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 5df8
  .long Op5e00,Op5e00,Op5e00,Op5e00,Op5e00,Op5e00,Op5e00,Op5e00 ;@ 5e00
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 5e08
  .long Op5e10,Op5e10,Op5e10,Op5e10,Op5e10,Op5e10,Op5e10,Op5e10 ;@ 5e10
  .long Op5e18,Op5e18,Op5e18,Op5e18,Op5e18,Op5e18,Op5e18,Op5e1f ;@ 5e18
  .long Op5e20,Op5e20,Op5e20,Op5e20,Op5e20,Op5e20,Op5e20,Op5e27 ;@ 5e20
  .long Op5e28,Op5e28,Op5e28,Op5e28,Op5e28,Op5e28,Op5e28,Op5e28 ;@ 5e28
  .long Op5e30,Op5e30,Op5e30,Op5e30,Op5e30,Op5e30,Op5e30,Op5e30 ;@ 5e30
  .long Op5e38,Op5e39,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 5e38
  .long Op5e40,Op5e40,Op5e40,Op5e40,Op5e40,Op5e40,Op5e40,Op5e40 ;@ 5e40
  .long Op5e48,Op5e48,Op5e48,Op5e48,Op5e48,Op5e48,Op5e48,Op5e48 ;@ 5e48
  .long Op5e50,Op5e50,Op5e50,Op5e50,Op5e50,Op5e50,Op5e50,Op5e50 ;@ 5e50
  .long Op5e58,Op5e58,Op5e58,Op5e58,Op5e58,Op5e58,Op5e58,Op5e58 ;@ 5e58
  .long Op5e60,Op5e60,Op5e60,Op5e60,Op5e60,Op5e60,Op5e60,Op5e60 ;@ 5e60
  .long Op5e68,Op5e68,Op5e68,Op5e68,Op5e68,Op5e68,Op5e68,Op5e68 ;@ 5e68
  .long Op5e70,Op5e70,Op5e70,Op5e70,Op5e70,Op5e70,Op5e70,Op5e70 ;@ 5e70
  .long Op5e78,Op5e79,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 5e78
  .long Op5e80,Op5e80,Op5e80,Op5e80,Op5e80,Op5e80,Op5e80,Op5e80 ;@ 5e80
  .long Op5e88,Op5e88,Op5e88,Op5e88,Op5e88,Op5e88,Op5e88,Op5e88 ;@ 5e88
  .long Op5e90,Op5e90,Op5e90,Op5e90,Op5e90,Op5e90,Op5e90,Op5e90 ;@ 5e90
  .long Op5e98,Op5e98,Op5e98,Op5e98,Op5e98,Op5e98,Op5e98,Op5e98 ;@ 5e98
  .long Op5ea0,Op5ea0,Op5ea0,Op5ea0,Op5ea0,Op5ea0,Op5ea0,Op5ea0 ;@ 5ea0
  .long Op5ea8,Op5ea8,Op5ea8,Op5ea8,Op5ea8,Op5ea8,Op5ea8,Op5ea8 ;@ 5ea8
  .long Op5eb0,Op5eb0,Op5eb0,Op5eb0,Op5eb0,Op5eb0,Op5eb0,Op5eb0 ;@ 5eb0
  .long Op5eb8,Op5eb9,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 5eb8
  .long Op5ec0,Op5ec0,Op5ec0,Op5ec0,Op5ec0,Op5ec0,Op5ec0,Op5ec0 ;@ 5ec0
  .long Op5ec8,Op5ec8,Op5ec8,Op5ec8,Op5ec8,Op5ec8,Op5ec8,Op5ec8 ;@ 5ec8
  .long Op5ed0,Op5ed0,Op5ed0,Op5ed0,Op5ed0,Op5ed0,Op5ed0,Op5ed0 ;@ 5ed0
  .long Op5ed8,Op5ed8,Op5ed8,Op5ed8,Op5ed8,Op5ed8,Op5ed8,Op5edf ;@ 5ed8
  .long Op5ee0,Op5ee0,Op5ee0,Op5ee0,Op5ee0,Op5ee0,Op5ee0,Op5ee7 ;@ 5ee0
  .long Op5ee8,Op5ee8,Op5ee8,Op5ee8,Op5ee8,Op5ee8,Op5ee8,Op5ee8 ;@ 5ee8
  .long Op5ef0,Op5ef0,Op5ef0,Op5ef0,Op5ef0,Op5ef0,Op5ef0,Op5ef0 ;@ 5ef0
  .long Op5ef8,Op5ef9,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 5ef8
  .long Op5f00,Op5f00,Op5f00,Op5f00,Op5f00,Op5f00,Op5f00,Op5f00 ;@ 5f00
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 5f08
  .long Op5f10,Op5f10,Op5f10,Op5f10,Op5f10,Op5f10,Op5f10,Op5f10 ;@ 5f10
  .long Op5f18,Op5f18,Op5f18,Op5f18,Op5f18,Op5f18,Op5f18,Op5f1f ;@ 5f18
  .long Op5f20,Op5f20,Op5f20,Op5f20,Op5f20,Op5f20,Op5f20,Op5f27 ;@ 5f20
  .long Op5f28,Op5f28,Op5f28,Op5f28,Op5f28,Op5f28,Op5f28,Op5f28 ;@ 5f28
  .long Op5f30,Op5f30,Op5f30,Op5f30,Op5f30,Op5f30,Op5f30,Op5f30 ;@ 5f30
  .long Op5f38,Op5f39,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 5f38
  .long Op5f40,Op5f40,Op5f40,Op5f40,Op5f40,Op5f40,Op5f40,Op5f40 ;@ 5f40
  .long Op5f48,Op5f48,Op5f48,Op5f48,Op5f48,Op5f48,Op5f48,Op5f48 ;@ 5f48
  .long Op5f50,Op5f50,Op5f50,Op5f50,Op5f50,Op5f50,Op5f50,Op5f50 ;@ 5f50
  .long Op5f58,Op5f58,Op5f58,Op5f58,Op5f58,Op5f58,Op5f58,Op5f58 ;@ 5f58
  .long Op5f60,Op5f60,Op5f60,Op5f60,Op5f60,Op5f60,Op5f60,Op5f60 ;@ 5f60
  .long Op5f68,Op5f68,Op5f68,Op5f68,Op5f68,Op5f68,Op5f68,Op5f68 ;@ 5f68
  .long Op5f70,Op5f70,Op5f70,Op5f70,Op5f70,Op5f70,Op5f70,Op5f70 ;@ 5f70
  .long Op5f78,Op5f79,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 5f78
  .long Op5f80,Op5f80,Op5f80,Op5f80,Op5f80,Op5f80,Op5f80,Op5f80 ;@ 5f80
  .long Op5f88,Op5f88,Op5f88,Op5f88,Op5f88,Op5f88,Op5f88,Op5f88 ;@ 5f88
  .long Op5f90,Op5f90,Op5f90,Op5f90,Op5f90,Op5f90,Op5f90,Op5f90 ;@ 5f90
  .long Op5f98,Op5f98,Op5f98,Op5f98,Op5f98,Op5f98,Op5f98,Op5f98 ;@ 5f98
  .long Op5fa0,Op5fa0,Op5fa0,Op5fa0,Op5fa0,Op5fa0,Op5fa0,Op5fa0 ;@ 5fa0
  .long Op5fa8,Op5fa8,Op5fa8,Op5fa8,Op5fa8,Op5fa8,Op5fa8,Op5fa8 ;@ 5fa8
  .long Op5fb0,Op5fb0,Op5fb0,Op5fb0,Op5fb0,Op5fb0,Op5fb0,Op5fb0 ;@ 5fb0
  .long Op5fb8,Op5fb9,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 5fb8
  .long Op5fc0,Op5fc0,Op5fc0,Op5fc0,Op5fc0,Op5fc0,Op5fc0,Op5fc0 ;@ 5fc0
  .long Op5fc8,Op5fc8,Op5fc8,Op5fc8,Op5fc8,Op5fc8,Op5fc8,Op5fc8 ;@ 5fc8
  .long Op5fd0,Op5fd0,Op5fd0,Op5fd0,Op5fd0,Op5fd0,Op5fd0,Op5fd0 ;@ 5fd0
  .long Op5fd8,Op5fd8,Op5fd8,Op5fd8,Op5fd8,Op5fd8,Op5fd8,Op5fdf ;@ 5fd8
  .long Op5fe0,Op5fe0,Op5fe0,Op5fe0,Op5fe0,Op5fe0,Op5fe0,Op5fe7 ;@ 5fe0
  .long Op5fe8,Op5fe8,Op5fe8,Op5fe8,Op5fe8,Op5fe8,Op5fe8,Op5fe8 ;@ 5fe8
  .long Op5ff0,Op5ff0,Op5ff0,Op5ff0,Op5ff0,Op5ff0,Op5ff0,Op5ff0 ;@ 5ff0
  .long Op5ff8,Op5ff9,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 5ff8
  .long Op6000,Op6003,Op6002,Op6003,Op6002,Op6003,Op6002,Op6003 ;@ 6000
  .long Op6002,Op6003,Op6002,Op6003,Op6002,Op6003,Op6002,Op6003 ;@ 6008
  .long Op6002,Op6003,Op6002,Op6003,Op6002,Op6003,Op6002,Op6003 ;@ 6010
  .long Op6002,Op6003,Op6002,Op6003,Op6002,Op6003,Op6002,Op6003 ;@ 6018
  .long Op6002,Op6003,Op6002,Op6003,Op6002,Op6003,Op6002,Op6003 ;@ 6020
  .long Op6002,Op6003,Op6002,Op6003,Op6002,Op6003,Op6002,Op6003 ;@ 6028
  .long Op6002,Op6003,Op6002,Op6003,Op6002,Op6003,Op6002,Op6003 ;@ 6030
  .long Op6002,Op6003,Op6002,Op6003,Op6002,Op6003,Op6002,Op6003 ;@ 6038
  .long Op6002,Op6003,Op6002,Op6003,Op6002,Op6003,Op6002,Op6003 ;@ 6040
  .long Op6002,Op6003,Op6002,Op6003,Op6002,Op6003,Op6002,Op6003 ;@ 6048
  .long Op6002,Op6003,Op6002,Op6003,Op6002,Op6003,Op6002,Op6003 ;@ 6050
  .long Op6002,Op6003,Op6002,Op6003,Op6002,Op6003,Op6002,Op6003 ;@ 6058
  .long Op6002,Op6003,Op6002,Op6003,Op6002,Op6003,Op6002,Op6003 ;@ 6060
  .long Op6002,Op6003,Op6002,Op6003,Op6002,Op6003,Op6002,Op6003 ;@ 6068
  .long Op6002,Op6003,Op6002,Op6003,Op6002,Op6003,Op6002,Op6003 ;@ 6070
  .long Op6002,Op6003,Op6002,Op6003,Op6002,Op6003,Op6002,Op6003 ;@ 6078
  .long Op6002,Op6003,Op6002,Op6003,Op6002,Op6003,Op6002,Op6003 ;@ 6080
  .long Op6002,Op6003,Op6002,Op6003,Op6002,Op6003,Op6002,Op6003 ;@ 6088
  .long Op6002,Op6003,Op6002,Op6003,Op6002,Op6003,Op6002,Op6003 ;@ 6090
  .long Op6002,Op6003,Op6002,Op6003,Op6002,Op6003,Op6002,Op6003 ;@ 6098
  .long Op6002,Op6003,Op6002,Op6003,Op6002,Op6003,Op6002,Op6003 ;@ 60a0
  .long Op6002,Op6003,Op6002,Op6003,Op6002,Op6003,Op6002,Op6003 ;@ 60a8
  .long Op6002,Op6003,Op6002,Op6003,Op6002,Op6003,Op6002,Op6003 ;@ 60b0
  .long Op6002,Op6003,Op6002,Op6003,Op6002,Op6003,Op6002,Op6003 ;@ 60b8
  .long Op6002,Op6003,Op6002,Op6003,Op6002,Op6003,Op6002,Op6003 ;@ 60c0
  .long Op6002,Op6003,Op6002,Op6003,Op6002,Op6003,Op6002,Op6003 ;@ 60c8
  .long Op6002,Op6003,Op6002,Op6003,Op6002,Op6003,Op6002,Op6003 ;@ 60d0
  .long Op6002,Op6003,Op6002,Op6003,Op6002,Op6003,Op6002,Op6003 ;@ 60d8
  .long Op6002,Op6003,Op6002,Op6003,Op6002,Op6003,Op6002,Op6003 ;@ 60e0
  .long Op6002,Op6003,Op6002,Op6003,Op6002,Op6003,Op6002,Op6003 ;@ 60e8
  .long Op6002,Op6003,Op6002,Op6003,Op6002,Op6003,Op6002,Op6003 ;@ 60f0
  .long Op6002,Op6003,Op6002,Op6003,Op6002,Op6003,Op6002,Op6003 ;@ 60f8
  .long Op6100,Op6103,Op6102,Op6103,Op6102,Op6103,Op6102,Op6103 ;@ 6100
  .long Op6102,Op6103,Op6102,Op6103,Op6102,Op6103,Op6102,Op6103 ;@ 6108
  .long Op6102,Op6103,Op6102,Op6103,Op6102,Op6103,Op6102,Op6103 ;@ 6110
  .long Op6102,Op6103,Op6102,Op6103,Op6102,Op6103,Op6102,Op6103 ;@ 6118
  .long Op6102,Op6103,Op6102,Op6103,Op6102,Op6103,Op6102,Op6103 ;@ 6120
  .long Op6102,Op6103,Op6102,Op6103,Op6102,Op6103,Op6102,Op6103 ;@ 6128
  .long Op6102,Op6103,Op6102,Op6103,Op6102,Op6103,Op6102,Op6103 ;@ 6130
  .long Op6102,Op6103,Op6102,Op6103,Op6102,Op6103,Op6102,Op6103 ;@ 6138
  .long Op6102,Op6103,Op6102,Op6103,Op6102,Op6103,Op6102,Op6103 ;@ 6140
  .long Op6102,Op6103,Op6102,Op6103,Op6102,Op6103,Op6102,Op6103 ;@ 6148
  .long Op6102,Op6103,Op6102,Op6103,Op6102,Op6103,Op6102,Op6103 ;@ 6150
  .long Op6102,Op6103,Op6102,Op6103,Op6102,Op6103,Op6102,Op6103 ;@ 6158
  .long Op6102,Op6103,Op6102,Op6103,Op6102,Op6103,Op6102,Op6103 ;@ 6160
  .long Op6102,Op6103,Op6102,Op6103,Op6102,Op6103,Op6102,Op6103 ;@ 6168
  .long Op6102,Op6103,Op6102,Op6103,Op6102,Op6103,Op6102,Op6103 ;@ 6170
  .long Op6102,Op6103,Op6102,Op6103,Op6102,Op6103,Op6102,Op6103 ;@ 6178
  .long Op6102,Op6103,Op6102,Op6103,Op6102,Op6103,Op6102,Op6103 ;@ 6180
  .long Op6102,Op6103,Op6102,Op6103,Op6102,Op6103,Op6102,Op6103 ;@ 6188
  .long Op6102,Op6103,Op6102,Op6103,Op6102,Op6103,Op6102,Op6103 ;@ 6190
  .long Op6102,Op6103,Op6102,Op6103,Op6102,Op6103,Op6102,Op6103 ;@ 6198
  .long Op6102,Op6103,Op6102,Op6103,Op6102,Op6103,Op6102,Op6103 ;@ 61a0
  .long Op6102,Op6103,Op6102,Op6103,Op6102,Op6103,Op6102,Op6103 ;@ 61a8
  .long Op6102,Op6103,Op6102,Op6103,Op6102,Op6103,Op6102,Op6103 ;@ 61b0
  .long Op6102,Op6103,Op6102,Op6103,Op6102,Op6103,Op6102,Op6103 ;@ 61b8
  .long Op6102,Op6103,Op6102,Op6103,Op6102,Op6103,Op6102,Op6103 ;@ 61c0
  .long Op6102,Op6103,Op6102,Op6103,Op6102,Op6103,Op6102,Op6103 ;@ 61c8
  .long Op6102,Op6103,Op6102,Op6103,Op6102,Op6103,Op6102,Op6103 ;@ 61d0
  .long Op6102,Op6103,Op6102,Op6103,Op6102,Op6103,Op6102,Op6103 ;@ 61d8
  .long Op6102,Op6103,Op6102,Op6103,Op6102,Op6103,Op6102,Op6103 ;@ 61e0
  .long Op6102,Op6103,Op6102,Op6103,Op6102,Op6103,Op6102,Op6103 ;@ 61e8
  .long Op6102,Op6103,Op6102,Op6103,Op6102,Op6103,Op6102,Op6103 ;@ 61f0
  .long Op6102,Op6103,Op6102,Op6103,Op6102,Op6103,Op6102,Op6103 ;@ 61f8
  .long Op6200,Op6203,Op6202,Op6203,Op6202,Op6203,Op6202,Op6203 ;@ 6200
  .long Op6202,Op6203,Op6202,Op6203,Op6202,Op6203,Op6202,Op6203 ;@ 6208
  .long Op6202,Op6203,Op6202,Op6203,Op6202,Op6203,Op6202,Op6203 ;@ 6210
  .long Op6202,Op6203,Op6202,Op6203,Op6202,Op6203,Op6202,Op6203 ;@ 6218
  .long Op6202,Op6203,Op6202,Op6203,Op6202,Op6203,Op6202,Op6203 ;@ 6220
  .long Op6202,Op6203,Op6202,Op6203,Op6202,Op6203,Op6202,Op6203 ;@ 6228
  .long Op6202,Op6203,Op6202,Op6203,Op6202,Op6203,Op6202,Op6203 ;@ 6230
  .long Op6202,Op6203,Op6202,Op6203,Op6202,Op6203,Op6202,Op6203 ;@ 6238
  .long Op6202,Op6203,Op6202,Op6203,Op6202,Op6203,Op6202,Op6203 ;@ 6240
  .long Op6202,Op6203,Op6202,Op6203,Op6202,Op6203,Op6202,Op6203 ;@ 6248
  .long Op6202,Op6203,Op6202,Op6203,Op6202,Op6203,Op6202,Op6203 ;@ 6250
  .long Op6202,Op6203,Op6202,Op6203,Op6202,Op6203,Op6202,Op6203 ;@ 6258
  .long Op6202,Op6203,Op6202,Op6203,Op6202,Op6203,Op6202,Op6203 ;@ 6260
  .long Op6202,Op6203,Op6202,Op6203,Op6202,Op6203,Op6202,Op6203 ;@ 6268
  .long Op6202,Op6203,Op6202,Op6203,Op6202,Op6203,Op6202,Op6203 ;@ 6270
  .long Op6202,Op6203,Op6202,Op6203,Op6202,Op6203,Op6202,Op6203 ;@ 6278
  .long Op6202,Op6203,Op6202,Op6203,Op6202,Op6203,Op6202,Op6203 ;@ 6280
  .long Op6202,Op6203,Op6202,Op6203,Op6202,Op6203,Op6202,Op6203 ;@ 6288
  .long Op6202,Op6203,Op6202,Op6203,Op6202,Op6203,Op6202,Op6203 ;@ 6290
  .long Op6202,Op6203,Op6202,Op6203,Op6202,Op6203,Op6202,Op6203 ;@ 6298
  .long Op6202,Op6203,Op6202,Op6203,Op6202,Op6203,Op6202,Op6203 ;@ 62a0
  .long Op6202,Op6203,Op6202,Op6203,Op6202,Op6203,Op6202,Op6203 ;@ 62a8
  .long Op6202,Op6203,Op6202,Op6203,Op6202,Op6203,Op6202,Op6203 ;@ 62b0
  .long Op6202,Op6203,Op6202,Op6203,Op6202,Op6203,Op6202,Op6203 ;@ 62b8
  .long Op6202,Op6203,Op6202,Op6203,Op6202,Op6203,Op6202,Op6203 ;@ 62c0
  .long Op6202,Op6203,Op6202,Op6203,Op6202,Op6203,Op6202,Op6203 ;@ 62c8
  .long Op6202,Op6203,Op6202,Op6203,Op6202,Op6203,Op6202,Op6203 ;@ 62d0
  .long Op6202,Op6203,Op6202,Op6203,Op6202,Op6203,Op6202,Op6203 ;@ 62d8
  .long Op6202,Op6203,Op6202,Op6203,Op6202,Op6203,Op6202,Op6203 ;@ 62e0
  .long Op6202,Op6203,Op6202,Op6203,Op6202,Op6203,Op6202,Op6203 ;@ 62e8
  .long Op6202,Op6203,Op6202,Op6203,Op6202,Op6203,Op6202,Op6203 ;@ 62f0
  .long Op6202,Op6203,Op6202,Op6203,Op6202,Op6203,Op6202,Op6203 ;@ 62f8
  .long Op6300,Op6303,Op6302,Op6303,Op6302,Op6303,Op6302,Op6303 ;@ 6300
  .long Op6302,Op6303,Op6302,Op6303,Op6302,Op6303,Op6302,Op6303 ;@ 6308
  .long Op6302,Op6303,Op6302,Op6303,Op6302,Op6303,Op6302,Op6303 ;@ 6310
  .long Op6302,Op6303,Op6302,Op6303,Op6302,Op6303,Op6302,Op6303 ;@ 6318
  .long Op6302,Op6303,Op6302,Op6303,Op6302,Op6303,Op6302,Op6303 ;@ 6320
  .long Op6302,Op6303,Op6302,Op6303,Op6302,Op6303,Op6302,Op6303 ;@ 6328
  .long Op6302,Op6303,Op6302,Op6303,Op6302,Op6303,Op6302,Op6303 ;@ 6330
  .long Op6302,Op6303,Op6302,Op6303,Op6302,Op6303,Op6302,Op6303 ;@ 6338
  .long Op6302,Op6303,Op6302,Op6303,Op6302,Op6303,Op6302,Op6303 ;@ 6340
  .long Op6302,Op6303,Op6302,Op6303,Op6302,Op6303,Op6302,Op6303 ;@ 6348
  .long Op6302,Op6303,Op6302,Op6303,Op6302,Op6303,Op6302,Op6303 ;@ 6350
  .long Op6302,Op6303,Op6302,Op6303,Op6302,Op6303,Op6302,Op6303 ;@ 6358
  .long Op6302,Op6303,Op6302,Op6303,Op6302,Op6303,Op6302,Op6303 ;@ 6360
  .long Op6302,Op6303,Op6302,Op6303,Op6302,Op6303,Op6302,Op6303 ;@ 6368
  .long Op6302,Op6303,Op6302,Op6303,Op6302,Op6303,Op6302,Op6303 ;@ 6370
  .long Op6302,Op6303,Op6302,Op6303,Op6302,Op6303,Op6302,Op6303 ;@ 6378
  .long Op6302,Op6303,Op6302,Op6303,Op6302,Op6303,Op6302,Op6303 ;@ 6380
  .long Op6302,Op6303,Op6302,Op6303,Op6302,Op6303,Op6302,Op6303 ;@ 6388
  .long Op6302,Op6303,Op6302,Op6303,Op6302,Op6303,Op6302,Op6303 ;@ 6390
  .long Op6302,Op6303,Op6302,Op6303,Op6302,Op6303,Op6302,Op6303 ;@ 6398
  .long Op6302,Op6303,Op6302,Op6303,Op6302,Op6303,Op6302,Op6303 ;@ 63a0
  .long Op6302,Op6303,Op6302,Op6303,Op6302,Op6303,Op6302,Op6303 ;@ 63a8
  .long Op6302,Op6303,Op6302,Op6303,Op6302,Op6303,Op6302,Op6303 ;@ 63b0
  .long Op6302,Op6303,Op6302,Op6303,Op6302,Op6303,Op6302,Op6303 ;@ 63b8
  .long Op6302,Op6303,Op6302,Op6303,Op6302,Op6303,Op6302,Op6303 ;@ 63c0
  .long Op6302,Op6303,Op6302,Op6303,Op6302,Op6303,Op6302,Op6303 ;@ 63c8
  .long Op6302,Op6303,Op6302,Op6303,Op6302,Op6303,Op6302,Op6303 ;@ 63d0
  .long Op6302,Op6303,Op6302,Op6303,Op6302,Op6303,Op6302,Op6303 ;@ 63d8
  .long Op6302,Op6303,Op6302,Op6303,Op6302,Op6303,Op6302,Op6303 ;@ 63e0
  .long Op6302,Op6303,Op6302,Op6303,Op6302,Op6303,Op6302,Op6303 ;@ 63e8
  .long Op6302,Op6303,Op6302,Op6303,Op6302,Op6303,Op6302,Op6303 ;@ 63f0
  .long Op6302,Op6303,Op6302,Op6303,Op6302,Op6303,Op6302,Op6303 ;@ 63f8
  .long Op6400,Op6403,Op6402,Op6403,Op6402,Op6403,Op6402,Op6403 ;@ 6400
  .long Op6402,Op6403,Op6402,Op6403,Op6402,Op6403,Op6402,Op6403 ;@ 6408
  .long Op6402,Op6403,Op6402,Op6403,Op6402,Op6403,Op6402,Op6403 ;@ 6410
  .long Op6402,Op6403,Op6402,Op6403,Op6402,Op6403,Op6402,Op6403 ;@ 6418
  .long Op6402,Op6403,Op6402,Op6403,Op6402,Op6403,Op6402,Op6403 ;@ 6420
  .long Op6402,Op6403,Op6402,Op6403,Op6402,Op6403,Op6402,Op6403 ;@ 6428
  .long Op6402,Op6403,Op6402,Op6403,Op6402,Op6403,Op6402,Op6403 ;@ 6430
  .long Op6402,Op6403,Op6402,Op6403,Op6402,Op6403,Op6402,Op6403 ;@ 6438
  .long Op6402,Op6403,Op6402,Op6403,Op6402,Op6403,Op6402,Op6403 ;@ 6440
  .long Op6402,Op6403,Op6402,Op6403,Op6402,Op6403,Op6402,Op6403 ;@ 6448
  .long Op6402,Op6403,Op6402,Op6403,Op6402,Op6403,Op6402,Op6403 ;@ 6450
  .long Op6402,Op6403,Op6402,Op6403,Op6402,Op6403,Op6402,Op6403 ;@ 6458
  .long Op6402,Op6403,Op6402,Op6403,Op6402,Op6403,Op6402,Op6403 ;@ 6460
  .long Op6402,Op6403,Op6402,Op6403,Op6402,Op6403,Op6402,Op6403 ;@ 6468
  .long Op6402,Op6403,Op6402,Op6403,Op6402,Op6403,Op6402,Op6403 ;@ 6470
  .long Op6402,Op6403,Op6402,Op6403,Op6402,Op6403,Op6402,Op6403 ;@ 6478
  .long Op6402,Op6403,Op6402,Op6403,Op6402,Op6403,Op6402,Op6403 ;@ 6480
  .long Op6402,Op6403,Op6402,Op6403,Op6402,Op6403,Op6402,Op6403 ;@ 6488
  .long Op6402,Op6403,Op6402,Op6403,Op6402,Op6403,Op6402,Op6403 ;@ 6490
  .long Op6402,Op6403,Op6402,Op6403,Op6402,Op6403,Op6402,Op6403 ;@ 6498
  .long Op6402,Op6403,Op6402,Op6403,Op6402,Op6403,Op6402,Op6403 ;@ 64a0
  .long Op6402,Op6403,Op6402,Op6403,Op6402,Op6403,Op6402,Op6403 ;@ 64a8
  .long Op6402,Op6403,Op6402,Op6403,Op6402,Op6403,Op6402,Op6403 ;@ 64b0
  .long Op6402,Op6403,Op6402,Op6403,Op6402,Op6403,Op6402,Op6403 ;@ 64b8
  .long Op6402,Op6403,Op6402,Op6403,Op6402,Op6403,Op6402,Op6403 ;@ 64c0
  .long Op6402,Op6403,Op6402,Op6403,Op6402,Op6403,Op6402,Op6403 ;@ 64c8
  .long Op6402,Op6403,Op6402,Op6403,Op6402,Op6403,Op6402,Op6403 ;@ 64d0
  .long Op6402,Op6403,Op6402,Op6403,Op6402,Op6403,Op6402,Op6403 ;@ 64d8
  .long Op6402,Op6403,Op6402,Op6403,Op6402,Op6403,Op6402,Op6403 ;@ 64e0
  .long Op6402,Op6403,Op6402,Op6403,Op6402,Op6403,Op6402,Op6403 ;@ 64e8
  .long Op6402,Op6403,Op6402,Op6403,Op6402,Op6403,Op6402,Op6403 ;@ 64f0
  .long Op6402,Op6403,Op6402,Op6403,Op6402,Op6403,Op6402,Op6403 ;@ 64f8
  .long Op6500,Op6503,Op6502,Op6503,Op6502,Op6503,Op6502,Op6503 ;@ 6500
  .long Op6502,Op6503,Op6502,Op6503,Op6502,Op6503,Op6502,Op6503 ;@ 6508
  .long Op6502,Op6503,Op6502,Op6503,Op6502,Op6503,Op6502,Op6503 ;@ 6510
  .long Op6502,Op6503,Op6502,Op6503,Op6502,Op6503,Op6502,Op6503 ;@ 6518
  .long Op6502,Op6503,Op6502,Op6503,Op6502,Op6503,Op6502,Op6503 ;@ 6520
  .long Op6502,Op6503,Op6502,Op6503,Op6502,Op6503,Op6502,Op6503 ;@ 6528
  .long Op6502,Op6503,Op6502,Op6503,Op6502,Op6503,Op6502,Op6503 ;@ 6530
  .long Op6502,Op6503,Op6502,Op6503,Op6502,Op6503,Op6502,Op6503 ;@ 6538
  .long Op6502,Op6503,Op6502,Op6503,Op6502,Op6503,Op6502,Op6503 ;@ 6540
  .long Op6502,Op6503,Op6502,Op6503,Op6502,Op6503,Op6502,Op6503 ;@ 6548
  .long Op6502,Op6503,Op6502,Op6503,Op6502,Op6503,Op6502,Op6503 ;@ 6550
  .long Op6502,Op6503,Op6502,Op6503,Op6502,Op6503,Op6502,Op6503 ;@ 6558
  .long Op6502,Op6503,Op6502,Op6503,Op6502,Op6503,Op6502,Op6503 ;@ 6560
  .long Op6502,Op6503,Op6502,Op6503,Op6502,Op6503,Op6502,Op6503 ;@ 6568
  .long Op6502,Op6503,Op6502,Op6503,Op6502,Op6503,Op6502,Op6503 ;@ 6570
  .long Op6502,Op6503,Op6502,Op6503,Op6502,Op6503,Op6502,Op6503 ;@ 6578
  .long Op6502,Op6503,Op6502,Op6503,Op6502,Op6503,Op6502,Op6503 ;@ 6580
  .long Op6502,Op6503,Op6502,Op6503,Op6502,Op6503,Op6502,Op6503 ;@ 6588
  .long Op6502,Op6503,Op6502,Op6503,Op6502,Op6503,Op6502,Op6503 ;@ 6590
  .long Op6502,Op6503,Op6502,Op6503,Op6502,Op6503,Op6502,Op6503 ;@ 6598
  .long Op6502,Op6503,Op6502,Op6503,Op6502,Op6503,Op6502,Op6503 ;@ 65a0
  .long Op6502,Op6503,Op6502,Op6503,Op6502,Op6503,Op6502,Op6503 ;@ 65a8
  .long Op6502,Op6503,Op6502,Op6503,Op6502,Op6503,Op6502,Op6503 ;@ 65b0
  .long Op6502,Op6503,Op6502,Op6503,Op6502,Op6503,Op6502,Op6503 ;@ 65b8
  .long Op6502,Op6503,Op6502,Op6503,Op6502,Op6503,Op6502,Op6503 ;@ 65c0
  .long Op6502,Op6503,Op6502,Op6503,Op6502,Op6503,Op6502,Op6503 ;@ 65c8
  .long Op6502,Op6503,Op6502,Op6503,Op6502,Op6503,Op6502,Op6503 ;@ 65d0
  .long Op6502,Op6503,Op6502,Op6503,Op6502,Op6503,Op6502,Op6503 ;@ 65d8
  .long Op6502,Op6503,Op6502,Op6503,Op6502,Op6503,Op6502,Op6503 ;@ 65e0
  .long Op6502,Op6503,Op6502,Op6503,Op6502,Op6503,Op6502,Op6503 ;@ 65e8
  .long Op6502,Op6503,Op6502,Op6503,Op6502,Op6503,Op6502,Op6503 ;@ 65f0
  .long Op6502,Op6503,Op6502,Op6503,Op6502,Op6503,Op6502,Op6503 ;@ 65f8
  .long Op6600,Op6603,Op6602,Op6603,Op6602,Op6603,Op6602,Op6603 ;@ 6600
  .long Op6602,Op6603,Op6602,Op6603,Op6602,Op6603,Op6602,Op6603 ;@ 6608
  .long Op6602,Op6603,Op6602,Op6603,Op6602,Op6603,Op6602,Op6603 ;@ 6610
  .long Op6602,Op6603,Op6602,Op6603,Op6602,Op6603,Op6602,Op6603 ;@ 6618
  .long Op6602,Op6603,Op6602,Op6603,Op6602,Op6603,Op6602,Op6603 ;@ 6620
  .long Op6602,Op6603,Op6602,Op6603,Op6602,Op6603,Op6602,Op6603 ;@ 6628
  .long Op6602,Op6603,Op6602,Op6603,Op6602,Op6603,Op6602,Op6603 ;@ 6630
  .long Op6602,Op6603,Op6602,Op6603,Op6602,Op6603,Op6602,Op6603 ;@ 6638
  .long Op6602,Op6603,Op6602,Op6603,Op6602,Op6603,Op6602,Op6603 ;@ 6640
  .long Op6602,Op6603,Op6602,Op6603,Op6602,Op6603,Op6602,Op6603 ;@ 6648
  .long Op6602,Op6603,Op6602,Op6603,Op6602,Op6603,Op6602,Op6603 ;@ 6650
  .long Op6602,Op6603,Op6602,Op6603,Op6602,Op6603,Op6602,Op6603 ;@ 6658
  .long Op6602,Op6603,Op6602,Op6603,Op6602,Op6603,Op6602,Op6603 ;@ 6660
  .long Op6602,Op6603,Op6602,Op6603,Op6602,Op6603,Op6602,Op6603 ;@ 6668
  .long Op6602,Op6603,Op6602,Op6603,Op6602,Op6603,Op6602,Op6603 ;@ 6670
  .long Op6602,Op6603,Op6602,Op6603,Op6602,Op6603,Op6602,Op6603 ;@ 6678
  .long Op6602,Op6603,Op6602,Op6603,Op6602,Op6603,Op6602,Op6603 ;@ 6680
  .long Op6602,Op6603,Op6602,Op6603,Op6602,Op6603,Op6602,Op6603 ;@ 6688
  .long Op6602,Op6603,Op6602,Op6603,Op6602,Op6603,Op6602,Op6603 ;@ 6690
  .long Op6602,Op6603,Op6602,Op6603,Op6602,Op6603,Op6602,Op6603 ;@ 6698
  .long Op6602,Op6603,Op6602,Op6603,Op6602,Op6603,Op6602,Op6603 ;@ 66a0
  .long Op6602,Op6603,Op6602,Op6603,Op6602,Op6603,Op6602,Op6603 ;@ 66a8
  .long Op6602,Op6603,Op6602,Op6603,Op6602,Op6603,Op6602,Op6603 ;@ 66b0
  .long Op6602,Op6603,Op6602,Op6603,Op6602,Op6603,Op6602,Op6603 ;@ 66b8
  .long Op6602,Op6603,Op6602,Op6603,Op6602,Op6603,Op6602,Op6603 ;@ 66c0
  .long Op6602,Op6603,Op6602,Op6603,Op6602,Op6603,Op6602,Op6603 ;@ 66c8
  .long Op6602,Op6603,Op6602,Op6603,Op6602,Op6603,Op6602,Op6603 ;@ 66d0
  .long Op6602,Op6603,Op6602,Op6603,Op6602,Op6603,Op6602,Op6603 ;@ 66d8
  .long Op6602,Op6603,Op6602,Op6603,Op6602,Op6603,Op6602,Op6603 ;@ 66e0
  .long Op6602,Op6603,Op6602,Op6603,Op6602,Op6603,Op6602,Op6603 ;@ 66e8
  .long Op6602,Op6603,Op6602,Op6603,Op6602,Op6603,Op6602,Op6603 ;@ 66f0
  .long Op6602,Op6603,Op6602,Op6603,Op6602,Op6603,Op6602,Op6603 ;@ 66f8
  .long Op6700,Op6703,Op6702,Op6703,Op6702,Op6703,Op6702,Op6703 ;@ 6700
  .long Op6702,Op6703,Op6702,Op6703,Op6702,Op6703,Op6702,Op6703 ;@ 6708
  .long Op6702,Op6703,Op6702,Op6703,Op6702,Op6703,Op6702,Op6703 ;@ 6710
  .long Op6702,Op6703,Op6702,Op6703,Op6702,Op6703,Op6702,Op6703 ;@ 6718
  .long Op6702,Op6703,Op6702,Op6703,Op6702,Op6703,Op6702,Op6703 ;@ 6720
  .long Op6702,Op6703,Op6702,Op6703,Op6702,Op6703,Op6702,Op6703 ;@ 6728
  .long Op6702,Op6703,Op6702,Op6703,Op6702,Op6703,Op6702,Op6703 ;@ 6730
  .long Op6702,Op6703,Op6702,Op6703,Op6702,Op6703,Op6702,Op6703 ;@ 6738
  .long Op6702,Op6703,Op6702,Op6703,Op6702,Op6703,Op6702,Op6703 ;@ 6740
  .long Op6702,Op6703,Op6702,Op6703,Op6702,Op6703,Op6702,Op6703 ;@ 6748
  .long Op6702,Op6703,Op6702,Op6703,Op6702,Op6703,Op6702,Op6703 ;@ 6750
  .long Op6702,Op6703,Op6702,Op6703,Op6702,Op6703,Op6702,Op6703 ;@ 6758
  .long Op6702,Op6703,Op6702,Op6703,Op6702,Op6703,Op6702,Op6703 ;@ 6760
  .long Op6702,Op6703,Op6702,Op6703,Op6702,Op6703,Op6702,Op6703 ;@ 6768
  .long Op6702,Op6703,Op6702,Op6703,Op6702,Op6703,Op6702,Op6703 ;@ 6770
  .long Op6702,Op6703,Op6702,Op6703,Op6702,Op6703,Op6702,Op6703 ;@ 6778
  .long Op6702,Op6703,Op6702,Op6703,Op6702,Op6703,Op6702,Op6703 ;@ 6780
  .long Op6702,Op6703,Op6702,Op6703,Op6702,Op6703,Op6702,Op6703 ;@ 6788
  .long Op6702,Op6703,Op6702,Op6703,Op6702,Op6703,Op6702,Op6703 ;@ 6790
  .long Op6702,Op6703,Op6702,Op6703,Op6702,Op6703,Op6702,Op6703 ;@ 6798
  .long Op6702,Op6703,Op6702,Op6703,Op6702,Op6703,Op6702,Op6703 ;@ 67a0
  .long Op6702,Op6703,Op6702,Op6703,Op6702,Op6703,Op6702,Op6703 ;@ 67a8
  .long Op6702,Op6703,Op6702,Op6703,Op6702,Op6703,Op6702,Op6703 ;@ 67b0
  .long Op6702,Op6703,Op6702,Op6703,Op6702,Op6703,Op6702,Op6703 ;@ 67b8
  .long Op6702,Op6703,Op6702,Op6703,Op6702,Op6703,Op6702,Op6703 ;@ 67c0
  .long Op6702,Op6703,Op6702,Op6703,Op6702,Op6703,Op6702,Op6703 ;@ 67c8
  .long Op6702,Op6703,Op6702,Op6703,Op6702,Op6703,Op6702,Op6703 ;@ 67d0
  .long Op6702,Op6703,Op6702,Op6703,Op6702,Op6703,Op6702,Op6703 ;@ 67d8
  .long Op6702,Op6703,Op6702,Op6703,Op6702,Op6703,Op6702,Op6703 ;@ 67e0
  .long Op6702,Op6703,Op6702,Op6703,Op6702,Op6703,Op6702,Op6703 ;@ 67e8
  .long Op6702,Op6703,Op6702,Op6703,Op6702,Op6703,Op6702,Op6703 ;@ 67f0
  .long Op6702,Op6703,Op6702,Op6703,Op6702,Op6703,Op6702,Op6703 ;@ 67f8
  .long Op6800,Op6803,Op6802,Op6803,Op6802,Op6803,Op6802,Op6803 ;@ 6800
  .long Op6802,Op6803,Op6802,Op6803,Op6802,Op6803,Op6802,Op6803 ;@ 6808
  .long Op6802,Op6803,Op6802,Op6803,Op6802,Op6803,Op6802,Op6803 ;@ 6810
  .long Op6802,Op6803,Op6802,Op6803,Op6802,Op6803,Op6802,Op6803 ;@ 6818
  .long Op6802,Op6803,Op6802,Op6803,Op6802,Op6803,Op6802,Op6803 ;@ 6820
  .long Op6802,Op6803,Op6802,Op6803,Op6802,Op6803,Op6802,Op6803 ;@ 6828
  .long Op6802,Op6803,Op6802,Op6803,Op6802,Op6803,Op6802,Op6803 ;@ 6830
  .long Op6802,Op6803,Op6802,Op6803,Op6802,Op6803,Op6802,Op6803 ;@ 6838
  .long Op6802,Op6803,Op6802,Op6803,Op6802,Op6803,Op6802,Op6803 ;@ 6840
  .long Op6802,Op6803,Op6802,Op6803,Op6802,Op6803,Op6802,Op6803 ;@ 6848
  .long Op6802,Op6803,Op6802,Op6803,Op6802,Op6803,Op6802,Op6803 ;@ 6850
  .long Op6802,Op6803,Op6802,Op6803,Op6802,Op6803,Op6802,Op6803 ;@ 6858
  .long Op6802,Op6803,Op6802,Op6803,Op6802,Op6803,Op6802,Op6803 ;@ 6860
  .long Op6802,Op6803,Op6802,Op6803,Op6802,Op6803,Op6802,Op6803 ;@ 6868
  .long Op6802,Op6803,Op6802,Op6803,Op6802,Op6803,Op6802,Op6803 ;@ 6870
  .long Op6802,Op6803,Op6802,Op6803,Op6802,Op6803,Op6802,Op6803 ;@ 6878
  .long Op6802,Op6803,Op6802,Op6803,Op6802,Op6803,Op6802,Op6803 ;@ 6880
  .long Op6802,Op6803,Op6802,Op6803,Op6802,Op6803,Op6802,Op6803 ;@ 6888
  .long Op6802,Op6803,Op6802,Op6803,Op6802,Op6803,Op6802,Op6803 ;@ 6890
  .long Op6802,Op6803,Op6802,Op6803,Op6802,Op6803,Op6802,Op6803 ;@ 6898
  .long Op6802,Op6803,Op6802,Op6803,Op6802,Op6803,Op6802,Op6803 ;@ 68a0
  .long Op6802,Op6803,Op6802,Op6803,Op6802,Op6803,Op6802,Op6803 ;@ 68a8
  .long Op6802,Op6803,Op6802,Op6803,Op6802,Op6803,Op6802,Op6803 ;@ 68b0
  .long Op6802,Op6803,Op6802,Op6803,Op6802,Op6803,Op6802,Op6803 ;@ 68b8
  .long Op6802,Op6803,Op6802,Op6803,Op6802,Op6803,Op6802,Op6803 ;@ 68c0
  .long Op6802,Op6803,Op6802,Op6803,Op6802,Op6803,Op6802,Op6803 ;@ 68c8
  .long Op6802,Op6803,Op6802,Op6803,Op6802,Op6803,Op6802,Op6803 ;@ 68d0
  .long Op6802,Op6803,Op6802,Op6803,Op6802,Op6803,Op6802,Op6803 ;@ 68d8
  .long Op6802,Op6803,Op6802,Op6803,Op6802,Op6803,Op6802,Op6803 ;@ 68e0
  .long Op6802,Op6803,Op6802,Op6803,Op6802,Op6803,Op6802,Op6803 ;@ 68e8
  .long Op6802,Op6803,Op6802,Op6803,Op6802,Op6803,Op6802,Op6803 ;@ 68f0
  .long Op6802,Op6803,Op6802,Op6803,Op6802,Op6803,Op6802,Op6803 ;@ 68f8
  .long Op6900,Op6903,Op6902,Op6903,Op6902,Op6903,Op6902,Op6903 ;@ 6900
  .long Op6902,Op6903,Op6902,Op6903,Op6902,Op6903,Op6902,Op6903 ;@ 6908
  .long Op6902,Op6903,Op6902,Op6903,Op6902,Op6903,Op6902,Op6903 ;@ 6910
  .long Op6902,Op6903,Op6902,Op6903,Op6902,Op6903,Op6902,Op6903 ;@ 6918
  .long Op6902,Op6903,Op6902,Op6903,Op6902,Op6903,Op6902,Op6903 ;@ 6920
  .long Op6902,Op6903,Op6902,Op6903,Op6902,Op6903,Op6902,Op6903 ;@ 6928
  .long Op6902,Op6903,Op6902,Op6903,Op6902,Op6903,Op6902,Op6903 ;@ 6930
  .long Op6902,Op6903,Op6902,Op6903,Op6902,Op6903,Op6902,Op6903 ;@ 6938
  .long Op6902,Op6903,Op6902,Op6903,Op6902,Op6903,Op6902,Op6903 ;@ 6940
  .long Op6902,Op6903,Op6902,Op6903,Op6902,Op6903,Op6902,Op6903 ;@ 6948
  .long Op6902,Op6903,Op6902,Op6903,Op6902,Op6903,Op6902,Op6903 ;@ 6950
  .long Op6902,Op6903,Op6902,Op6903,Op6902,Op6903,Op6902,Op6903 ;@ 6958
  .long Op6902,Op6903,Op6902,Op6903,Op6902,Op6903,Op6902,Op6903 ;@ 6960
  .long Op6902,Op6903,Op6902,Op6903,Op6902,Op6903,Op6902,Op6903 ;@ 6968
  .long Op6902,Op6903,Op6902,Op6903,Op6902,Op6903,Op6902,Op6903 ;@ 6970
  .long Op6902,Op6903,Op6902,Op6903,Op6902,Op6903,Op6902,Op6903 ;@ 6978
  .long Op6902,Op6903,Op6902,Op6903,Op6902,Op6903,Op6902,Op6903 ;@ 6980
  .long Op6902,Op6903,Op6902,Op6903,Op6902,Op6903,Op6902,Op6903 ;@ 6988
  .long Op6902,Op6903,Op6902,Op6903,Op6902,Op6903,Op6902,Op6903 ;@ 6990
  .long Op6902,Op6903,Op6902,Op6903,Op6902,Op6903,Op6902,Op6903 ;@ 6998
  .long Op6902,Op6903,Op6902,Op6903,Op6902,Op6903,Op6902,Op6903 ;@ 69a0
  .long Op6902,Op6903,Op6902,Op6903,Op6902,Op6903,Op6902,Op6903 ;@ 69a8
  .long Op6902,Op6903,Op6902,Op6903,Op6902,Op6903,Op6902,Op6903 ;@ 69b0
  .long Op6902,Op6903,Op6902,Op6903,Op6902,Op6903,Op6902,Op6903 ;@ 69b8
  .long Op6902,Op6903,Op6902,Op6903,Op6902,Op6903,Op6902,Op6903 ;@ 69c0
  .long Op6902,Op6903,Op6902,Op6903,Op6902,Op6903,Op6902,Op6903 ;@ 69c8
  .long Op6902,Op6903,Op6902,Op6903,Op6902,Op6903,Op6902,Op6903 ;@ 69d0
  .long Op6902,Op6903,Op6902,Op6903,Op6902,Op6903,Op6902,Op6903 ;@ 69d8
  .long Op6902,Op6903,Op6902,Op6903,Op6902,Op6903,Op6902,Op6903 ;@ 69e0
  .long Op6902,Op6903,Op6902,Op6903,Op6902,Op6903,Op6902,Op6903 ;@ 69e8
  .long Op6902,Op6903,Op6902,Op6903,Op6902,Op6903,Op6902,Op6903 ;@ 69f0
  .long Op6902,Op6903,Op6902,Op6903,Op6902,Op6903,Op6902,Op6903 ;@ 69f8
  .long Op6a00,Op6a03,Op6a02,Op6a03,Op6a02,Op6a03,Op6a02,Op6a03 ;@ 6a00
  .long Op6a02,Op6a03,Op6a02,Op6a03,Op6a02,Op6a03,Op6a02,Op6a03 ;@ 6a08
  .long Op6a02,Op6a03,Op6a02,Op6a03,Op6a02,Op6a03,Op6a02,Op6a03 ;@ 6a10
  .long Op6a02,Op6a03,Op6a02,Op6a03,Op6a02,Op6a03,Op6a02,Op6a03 ;@ 6a18
  .long Op6a02,Op6a03,Op6a02,Op6a03,Op6a02,Op6a03,Op6a02,Op6a03 ;@ 6a20
  .long Op6a02,Op6a03,Op6a02,Op6a03,Op6a02,Op6a03,Op6a02,Op6a03 ;@ 6a28
  .long Op6a02,Op6a03,Op6a02,Op6a03,Op6a02,Op6a03,Op6a02,Op6a03 ;@ 6a30
  .long Op6a02,Op6a03,Op6a02,Op6a03,Op6a02,Op6a03,Op6a02,Op6a03 ;@ 6a38
  .long Op6a02,Op6a03,Op6a02,Op6a03,Op6a02,Op6a03,Op6a02,Op6a03 ;@ 6a40
  .long Op6a02,Op6a03,Op6a02,Op6a03,Op6a02,Op6a03,Op6a02,Op6a03 ;@ 6a48
  .long Op6a02,Op6a03,Op6a02,Op6a03,Op6a02,Op6a03,Op6a02,Op6a03 ;@ 6a50
  .long Op6a02,Op6a03,Op6a02,Op6a03,Op6a02,Op6a03,Op6a02,Op6a03 ;@ 6a58
  .long Op6a02,Op6a03,Op6a02,Op6a03,Op6a02,Op6a03,Op6a02,Op6a03 ;@ 6a60
  .long Op6a02,Op6a03,Op6a02,Op6a03,Op6a02,Op6a03,Op6a02,Op6a03 ;@ 6a68
  .long Op6a02,Op6a03,Op6a02,Op6a03,Op6a02,Op6a03,Op6a02,Op6a03 ;@ 6a70
  .long Op6a02,Op6a03,Op6a02,Op6a03,Op6a02,Op6a03,Op6a02,Op6a03 ;@ 6a78
  .long Op6a02,Op6a03,Op6a02,Op6a03,Op6a02,Op6a03,Op6a02,Op6a03 ;@ 6a80
  .long Op6a02,Op6a03,Op6a02,Op6a03,Op6a02,Op6a03,Op6a02,Op6a03 ;@ 6a88
  .long Op6a02,Op6a03,Op6a02,Op6a03,Op6a02,Op6a03,Op6a02,Op6a03 ;@ 6a90
  .long Op6a02,Op6a03,Op6a02,Op6a03,Op6a02,Op6a03,Op6a02,Op6a03 ;@ 6a98
  .long Op6a02,Op6a03,Op6a02,Op6a03,Op6a02,Op6a03,Op6a02,Op6a03 ;@ 6aa0
  .long Op6a02,Op6a03,Op6a02,Op6a03,Op6a02,Op6a03,Op6a02,Op6a03 ;@ 6aa8
  .long Op6a02,Op6a03,Op6a02,Op6a03,Op6a02,Op6a03,Op6a02,Op6a03 ;@ 6ab0
  .long Op6a02,Op6a03,Op6a02,Op6a03,Op6a02,Op6a03,Op6a02,Op6a03 ;@ 6ab8
  .long Op6a02,Op6a03,Op6a02,Op6a03,Op6a02,Op6a03,Op6a02,Op6a03 ;@ 6ac0
  .long Op6a02,Op6a03,Op6a02,Op6a03,Op6a02,Op6a03,Op6a02,Op6a03 ;@ 6ac8
  .long Op6a02,Op6a03,Op6a02,Op6a03,Op6a02,Op6a03,Op6a02,Op6a03 ;@ 6ad0
  .long Op6a02,Op6a03,Op6a02,Op6a03,Op6a02,Op6a03,Op6a02,Op6a03 ;@ 6ad8
  .long Op6a02,Op6a03,Op6a02,Op6a03,Op6a02,Op6a03,Op6a02,Op6a03 ;@ 6ae0
  .long Op6a02,Op6a03,Op6a02,Op6a03,Op6a02,Op6a03,Op6a02,Op6a03 ;@ 6ae8
  .long Op6a02,Op6a03,Op6a02,Op6a03,Op6a02,Op6a03,Op6a02,Op6a03 ;@ 6af0
  .long Op6a02,Op6a03,Op6a02,Op6a03,Op6a02,Op6a03,Op6a02,Op6a03 ;@ 6af8
  .long Op6b00,Op6b03,Op6b02,Op6b03,Op6b02,Op6b03,Op6b02,Op6b03 ;@ 6b00
  .long Op6b02,Op6b03,Op6b02,Op6b03,Op6b02,Op6b03,Op6b02,Op6b03 ;@ 6b08
  .long Op6b02,Op6b03,Op6b02,Op6b03,Op6b02,Op6b03,Op6b02,Op6b03 ;@ 6b10
  .long Op6b02,Op6b03,Op6b02,Op6b03,Op6b02,Op6b03,Op6b02,Op6b03 ;@ 6b18
  .long Op6b02,Op6b03,Op6b02,Op6b03,Op6b02,Op6b03,Op6b02,Op6b03 ;@ 6b20
  .long Op6b02,Op6b03,Op6b02,Op6b03,Op6b02,Op6b03,Op6b02,Op6b03 ;@ 6b28
  .long Op6b02,Op6b03,Op6b02,Op6b03,Op6b02,Op6b03,Op6b02,Op6b03 ;@ 6b30
  .long Op6b02,Op6b03,Op6b02,Op6b03,Op6b02,Op6b03,Op6b02,Op6b03 ;@ 6b38
  .long Op6b02,Op6b03,Op6b02,Op6b03,Op6b02,Op6b03,Op6b02,Op6b03 ;@ 6b40
  .long Op6b02,Op6b03,Op6b02,Op6b03,Op6b02,Op6b03,Op6b02,Op6b03 ;@ 6b48
  .long Op6b02,Op6b03,Op6b02,Op6b03,Op6b02,Op6b03,Op6b02,Op6b03 ;@ 6b50
  .long Op6b02,Op6b03,Op6b02,Op6b03,Op6b02,Op6b03,Op6b02,Op6b03 ;@ 6b58
  .long Op6b02,Op6b03,Op6b02,Op6b03,Op6b02,Op6b03,Op6b02,Op6b03 ;@ 6b60
  .long Op6b02,Op6b03,Op6b02,Op6b03,Op6b02,Op6b03,Op6b02,Op6b03 ;@ 6b68
  .long Op6b02,Op6b03,Op6b02,Op6b03,Op6b02,Op6b03,Op6b02,Op6b03 ;@ 6b70
  .long Op6b02,Op6b03,Op6b02,Op6b03,Op6b02,Op6b03,Op6b02,Op6b03 ;@ 6b78
  .long Op6b02,Op6b03,Op6b02,Op6b03,Op6b02,Op6b03,Op6b02,Op6b03 ;@ 6b80
  .long Op6b02,Op6b03,Op6b02,Op6b03,Op6b02,Op6b03,Op6b02,Op6b03 ;@ 6b88
  .long Op6b02,Op6b03,Op6b02,Op6b03,Op6b02,Op6b03,Op6b02,Op6b03 ;@ 6b90
  .long Op6b02,Op6b03,Op6b02,Op6b03,Op6b02,Op6b03,Op6b02,Op6b03 ;@ 6b98
  .long Op6b02,Op6b03,Op6b02,Op6b03,Op6b02,Op6b03,Op6b02,Op6b03 ;@ 6ba0
  .long Op6b02,Op6b03,Op6b02,Op6b03,Op6b02,Op6b03,Op6b02,Op6b03 ;@ 6ba8
  .long Op6b02,Op6b03,Op6b02,Op6b03,Op6b02,Op6b03,Op6b02,Op6b03 ;@ 6bb0
  .long Op6b02,Op6b03,Op6b02,Op6b03,Op6b02,Op6b03,Op6b02,Op6b03 ;@ 6bb8
  .long Op6b02,Op6b03,Op6b02,Op6b03,Op6b02,Op6b03,Op6b02,Op6b03 ;@ 6bc0
  .long Op6b02,Op6b03,Op6b02,Op6b03,Op6b02,Op6b03,Op6b02,Op6b03 ;@ 6bc8
  .long Op6b02,Op6b03,Op6b02,Op6b03,Op6b02,Op6b03,Op6b02,Op6b03 ;@ 6bd0
  .long Op6b02,Op6b03,Op6b02,Op6b03,Op6b02,Op6b03,Op6b02,Op6b03 ;@ 6bd8
  .long Op6b02,Op6b03,Op6b02,Op6b03,Op6b02,Op6b03,Op6b02,Op6b03 ;@ 6be0
  .long Op6b02,Op6b03,Op6b02,Op6b03,Op6b02,Op6b03,Op6b02,Op6b03 ;@ 6be8
  .long Op6b02,Op6b03,Op6b02,Op6b03,Op6b02,Op6b03,Op6b02,Op6b03 ;@ 6bf0
  .long Op6b02,Op6b03,Op6b02,Op6b03,Op6b02,Op6b03,Op6b02,Op6b03 ;@ 6bf8
  .long Op6c00,Op6c03,Op6c02,Op6c03,Op6c02,Op6c03,Op6c02,Op6c03 ;@ 6c00
  .long Op6c02,Op6c03,Op6c02,Op6c03,Op6c02,Op6c03,Op6c02,Op6c03 ;@ 6c08
  .long Op6c02,Op6c03,Op6c02,Op6c03,Op6c02,Op6c03,Op6c02,Op6c03 ;@ 6c10
  .long Op6c02,Op6c03,Op6c02,Op6c03,Op6c02,Op6c03,Op6c02,Op6c03 ;@ 6c18
  .long Op6c02,Op6c03,Op6c02,Op6c03,Op6c02,Op6c03,Op6c02,Op6c03 ;@ 6c20
  .long Op6c02,Op6c03,Op6c02,Op6c03,Op6c02,Op6c03,Op6c02,Op6c03 ;@ 6c28
  .long Op6c02,Op6c03,Op6c02,Op6c03,Op6c02,Op6c03,Op6c02,Op6c03 ;@ 6c30
  .long Op6c02,Op6c03,Op6c02,Op6c03,Op6c02,Op6c03,Op6c02,Op6c03 ;@ 6c38
  .long Op6c02,Op6c03,Op6c02,Op6c03,Op6c02,Op6c03,Op6c02,Op6c03 ;@ 6c40
  .long Op6c02,Op6c03,Op6c02,Op6c03,Op6c02,Op6c03,Op6c02,Op6c03 ;@ 6c48
  .long Op6c02,Op6c03,Op6c02,Op6c03,Op6c02,Op6c03,Op6c02,Op6c03 ;@ 6c50
  .long Op6c02,Op6c03,Op6c02,Op6c03,Op6c02,Op6c03,Op6c02,Op6c03 ;@ 6c58
  .long Op6c02,Op6c03,Op6c02,Op6c03,Op6c02,Op6c03,Op6c02,Op6c03 ;@ 6c60
  .long Op6c02,Op6c03,Op6c02,Op6c03,Op6c02,Op6c03,Op6c02,Op6c03 ;@ 6c68
  .long Op6c02,Op6c03,Op6c02,Op6c03,Op6c02,Op6c03,Op6c02,Op6c03 ;@ 6c70
  .long Op6c02,Op6c03,Op6c02,Op6c03,Op6c02,Op6c03,Op6c02,Op6c03 ;@ 6c78
  .long Op6c02,Op6c03,Op6c02,Op6c03,Op6c02,Op6c03,Op6c02,Op6c03 ;@ 6c80
  .long Op6c02,Op6c03,Op6c02,Op6c03,Op6c02,Op6c03,Op6c02,Op6c03 ;@ 6c88
  .long Op6c02,Op6c03,Op6c02,Op6c03,Op6c02,Op6c03,Op6c02,Op6c03 ;@ 6c90
  .long Op6c02,Op6c03,Op6c02,Op6c03,Op6c02,Op6c03,Op6c02,Op6c03 ;@ 6c98
  .long Op6c02,Op6c03,Op6c02,Op6c03,Op6c02,Op6c03,Op6c02,Op6c03 ;@ 6ca0
  .long Op6c02,Op6c03,Op6c02,Op6c03,Op6c02,Op6c03,Op6c02,Op6c03 ;@ 6ca8
  .long Op6c02,Op6c03,Op6c02,Op6c03,Op6c02,Op6c03,Op6c02,Op6c03 ;@ 6cb0
  .long Op6c02,Op6c03,Op6c02,Op6c03,Op6c02,Op6c03,Op6c02,Op6c03 ;@ 6cb8
  .long Op6c02,Op6c03,Op6c02,Op6c03,Op6c02,Op6c03,Op6c02,Op6c03 ;@ 6cc0
  .long Op6c02,Op6c03,Op6c02,Op6c03,Op6c02,Op6c03,Op6c02,Op6c03 ;@ 6cc8
  .long Op6c02,Op6c03,Op6c02,Op6c03,Op6c02,Op6c03,Op6c02,Op6c03 ;@ 6cd0
  .long Op6c02,Op6c03,Op6c02,Op6c03,Op6c02,Op6c03,Op6c02,Op6c03 ;@ 6cd8
  .long Op6c02,Op6c03,Op6c02,Op6c03,Op6c02,Op6c03,Op6c02,Op6c03 ;@ 6ce0
  .long Op6c02,Op6c03,Op6c02,Op6c03,Op6c02,Op6c03,Op6c02,Op6c03 ;@ 6ce8
  .long Op6c02,Op6c03,Op6c02,Op6c03,Op6c02,Op6c03,Op6c02,Op6c03 ;@ 6cf0
  .long Op6c02,Op6c03,Op6c02,Op6c03,Op6c02,Op6c03,Op6c02,Op6c03 ;@ 6cf8
  .long Op6d00,Op6d03,Op6d02,Op6d03,Op6d02,Op6d03,Op6d02,Op6d03 ;@ 6d00
  .long Op6d02,Op6d03,Op6d02,Op6d03,Op6d02,Op6d03,Op6d02,Op6d03 ;@ 6d08
  .long Op6d02,Op6d03,Op6d02,Op6d03,Op6d02,Op6d03,Op6d02,Op6d03 ;@ 6d10
  .long Op6d02,Op6d03,Op6d02,Op6d03,Op6d02,Op6d03,Op6d02,Op6d03 ;@ 6d18
  .long Op6d02,Op6d03,Op6d02,Op6d03,Op6d02,Op6d03,Op6d02,Op6d03 ;@ 6d20
  .long Op6d02,Op6d03,Op6d02,Op6d03,Op6d02,Op6d03,Op6d02,Op6d03 ;@ 6d28
  .long Op6d02,Op6d03,Op6d02,Op6d03,Op6d02,Op6d03,Op6d02,Op6d03 ;@ 6d30
  .long Op6d02,Op6d03,Op6d02,Op6d03,Op6d02,Op6d03,Op6d02,Op6d03 ;@ 6d38
  .long Op6d02,Op6d03,Op6d02,Op6d03,Op6d02,Op6d03,Op6d02,Op6d03 ;@ 6d40
  .long Op6d02,Op6d03,Op6d02,Op6d03,Op6d02,Op6d03,Op6d02,Op6d03 ;@ 6d48
  .long Op6d02,Op6d03,Op6d02,Op6d03,Op6d02,Op6d03,Op6d02,Op6d03 ;@ 6d50
  .long Op6d02,Op6d03,Op6d02,Op6d03,Op6d02,Op6d03,Op6d02,Op6d03 ;@ 6d58
  .long Op6d02,Op6d03,Op6d02,Op6d03,Op6d02,Op6d03,Op6d02,Op6d03 ;@ 6d60
  .long Op6d02,Op6d03,Op6d02,Op6d03,Op6d02,Op6d03,Op6d02,Op6d03 ;@ 6d68
  .long Op6d02,Op6d03,Op6d02,Op6d03,Op6d02,Op6d03,Op6d02,Op6d03 ;@ 6d70
  .long Op6d02,Op6d03,Op6d02,Op6d03,Op6d02,Op6d03,Op6d02,Op6d03 ;@ 6d78
  .long Op6d02,Op6d03,Op6d02,Op6d03,Op6d02,Op6d03,Op6d02,Op6d03 ;@ 6d80
  .long Op6d02,Op6d03,Op6d02,Op6d03,Op6d02,Op6d03,Op6d02,Op6d03 ;@ 6d88
  .long Op6d02,Op6d03,Op6d02,Op6d03,Op6d02,Op6d03,Op6d02,Op6d03 ;@ 6d90
  .long Op6d02,Op6d03,Op6d02,Op6d03,Op6d02,Op6d03,Op6d02,Op6d03 ;@ 6d98
  .long Op6d02,Op6d03,Op6d02,Op6d03,Op6d02,Op6d03,Op6d02,Op6d03 ;@ 6da0
  .long Op6d02,Op6d03,Op6d02,Op6d03,Op6d02,Op6d03,Op6d02,Op6d03 ;@ 6da8
  .long Op6d02,Op6d03,Op6d02,Op6d03,Op6d02,Op6d03,Op6d02,Op6d03 ;@ 6db0
  .long Op6d02,Op6d03,Op6d02,Op6d03,Op6d02,Op6d03,Op6d02,Op6d03 ;@ 6db8
  .long Op6d02,Op6d03,Op6d02,Op6d03,Op6d02,Op6d03,Op6d02,Op6d03 ;@ 6dc0
  .long Op6d02,Op6d03,Op6d02,Op6d03,Op6d02,Op6d03,Op6d02,Op6d03 ;@ 6dc8
  .long Op6d02,Op6d03,Op6d02,Op6d03,Op6d02,Op6d03,Op6d02,Op6d03 ;@ 6dd0
  .long Op6d02,Op6d03,Op6d02,Op6d03,Op6d02,Op6d03,Op6d02,Op6d03 ;@ 6dd8
  .long Op6d02,Op6d03,Op6d02,Op6d03,Op6d02,Op6d03,Op6d02,Op6d03 ;@ 6de0
  .long Op6d02,Op6d03,Op6d02,Op6d03,Op6d02,Op6d03,Op6d02,Op6d03 ;@ 6de8
  .long Op6d02,Op6d03,Op6d02,Op6d03,Op6d02,Op6d03,Op6d02,Op6d03 ;@ 6df0
  .long Op6d02,Op6d03,Op6d02,Op6d03,Op6d02,Op6d03,Op6d02,Op6d03 ;@ 6df8
  .long Op6e00,Op6e03,Op6e02,Op6e03,Op6e02,Op6e03,Op6e02,Op6e03 ;@ 6e00
  .long Op6e02,Op6e03,Op6e02,Op6e03,Op6e02,Op6e03,Op6e02,Op6e03 ;@ 6e08
  .long Op6e02,Op6e03,Op6e02,Op6e03,Op6e02,Op6e03,Op6e02,Op6e03 ;@ 6e10
  .long Op6e02,Op6e03,Op6e02,Op6e03,Op6e02,Op6e03,Op6e02,Op6e03 ;@ 6e18
  .long Op6e02,Op6e03,Op6e02,Op6e03,Op6e02,Op6e03,Op6e02,Op6e03 ;@ 6e20
  .long Op6e02,Op6e03,Op6e02,Op6e03,Op6e02,Op6e03,Op6e02,Op6e03 ;@ 6e28
  .long Op6e02,Op6e03,Op6e02,Op6e03,Op6e02,Op6e03,Op6e02,Op6e03 ;@ 6e30
  .long Op6e02,Op6e03,Op6e02,Op6e03,Op6e02,Op6e03,Op6e02,Op6e03 ;@ 6e38
  .long Op6e02,Op6e03,Op6e02,Op6e03,Op6e02,Op6e03,Op6e02,Op6e03 ;@ 6e40
  .long Op6e02,Op6e03,Op6e02,Op6e03,Op6e02,Op6e03,Op6e02,Op6e03 ;@ 6e48
  .long Op6e02,Op6e03,Op6e02,Op6e03,Op6e02,Op6e03,Op6e02,Op6e03 ;@ 6e50
  .long Op6e02,Op6e03,Op6e02,Op6e03,Op6e02,Op6e03,Op6e02,Op6e03 ;@ 6e58
  .long Op6e02,Op6e03,Op6e02,Op6e03,Op6e02,Op6e03,Op6e02,Op6e03 ;@ 6e60
  .long Op6e02,Op6e03,Op6e02,Op6e03,Op6e02,Op6e03,Op6e02,Op6e03 ;@ 6e68
  .long Op6e02,Op6e03,Op6e02,Op6e03,Op6e02,Op6e03,Op6e02,Op6e03 ;@ 6e70
  .long Op6e02,Op6e03,Op6e02,Op6e03,Op6e02,Op6e03,Op6e02,Op6e03 ;@ 6e78
  .long Op6e02,Op6e03,Op6e02,Op6e03,Op6e02,Op6e03,Op6e02,Op6e03 ;@ 6e80
  .long Op6e02,Op6e03,Op6e02,Op6e03,Op6e02,Op6e03,Op6e02,Op6e03 ;@ 6e88
  .long Op6e02,Op6e03,Op6e02,Op6e03,Op6e02,Op6e03,Op6e02,Op6e03 ;@ 6e90
  .long Op6e02,Op6e03,Op6e02,Op6e03,Op6e02,Op6e03,Op6e02,Op6e03 ;@ 6e98
  .long Op6e02,Op6e03,Op6e02,Op6e03,Op6e02,Op6e03,Op6e02,Op6e03 ;@ 6ea0
  .long Op6e02,Op6e03,Op6e02,Op6e03,Op6e02,Op6e03,Op6e02,Op6e03 ;@ 6ea8
  .long Op6e02,Op6e03,Op6e02,Op6e03,Op6e02,Op6e03,Op6e02,Op6e03 ;@ 6eb0
  .long Op6e02,Op6e03,Op6e02,Op6e03,Op6e02,Op6e03,Op6e02,Op6e03 ;@ 6eb8
  .long Op6e02,Op6e03,Op6e02,Op6e03,Op6e02,Op6e03,Op6e02,Op6e03 ;@ 6ec0
  .long Op6e02,Op6e03,Op6e02,Op6e03,Op6e02,Op6e03,Op6e02,Op6e03 ;@ 6ec8
  .long Op6e02,Op6e03,Op6e02,Op6e03,Op6e02,Op6e03,Op6e02,Op6e03 ;@ 6ed0
  .long Op6e02,Op6e03,Op6e02,Op6e03,Op6e02,Op6e03,Op6e02,Op6e03 ;@ 6ed8
  .long Op6e02,Op6e03,Op6e02,Op6e03,Op6e02,Op6e03,Op6e02,Op6e03 ;@ 6ee0
  .long Op6e02,Op6e03,Op6e02,Op6e03,Op6e02,Op6e03,Op6e02,Op6e03 ;@ 6ee8
  .long Op6e02,Op6e03,Op6e02,Op6e03,Op6e02,Op6e03,Op6e02,Op6e03 ;@ 6ef0
  .long Op6e02,Op6e03,Op6e02,Op6e03,Op6e02,Op6e03,Op6e02,Op6e03 ;@ 6ef8
  .long Op6f00,Op6f03,Op6f02,Op6f03,Op6f02,Op6f03,Op6f02,Op6f03 ;@ 6f00
  .long Op6f02,Op6f03,Op6f02,Op6f03,Op6f02,Op6f03,Op6f02,Op6f03 ;@ 6f08
  .long Op6f02,Op6f03,Op6f02,Op6f03,Op6f02,Op6f03,Op6f02,Op6f03 ;@ 6f10
  .long Op6f02,Op6f03,Op6f02,Op6f03,Op6f02,Op6f03,Op6f02,Op6f03 ;@ 6f18
  .long Op6f02,Op6f03,Op6f02,Op6f03,Op6f02,Op6f03,Op6f02,Op6f03 ;@ 6f20
  .long Op6f02,Op6f03,Op6f02,Op6f03,Op6f02,Op6f03,Op6f02,Op6f03 ;@ 6f28
  .long Op6f02,Op6f03,Op6f02,Op6f03,Op6f02,Op6f03,Op6f02,Op6f03 ;@ 6f30
  .long Op6f02,Op6f03,Op6f02,Op6f03,Op6f02,Op6f03,Op6f02,Op6f03 ;@ 6f38
  .long Op6f02,Op6f03,Op6f02,Op6f03,Op6f02,Op6f03,Op6f02,Op6f03 ;@ 6f40
  .long Op6f02,Op6f03,Op6f02,Op6f03,Op6f02,Op6f03,Op6f02,Op6f03 ;@ 6f48
  .long Op6f02,Op6f03,Op6f02,Op6f03,Op6f02,Op6f03,Op6f02,Op6f03 ;@ 6f50
  .long Op6f02,Op6f03,Op6f02,Op6f03,Op6f02,Op6f03,Op6f02,Op6f03 ;@ 6f58
  .long Op6f02,Op6f03,Op6f02,Op6f03,Op6f02,Op6f03,Op6f02,Op6f03 ;@ 6f60
  .long Op6f02,Op6f03,Op6f02,Op6f03,Op6f02,Op6f03,Op6f02,Op6f03 ;@ 6f68
  .long Op6f02,Op6f03,Op6f02,Op6f03,Op6f02,Op6f03,Op6f02,Op6f03 ;@ 6f70
  .long Op6f02,Op6f03,Op6f02,Op6f03,Op6f02,Op6f03,Op6f02,Op6f03 ;@ 6f78
  .long Op6f02,Op6f03,Op6f02,Op6f03,Op6f02,Op6f03,Op6f02,Op6f03 ;@ 6f80
  .long Op6f02,Op6f03,Op6f02,Op6f03,Op6f02,Op6f03,Op6f02,Op6f03 ;@ 6f88
  .long Op6f02,Op6f03,Op6f02,Op6f03,Op6f02,Op6f03,Op6f02,Op6f03 ;@ 6f90
  .long Op6f02,Op6f03,Op6f02,Op6f03,Op6f02,Op6f03,Op6f02,Op6f03 ;@ 6f98
  .long Op6f02,Op6f03,Op6f02,Op6f03,Op6f02,Op6f03,Op6f02,Op6f03 ;@ 6fa0
  .long Op6f02,Op6f03,Op6f02,Op6f03,Op6f02,Op6f03,Op6f02,Op6f03 ;@ 6fa8
  .long Op6f02,Op6f03,Op6f02,Op6f03,Op6f02,Op6f03,Op6f02,Op6f03 ;@ 6fb0
  .long Op6f02,Op6f03,Op6f02,Op6f03,Op6f02,Op6f03,Op6f02,Op6f03 ;@ 6fb8
  .long Op6f02,Op6f03,Op6f02,Op6f03,Op6f02,Op6f03,Op6f02,Op6f03 ;@ 6fc0
  .long Op6f02,Op6f03,Op6f02,Op6f03,Op6f02,Op6f03,Op6f02,Op6f03 ;@ 6fc8
  .long Op6f02,Op6f03,Op6f02,Op6f03,Op6f02,Op6f03,Op6f02,Op6f03 ;@ 6fd0
  .long Op6f02,Op6f03,Op6f02,Op6f03,Op6f02,Op6f03,Op6f02,Op6f03 ;@ 6fd8
  .long Op6f02,Op6f03,Op6f02,Op6f03,Op6f02,Op6f03,Op6f02,Op6f03 ;@ 6fe0
  .long Op6f02,Op6f03,Op6f02,Op6f03,Op6f02,Op6f03,Op6f02,Op6f03 ;@ 6fe8
  .long Op6f02,Op6f03,Op6f02,Op6f03,Op6f02,Op6f03,Op6f02,Op6f03 ;@ 6ff0
  .long Op6f02,Op6f03,Op6f02,Op6f03,Op6f02,Op6f03,Op6f02,Op6f03 ;@ 6ff8
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7000
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7008
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7010
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7018
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7020
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7028
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7030
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7038
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7040
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7048
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7050
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7058
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7060
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7068
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7070
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7078
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7080
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7088
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7090
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7098
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 70a0
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 70a8
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 70b0
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 70b8
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 70c0
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 70c8
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 70d0
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 70d8
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 70e0
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 70e8
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 70f0
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 70f8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7100
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7108
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7110
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7118
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7120
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7128
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7130
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7138
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7140
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7148
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7150
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7158
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7160
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7168
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7170
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7178
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7180
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7188
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7190
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7198
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 71a0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 71a8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 71b0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 71b8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 71c0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 71c8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 71d0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 71d8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 71e0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 71e8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 71f0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 71f8
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7200
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7208
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7210
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7218
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7220
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7228
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7230
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7238
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7240
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7248
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7250
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7258
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7260
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7268
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7270
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7278
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7280
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7288
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7290
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7298
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 72a0
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 72a8
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 72b0
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 72b8
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 72c0
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 72c8
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 72d0
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 72d8
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 72e0
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 72e8
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 72f0
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 72f8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7300
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7308
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7310
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7318
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7320
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7328
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7330
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7338
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7340
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7348
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7350
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7358
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7360
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7368
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7370
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7378
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7380
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7388
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7390
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7398
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 73a0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 73a8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 73b0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 73b8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 73c0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 73c8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 73d0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 73d8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 73e0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 73e8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 73f0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 73f8
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7400
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7408
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7410
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7418
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7420
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7428
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7430
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7438
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7440
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7448
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7450
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7458
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7460
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7468
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7470
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7478
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7480
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7488
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7490
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7498
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 74a0
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 74a8
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 74b0
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 74b8
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 74c0
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 74c8
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 74d0
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 74d8
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 74e0
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 74e8
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 74f0
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 74f8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7500
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7508
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7510
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7518
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7520
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7528
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7530
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7538
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7540
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7548
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7550
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7558
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7560
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7568
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7570
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7578
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7580
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7588
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7590
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7598
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 75a0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 75a8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 75b0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 75b8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 75c0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 75c8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 75d0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 75d8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 75e0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 75e8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 75f0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 75f8
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7600
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7608
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7610
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7618
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7620
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7628
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7630
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7638
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7640
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7648
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7650
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7658
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7660
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7668
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7670
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7678
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7680
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7688
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7690
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7698
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 76a0
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 76a8
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 76b0
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 76b8
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 76c0
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 76c8
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 76d0
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 76d8
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 76e0
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 76e8
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 76f0
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 76f8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7700
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7708
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7710
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7718
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7720
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7728
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7730
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7738
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7740
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7748
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7750
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7758
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7760
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7768
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7770
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7778
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7780
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7788
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7790
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7798
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 77a0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 77a8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 77b0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 77b8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 77c0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 77c8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 77d0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 77d8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 77e0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 77e8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 77f0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 77f8
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7800
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7808
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7810
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7818
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7820
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7828
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7830
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7838
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7840
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7848
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7850
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7858
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7860
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7868
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7870
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7878
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7880
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7888
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7890
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7898
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 78a0
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 78a8
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 78b0
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 78b8
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 78c0
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 78c8
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 78d0
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 78d8
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 78e0
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 78e8
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 78f0
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 78f8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7900
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7908
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7910
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7918
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7920
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7928
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7930
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7938
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7940
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7948
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7950
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7958
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7960
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7968
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7970
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7978
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7980
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7988
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7990
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7998
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 79a0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 79a8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 79b0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 79b8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 79c0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 79c8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 79d0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 79d8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 79e0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 79e8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 79f0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 79f8
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7a00
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7a08
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7a10
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7a18
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7a20
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7a28
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7a30
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7a38
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7a40
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7a48
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7a50
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7a58
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7a60
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7a68
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7a70
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7a78
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7a80
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7a88
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7a90
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7a98
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7aa0
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7aa8
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7ab0
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7ab8
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7ac0
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7ac8
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7ad0
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7ad8
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7ae0
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7ae8
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7af0
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7af8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7b00
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7b08
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7b10
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7b18
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7b20
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7b28
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7b30
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7b38
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7b40
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7b48
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7b50
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7b58
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7b60
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7b68
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7b70
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7b78
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7b80
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7b88
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7b90
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7b98
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7ba0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7ba8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7bb0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7bb8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7bc0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7bc8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7bd0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7bd8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7be0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7be8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7bf0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7bf8
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7c00
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7c08
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7c10
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7c18
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7c20
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7c28
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7c30
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7c38
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7c40
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7c48
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7c50
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7c58
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7c60
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7c68
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7c70
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7c78
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7c80
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7c88
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7c90
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7c98
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7ca0
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7ca8
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7cb0
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7cb8
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7cc0
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7cc8
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7cd0
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7cd8
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7ce0
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7ce8
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7cf0
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7cf8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7d00
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7d08
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7d10
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7d18
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7d20
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7d28
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7d30
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7d38
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7d40
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7d48
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7d50
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7d58
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7d60
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7d68
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7d70
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7d78
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7d80
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7d88
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7d90
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7d98
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7da0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7da8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7db0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7db8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7dc0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7dc8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7dd0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7dd8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7de0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7de8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7df0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7df8
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7e00
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7e08
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7e10
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7e18
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7e20
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7e28
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7e30
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7e38
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7e40
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7e48
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7e50
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7e58
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7e60
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7e68
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7e70
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7e78
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7e80
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7e88
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7e90
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7e98
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7ea0
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7ea8
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7eb0
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7eb8
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7ec0
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7ec8
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7ed0
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7ed8
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7ee0
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7ee8
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7ef0
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7ef8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7f00
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7f08
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7f10
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7f18
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7f20
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7f28
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7f30
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7f38
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7f40
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7f48
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7f50
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7f58
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7f60
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7f68
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7f70
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7f78
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7f80
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7f88
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7f90
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7f98
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7fa0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7fa8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7fb0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7fb8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7fc0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7fc8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7fd0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7fd8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7fe0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7fe8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7ff0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7ff8
  .long Op8000,Op8000,Op8000,Op8000,Op8000,Op8000,Op8000,Op8000 ;@ 8000
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 8008
  .long Op8010,Op8010,Op8010,Op8010,Op8010,Op8010,Op8010,Op8010 ;@ 8010
  .long Op8018,Op8018,Op8018,Op8018,Op8018,Op8018,Op8018,Op801f ;@ 8018
  .long Op8020,Op8020,Op8020,Op8020,Op8020,Op8020,Op8020,Op8027 ;@ 8020
  .long Op8028,Op8028,Op8028,Op8028,Op8028,Op8028,Op8028,Op8028 ;@ 8028
  .long Op8030,Op8030,Op8030,Op8030,Op8030,Op8030,Op8030,Op8030 ;@ 8030
  .long Op8038,Op8039,Op803a,Op803b,Op803c,Op____,Op____,Op____ ;@ 8038
  .long Op8040,Op8040,Op8040,Op8040,Op8040,Op8040,Op8040,Op8040 ;@ 8040
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 8048
  .long Op8050,Op8050,Op8050,Op8050,Op8050,Op8050,Op8050,Op8050 ;@ 8050
  .long Op8058,Op8058,Op8058,Op8058,Op8058,Op8058,Op8058,Op8058 ;@ 8058
  .long Op8060,Op8060,Op8060,Op8060,Op8060,Op8060,Op8060,Op8060 ;@ 8060
  .long Op8068,Op8068,Op8068,Op8068,Op8068,Op8068,Op8068,Op8068 ;@ 8068
  .long Op8070,Op8070,Op8070,Op8070,Op8070,Op8070,Op8070,Op8070 ;@ 8070
  .long Op8078,Op8079,Op807a,Op807b,Op807c,Op____,Op____,Op____ ;@ 8078
  .long Op8080,Op8080,Op8080,Op8080,Op8080,Op8080,Op8080,Op8080 ;@ 8080
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 8088
  .long Op8090,Op8090,Op8090,Op8090,Op8090,Op8090,Op8090,Op8090 ;@ 8090
  .long Op8098,Op8098,Op8098,Op8098,Op8098,Op8098,Op8098,Op8098 ;@ 8098
  .long Op80a0,Op80a0,Op80a0,Op80a0,Op80a0,Op80a0,Op80a0,Op80a0 ;@ 80a0
  .long Op80a8,Op80a8,Op80a8,Op80a8,Op80a8,Op80a8,Op80a8,Op80a8 ;@ 80a8
  .long Op80b0,Op80b0,Op80b0,Op80b0,Op80b0,Op80b0,Op80b0,Op80b0 ;@ 80b0
  .long Op80b8,Op80b9,Op80ba,Op80bb,Op80bc,Op____,Op____,Op____ ;@ 80b8
  .long Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0 ;@ 80c0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 80c8
  .long Op80d0,Op80d0,Op80d0,Op80d0,Op80d0,Op80d0,Op80d0,Op80d0 ;@ 80d0
  .long Op80d8,Op80d8,Op80d8,Op80d8,Op80d8,Op80d8,Op80d8,Op80d8 ;@ 80d8
  .long Op80e0,Op80e0,Op80e0,Op80e0,Op80e0,Op80e0,Op80e0,Op80e0 ;@ 80e0
  .long Op80e8,Op80e8,Op80e8,Op80e8,Op80e8,Op80e8,Op80e8,Op80e8 ;@ 80e8
  .long Op80f0,Op80f0,Op80f0,Op80f0,Op80f0,Op80f0,Op80f0,Op80f0 ;@ 80f0
  .long Op80f8,Op80f9,Op80fa,Op80fb,Op80fc,Op____,Op____,Op____ ;@ 80f8
  .long Op8100,Op8100,Op8100,Op8100,Op8100,Op8100,Op8100,Op8100 ;@ 8100
  .long Op8108,Op8108,Op8108,Op8108,Op8108,Op8108,Op8108,Op810f ;@ 8108
  .long Op8110,Op8110,Op8110,Op8110,Op8110,Op8110,Op8110,Op8110 ;@ 8110
  .long Op8118,Op8118,Op8118,Op8118,Op8118,Op8118,Op8118,Op811f ;@ 8118
  .long Op8120,Op8120,Op8120,Op8120,Op8120,Op8120,Op8120,Op8127 ;@ 8120
  .long Op8128,Op8128,Op8128,Op8128,Op8128,Op8128,Op8128,Op8128 ;@ 8128
  .long Op8130,Op8130,Op8130,Op8130,Op8130,Op8130,Op8130,Op8130 ;@ 8130
  .long Op8138,Op8139,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 8138
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 8140
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 8148
  .long Op8150,Op8150,Op8150,Op8150,Op8150,Op8150,Op8150,Op8150 ;@ 8150
  .long Op8158,Op8158,Op8158,Op8158,Op8158,Op8158,Op8158,Op8158 ;@ 8158
  .long Op8160,Op8160,Op8160,Op8160,Op8160,Op8160,Op8160,Op8160 ;@ 8160
  .long Op8168,Op8168,Op8168,Op8168,Op8168,Op8168,Op8168,Op8168 ;@ 8168
  .long Op8170,Op8170,Op8170,Op8170,Op8170,Op8170,Op8170,Op8170 ;@ 8170
  .long Op8178,Op8179,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 8178
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 8180
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 8188
  .long Op8190,Op8190,Op8190,Op8190,Op8190,Op8190,Op8190,Op8190 ;@ 8190
  .long Op8198,Op8198,Op8198,Op8198,Op8198,Op8198,Op8198,Op8198 ;@ 8198
  .long Op81a0,Op81a0,Op81a0,Op81a0,Op81a0,Op81a0,Op81a0,Op81a0 ;@ 81a0
  .long Op81a8,Op81a8,Op81a8,Op81a8,Op81a8,Op81a8,Op81a8,Op81a8 ;@ 81a8
  .long Op81b0,Op81b0,Op81b0,Op81b0,Op81b0,Op81b0,Op81b0,Op81b0 ;@ 81b0
  .long Op81b8,Op81b9,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 81b8
  .long Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0 ;@ 81c0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 81c8
  .long Op81d0,Op81d0,Op81d0,Op81d0,Op81d0,Op81d0,Op81d0,Op81d0 ;@ 81d0
  .long Op81d8,Op81d8,Op81d8,Op81d8,Op81d8,Op81d8,Op81d8,Op81d8 ;@ 81d8
  .long Op81e0,Op81e0,Op81e0,Op81e0,Op81e0,Op81e0,Op81e0,Op81e0 ;@ 81e0
  .long Op81e8,Op81e8,Op81e8,Op81e8,Op81e8,Op81e8,Op81e8,Op81e8 ;@ 81e8
  .long Op81f0,Op81f0,Op81f0,Op81f0,Op81f0,Op81f0,Op81f0,Op81f0 ;@ 81f0
  .long Op81f8,Op81f9,Op81fa,Op81fb,Op81fc,Op____,Op____,Op____ ;@ 81f8
  .long Op8000,Op8000,Op8000,Op8000,Op8000,Op8000,Op8000,Op8000 ;@ 8200
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 8208
  .long Op8010,Op8010,Op8010,Op8010,Op8010,Op8010,Op8010,Op8010 ;@ 8210
  .long Op8018,Op8018,Op8018,Op8018,Op8018,Op8018,Op8018,Op801f ;@ 8218
  .long Op8020,Op8020,Op8020,Op8020,Op8020,Op8020,Op8020,Op8027 ;@ 8220
  .long Op8028,Op8028,Op8028,Op8028,Op8028,Op8028,Op8028,Op8028 ;@ 8228
  .long Op8030,Op8030,Op8030,Op8030,Op8030,Op8030,Op8030,Op8030 ;@ 8230
  .long Op8038,Op8039,Op803a,Op803b,Op803c,Op____,Op____,Op____ ;@ 8238
  .long Op8040,Op8040,Op8040,Op8040,Op8040,Op8040,Op8040,Op8040 ;@ 8240
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 8248
  .long Op8050,Op8050,Op8050,Op8050,Op8050,Op8050,Op8050,Op8050 ;@ 8250
  .long Op8058,Op8058,Op8058,Op8058,Op8058,Op8058,Op8058,Op8058 ;@ 8258
  .long Op8060,Op8060,Op8060,Op8060,Op8060,Op8060,Op8060,Op8060 ;@ 8260
  .long Op8068,Op8068,Op8068,Op8068,Op8068,Op8068,Op8068,Op8068 ;@ 8268
  .long Op8070,Op8070,Op8070,Op8070,Op8070,Op8070,Op8070,Op8070 ;@ 8270
  .long Op8078,Op8079,Op807a,Op807b,Op807c,Op____,Op____,Op____ ;@ 8278
  .long Op8080,Op8080,Op8080,Op8080,Op8080,Op8080,Op8080,Op8080 ;@ 8280
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 8288
  .long Op8090,Op8090,Op8090,Op8090,Op8090,Op8090,Op8090,Op8090 ;@ 8290
  .long Op8098,Op8098,Op8098,Op8098,Op8098,Op8098,Op8098,Op8098 ;@ 8298
  .long Op80a0,Op80a0,Op80a0,Op80a0,Op80a0,Op80a0,Op80a0,Op80a0 ;@ 82a0
  .long Op80a8,Op80a8,Op80a8,Op80a8,Op80a8,Op80a8,Op80a8,Op80a8 ;@ 82a8
  .long Op80b0,Op80b0,Op80b0,Op80b0,Op80b0,Op80b0,Op80b0,Op80b0 ;@ 82b0
  .long Op80b8,Op80b9,Op80ba,Op80bb,Op80bc,Op____,Op____,Op____ ;@ 82b8
  .long Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0 ;@ 82c0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 82c8
  .long Op80d0,Op80d0,Op80d0,Op80d0,Op80d0,Op80d0,Op80d0,Op80d0 ;@ 82d0
  .long Op80d8,Op80d8,Op80d8,Op80d8,Op80d8,Op80d8,Op80d8,Op80d8 ;@ 82d8
  .long Op80e0,Op80e0,Op80e0,Op80e0,Op80e0,Op80e0,Op80e0,Op80e0 ;@ 82e0
  .long Op80e8,Op80e8,Op80e8,Op80e8,Op80e8,Op80e8,Op80e8,Op80e8 ;@ 82e8
  .long Op80f0,Op80f0,Op80f0,Op80f0,Op80f0,Op80f0,Op80f0,Op80f0 ;@ 82f0
  .long Op80f8,Op80f9,Op80fa,Op80fb,Op80fc,Op____,Op____,Op____ ;@ 82f8
  .long Op8100,Op8100,Op8100,Op8100,Op8100,Op8100,Op8100,Op8100 ;@ 8300
  .long Op8108,Op8108,Op8108,Op8108,Op8108,Op8108,Op8108,Op810f ;@ 8308
  .long Op8110,Op8110,Op8110,Op8110,Op8110,Op8110,Op8110,Op8110 ;@ 8310
  .long Op8118,Op8118,Op8118,Op8118,Op8118,Op8118,Op8118,Op811f ;@ 8318
  .long Op8120,Op8120,Op8120,Op8120,Op8120,Op8120,Op8120,Op8127 ;@ 8320
  .long Op8128,Op8128,Op8128,Op8128,Op8128,Op8128,Op8128,Op8128 ;@ 8328
  .long Op8130,Op8130,Op8130,Op8130,Op8130,Op8130,Op8130,Op8130 ;@ 8330
  .long Op8138,Op8139,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 8338
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 8340
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 8348
  .long Op8150,Op8150,Op8150,Op8150,Op8150,Op8150,Op8150,Op8150 ;@ 8350
  .long Op8158,Op8158,Op8158,Op8158,Op8158,Op8158,Op8158,Op8158 ;@ 8358
  .long Op8160,Op8160,Op8160,Op8160,Op8160,Op8160,Op8160,Op8160 ;@ 8360
  .long Op8168,Op8168,Op8168,Op8168,Op8168,Op8168,Op8168,Op8168 ;@ 8368
  .long Op8170,Op8170,Op8170,Op8170,Op8170,Op8170,Op8170,Op8170 ;@ 8370
  .long Op8178,Op8179,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 8378
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 8380
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 8388
  .long Op8190,Op8190,Op8190,Op8190,Op8190,Op8190,Op8190,Op8190 ;@ 8390
  .long Op8198,Op8198,Op8198,Op8198,Op8198,Op8198,Op8198,Op8198 ;@ 8398
  .long Op81a0,Op81a0,Op81a0,Op81a0,Op81a0,Op81a0,Op81a0,Op81a0 ;@ 83a0
  .long Op81a8,Op81a8,Op81a8,Op81a8,Op81a8,Op81a8,Op81a8,Op81a8 ;@ 83a8
  .long Op81b0,Op81b0,Op81b0,Op81b0,Op81b0,Op81b0,Op81b0,Op81b0 ;@ 83b0
  .long Op81b8,Op81b9,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 83b8
  .long Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0 ;@ 83c0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 83c8
  .long Op81d0,Op81d0,Op81d0,Op81d0,Op81d0,Op81d0,Op81d0,Op81d0 ;@ 83d0
  .long Op81d8,Op81d8,Op81d8,Op81d8,Op81d8,Op81d8,Op81d8,Op81d8 ;@ 83d8
  .long Op81e0,Op81e0,Op81e0,Op81e0,Op81e0,Op81e0,Op81e0,Op81e0 ;@ 83e0
  .long Op81e8,Op81e8,Op81e8,Op81e8,Op81e8,Op81e8,Op81e8,Op81e8 ;@ 83e8
  .long Op81f0,Op81f0,Op81f0,Op81f0,Op81f0,Op81f0,Op81f0,Op81f0 ;@ 83f0
  .long Op81f8,Op81f9,Op81fa,Op81fb,Op81fc,Op____,Op____,Op____ ;@ 83f8
  .long Op8000,Op8000,Op8000,Op8000,Op8000,Op8000,Op8000,Op8000 ;@ 8400
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 8408
  .long Op8010,Op8010,Op8010,Op8010,Op8010,Op8010,Op8010,Op8010 ;@ 8410
  .long Op8018,Op8018,Op8018,Op8018,Op8018,Op8018,Op8018,Op801f ;@ 8418
  .long Op8020,Op8020,Op8020,Op8020,Op8020,Op8020,Op8020,Op8027 ;@ 8420
  .long Op8028,Op8028,Op8028,Op8028,Op8028,Op8028,Op8028,Op8028 ;@ 8428
  .long Op8030,Op8030,Op8030,Op8030,Op8030,Op8030,Op8030,Op8030 ;@ 8430
  .long Op8038,Op8039,Op803a,Op803b,Op803c,Op____,Op____,Op____ ;@ 8438
  .long Op8040,Op8040,Op8040,Op8040,Op8040,Op8040,Op8040,Op8040 ;@ 8440
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 8448
  .long Op8050,Op8050,Op8050,Op8050,Op8050,Op8050,Op8050,Op8050 ;@ 8450
  .long Op8058,Op8058,Op8058,Op8058,Op8058,Op8058,Op8058,Op8058 ;@ 8458
  .long Op8060,Op8060,Op8060,Op8060,Op8060,Op8060,Op8060,Op8060 ;@ 8460
  .long Op8068,Op8068,Op8068,Op8068,Op8068,Op8068,Op8068,Op8068 ;@ 8468
  .long Op8070,Op8070,Op8070,Op8070,Op8070,Op8070,Op8070,Op8070 ;@ 8470
  .long Op8078,Op8079,Op807a,Op807b,Op807c,Op____,Op____,Op____ ;@ 8478
  .long Op8080,Op8080,Op8080,Op8080,Op8080,Op8080,Op8080,Op8080 ;@ 8480
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 8488
  .long Op8090,Op8090,Op8090,Op8090,Op8090,Op8090,Op8090,Op8090 ;@ 8490
  .long Op8098,Op8098,Op8098,Op8098,Op8098,Op8098,Op8098,Op8098 ;@ 8498
  .long Op80a0,Op80a0,Op80a0,Op80a0,Op80a0,Op80a0,Op80a0,Op80a0 ;@ 84a0
  .long Op80a8,Op80a8,Op80a8,Op80a8,Op80a8,Op80a8,Op80a8,Op80a8 ;@ 84a8
  .long Op80b0,Op80b0,Op80b0,Op80b0,Op80b0,Op80b0,Op80b0,Op80b0 ;@ 84b0
  .long Op80b8,Op80b9,Op80ba,Op80bb,Op80bc,Op____,Op____,Op____ ;@ 84b8
  .long Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0 ;@ 84c0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 84c8
  .long Op80d0,Op80d0,Op80d0,Op80d0,Op80d0,Op80d0,Op80d0,Op80d0 ;@ 84d0
  .long Op80d8,Op80d8,Op80d8,Op80d8,Op80d8,Op80d8,Op80d8,Op80d8 ;@ 84d8
  .long Op80e0,Op80e0,Op80e0,Op80e0,Op80e0,Op80e0,Op80e0,Op80e0 ;@ 84e0
  .long Op80e8,Op80e8,Op80e8,Op80e8,Op80e8,Op80e8,Op80e8,Op80e8 ;@ 84e8
  .long Op80f0,Op80f0,Op80f0,Op80f0,Op80f0,Op80f0,Op80f0,Op80f0 ;@ 84f0
  .long Op80f8,Op80f9,Op80fa,Op80fb,Op80fc,Op____,Op____,Op____ ;@ 84f8
  .long Op8100,Op8100,Op8100,Op8100,Op8100,Op8100,Op8100,Op8100 ;@ 8500
  .long Op8108,Op8108,Op8108,Op8108,Op8108,Op8108,Op8108,Op810f ;@ 8508
  .long Op8110,Op8110,Op8110,Op8110,Op8110,Op8110,Op8110,Op8110 ;@ 8510
  .long Op8118,Op8118,Op8118,Op8118,Op8118,Op8118,Op8118,Op811f ;@ 8518
  .long Op8120,Op8120,Op8120,Op8120,Op8120,Op8120,Op8120,Op8127 ;@ 8520
  .long Op8128,Op8128,Op8128,Op8128,Op8128,Op8128,Op8128,Op8128 ;@ 8528
  .long Op8130,Op8130,Op8130,Op8130,Op8130,Op8130,Op8130,Op8130 ;@ 8530
  .long Op8138,Op8139,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 8538
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 8540
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 8548
  .long Op8150,Op8150,Op8150,Op8150,Op8150,Op8150,Op8150,Op8150 ;@ 8550
  .long Op8158,Op8158,Op8158,Op8158,Op8158,Op8158,Op8158,Op8158 ;@ 8558
  .long Op8160,Op8160,Op8160,Op8160,Op8160,Op8160,Op8160,Op8160 ;@ 8560
  .long Op8168,Op8168,Op8168,Op8168,Op8168,Op8168,Op8168,Op8168 ;@ 8568
  .long Op8170,Op8170,Op8170,Op8170,Op8170,Op8170,Op8170,Op8170 ;@ 8570
  .long Op8178,Op8179,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 8578
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 8580
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 8588
  .long Op8190,Op8190,Op8190,Op8190,Op8190,Op8190,Op8190,Op8190 ;@ 8590
  .long Op8198,Op8198,Op8198,Op8198,Op8198,Op8198,Op8198,Op8198 ;@ 8598
  .long Op81a0,Op81a0,Op81a0,Op81a0,Op81a0,Op81a0,Op81a0,Op81a0 ;@ 85a0
  .long Op81a8,Op81a8,Op81a8,Op81a8,Op81a8,Op81a8,Op81a8,Op81a8 ;@ 85a8
  .long Op81b0,Op81b0,Op81b0,Op81b0,Op81b0,Op81b0,Op81b0,Op81b0 ;@ 85b0
  .long Op81b8,Op81b9,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 85b8
  .long Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0 ;@ 85c0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 85c8
  .long Op81d0,Op81d0,Op81d0,Op81d0,Op81d0,Op81d0,Op81d0,Op81d0 ;@ 85d0
  .long Op81d8,Op81d8,Op81d8,Op81d8,Op81d8,Op81d8,Op81d8,Op81d8 ;@ 85d8
  .long Op81e0,Op81e0,Op81e0,Op81e0,Op81e0,Op81e0,Op81e0,Op81e0 ;@ 85e0
  .long Op81e8,Op81e8,Op81e8,Op81e8,Op81e8,Op81e8,Op81e8,Op81e8 ;@ 85e8
  .long Op81f0,Op81f0,Op81f0,Op81f0,Op81f0,Op81f0,Op81f0,Op81f0 ;@ 85f0
  .long Op81f8,Op81f9,Op81fa,Op81fb,Op81fc,Op____,Op____,Op____ ;@ 85f8
  .long Op8000,Op8000,Op8000,Op8000,Op8000,Op8000,Op8000,Op8000 ;@ 8600
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 8608
  .long Op8010,Op8010,Op8010,Op8010,Op8010,Op8010,Op8010,Op8010 ;@ 8610
  .long Op8018,Op8018,Op8018,Op8018,Op8018,Op8018,Op8018,Op801f ;@ 8618
  .long Op8020,Op8020,Op8020,Op8020,Op8020,Op8020,Op8020,Op8027 ;@ 8620
  .long Op8028,Op8028,Op8028,Op8028,Op8028,Op8028,Op8028,Op8028 ;@ 8628
  .long Op8030,Op8030,Op8030,Op8030,Op8030,Op8030,Op8030,Op8030 ;@ 8630
  .long Op8038,Op8039,Op803a,Op803b,Op803c,Op____,Op____,Op____ ;@ 8638
  .long Op8040,Op8040,Op8040,Op8040,Op8040,Op8040,Op8040,Op8040 ;@ 8640
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 8648
  .long Op8050,Op8050,Op8050,Op8050,Op8050,Op8050,Op8050,Op8050 ;@ 8650
  .long Op8058,Op8058,Op8058,Op8058,Op8058,Op8058,Op8058,Op8058 ;@ 8658
  .long Op8060,Op8060,Op8060,Op8060,Op8060,Op8060,Op8060,Op8060 ;@ 8660
  .long Op8068,Op8068,Op8068,Op8068,Op8068,Op8068,Op8068,Op8068 ;@ 8668
  .long Op8070,Op8070,Op8070,Op8070,Op8070,Op8070,Op8070,Op8070 ;@ 8670
  .long Op8078,Op8079,Op807a,Op807b,Op807c,Op____,Op____,Op____ ;@ 8678
  .long Op8080,Op8080,Op8080,Op8080,Op8080,Op8080,Op8080,Op8080 ;@ 8680
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 8688
  .long Op8090,Op8090,Op8090,Op8090,Op8090,Op8090,Op8090,Op8090 ;@ 8690
  .long Op8098,Op8098,Op8098,Op8098,Op8098,Op8098,Op8098,Op8098 ;@ 8698
  .long Op80a0,Op80a0,Op80a0,Op80a0,Op80a0,Op80a0,Op80a0,Op80a0 ;@ 86a0
  .long Op80a8,Op80a8,Op80a8,Op80a8,Op80a8,Op80a8,Op80a8,Op80a8 ;@ 86a8
  .long Op80b0,Op80b0,Op80b0,Op80b0,Op80b0,Op80b0,Op80b0,Op80b0 ;@ 86b0
  .long Op80b8,Op80b9,Op80ba,Op80bb,Op80bc,Op____,Op____,Op____ ;@ 86b8
  .long Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0 ;@ 86c0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 86c8
  .long Op80d0,Op80d0,Op80d0,Op80d0,Op80d0,Op80d0,Op80d0,Op80d0 ;@ 86d0
  .long Op80d8,Op80d8,Op80d8,Op80d8,Op80d8,Op80d8,Op80d8,Op80d8 ;@ 86d8
  .long Op80e0,Op80e0,Op80e0,Op80e0,Op80e0,Op80e0,Op80e0,Op80e0 ;@ 86e0
  .long Op80e8,Op80e8,Op80e8,Op80e8,Op80e8,Op80e8,Op80e8,Op80e8 ;@ 86e8
  .long Op80f0,Op80f0,Op80f0,Op80f0,Op80f0,Op80f0,Op80f0,Op80f0 ;@ 86f0
  .long Op80f8,Op80f9,Op80fa,Op80fb,Op80fc,Op____,Op____,Op____ ;@ 86f8
  .long Op8100,Op8100,Op8100,Op8100,Op8100,Op8100,Op8100,Op8100 ;@ 8700
  .long Op8108,Op8108,Op8108,Op8108,Op8108,Op8108,Op8108,Op810f ;@ 8708
  .long Op8110,Op8110,Op8110,Op8110,Op8110,Op8110,Op8110,Op8110 ;@ 8710
  .long Op8118,Op8118,Op8118,Op8118,Op8118,Op8118,Op8118,Op811f ;@ 8718
  .long Op8120,Op8120,Op8120,Op8120,Op8120,Op8120,Op8120,Op8127 ;@ 8720
  .long Op8128,Op8128,Op8128,Op8128,Op8128,Op8128,Op8128,Op8128 ;@ 8728
  .long Op8130,Op8130,Op8130,Op8130,Op8130,Op8130,Op8130,Op8130 ;@ 8730
  .long Op8138,Op8139,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 8738
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 8740
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 8748
  .long Op8150,Op8150,Op8150,Op8150,Op8150,Op8150,Op8150,Op8150 ;@ 8750
  .long Op8158,Op8158,Op8158,Op8158,Op8158,Op8158,Op8158,Op8158 ;@ 8758
  .long Op8160,Op8160,Op8160,Op8160,Op8160,Op8160,Op8160,Op8160 ;@ 8760
  .long Op8168,Op8168,Op8168,Op8168,Op8168,Op8168,Op8168,Op8168 ;@ 8768
  .long Op8170,Op8170,Op8170,Op8170,Op8170,Op8170,Op8170,Op8170 ;@ 8770
  .long Op8178,Op8179,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 8778
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 8780
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 8788
  .long Op8190,Op8190,Op8190,Op8190,Op8190,Op8190,Op8190,Op8190 ;@ 8790
  .long Op8198,Op8198,Op8198,Op8198,Op8198,Op8198,Op8198,Op8198 ;@ 8798
  .long Op81a0,Op81a0,Op81a0,Op81a0,Op81a0,Op81a0,Op81a0,Op81a0 ;@ 87a0
  .long Op81a8,Op81a8,Op81a8,Op81a8,Op81a8,Op81a8,Op81a8,Op81a8 ;@ 87a8
  .long Op81b0,Op81b0,Op81b0,Op81b0,Op81b0,Op81b0,Op81b0,Op81b0 ;@ 87b0
  .long Op81b8,Op81b9,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 87b8
  .long Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0 ;@ 87c0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 87c8
  .long Op81d0,Op81d0,Op81d0,Op81d0,Op81d0,Op81d0,Op81d0,Op81d0 ;@ 87d0
  .long Op81d8,Op81d8,Op81d8,Op81d8,Op81d8,Op81d8,Op81d8,Op81d8 ;@ 87d8
  .long Op81e0,Op81e0,Op81e0,Op81e0,Op81e0,Op81e0,Op81e0,Op81e0 ;@ 87e0
  .long Op81e8,Op81e8,Op81e8,Op81e8,Op81e8,Op81e8,Op81e8,Op81e8 ;@ 87e8
  .long Op81f0,Op81f0,Op81f0,Op81f0,Op81f0,Op81f0,Op81f0,Op81f0 ;@ 87f0
  .long Op81f8,Op81f9,Op81fa,Op81fb,Op81fc,Op____,Op____,Op____ ;@ 87f8
  .long Op8000,Op8000,Op8000,Op8000,Op8000,Op8000,Op8000,Op8000 ;@ 8800
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 8808
  .long Op8010,Op8010,Op8010,Op8010,Op8010,Op8010,Op8010,Op8010 ;@ 8810
  .long Op8018,Op8018,Op8018,Op8018,Op8018,Op8018,Op8018,Op801f ;@ 8818
  .long Op8020,Op8020,Op8020,Op8020,Op8020,Op8020,Op8020,Op8027 ;@ 8820
  .long Op8028,Op8028,Op8028,Op8028,Op8028,Op8028,Op8028,Op8028 ;@ 8828
  .long Op8030,Op8030,Op8030,Op8030,Op8030,Op8030,Op8030,Op8030 ;@ 8830
  .long Op8038,Op8039,Op803a,Op803b,Op803c,Op____,Op____,Op____ ;@ 8838
  .long Op8040,Op8040,Op8040,Op8040,Op8040,Op8040,Op8040,Op8040 ;@ 8840
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 8848
  .long Op8050,Op8050,Op8050,Op8050,Op8050,Op8050,Op8050,Op8050 ;@ 8850
  .long Op8058,Op8058,Op8058,Op8058,Op8058,Op8058,Op8058,Op8058 ;@ 8858
  .long Op8060,Op8060,Op8060,Op8060,Op8060,Op8060,Op8060,Op8060 ;@ 8860
  .long Op8068,Op8068,Op8068,Op8068,Op8068,Op8068,Op8068,Op8068 ;@ 8868
  .long Op8070,Op8070,Op8070,Op8070,Op8070,Op8070,Op8070,Op8070 ;@ 8870
  .long Op8078,Op8079,Op807a,Op807b,Op807c,Op____,Op____,Op____ ;@ 8878
  .long Op8080,Op8080,Op8080,Op8080,Op8080,Op8080,Op8080,Op8080 ;@ 8880
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 8888
  .long Op8090,Op8090,Op8090,Op8090,Op8090,Op8090,Op8090,Op8090 ;@ 8890
  .long Op8098,Op8098,Op8098,Op8098,Op8098,Op8098,Op8098,Op8098 ;@ 8898
  .long Op80a0,Op80a0,Op80a0,Op80a0,Op80a0,Op80a0,Op80a0,Op80a0 ;@ 88a0
  .long Op80a8,Op80a8,Op80a8,Op80a8,Op80a8,Op80a8,Op80a8,Op80a8 ;@ 88a8
  .long Op80b0,Op80b0,Op80b0,Op80b0,Op80b0,Op80b0,Op80b0,Op80b0 ;@ 88b0
  .long Op80b8,Op80b9,Op80ba,Op80bb,Op80bc,Op____,Op____,Op____ ;@ 88b8
  .long Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0 ;@ 88c0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 88c8
  .long Op80d0,Op80d0,Op80d0,Op80d0,Op80d0,Op80d0,Op80d0,Op80d0 ;@ 88d0
  .long Op80d8,Op80d8,Op80d8,Op80d8,Op80d8,Op80d8,Op80d8,Op80d8 ;@ 88d8
  .long Op80e0,Op80e0,Op80e0,Op80e0,Op80e0,Op80e0,Op80e0,Op80e0 ;@ 88e0
  .long Op80e8,Op80e8,Op80e8,Op80e8,Op80e8,Op80e8,Op80e8,Op80e8 ;@ 88e8
  .long Op80f0,Op80f0,Op80f0,Op80f0,Op80f0,Op80f0,Op80f0,Op80f0 ;@ 88f0
  .long Op80f8,Op80f9,Op80fa,Op80fb,Op80fc,Op____,Op____,Op____ ;@ 88f8
  .long Op8100,Op8100,Op8100,Op8100,Op8100,Op8100,Op8100,Op8100 ;@ 8900
  .long Op8108,Op8108,Op8108,Op8108,Op8108,Op8108,Op8108,Op810f ;@ 8908
  .long Op8110,Op8110,Op8110,Op8110,Op8110,Op8110,Op8110,Op8110 ;@ 8910
  .long Op8118,Op8118,Op8118,Op8118,Op8118,Op8118,Op8118,Op811f ;@ 8918
  .long Op8120,Op8120,Op8120,Op8120,Op8120,Op8120,Op8120,Op8127 ;@ 8920
  .long Op8128,Op8128,Op8128,Op8128,Op8128,Op8128,Op8128,Op8128 ;@ 8928
  .long Op8130,Op8130,Op8130,Op8130,Op8130,Op8130,Op8130,Op8130 ;@ 8930
  .long Op8138,Op8139,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 8938
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 8940
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 8948
  .long Op8150,Op8150,Op8150,Op8150,Op8150,Op8150,Op8150,Op8150 ;@ 8950
  .long Op8158,Op8158,Op8158,Op8158,Op8158,Op8158,Op8158,Op8158 ;@ 8958
  .long Op8160,Op8160,Op8160,Op8160,Op8160,Op8160,Op8160,Op8160 ;@ 8960
  .long Op8168,Op8168,Op8168,Op8168,Op8168,Op8168,Op8168,Op8168 ;@ 8968
  .long Op8170,Op8170,Op8170,Op8170,Op8170,Op8170,Op8170,Op8170 ;@ 8970
  .long Op8178,Op8179,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 8978
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 8980
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 8988
  .long Op8190,Op8190,Op8190,Op8190,Op8190,Op8190,Op8190,Op8190 ;@ 8990
  .long Op8198,Op8198,Op8198,Op8198,Op8198,Op8198,Op8198,Op8198 ;@ 8998
  .long Op81a0,Op81a0,Op81a0,Op81a0,Op81a0,Op81a0,Op81a0,Op81a0 ;@ 89a0
  .long Op81a8,Op81a8,Op81a8,Op81a8,Op81a8,Op81a8,Op81a8,Op81a8 ;@ 89a8
  .long Op81b0,Op81b0,Op81b0,Op81b0,Op81b0,Op81b0,Op81b0,Op81b0 ;@ 89b0
  .long Op81b8,Op81b9,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 89b8
  .long Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0 ;@ 89c0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 89c8
  .long Op81d0,Op81d0,Op81d0,Op81d0,Op81d0,Op81d0,Op81d0,Op81d0 ;@ 89d0
  .long Op81d8,Op81d8,Op81d8,Op81d8,Op81d8,Op81d8,Op81d8,Op81d8 ;@ 89d8
  .long Op81e0,Op81e0,Op81e0,Op81e0,Op81e0,Op81e0,Op81e0,Op81e0 ;@ 89e0
  .long Op81e8,Op81e8,Op81e8,Op81e8,Op81e8,Op81e8,Op81e8,Op81e8 ;@ 89e8
  .long Op81f0,Op81f0,Op81f0,Op81f0,Op81f0,Op81f0,Op81f0,Op81f0 ;@ 89f0
  .long Op81f8,Op81f9,Op81fa,Op81fb,Op81fc,Op____,Op____,Op____ ;@ 89f8
  .long Op8000,Op8000,Op8000,Op8000,Op8000,Op8000,Op8000,Op8000 ;@ 8a00
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 8a08
  .long Op8010,Op8010,Op8010,Op8010,Op8010,Op8010,Op8010,Op8010 ;@ 8a10
  .long Op8018,Op8018,Op8018,Op8018,Op8018,Op8018,Op8018,Op801f ;@ 8a18
  .long Op8020,Op8020,Op8020,Op8020,Op8020,Op8020,Op8020,Op8027 ;@ 8a20
  .long Op8028,Op8028,Op8028,Op8028,Op8028,Op8028,Op8028,Op8028 ;@ 8a28
  .long Op8030,Op8030,Op8030,Op8030,Op8030,Op8030,Op8030,Op8030 ;@ 8a30
  .long Op8038,Op8039,Op803a,Op803b,Op803c,Op____,Op____,Op____ ;@ 8a38
  .long Op8040,Op8040,Op8040,Op8040,Op8040,Op8040,Op8040,Op8040 ;@ 8a40
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 8a48
  .long Op8050,Op8050,Op8050,Op8050,Op8050,Op8050,Op8050,Op8050 ;@ 8a50
  .long Op8058,Op8058,Op8058,Op8058,Op8058,Op8058,Op8058,Op8058 ;@ 8a58
  .long Op8060,Op8060,Op8060,Op8060,Op8060,Op8060,Op8060,Op8060 ;@ 8a60
  .long Op8068,Op8068,Op8068,Op8068,Op8068,Op8068,Op8068,Op8068 ;@ 8a68
  .long Op8070,Op8070,Op8070,Op8070,Op8070,Op8070,Op8070,Op8070 ;@ 8a70
  .long Op8078,Op8079,Op807a,Op807b,Op807c,Op____,Op____,Op____ ;@ 8a78
  .long Op8080,Op8080,Op8080,Op8080,Op8080,Op8080,Op8080,Op8080 ;@ 8a80
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 8a88
  .long Op8090,Op8090,Op8090,Op8090,Op8090,Op8090,Op8090,Op8090 ;@ 8a90
  .long Op8098,Op8098,Op8098,Op8098,Op8098,Op8098,Op8098,Op8098 ;@ 8a98
  .long Op80a0,Op80a0,Op80a0,Op80a0,Op80a0,Op80a0,Op80a0,Op80a0 ;@ 8aa0
  .long Op80a8,Op80a8,Op80a8,Op80a8,Op80a8,Op80a8,Op80a8,Op80a8 ;@ 8aa8
  .long Op80b0,Op80b0,Op80b0,Op80b0,Op80b0,Op80b0,Op80b0,Op80b0 ;@ 8ab0
  .long Op80b8,Op80b9,Op80ba,Op80bb,Op80bc,Op____,Op____,Op____ ;@ 8ab8
  .long Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0 ;@ 8ac0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 8ac8
  .long Op80d0,Op80d0,Op80d0,Op80d0,Op80d0,Op80d0,Op80d0,Op80d0 ;@ 8ad0
  .long Op80d8,Op80d8,Op80d8,Op80d8,Op80d8,Op80d8,Op80d8,Op80d8 ;@ 8ad8
  .long Op80e0,Op80e0,Op80e0,Op80e0,Op80e0,Op80e0,Op80e0,Op80e0 ;@ 8ae0
  .long Op80e8,Op80e8,Op80e8,Op80e8,Op80e8,Op80e8,Op80e8,Op80e8 ;@ 8ae8
  .long Op80f0,Op80f0,Op80f0,Op80f0,Op80f0,Op80f0,Op80f0,Op80f0 ;@ 8af0
  .long Op80f8,Op80f9,Op80fa,Op80fb,Op80fc,Op____,Op____,Op____ ;@ 8af8
  .long Op8100,Op8100,Op8100,Op8100,Op8100,Op8100,Op8100,Op8100 ;@ 8b00
  .long Op8108,Op8108,Op8108,Op8108,Op8108,Op8108,Op8108,Op810f ;@ 8b08
  .long Op8110,Op8110,Op8110,Op8110,Op8110,Op8110,Op8110,Op8110 ;@ 8b10
  .long Op8118,Op8118,Op8118,Op8118,Op8118,Op8118,Op8118,Op811f ;@ 8b18
  .long Op8120,Op8120,Op8120,Op8120,Op8120,Op8120,Op8120,Op8127 ;@ 8b20
  .long Op8128,Op8128,Op8128,Op8128,Op8128,Op8128,Op8128,Op8128 ;@ 8b28
  .long Op8130,Op8130,Op8130,Op8130,Op8130,Op8130,Op8130,Op8130 ;@ 8b30
  .long Op8138,Op8139,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 8b38
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 8b40
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 8b48
  .long Op8150,Op8150,Op8150,Op8150,Op8150,Op8150,Op8150,Op8150 ;@ 8b50
  .long Op8158,Op8158,Op8158,Op8158,Op8158,Op8158,Op8158,Op8158 ;@ 8b58
  .long Op8160,Op8160,Op8160,Op8160,Op8160,Op8160,Op8160,Op8160 ;@ 8b60
  .long Op8168,Op8168,Op8168,Op8168,Op8168,Op8168,Op8168,Op8168 ;@ 8b68
  .long Op8170,Op8170,Op8170,Op8170,Op8170,Op8170,Op8170,Op8170 ;@ 8b70
  .long Op8178,Op8179,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 8b78
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 8b80
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 8b88
  .long Op8190,Op8190,Op8190,Op8190,Op8190,Op8190,Op8190,Op8190 ;@ 8b90
  .long Op8198,Op8198,Op8198,Op8198,Op8198,Op8198,Op8198,Op8198 ;@ 8b98
  .long Op81a0,Op81a0,Op81a0,Op81a0,Op81a0,Op81a0,Op81a0,Op81a0 ;@ 8ba0
  .long Op81a8,Op81a8,Op81a8,Op81a8,Op81a8,Op81a8,Op81a8,Op81a8 ;@ 8ba8
  .long Op81b0,Op81b0,Op81b0,Op81b0,Op81b0,Op81b0,Op81b0,Op81b0 ;@ 8bb0
  .long Op81b8,Op81b9,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 8bb8
  .long Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0 ;@ 8bc0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 8bc8
  .long Op81d0,Op81d0,Op81d0,Op81d0,Op81d0,Op81d0,Op81d0,Op81d0 ;@ 8bd0
  .long Op81d8,Op81d8,Op81d8,Op81d8,Op81d8,Op81d8,Op81d8,Op81d8 ;@ 8bd8
  .long Op81e0,Op81e0,Op81e0,Op81e0,Op81e0,Op81e0,Op81e0,Op81e0 ;@ 8be0
  .long Op81e8,Op81e8,Op81e8,Op81e8,Op81e8,Op81e8,Op81e8,Op81e8 ;@ 8be8
  .long Op81f0,Op81f0,Op81f0,Op81f0,Op81f0,Op81f0,Op81f0,Op81f0 ;@ 8bf0
  .long Op81f8,Op81f9,Op81fa,Op81fb,Op81fc,Op____,Op____,Op____ ;@ 8bf8
  .long Op8000,Op8000,Op8000,Op8000,Op8000,Op8000,Op8000,Op8000 ;@ 8c00
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 8c08
  .long Op8010,Op8010,Op8010,Op8010,Op8010,Op8010,Op8010,Op8010 ;@ 8c10
  .long Op8018,Op8018,Op8018,Op8018,Op8018,Op8018,Op8018,Op801f ;@ 8c18
  .long Op8020,Op8020,Op8020,Op8020,Op8020,Op8020,Op8020,Op8027 ;@ 8c20
  .long Op8028,Op8028,Op8028,Op8028,Op8028,Op8028,Op8028,Op8028 ;@ 8c28
  .long Op8030,Op8030,Op8030,Op8030,Op8030,Op8030,Op8030,Op8030 ;@ 8c30
  .long Op8038,Op8039,Op803a,Op803b,Op803c,Op____,Op____,Op____ ;@ 8c38
  .long Op8040,Op8040,Op8040,Op8040,Op8040,Op8040,Op8040,Op8040 ;@ 8c40
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 8c48
  .long Op8050,Op8050,Op8050,Op8050,Op8050,Op8050,Op8050,Op8050 ;@ 8c50
  .long Op8058,Op8058,Op8058,Op8058,Op8058,Op8058,Op8058,Op8058 ;@ 8c58
  .long Op8060,Op8060,Op8060,Op8060,Op8060,Op8060,Op8060,Op8060 ;@ 8c60
  .long Op8068,Op8068,Op8068,Op8068,Op8068,Op8068,Op8068,Op8068 ;@ 8c68
  .long Op8070,Op8070,Op8070,Op8070,Op8070,Op8070,Op8070,Op8070 ;@ 8c70
  .long Op8078,Op8079,Op807a,Op807b,Op807c,Op____,Op____,Op____ ;@ 8c78
  .long Op8080,Op8080,Op8080,Op8080,Op8080,Op8080,Op8080,Op8080 ;@ 8c80
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 8c88
  .long Op8090,Op8090,Op8090,Op8090,Op8090,Op8090,Op8090,Op8090 ;@ 8c90
  .long Op8098,Op8098,Op8098,Op8098,Op8098,Op8098,Op8098,Op8098 ;@ 8c98
  .long Op80a0,Op80a0,Op80a0,Op80a0,Op80a0,Op80a0,Op80a0,Op80a0 ;@ 8ca0
  .long Op80a8,Op80a8,Op80a8,Op80a8,Op80a8,Op80a8,Op80a8,Op80a8 ;@ 8ca8
  .long Op80b0,Op80b0,Op80b0,Op80b0,Op80b0,Op80b0,Op80b0,Op80b0 ;@ 8cb0
  .long Op80b8,Op80b9,Op80ba,Op80bb,Op80bc,Op____,Op____,Op____ ;@ 8cb8
  .long Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0 ;@ 8cc0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 8cc8
  .long Op80d0,Op80d0,Op80d0,Op80d0,Op80d0,Op80d0,Op80d0,Op80d0 ;@ 8cd0
  .long Op80d8,Op80d8,Op80d8,Op80d8,Op80d8,Op80d8,Op80d8,Op80d8 ;@ 8cd8
  .long Op80e0,Op80e0,Op80e0,Op80e0,Op80e0,Op80e0,Op80e0,Op80e0 ;@ 8ce0
  .long Op80e8,Op80e8,Op80e8,Op80e8,Op80e8,Op80e8,Op80e8,Op80e8 ;@ 8ce8
  .long Op80f0,Op80f0,Op80f0,Op80f0,Op80f0,Op80f0,Op80f0,Op80f0 ;@ 8cf0
  .long Op80f8,Op80f9,Op80fa,Op80fb,Op80fc,Op____,Op____,Op____ ;@ 8cf8
  .long Op8100,Op8100,Op8100,Op8100,Op8100,Op8100,Op8100,Op8100 ;@ 8d00
  .long Op8108,Op8108,Op8108,Op8108,Op8108,Op8108,Op8108,Op810f ;@ 8d08
  .long Op8110,Op8110,Op8110,Op8110,Op8110,Op8110,Op8110,Op8110 ;@ 8d10
  .long Op8118,Op8118,Op8118,Op8118,Op8118,Op8118,Op8118,Op811f ;@ 8d18
  .long Op8120,Op8120,Op8120,Op8120,Op8120,Op8120,Op8120,Op8127 ;@ 8d20
  .long Op8128,Op8128,Op8128,Op8128,Op8128,Op8128,Op8128,Op8128 ;@ 8d28
  .long Op8130,Op8130,Op8130,Op8130,Op8130,Op8130,Op8130,Op8130 ;@ 8d30
  .long Op8138,Op8139,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 8d38
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 8d40
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 8d48
  .long Op8150,Op8150,Op8150,Op8150,Op8150,Op8150,Op8150,Op8150 ;@ 8d50
  .long Op8158,Op8158,Op8158,Op8158,Op8158,Op8158,Op8158,Op8158 ;@ 8d58
  .long Op8160,Op8160,Op8160,Op8160,Op8160,Op8160,Op8160,Op8160 ;@ 8d60
  .long Op8168,Op8168,Op8168,Op8168,Op8168,Op8168,Op8168,Op8168 ;@ 8d68
  .long Op8170,Op8170,Op8170,Op8170,Op8170,Op8170,Op8170,Op8170 ;@ 8d70
  .long Op8178,Op8179,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 8d78
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 8d80
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 8d88
  .long Op8190,Op8190,Op8190,Op8190,Op8190,Op8190,Op8190,Op8190 ;@ 8d90
  .long Op8198,Op8198,Op8198,Op8198,Op8198,Op8198,Op8198,Op8198 ;@ 8d98
  .long Op81a0,Op81a0,Op81a0,Op81a0,Op81a0,Op81a0,Op81a0,Op81a0 ;@ 8da0
  .long Op81a8,Op81a8,Op81a8,Op81a8,Op81a8,Op81a8,Op81a8,Op81a8 ;@ 8da8
  .long Op81b0,Op81b0,Op81b0,Op81b0,Op81b0,Op81b0,Op81b0,Op81b0 ;@ 8db0
  .long Op81b8,Op81b9,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 8db8
  .long Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0 ;@ 8dc0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 8dc8
  .long Op81d0,Op81d0,Op81d0,Op81d0,Op81d0,Op81d0,Op81d0,Op81d0 ;@ 8dd0
  .long Op81d8,Op81d8,Op81d8,Op81d8,Op81d8,Op81d8,Op81d8,Op81d8 ;@ 8dd8
  .long Op81e0,Op81e0,Op81e0,Op81e0,Op81e0,Op81e0,Op81e0,Op81e0 ;@ 8de0
  .long Op81e8,Op81e8,Op81e8,Op81e8,Op81e8,Op81e8,Op81e8,Op81e8 ;@ 8de8
  .long Op81f0,Op81f0,Op81f0,Op81f0,Op81f0,Op81f0,Op81f0,Op81f0 ;@ 8df0
  .long Op81f8,Op81f9,Op81fa,Op81fb,Op81fc,Op____,Op____,Op____ ;@ 8df8
  .long Op8000,Op8000,Op8000,Op8000,Op8000,Op8000,Op8000,Op8000 ;@ 8e00
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 8e08
  .long Op8010,Op8010,Op8010,Op8010,Op8010,Op8010,Op8010,Op8010 ;@ 8e10
  .long Op8018,Op8018,Op8018,Op8018,Op8018,Op8018,Op8018,Op801f ;@ 8e18
  .long Op8020,Op8020,Op8020,Op8020,Op8020,Op8020,Op8020,Op8027 ;@ 8e20
  .long Op8028,Op8028,Op8028,Op8028,Op8028,Op8028,Op8028,Op8028 ;@ 8e28
  .long Op8030,Op8030,Op8030,Op8030,Op8030,Op8030,Op8030,Op8030 ;@ 8e30
  .long Op8038,Op8039,Op803a,Op803b,Op803c,Op____,Op____,Op____ ;@ 8e38
  .long Op8040,Op8040,Op8040,Op8040,Op8040,Op8040,Op8040,Op8040 ;@ 8e40
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 8e48
  .long Op8050,Op8050,Op8050,Op8050,Op8050,Op8050,Op8050,Op8050 ;@ 8e50
  .long Op8058,Op8058,Op8058,Op8058,Op8058,Op8058,Op8058,Op8058 ;@ 8e58
  .long Op8060,Op8060,Op8060,Op8060,Op8060,Op8060,Op8060,Op8060 ;@ 8e60
  .long Op8068,Op8068,Op8068,Op8068,Op8068,Op8068,Op8068,Op8068 ;@ 8e68
  .long Op8070,Op8070,Op8070,Op8070,Op8070,Op8070,Op8070,Op8070 ;@ 8e70
  .long Op8078,Op8079,Op807a,Op807b,Op807c,Op____,Op____,Op____ ;@ 8e78
  .long Op8080,Op8080,Op8080,Op8080,Op8080,Op8080,Op8080,Op8080 ;@ 8e80
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 8e88
  .long Op8090,Op8090,Op8090,Op8090,Op8090,Op8090,Op8090,Op8090 ;@ 8e90
  .long Op8098,Op8098,Op8098,Op8098,Op8098,Op8098,Op8098,Op8098 ;@ 8e98
  .long Op80a0,Op80a0,Op80a0,Op80a0,Op80a0,Op80a0,Op80a0,Op80a0 ;@ 8ea0
  .long Op80a8,Op80a8,Op80a8,Op80a8,Op80a8,Op80a8,Op80a8,Op80a8 ;@ 8ea8
  .long Op80b0,Op80b0,Op80b0,Op80b0,Op80b0,Op80b0,Op80b0,Op80b0 ;@ 8eb0
  .long Op80b8,Op80b9,Op80ba,Op80bb,Op80bc,Op____,Op____,Op____ ;@ 8eb8
  .long Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0,Op80c0 ;@ 8ec0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 8ec8
  .long Op80d0,Op80d0,Op80d0,Op80d0,Op80d0,Op80d0,Op80d0,Op80d0 ;@ 8ed0
  .long Op80d8,Op80d8,Op80d8,Op80d8,Op80d8,Op80d8,Op80d8,Op80d8 ;@ 8ed8
  .long Op80e0,Op80e0,Op80e0,Op80e0,Op80e0,Op80e0,Op80e0,Op80e0 ;@ 8ee0
  .long Op80e8,Op80e8,Op80e8,Op80e8,Op80e8,Op80e8,Op80e8,Op80e8 ;@ 8ee8
  .long Op80f0,Op80f0,Op80f0,Op80f0,Op80f0,Op80f0,Op80f0,Op80f0 ;@ 8ef0
  .long Op80f8,Op80f9,Op80fa,Op80fb,Op80fc,Op____,Op____,Op____ ;@ 8ef8
  .long Op8100,Op8100,Op8100,Op8100,Op8100,Op8100,Op8100,Op8100 ;@ 8f00
  .long Op8f08,Op8f08,Op8f08,Op8f08,Op8f08,Op8f08,Op8f08,Op8f0f ;@ 8f08
  .long Op8110,Op8110,Op8110,Op8110,Op8110,Op8110,Op8110,Op8110 ;@ 8f10
  .long Op8118,Op8118,Op8118,Op8118,Op8118,Op8118,Op8118,Op811f ;@ 8f18
  .long Op8120,Op8120,Op8120,Op8120,Op8120,Op8120,Op8120,Op8127 ;@ 8f20
  .long Op8128,Op8128,Op8128,Op8128,Op8128,Op8128,Op8128,Op8128 ;@ 8f28
  .long Op8130,Op8130,Op8130,Op8130,Op8130,Op8130,Op8130,Op8130 ;@ 8f30
  .long Op8138,Op8139,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 8f38
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 8f40
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 8f48
  .long Op8150,Op8150,Op8150,Op8150,Op8150,Op8150,Op8150,Op8150 ;@ 8f50
  .long Op8158,Op8158,Op8158,Op8158,Op8158,Op8158,Op8158,Op8158 ;@ 8f58
  .long Op8160,Op8160,Op8160,Op8160,Op8160,Op8160,Op8160,Op8160 ;@ 8f60
  .long Op8168,Op8168,Op8168,Op8168,Op8168,Op8168,Op8168,Op8168 ;@ 8f68
  .long Op8170,Op8170,Op8170,Op8170,Op8170,Op8170,Op8170,Op8170 ;@ 8f70
  .long Op8178,Op8179,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 8f78
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 8f80
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 8f88
  .long Op8190,Op8190,Op8190,Op8190,Op8190,Op8190,Op8190,Op8190 ;@ 8f90
  .long Op8198,Op8198,Op8198,Op8198,Op8198,Op8198,Op8198,Op8198 ;@ 8f98
  .long Op81a0,Op81a0,Op81a0,Op81a0,Op81a0,Op81a0,Op81a0,Op81a0 ;@ 8fa0
  .long Op81a8,Op81a8,Op81a8,Op81a8,Op81a8,Op81a8,Op81a8,Op81a8 ;@ 8fa8
  .long Op81b0,Op81b0,Op81b0,Op81b0,Op81b0,Op81b0,Op81b0,Op81b0 ;@ 8fb0
  .long Op81b8,Op81b9,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 8fb8
  .long Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0,Op81c0 ;@ 8fc0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 8fc8
  .long Op81d0,Op81d0,Op81d0,Op81d0,Op81d0,Op81d0,Op81d0,Op81d0 ;@ 8fd0
  .long Op81d8,Op81d8,Op81d8,Op81d8,Op81d8,Op81d8,Op81d8,Op81d8 ;@ 8fd8
  .long Op81e0,Op81e0,Op81e0,Op81e0,Op81e0,Op81e0,Op81e0,Op81e0 ;@ 8fe0
  .long Op81e8,Op81e8,Op81e8,Op81e8,Op81e8,Op81e8,Op81e8,Op81e8 ;@ 8fe8
  .long Op81f0,Op81f0,Op81f0,Op81f0,Op81f0,Op81f0,Op81f0,Op81f0 ;@ 8ff0
  .long Op81f8,Op81f9,Op81fa,Op81fb,Op81fc,Op____,Op____,Op____ ;@ 8ff8
  .long Op9000,Op9000,Op9000,Op9000,Op9000,Op9000,Op9000,Op9000 ;@ 9000
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 9008
  .long Op9010,Op9010,Op9010,Op9010,Op9010,Op9010,Op9010,Op9010 ;@ 9010
  .long Op9018,Op9018,Op9018,Op9018,Op9018,Op9018,Op9018,Op901f ;@ 9018
  .long Op9020,Op9020,Op9020,Op9020,Op9020,Op9020,Op9020,Op9027 ;@ 9020
  .long Op9028,Op9028,Op9028,Op9028,Op9028,Op9028,Op9028,Op9028 ;@ 9028
  .long Op9030,Op9030,Op9030,Op9030,Op9030,Op9030,Op9030,Op9030 ;@ 9030
  .long Op9038,Op9039,Op903a,Op903b,Op903c,Op____,Op____,Op____ ;@ 9038
  .long Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040 ;@ 9040
  .long Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040 ;@ 9048
  .long Op9050,Op9050,Op9050,Op9050,Op9050,Op9050,Op9050,Op9050 ;@ 9050
  .long Op9058,Op9058,Op9058,Op9058,Op9058,Op9058,Op9058,Op9058 ;@ 9058
  .long Op9060,Op9060,Op9060,Op9060,Op9060,Op9060,Op9060,Op9060 ;@ 9060
  .long Op9068,Op9068,Op9068,Op9068,Op9068,Op9068,Op9068,Op9068 ;@ 9068
  .long Op9070,Op9070,Op9070,Op9070,Op9070,Op9070,Op9070,Op9070 ;@ 9070
  .long Op9078,Op9079,Op907a,Op907b,Op907c,Op____,Op____,Op____ ;@ 9078
  .long Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080 ;@ 9080
  .long Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080 ;@ 9088
  .long Op9090,Op9090,Op9090,Op9090,Op9090,Op9090,Op9090,Op9090 ;@ 9090
  .long Op9098,Op9098,Op9098,Op9098,Op9098,Op9098,Op9098,Op9098 ;@ 9098
  .long Op90a0,Op90a0,Op90a0,Op90a0,Op90a0,Op90a0,Op90a0,Op90a0 ;@ 90a0
  .long Op90a8,Op90a8,Op90a8,Op90a8,Op90a8,Op90a8,Op90a8,Op90a8 ;@ 90a8
  .long Op90b0,Op90b0,Op90b0,Op90b0,Op90b0,Op90b0,Op90b0,Op90b0 ;@ 90b0
  .long Op90b8,Op90b9,Op90ba,Op90bb,Op90bc,Op____,Op____,Op____ ;@ 90b8
  .long Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0 ;@ 90c0
  .long Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0 ;@ 90c8
  .long Op90d0,Op90d0,Op90d0,Op90d0,Op90d0,Op90d0,Op90d0,Op90d0 ;@ 90d0
  .long Op90d8,Op90d8,Op90d8,Op90d8,Op90d8,Op90d8,Op90d8,Op90d8 ;@ 90d8
  .long Op90e0,Op90e0,Op90e0,Op90e0,Op90e0,Op90e0,Op90e0,Op90e0 ;@ 90e0
  .long Op90e8,Op90e8,Op90e8,Op90e8,Op90e8,Op90e8,Op90e8,Op90e8 ;@ 90e8
  .long Op90f0,Op90f0,Op90f0,Op90f0,Op90f0,Op90f0,Op90f0,Op90f0 ;@ 90f0
  .long Op90f8,Op90f9,Op90fa,Op90fb,Op90fc,Op____,Op____,Op____ ;@ 90f8
  .long Op9100,Op9100,Op9100,Op9100,Op9100,Op9100,Op9100,Op9100 ;@ 9100
  .long Op9108,Op9108,Op9108,Op9108,Op9108,Op9108,Op9108,Op910f ;@ 9108
  .long Op9110,Op9110,Op9110,Op9110,Op9110,Op9110,Op9110,Op9110 ;@ 9110
  .long Op9118,Op9118,Op9118,Op9118,Op9118,Op9118,Op9118,Op911f ;@ 9118
  .long Op9120,Op9120,Op9120,Op9120,Op9120,Op9120,Op9120,Op9127 ;@ 9120
  .long Op9128,Op9128,Op9128,Op9128,Op9128,Op9128,Op9128,Op9128 ;@ 9128
  .long Op9130,Op9130,Op9130,Op9130,Op9130,Op9130,Op9130,Op9130 ;@ 9130
  .long Op9138,Op9139,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 9138
  .long Op9140,Op9140,Op9140,Op9140,Op9140,Op9140,Op9140,Op9140 ;@ 9140
  .long Op9148,Op9148,Op9148,Op9148,Op9148,Op9148,Op9148,Op9148 ;@ 9148
  .long Op9150,Op9150,Op9150,Op9150,Op9150,Op9150,Op9150,Op9150 ;@ 9150
  .long Op9158,Op9158,Op9158,Op9158,Op9158,Op9158,Op9158,Op9158 ;@ 9158
  .long Op9160,Op9160,Op9160,Op9160,Op9160,Op9160,Op9160,Op9160 ;@ 9160
  .long Op9168,Op9168,Op9168,Op9168,Op9168,Op9168,Op9168,Op9168 ;@ 9168
  .long Op9170,Op9170,Op9170,Op9170,Op9170,Op9170,Op9170,Op9170 ;@ 9170
  .long Op9178,Op9179,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 9178
  .long Op9180,Op9180,Op9180,Op9180,Op9180,Op9180,Op9180,Op9180 ;@ 9180
  .long Op9188,Op9188,Op9188,Op9188,Op9188,Op9188,Op9188,Op9188 ;@ 9188
  .long Op9190,Op9190,Op9190,Op9190,Op9190,Op9190,Op9190,Op9190 ;@ 9190
  .long Op9198,Op9198,Op9198,Op9198,Op9198,Op9198,Op9198,Op9198 ;@ 9198
  .long Op91a0,Op91a0,Op91a0,Op91a0,Op91a0,Op91a0,Op91a0,Op91a0 ;@ 91a0
  .long Op91a8,Op91a8,Op91a8,Op91a8,Op91a8,Op91a8,Op91a8,Op91a8 ;@ 91a8
  .long Op91b0,Op91b0,Op91b0,Op91b0,Op91b0,Op91b0,Op91b0,Op91b0 ;@ 91b0
  .long Op91b8,Op91b9,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 91b8
  .long Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0 ;@ 91c0
  .long Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0 ;@ 91c8
  .long Op91d0,Op91d0,Op91d0,Op91d0,Op91d0,Op91d0,Op91d0,Op91d0 ;@ 91d0
  .long Op91d8,Op91d8,Op91d8,Op91d8,Op91d8,Op91d8,Op91d8,Op91d8 ;@ 91d8
  .long Op91e0,Op91e0,Op91e0,Op91e0,Op91e0,Op91e0,Op91e0,Op91e0 ;@ 91e0
  .long Op91e8,Op91e8,Op91e8,Op91e8,Op91e8,Op91e8,Op91e8,Op91e8 ;@ 91e8
  .long Op91f0,Op91f0,Op91f0,Op91f0,Op91f0,Op91f0,Op91f0,Op91f0 ;@ 91f0
  .long Op91f8,Op91f9,Op91fa,Op91fb,Op91fc,Op____,Op____,Op____ ;@ 91f8
  .long Op9000,Op9000,Op9000,Op9000,Op9000,Op9000,Op9000,Op9000 ;@ 9200
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 9208
  .long Op9010,Op9010,Op9010,Op9010,Op9010,Op9010,Op9010,Op9010 ;@ 9210
  .long Op9018,Op9018,Op9018,Op9018,Op9018,Op9018,Op9018,Op901f ;@ 9218
  .long Op9020,Op9020,Op9020,Op9020,Op9020,Op9020,Op9020,Op9027 ;@ 9220
  .long Op9028,Op9028,Op9028,Op9028,Op9028,Op9028,Op9028,Op9028 ;@ 9228
  .long Op9030,Op9030,Op9030,Op9030,Op9030,Op9030,Op9030,Op9030 ;@ 9230
  .long Op9038,Op9039,Op903a,Op903b,Op903c,Op____,Op____,Op____ ;@ 9238
  .long Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040 ;@ 9240
  .long Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040 ;@ 9248
  .long Op9050,Op9050,Op9050,Op9050,Op9050,Op9050,Op9050,Op9050 ;@ 9250
  .long Op9058,Op9058,Op9058,Op9058,Op9058,Op9058,Op9058,Op9058 ;@ 9258
  .long Op9060,Op9060,Op9060,Op9060,Op9060,Op9060,Op9060,Op9060 ;@ 9260
  .long Op9068,Op9068,Op9068,Op9068,Op9068,Op9068,Op9068,Op9068 ;@ 9268
  .long Op9070,Op9070,Op9070,Op9070,Op9070,Op9070,Op9070,Op9070 ;@ 9270
  .long Op9078,Op9079,Op907a,Op907b,Op907c,Op____,Op____,Op____ ;@ 9278
  .long Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080 ;@ 9280
  .long Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080 ;@ 9288
  .long Op9090,Op9090,Op9090,Op9090,Op9090,Op9090,Op9090,Op9090 ;@ 9290
  .long Op9098,Op9098,Op9098,Op9098,Op9098,Op9098,Op9098,Op9098 ;@ 9298
  .long Op90a0,Op90a0,Op90a0,Op90a0,Op90a0,Op90a0,Op90a0,Op90a0 ;@ 92a0
  .long Op90a8,Op90a8,Op90a8,Op90a8,Op90a8,Op90a8,Op90a8,Op90a8 ;@ 92a8
  .long Op90b0,Op90b0,Op90b0,Op90b0,Op90b0,Op90b0,Op90b0,Op90b0 ;@ 92b0
  .long Op90b8,Op90b9,Op90ba,Op90bb,Op90bc,Op____,Op____,Op____ ;@ 92b8
  .long Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0 ;@ 92c0
  .long Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0 ;@ 92c8
  .long Op90d0,Op90d0,Op90d0,Op90d0,Op90d0,Op90d0,Op90d0,Op90d0 ;@ 92d0
  .long Op90d8,Op90d8,Op90d8,Op90d8,Op90d8,Op90d8,Op90d8,Op90d8 ;@ 92d8
  .long Op90e0,Op90e0,Op90e0,Op90e0,Op90e0,Op90e0,Op90e0,Op90e0 ;@ 92e0
  .long Op90e8,Op90e8,Op90e8,Op90e8,Op90e8,Op90e8,Op90e8,Op90e8 ;@ 92e8
  .long Op90f0,Op90f0,Op90f0,Op90f0,Op90f0,Op90f0,Op90f0,Op90f0 ;@ 92f0
  .long Op90f8,Op90f9,Op90fa,Op90fb,Op90fc,Op____,Op____,Op____ ;@ 92f8
  .long Op9100,Op9100,Op9100,Op9100,Op9100,Op9100,Op9100,Op9100 ;@ 9300
  .long Op9108,Op9108,Op9108,Op9108,Op9108,Op9108,Op9108,Op910f ;@ 9308
  .long Op9110,Op9110,Op9110,Op9110,Op9110,Op9110,Op9110,Op9110 ;@ 9310
  .long Op9118,Op9118,Op9118,Op9118,Op9118,Op9118,Op9118,Op911f ;@ 9318
  .long Op9120,Op9120,Op9120,Op9120,Op9120,Op9120,Op9120,Op9127 ;@ 9320
  .long Op9128,Op9128,Op9128,Op9128,Op9128,Op9128,Op9128,Op9128 ;@ 9328
  .long Op9130,Op9130,Op9130,Op9130,Op9130,Op9130,Op9130,Op9130 ;@ 9330
  .long Op9138,Op9139,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 9338
  .long Op9140,Op9140,Op9140,Op9140,Op9140,Op9140,Op9140,Op9140 ;@ 9340
  .long Op9148,Op9148,Op9148,Op9148,Op9148,Op9148,Op9148,Op9148 ;@ 9348
  .long Op9150,Op9150,Op9150,Op9150,Op9150,Op9150,Op9150,Op9150 ;@ 9350
  .long Op9158,Op9158,Op9158,Op9158,Op9158,Op9158,Op9158,Op9158 ;@ 9358
  .long Op9160,Op9160,Op9160,Op9160,Op9160,Op9160,Op9160,Op9160 ;@ 9360
  .long Op9168,Op9168,Op9168,Op9168,Op9168,Op9168,Op9168,Op9168 ;@ 9368
  .long Op9170,Op9170,Op9170,Op9170,Op9170,Op9170,Op9170,Op9170 ;@ 9370
  .long Op9178,Op9179,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 9378
  .long Op9180,Op9180,Op9180,Op9180,Op9180,Op9180,Op9180,Op9180 ;@ 9380
  .long Op9188,Op9188,Op9188,Op9188,Op9188,Op9188,Op9188,Op9188 ;@ 9388
  .long Op9190,Op9190,Op9190,Op9190,Op9190,Op9190,Op9190,Op9190 ;@ 9390
  .long Op9198,Op9198,Op9198,Op9198,Op9198,Op9198,Op9198,Op9198 ;@ 9398
  .long Op91a0,Op91a0,Op91a0,Op91a0,Op91a0,Op91a0,Op91a0,Op91a0 ;@ 93a0
  .long Op91a8,Op91a8,Op91a8,Op91a8,Op91a8,Op91a8,Op91a8,Op91a8 ;@ 93a8
  .long Op91b0,Op91b0,Op91b0,Op91b0,Op91b0,Op91b0,Op91b0,Op91b0 ;@ 93b0
  .long Op91b8,Op91b9,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 93b8
  .long Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0 ;@ 93c0
  .long Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0 ;@ 93c8
  .long Op91d0,Op91d0,Op91d0,Op91d0,Op91d0,Op91d0,Op91d0,Op91d0 ;@ 93d0
  .long Op91d8,Op91d8,Op91d8,Op91d8,Op91d8,Op91d8,Op91d8,Op91d8 ;@ 93d8
  .long Op91e0,Op91e0,Op91e0,Op91e0,Op91e0,Op91e0,Op91e0,Op91e0 ;@ 93e0
  .long Op91e8,Op91e8,Op91e8,Op91e8,Op91e8,Op91e8,Op91e8,Op91e8 ;@ 93e8
  .long Op91f0,Op91f0,Op91f0,Op91f0,Op91f0,Op91f0,Op91f0,Op91f0 ;@ 93f0
  .long Op91f8,Op91f9,Op91fa,Op91fb,Op91fc,Op____,Op____,Op____ ;@ 93f8
  .long Op9000,Op9000,Op9000,Op9000,Op9000,Op9000,Op9000,Op9000 ;@ 9400
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 9408
  .long Op9010,Op9010,Op9010,Op9010,Op9010,Op9010,Op9010,Op9010 ;@ 9410
  .long Op9018,Op9018,Op9018,Op9018,Op9018,Op9018,Op9018,Op901f ;@ 9418
  .long Op9020,Op9020,Op9020,Op9020,Op9020,Op9020,Op9020,Op9027 ;@ 9420
  .long Op9028,Op9028,Op9028,Op9028,Op9028,Op9028,Op9028,Op9028 ;@ 9428
  .long Op9030,Op9030,Op9030,Op9030,Op9030,Op9030,Op9030,Op9030 ;@ 9430
  .long Op9038,Op9039,Op903a,Op903b,Op903c,Op____,Op____,Op____ ;@ 9438
  .long Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040 ;@ 9440
  .long Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040 ;@ 9448
  .long Op9050,Op9050,Op9050,Op9050,Op9050,Op9050,Op9050,Op9050 ;@ 9450
  .long Op9058,Op9058,Op9058,Op9058,Op9058,Op9058,Op9058,Op9058 ;@ 9458
  .long Op9060,Op9060,Op9060,Op9060,Op9060,Op9060,Op9060,Op9060 ;@ 9460
  .long Op9068,Op9068,Op9068,Op9068,Op9068,Op9068,Op9068,Op9068 ;@ 9468
  .long Op9070,Op9070,Op9070,Op9070,Op9070,Op9070,Op9070,Op9070 ;@ 9470
  .long Op9078,Op9079,Op907a,Op907b,Op907c,Op____,Op____,Op____ ;@ 9478
  .long Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080 ;@ 9480
  .long Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080 ;@ 9488
  .long Op9090,Op9090,Op9090,Op9090,Op9090,Op9090,Op9090,Op9090 ;@ 9490
  .long Op9098,Op9098,Op9098,Op9098,Op9098,Op9098,Op9098,Op9098 ;@ 9498
  .long Op90a0,Op90a0,Op90a0,Op90a0,Op90a0,Op90a0,Op90a0,Op90a0 ;@ 94a0
  .long Op90a8,Op90a8,Op90a8,Op90a8,Op90a8,Op90a8,Op90a8,Op90a8 ;@ 94a8
  .long Op90b0,Op90b0,Op90b0,Op90b0,Op90b0,Op90b0,Op90b0,Op90b0 ;@ 94b0
  .long Op90b8,Op90b9,Op90ba,Op90bb,Op90bc,Op____,Op____,Op____ ;@ 94b8
  .long Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0 ;@ 94c0
  .long Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0 ;@ 94c8
  .long Op90d0,Op90d0,Op90d0,Op90d0,Op90d0,Op90d0,Op90d0,Op90d0 ;@ 94d0
  .long Op90d8,Op90d8,Op90d8,Op90d8,Op90d8,Op90d8,Op90d8,Op90d8 ;@ 94d8
  .long Op90e0,Op90e0,Op90e0,Op90e0,Op90e0,Op90e0,Op90e0,Op90e0 ;@ 94e0
  .long Op90e8,Op90e8,Op90e8,Op90e8,Op90e8,Op90e8,Op90e8,Op90e8 ;@ 94e8
  .long Op90f0,Op90f0,Op90f0,Op90f0,Op90f0,Op90f0,Op90f0,Op90f0 ;@ 94f0
  .long Op90f8,Op90f9,Op90fa,Op90fb,Op90fc,Op____,Op____,Op____ ;@ 94f8
  .long Op9100,Op9100,Op9100,Op9100,Op9100,Op9100,Op9100,Op9100 ;@ 9500
  .long Op9108,Op9108,Op9108,Op9108,Op9108,Op9108,Op9108,Op910f ;@ 9508
  .long Op9110,Op9110,Op9110,Op9110,Op9110,Op9110,Op9110,Op9110 ;@ 9510
  .long Op9118,Op9118,Op9118,Op9118,Op9118,Op9118,Op9118,Op911f ;@ 9518
  .long Op9120,Op9120,Op9120,Op9120,Op9120,Op9120,Op9120,Op9127 ;@ 9520
  .long Op9128,Op9128,Op9128,Op9128,Op9128,Op9128,Op9128,Op9128 ;@ 9528
  .long Op9130,Op9130,Op9130,Op9130,Op9130,Op9130,Op9130,Op9130 ;@ 9530
  .long Op9138,Op9139,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 9538
  .long Op9140,Op9140,Op9140,Op9140,Op9140,Op9140,Op9140,Op9140 ;@ 9540
  .long Op9148,Op9148,Op9148,Op9148,Op9148,Op9148,Op9148,Op9148 ;@ 9548
  .long Op9150,Op9150,Op9150,Op9150,Op9150,Op9150,Op9150,Op9150 ;@ 9550
  .long Op9158,Op9158,Op9158,Op9158,Op9158,Op9158,Op9158,Op9158 ;@ 9558
  .long Op9160,Op9160,Op9160,Op9160,Op9160,Op9160,Op9160,Op9160 ;@ 9560
  .long Op9168,Op9168,Op9168,Op9168,Op9168,Op9168,Op9168,Op9168 ;@ 9568
  .long Op9170,Op9170,Op9170,Op9170,Op9170,Op9170,Op9170,Op9170 ;@ 9570
  .long Op9178,Op9179,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 9578
  .long Op9180,Op9180,Op9180,Op9180,Op9180,Op9180,Op9180,Op9180 ;@ 9580
  .long Op9188,Op9188,Op9188,Op9188,Op9188,Op9188,Op9188,Op9188 ;@ 9588
  .long Op9190,Op9190,Op9190,Op9190,Op9190,Op9190,Op9190,Op9190 ;@ 9590
  .long Op9198,Op9198,Op9198,Op9198,Op9198,Op9198,Op9198,Op9198 ;@ 9598
  .long Op91a0,Op91a0,Op91a0,Op91a0,Op91a0,Op91a0,Op91a0,Op91a0 ;@ 95a0
  .long Op91a8,Op91a8,Op91a8,Op91a8,Op91a8,Op91a8,Op91a8,Op91a8 ;@ 95a8
  .long Op91b0,Op91b0,Op91b0,Op91b0,Op91b0,Op91b0,Op91b0,Op91b0 ;@ 95b0
  .long Op91b8,Op91b9,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 95b8
  .long Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0 ;@ 95c0
  .long Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0 ;@ 95c8
  .long Op91d0,Op91d0,Op91d0,Op91d0,Op91d0,Op91d0,Op91d0,Op91d0 ;@ 95d0
  .long Op91d8,Op91d8,Op91d8,Op91d8,Op91d8,Op91d8,Op91d8,Op91d8 ;@ 95d8
  .long Op91e0,Op91e0,Op91e0,Op91e0,Op91e0,Op91e0,Op91e0,Op91e0 ;@ 95e0
  .long Op91e8,Op91e8,Op91e8,Op91e8,Op91e8,Op91e8,Op91e8,Op91e8 ;@ 95e8
  .long Op91f0,Op91f0,Op91f0,Op91f0,Op91f0,Op91f0,Op91f0,Op91f0 ;@ 95f0
  .long Op91f8,Op91f9,Op91fa,Op91fb,Op91fc,Op____,Op____,Op____ ;@ 95f8
  .long Op9000,Op9000,Op9000,Op9000,Op9000,Op9000,Op9000,Op9000 ;@ 9600
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 9608
  .long Op9010,Op9010,Op9010,Op9010,Op9010,Op9010,Op9010,Op9010 ;@ 9610
  .long Op9018,Op9018,Op9018,Op9018,Op9018,Op9018,Op9018,Op901f ;@ 9618
  .long Op9020,Op9020,Op9020,Op9020,Op9020,Op9020,Op9020,Op9027 ;@ 9620
  .long Op9028,Op9028,Op9028,Op9028,Op9028,Op9028,Op9028,Op9028 ;@ 9628
  .long Op9030,Op9030,Op9030,Op9030,Op9030,Op9030,Op9030,Op9030 ;@ 9630
  .long Op9038,Op9039,Op903a,Op903b,Op903c,Op____,Op____,Op____ ;@ 9638
  .long Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040 ;@ 9640
  .long Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040 ;@ 9648
  .long Op9050,Op9050,Op9050,Op9050,Op9050,Op9050,Op9050,Op9050 ;@ 9650
  .long Op9058,Op9058,Op9058,Op9058,Op9058,Op9058,Op9058,Op9058 ;@ 9658
  .long Op9060,Op9060,Op9060,Op9060,Op9060,Op9060,Op9060,Op9060 ;@ 9660
  .long Op9068,Op9068,Op9068,Op9068,Op9068,Op9068,Op9068,Op9068 ;@ 9668
  .long Op9070,Op9070,Op9070,Op9070,Op9070,Op9070,Op9070,Op9070 ;@ 9670
  .long Op9078,Op9079,Op907a,Op907b,Op907c,Op____,Op____,Op____ ;@ 9678
  .long Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080 ;@ 9680
  .long Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080 ;@ 9688
  .long Op9090,Op9090,Op9090,Op9090,Op9090,Op9090,Op9090,Op9090 ;@ 9690
  .long Op9098,Op9098,Op9098,Op9098,Op9098,Op9098,Op9098,Op9098 ;@ 9698
  .long Op90a0,Op90a0,Op90a0,Op90a0,Op90a0,Op90a0,Op90a0,Op90a0 ;@ 96a0
  .long Op90a8,Op90a8,Op90a8,Op90a8,Op90a8,Op90a8,Op90a8,Op90a8 ;@ 96a8
  .long Op90b0,Op90b0,Op90b0,Op90b0,Op90b0,Op90b0,Op90b0,Op90b0 ;@ 96b0
  .long Op90b8,Op90b9,Op90ba,Op90bb,Op90bc,Op____,Op____,Op____ ;@ 96b8
  .long Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0 ;@ 96c0
  .long Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0 ;@ 96c8
  .long Op90d0,Op90d0,Op90d0,Op90d0,Op90d0,Op90d0,Op90d0,Op90d0 ;@ 96d0
  .long Op90d8,Op90d8,Op90d8,Op90d8,Op90d8,Op90d8,Op90d8,Op90d8 ;@ 96d8
  .long Op90e0,Op90e0,Op90e0,Op90e0,Op90e0,Op90e0,Op90e0,Op90e0 ;@ 96e0
  .long Op90e8,Op90e8,Op90e8,Op90e8,Op90e8,Op90e8,Op90e8,Op90e8 ;@ 96e8
  .long Op90f0,Op90f0,Op90f0,Op90f0,Op90f0,Op90f0,Op90f0,Op90f0 ;@ 96f0
  .long Op90f8,Op90f9,Op90fa,Op90fb,Op90fc,Op____,Op____,Op____ ;@ 96f8
  .long Op9100,Op9100,Op9100,Op9100,Op9100,Op9100,Op9100,Op9100 ;@ 9700
  .long Op9108,Op9108,Op9108,Op9108,Op9108,Op9108,Op9108,Op910f ;@ 9708
  .long Op9110,Op9110,Op9110,Op9110,Op9110,Op9110,Op9110,Op9110 ;@ 9710
  .long Op9118,Op9118,Op9118,Op9118,Op9118,Op9118,Op9118,Op911f ;@ 9718
  .long Op9120,Op9120,Op9120,Op9120,Op9120,Op9120,Op9120,Op9127 ;@ 9720
  .long Op9128,Op9128,Op9128,Op9128,Op9128,Op9128,Op9128,Op9128 ;@ 9728
  .long Op9130,Op9130,Op9130,Op9130,Op9130,Op9130,Op9130,Op9130 ;@ 9730
  .long Op9138,Op9139,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 9738
  .long Op9140,Op9140,Op9140,Op9140,Op9140,Op9140,Op9140,Op9140 ;@ 9740
  .long Op9148,Op9148,Op9148,Op9148,Op9148,Op9148,Op9148,Op9148 ;@ 9748
  .long Op9150,Op9150,Op9150,Op9150,Op9150,Op9150,Op9150,Op9150 ;@ 9750
  .long Op9158,Op9158,Op9158,Op9158,Op9158,Op9158,Op9158,Op9158 ;@ 9758
  .long Op9160,Op9160,Op9160,Op9160,Op9160,Op9160,Op9160,Op9160 ;@ 9760
  .long Op9168,Op9168,Op9168,Op9168,Op9168,Op9168,Op9168,Op9168 ;@ 9768
  .long Op9170,Op9170,Op9170,Op9170,Op9170,Op9170,Op9170,Op9170 ;@ 9770
  .long Op9178,Op9179,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 9778
  .long Op9180,Op9180,Op9180,Op9180,Op9180,Op9180,Op9180,Op9180 ;@ 9780
  .long Op9188,Op9188,Op9188,Op9188,Op9188,Op9188,Op9188,Op9188 ;@ 9788
  .long Op9190,Op9190,Op9190,Op9190,Op9190,Op9190,Op9190,Op9190 ;@ 9790
  .long Op9198,Op9198,Op9198,Op9198,Op9198,Op9198,Op9198,Op9198 ;@ 9798
  .long Op91a0,Op91a0,Op91a0,Op91a0,Op91a0,Op91a0,Op91a0,Op91a0 ;@ 97a0
  .long Op91a8,Op91a8,Op91a8,Op91a8,Op91a8,Op91a8,Op91a8,Op91a8 ;@ 97a8
  .long Op91b0,Op91b0,Op91b0,Op91b0,Op91b0,Op91b0,Op91b0,Op91b0 ;@ 97b0
  .long Op91b8,Op91b9,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 97b8
  .long Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0 ;@ 97c0
  .long Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0 ;@ 97c8
  .long Op91d0,Op91d0,Op91d0,Op91d0,Op91d0,Op91d0,Op91d0,Op91d0 ;@ 97d0
  .long Op91d8,Op91d8,Op91d8,Op91d8,Op91d8,Op91d8,Op91d8,Op91d8 ;@ 97d8
  .long Op91e0,Op91e0,Op91e0,Op91e0,Op91e0,Op91e0,Op91e0,Op91e0 ;@ 97e0
  .long Op91e8,Op91e8,Op91e8,Op91e8,Op91e8,Op91e8,Op91e8,Op91e8 ;@ 97e8
  .long Op91f0,Op91f0,Op91f0,Op91f0,Op91f0,Op91f0,Op91f0,Op91f0 ;@ 97f0
  .long Op91f8,Op91f9,Op91fa,Op91fb,Op91fc,Op____,Op____,Op____ ;@ 97f8
  .long Op9000,Op9000,Op9000,Op9000,Op9000,Op9000,Op9000,Op9000 ;@ 9800
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 9808
  .long Op9010,Op9010,Op9010,Op9010,Op9010,Op9010,Op9010,Op9010 ;@ 9810
  .long Op9018,Op9018,Op9018,Op9018,Op9018,Op9018,Op9018,Op901f ;@ 9818
  .long Op9020,Op9020,Op9020,Op9020,Op9020,Op9020,Op9020,Op9027 ;@ 9820
  .long Op9028,Op9028,Op9028,Op9028,Op9028,Op9028,Op9028,Op9028 ;@ 9828
  .long Op9030,Op9030,Op9030,Op9030,Op9030,Op9030,Op9030,Op9030 ;@ 9830
  .long Op9038,Op9039,Op903a,Op903b,Op903c,Op____,Op____,Op____ ;@ 9838
  .long Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040 ;@ 9840
  .long Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040 ;@ 9848
  .long Op9050,Op9050,Op9050,Op9050,Op9050,Op9050,Op9050,Op9050 ;@ 9850
  .long Op9058,Op9058,Op9058,Op9058,Op9058,Op9058,Op9058,Op9058 ;@ 9858
  .long Op9060,Op9060,Op9060,Op9060,Op9060,Op9060,Op9060,Op9060 ;@ 9860
  .long Op9068,Op9068,Op9068,Op9068,Op9068,Op9068,Op9068,Op9068 ;@ 9868
  .long Op9070,Op9070,Op9070,Op9070,Op9070,Op9070,Op9070,Op9070 ;@ 9870
  .long Op9078,Op9079,Op907a,Op907b,Op907c,Op____,Op____,Op____ ;@ 9878
  .long Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080 ;@ 9880
  .long Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080 ;@ 9888
  .long Op9090,Op9090,Op9090,Op9090,Op9090,Op9090,Op9090,Op9090 ;@ 9890
  .long Op9098,Op9098,Op9098,Op9098,Op9098,Op9098,Op9098,Op9098 ;@ 9898
  .long Op90a0,Op90a0,Op90a0,Op90a0,Op90a0,Op90a0,Op90a0,Op90a0 ;@ 98a0
  .long Op90a8,Op90a8,Op90a8,Op90a8,Op90a8,Op90a8,Op90a8,Op90a8 ;@ 98a8
  .long Op90b0,Op90b0,Op90b0,Op90b0,Op90b0,Op90b0,Op90b0,Op90b0 ;@ 98b0
  .long Op90b8,Op90b9,Op90ba,Op90bb,Op90bc,Op____,Op____,Op____ ;@ 98b8
  .long Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0 ;@ 98c0
  .long Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0 ;@ 98c8
  .long Op90d0,Op90d0,Op90d0,Op90d0,Op90d0,Op90d0,Op90d0,Op90d0 ;@ 98d0
  .long Op90d8,Op90d8,Op90d8,Op90d8,Op90d8,Op90d8,Op90d8,Op90d8 ;@ 98d8
  .long Op90e0,Op90e0,Op90e0,Op90e0,Op90e0,Op90e0,Op90e0,Op90e0 ;@ 98e0
  .long Op90e8,Op90e8,Op90e8,Op90e8,Op90e8,Op90e8,Op90e8,Op90e8 ;@ 98e8
  .long Op90f0,Op90f0,Op90f0,Op90f0,Op90f0,Op90f0,Op90f0,Op90f0 ;@ 98f0
  .long Op90f8,Op90f9,Op90fa,Op90fb,Op90fc,Op____,Op____,Op____ ;@ 98f8
  .long Op9100,Op9100,Op9100,Op9100,Op9100,Op9100,Op9100,Op9100 ;@ 9900
  .long Op9108,Op9108,Op9108,Op9108,Op9108,Op9108,Op9108,Op910f ;@ 9908
  .long Op9110,Op9110,Op9110,Op9110,Op9110,Op9110,Op9110,Op9110 ;@ 9910
  .long Op9118,Op9118,Op9118,Op9118,Op9118,Op9118,Op9118,Op911f ;@ 9918
  .long Op9120,Op9120,Op9120,Op9120,Op9120,Op9120,Op9120,Op9127 ;@ 9920
  .long Op9128,Op9128,Op9128,Op9128,Op9128,Op9128,Op9128,Op9128 ;@ 9928
  .long Op9130,Op9130,Op9130,Op9130,Op9130,Op9130,Op9130,Op9130 ;@ 9930
  .long Op9138,Op9139,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 9938
  .long Op9140,Op9140,Op9140,Op9140,Op9140,Op9140,Op9140,Op9140 ;@ 9940
  .long Op9148,Op9148,Op9148,Op9148,Op9148,Op9148,Op9148,Op9148 ;@ 9948
  .long Op9150,Op9150,Op9150,Op9150,Op9150,Op9150,Op9150,Op9150 ;@ 9950
  .long Op9158,Op9158,Op9158,Op9158,Op9158,Op9158,Op9158,Op9158 ;@ 9958
  .long Op9160,Op9160,Op9160,Op9160,Op9160,Op9160,Op9160,Op9160 ;@ 9960
  .long Op9168,Op9168,Op9168,Op9168,Op9168,Op9168,Op9168,Op9168 ;@ 9968
  .long Op9170,Op9170,Op9170,Op9170,Op9170,Op9170,Op9170,Op9170 ;@ 9970
  .long Op9178,Op9179,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 9978
  .long Op9180,Op9180,Op9180,Op9180,Op9180,Op9180,Op9180,Op9180 ;@ 9980
  .long Op9188,Op9188,Op9188,Op9188,Op9188,Op9188,Op9188,Op9188 ;@ 9988
  .long Op9190,Op9190,Op9190,Op9190,Op9190,Op9190,Op9190,Op9190 ;@ 9990
  .long Op9198,Op9198,Op9198,Op9198,Op9198,Op9198,Op9198,Op9198 ;@ 9998
  .long Op91a0,Op91a0,Op91a0,Op91a0,Op91a0,Op91a0,Op91a0,Op91a0 ;@ 99a0
  .long Op91a8,Op91a8,Op91a8,Op91a8,Op91a8,Op91a8,Op91a8,Op91a8 ;@ 99a8
  .long Op91b0,Op91b0,Op91b0,Op91b0,Op91b0,Op91b0,Op91b0,Op91b0 ;@ 99b0
  .long Op91b8,Op91b9,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 99b8
  .long Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0 ;@ 99c0
  .long Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0 ;@ 99c8
  .long Op91d0,Op91d0,Op91d0,Op91d0,Op91d0,Op91d0,Op91d0,Op91d0 ;@ 99d0
  .long Op91d8,Op91d8,Op91d8,Op91d8,Op91d8,Op91d8,Op91d8,Op91d8 ;@ 99d8
  .long Op91e0,Op91e0,Op91e0,Op91e0,Op91e0,Op91e0,Op91e0,Op91e0 ;@ 99e0
  .long Op91e8,Op91e8,Op91e8,Op91e8,Op91e8,Op91e8,Op91e8,Op91e8 ;@ 99e8
  .long Op91f0,Op91f0,Op91f0,Op91f0,Op91f0,Op91f0,Op91f0,Op91f0 ;@ 99f0
  .long Op91f8,Op91f9,Op91fa,Op91fb,Op91fc,Op____,Op____,Op____ ;@ 99f8
  .long Op9000,Op9000,Op9000,Op9000,Op9000,Op9000,Op9000,Op9000 ;@ 9a00
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 9a08
  .long Op9010,Op9010,Op9010,Op9010,Op9010,Op9010,Op9010,Op9010 ;@ 9a10
  .long Op9018,Op9018,Op9018,Op9018,Op9018,Op9018,Op9018,Op901f ;@ 9a18
  .long Op9020,Op9020,Op9020,Op9020,Op9020,Op9020,Op9020,Op9027 ;@ 9a20
  .long Op9028,Op9028,Op9028,Op9028,Op9028,Op9028,Op9028,Op9028 ;@ 9a28
  .long Op9030,Op9030,Op9030,Op9030,Op9030,Op9030,Op9030,Op9030 ;@ 9a30
  .long Op9038,Op9039,Op903a,Op903b,Op903c,Op____,Op____,Op____ ;@ 9a38
  .long Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040 ;@ 9a40
  .long Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040 ;@ 9a48
  .long Op9050,Op9050,Op9050,Op9050,Op9050,Op9050,Op9050,Op9050 ;@ 9a50
  .long Op9058,Op9058,Op9058,Op9058,Op9058,Op9058,Op9058,Op9058 ;@ 9a58
  .long Op9060,Op9060,Op9060,Op9060,Op9060,Op9060,Op9060,Op9060 ;@ 9a60
  .long Op9068,Op9068,Op9068,Op9068,Op9068,Op9068,Op9068,Op9068 ;@ 9a68
  .long Op9070,Op9070,Op9070,Op9070,Op9070,Op9070,Op9070,Op9070 ;@ 9a70
  .long Op9078,Op9079,Op907a,Op907b,Op907c,Op____,Op____,Op____ ;@ 9a78
  .long Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080 ;@ 9a80
  .long Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080 ;@ 9a88
  .long Op9090,Op9090,Op9090,Op9090,Op9090,Op9090,Op9090,Op9090 ;@ 9a90
  .long Op9098,Op9098,Op9098,Op9098,Op9098,Op9098,Op9098,Op9098 ;@ 9a98
  .long Op90a0,Op90a0,Op90a0,Op90a0,Op90a0,Op90a0,Op90a0,Op90a0 ;@ 9aa0
  .long Op90a8,Op90a8,Op90a8,Op90a8,Op90a8,Op90a8,Op90a8,Op90a8 ;@ 9aa8
  .long Op90b0,Op90b0,Op90b0,Op90b0,Op90b0,Op90b0,Op90b0,Op90b0 ;@ 9ab0
  .long Op90b8,Op90b9,Op90ba,Op90bb,Op90bc,Op____,Op____,Op____ ;@ 9ab8
  .long Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0 ;@ 9ac0
  .long Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0 ;@ 9ac8
  .long Op90d0,Op90d0,Op90d0,Op90d0,Op90d0,Op90d0,Op90d0,Op90d0 ;@ 9ad0
  .long Op90d8,Op90d8,Op90d8,Op90d8,Op90d8,Op90d8,Op90d8,Op90d8 ;@ 9ad8
  .long Op90e0,Op90e0,Op90e0,Op90e0,Op90e0,Op90e0,Op90e0,Op90e0 ;@ 9ae0
  .long Op90e8,Op90e8,Op90e8,Op90e8,Op90e8,Op90e8,Op90e8,Op90e8 ;@ 9ae8
  .long Op90f0,Op90f0,Op90f0,Op90f0,Op90f0,Op90f0,Op90f0,Op90f0 ;@ 9af0
  .long Op90f8,Op90f9,Op90fa,Op90fb,Op90fc,Op____,Op____,Op____ ;@ 9af8
  .long Op9100,Op9100,Op9100,Op9100,Op9100,Op9100,Op9100,Op9100 ;@ 9b00
  .long Op9108,Op9108,Op9108,Op9108,Op9108,Op9108,Op9108,Op910f ;@ 9b08
  .long Op9110,Op9110,Op9110,Op9110,Op9110,Op9110,Op9110,Op9110 ;@ 9b10
  .long Op9118,Op9118,Op9118,Op9118,Op9118,Op9118,Op9118,Op911f ;@ 9b18
  .long Op9120,Op9120,Op9120,Op9120,Op9120,Op9120,Op9120,Op9127 ;@ 9b20
  .long Op9128,Op9128,Op9128,Op9128,Op9128,Op9128,Op9128,Op9128 ;@ 9b28
  .long Op9130,Op9130,Op9130,Op9130,Op9130,Op9130,Op9130,Op9130 ;@ 9b30
  .long Op9138,Op9139,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 9b38
  .long Op9140,Op9140,Op9140,Op9140,Op9140,Op9140,Op9140,Op9140 ;@ 9b40
  .long Op9148,Op9148,Op9148,Op9148,Op9148,Op9148,Op9148,Op9148 ;@ 9b48
  .long Op9150,Op9150,Op9150,Op9150,Op9150,Op9150,Op9150,Op9150 ;@ 9b50
  .long Op9158,Op9158,Op9158,Op9158,Op9158,Op9158,Op9158,Op9158 ;@ 9b58
  .long Op9160,Op9160,Op9160,Op9160,Op9160,Op9160,Op9160,Op9160 ;@ 9b60
  .long Op9168,Op9168,Op9168,Op9168,Op9168,Op9168,Op9168,Op9168 ;@ 9b68
  .long Op9170,Op9170,Op9170,Op9170,Op9170,Op9170,Op9170,Op9170 ;@ 9b70
  .long Op9178,Op9179,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 9b78
  .long Op9180,Op9180,Op9180,Op9180,Op9180,Op9180,Op9180,Op9180 ;@ 9b80
  .long Op9188,Op9188,Op9188,Op9188,Op9188,Op9188,Op9188,Op9188 ;@ 9b88
  .long Op9190,Op9190,Op9190,Op9190,Op9190,Op9190,Op9190,Op9190 ;@ 9b90
  .long Op9198,Op9198,Op9198,Op9198,Op9198,Op9198,Op9198,Op9198 ;@ 9b98
  .long Op91a0,Op91a0,Op91a0,Op91a0,Op91a0,Op91a0,Op91a0,Op91a0 ;@ 9ba0
  .long Op91a8,Op91a8,Op91a8,Op91a8,Op91a8,Op91a8,Op91a8,Op91a8 ;@ 9ba8
  .long Op91b0,Op91b0,Op91b0,Op91b0,Op91b0,Op91b0,Op91b0,Op91b0 ;@ 9bb0
  .long Op91b8,Op91b9,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 9bb8
  .long Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0 ;@ 9bc0
  .long Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0 ;@ 9bc8
  .long Op91d0,Op91d0,Op91d0,Op91d0,Op91d0,Op91d0,Op91d0,Op91d0 ;@ 9bd0
  .long Op91d8,Op91d8,Op91d8,Op91d8,Op91d8,Op91d8,Op91d8,Op91d8 ;@ 9bd8
  .long Op91e0,Op91e0,Op91e0,Op91e0,Op91e0,Op91e0,Op91e0,Op91e0 ;@ 9be0
  .long Op91e8,Op91e8,Op91e8,Op91e8,Op91e8,Op91e8,Op91e8,Op91e8 ;@ 9be8
  .long Op91f0,Op91f0,Op91f0,Op91f0,Op91f0,Op91f0,Op91f0,Op91f0 ;@ 9bf0
  .long Op91f8,Op91f9,Op91fa,Op91fb,Op91fc,Op____,Op____,Op____ ;@ 9bf8
  .long Op9000,Op9000,Op9000,Op9000,Op9000,Op9000,Op9000,Op9000 ;@ 9c00
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 9c08
  .long Op9010,Op9010,Op9010,Op9010,Op9010,Op9010,Op9010,Op9010 ;@ 9c10
  .long Op9018,Op9018,Op9018,Op9018,Op9018,Op9018,Op9018,Op901f ;@ 9c18
  .long Op9020,Op9020,Op9020,Op9020,Op9020,Op9020,Op9020,Op9027 ;@ 9c20
  .long Op9028,Op9028,Op9028,Op9028,Op9028,Op9028,Op9028,Op9028 ;@ 9c28
  .long Op9030,Op9030,Op9030,Op9030,Op9030,Op9030,Op9030,Op9030 ;@ 9c30
  .long Op9038,Op9039,Op903a,Op903b,Op903c,Op____,Op____,Op____ ;@ 9c38
  .long Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040 ;@ 9c40
  .long Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040 ;@ 9c48
  .long Op9050,Op9050,Op9050,Op9050,Op9050,Op9050,Op9050,Op9050 ;@ 9c50
  .long Op9058,Op9058,Op9058,Op9058,Op9058,Op9058,Op9058,Op9058 ;@ 9c58
  .long Op9060,Op9060,Op9060,Op9060,Op9060,Op9060,Op9060,Op9060 ;@ 9c60
  .long Op9068,Op9068,Op9068,Op9068,Op9068,Op9068,Op9068,Op9068 ;@ 9c68
  .long Op9070,Op9070,Op9070,Op9070,Op9070,Op9070,Op9070,Op9070 ;@ 9c70
  .long Op9078,Op9079,Op907a,Op907b,Op907c,Op____,Op____,Op____ ;@ 9c78
  .long Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080 ;@ 9c80
  .long Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080 ;@ 9c88
  .long Op9090,Op9090,Op9090,Op9090,Op9090,Op9090,Op9090,Op9090 ;@ 9c90
  .long Op9098,Op9098,Op9098,Op9098,Op9098,Op9098,Op9098,Op9098 ;@ 9c98
  .long Op90a0,Op90a0,Op90a0,Op90a0,Op90a0,Op90a0,Op90a0,Op90a0 ;@ 9ca0
  .long Op90a8,Op90a8,Op90a8,Op90a8,Op90a8,Op90a8,Op90a8,Op90a8 ;@ 9ca8
  .long Op90b0,Op90b0,Op90b0,Op90b0,Op90b0,Op90b0,Op90b0,Op90b0 ;@ 9cb0
  .long Op90b8,Op90b9,Op90ba,Op90bb,Op90bc,Op____,Op____,Op____ ;@ 9cb8
  .long Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0 ;@ 9cc0
  .long Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0 ;@ 9cc8
  .long Op90d0,Op90d0,Op90d0,Op90d0,Op90d0,Op90d0,Op90d0,Op90d0 ;@ 9cd0
  .long Op90d8,Op90d8,Op90d8,Op90d8,Op90d8,Op90d8,Op90d8,Op90d8 ;@ 9cd8
  .long Op90e0,Op90e0,Op90e0,Op90e0,Op90e0,Op90e0,Op90e0,Op90e0 ;@ 9ce0
  .long Op90e8,Op90e8,Op90e8,Op90e8,Op90e8,Op90e8,Op90e8,Op90e8 ;@ 9ce8
  .long Op90f0,Op90f0,Op90f0,Op90f0,Op90f0,Op90f0,Op90f0,Op90f0 ;@ 9cf0
  .long Op90f8,Op90f9,Op90fa,Op90fb,Op90fc,Op____,Op____,Op____ ;@ 9cf8
  .long Op9100,Op9100,Op9100,Op9100,Op9100,Op9100,Op9100,Op9100 ;@ 9d00
  .long Op9108,Op9108,Op9108,Op9108,Op9108,Op9108,Op9108,Op910f ;@ 9d08
  .long Op9110,Op9110,Op9110,Op9110,Op9110,Op9110,Op9110,Op9110 ;@ 9d10
  .long Op9118,Op9118,Op9118,Op9118,Op9118,Op9118,Op9118,Op911f ;@ 9d18
  .long Op9120,Op9120,Op9120,Op9120,Op9120,Op9120,Op9120,Op9127 ;@ 9d20
  .long Op9128,Op9128,Op9128,Op9128,Op9128,Op9128,Op9128,Op9128 ;@ 9d28
  .long Op9130,Op9130,Op9130,Op9130,Op9130,Op9130,Op9130,Op9130 ;@ 9d30
  .long Op9138,Op9139,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 9d38
  .long Op9140,Op9140,Op9140,Op9140,Op9140,Op9140,Op9140,Op9140 ;@ 9d40
  .long Op9148,Op9148,Op9148,Op9148,Op9148,Op9148,Op9148,Op9148 ;@ 9d48
  .long Op9150,Op9150,Op9150,Op9150,Op9150,Op9150,Op9150,Op9150 ;@ 9d50
  .long Op9158,Op9158,Op9158,Op9158,Op9158,Op9158,Op9158,Op9158 ;@ 9d58
  .long Op9160,Op9160,Op9160,Op9160,Op9160,Op9160,Op9160,Op9160 ;@ 9d60
  .long Op9168,Op9168,Op9168,Op9168,Op9168,Op9168,Op9168,Op9168 ;@ 9d68
  .long Op9170,Op9170,Op9170,Op9170,Op9170,Op9170,Op9170,Op9170 ;@ 9d70
  .long Op9178,Op9179,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 9d78
  .long Op9180,Op9180,Op9180,Op9180,Op9180,Op9180,Op9180,Op9180 ;@ 9d80
  .long Op9188,Op9188,Op9188,Op9188,Op9188,Op9188,Op9188,Op9188 ;@ 9d88
  .long Op9190,Op9190,Op9190,Op9190,Op9190,Op9190,Op9190,Op9190 ;@ 9d90
  .long Op9198,Op9198,Op9198,Op9198,Op9198,Op9198,Op9198,Op9198 ;@ 9d98
  .long Op91a0,Op91a0,Op91a0,Op91a0,Op91a0,Op91a0,Op91a0,Op91a0 ;@ 9da0
  .long Op91a8,Op91a8,Op91a8,Op91a8,Op91a8,Op91a8,Op91a8,Op91a8 ;@ 9da8
  .long Op91b0,Op91b0,Op91b0,Op91b0,Op91b0,Op91b0,Op91b0,Op91b0 ;@ 9db0
  .long Op91b8,Op91b9,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 9db8
  .long Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0 ;@ 9dc0
  .long Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0 ;@ 9dc8
  .long Op91d0,Op91d0,Op91d0,Op91d0,Op91d0,Op91d0,Op91d0,Op91d0 ;@ 9dd0
  .long Op91d8,Op91d8,Op91d8,Op91d8,Op91d8,Op91d8,Op91d8,Op91d8 ;@ 9dd8
  .long Op91e0,Op91e0,Op91e0,Op91e0,Op91e0,Op91e0,Op91e0,Op91e0 ;@ 9de0
  .long Op91e8,Op91e8,Op91e8,Op91e8,Op91e8,Op91e8,Op91e8,Op91e8 ;@ 9de8
  .long Op91f0,Op91f0,Op91f0,Op91f0,Op91f0,Op91f0,Op91f0,Op91f0 ;@ 9df0
  .long Op91f8,Op91f9,Op91fa,Op91fb,Op91fc,Op____,Op____,Op____ ;@ 9df8
  .long Op9000,Op9000,Op9000,Op9000,Op9000,Op9000,Op9000,Op9000 ;@ 9e00
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 9e08
  .long Op9010,Op9010,Op9010,Op9010,Op9010,Op9010,Op9010,Op9010 ;@ 9e10
  .long Op9018,Op9018,Op9018,Op9018,Op9018,Op9018,Op9018,Op901f ;@ 9e18
  .long Op9020,Op9020,Op9020,Op9020,Op9020,Op9020,Op9020,Op9027 ;@ 9e20
  .long Op9028,Op9028,Op9028,Op9028,Op9028,Op9028,Op9028,Op9028 ;@ 9e28
  .long Op9030,Op9030,Op9030,Op9030,Op9030,Op9030,Op9030,Op9030 ;@ 9e30
  .long Op9038,Op9039,Op903a,Op903b,Op903c,Op____,Op____,Op____ ;@ 9e38
  .long Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040 ;@ 9e40
  .long Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040,Op9040 ;@ 9e48
  .long Op9050,Op9050,Op9050,Op9050,Op9050,Op9050,Op9050,Op9050 ;@ 9e50
  .long Op9058,Op9058,Op9058,Op9058,Op9058,Op9058,Op9058,Op9058 ;@ 9e58
  .long Op9060,Op9060,Op9060,Op9060,Op9060,Op9060,Op9060,Op9060 ;@ 9e60
  .long Op9068,Op9068,Op9068,Op9068,Op9068,Op9068,Op9068,Op9068 ;@ 9e68
  .long Op9070,Op9070,Op9070,Op9070,Op9070,Op9070,Op9070,Op9070 ;@ 9e70
  .long Op9078,Op9079,Op907a,Op907b,Op907c,Op____,Op____,Op____ ;@ 9e78
  .long Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080 ;@ 9e80
  .long Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080,Op9080 ;@ 9e88
  .long Op9090,Op9090,Op9090,Op9090,Op9090,Op9090,Op9090,Op9090 ;@ 9e90
  .long Op9098,Op9098,Op9098,Op9098,Op9098,Op9098,Op9098,Op9098 ;@ 9e98
  .long Op90a0,Op90a0,Op90a0,Op90a0,Op90a0,Op90a0,Op90a0,Op90a0 ;@ 9ea0
  .long Op90a8,Op90a8,Op90a8,Op90a8,Op90a8,Op90a8,Op90a8,Op90a8 ;@ 9ea8
  .long Op90b0,Op90b0,Op90b0,Op90b0,Op90b0,Op90b0,Op90b0,Op90b0 ;@ 9eb0
  .long Op90b8,Op90b9,Op90ba,Op90bb,Op90bc,Op____,Op____,Op____ ;@ 9eb8
  .long Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0 ;@ 9ec0
  .long Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0,Op90c0 ;@ 9ec8
  .long Op90d0,Op90d0,Op90d0,Op90d0,Op90d0,Op90d0,Op90d0,Op90d0 ;@ 9ed0
  .long Op90d8,Op90d8,Op90d8,Op90d8,Op90d8,Op90d8,Op90d8,Op90d8 ;@ 9ed8
  .long Op90e0,Op90e0,Op90e0,Op90e0,Op90e0,Op90e0,Op90e0,Op90e0 ;@ 9ee0
  .long Op90e8,Op90e8,Op90e8,Op90e8,Op90e8,Op90e8,Op90e8,Op90e8 ;@ 9ee8
  .long Op90f0,Op90f0,Op90f0,Op90f0,Op90f0,Op90f0,Op90f0,Op90f0 ;@ 9ef0
  .long Op90f8,Op90f9,Op90fa,Op90fb,Op90fc,Op____,Op____,Op____ ;@ 9ef8
  .long Op9100,Op9100,Op9100,Op9100,Op9100,Op9100,Op9100,Op9100 ;@ 9f00
  .long Op9f08,Op9f08,Op9f08,Op9f08,Op9f08,Op9f08,Op9f08,Op9f0f ;@ 9f08
  .long Op9110,Op9110,Op9110,Op9110,Op9110,Op9110,Op9110,Op9110 ;@ 9f10
  .long Op9118,Op9118,Op9118,Op9118,Op9118,Op9118,Op9118,Op911f ;@ 9f18
  .long Op9120,Op9120,Op9120,Op9120,Op9120,Op9120,Op9120,Op9127 ;@ 9f20
  .long Op9128,Op9128,Op9128,Op9128,Op9128,Op9128,Op9128,Op9128 ;@ 9f28
  .long Op9130,Op9130,Op9130,Op9130,Op9130,Op9130,Op9130,Op9130 ;@ 9f30
  .long Op9138,Op9139,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 9f38
  .long Op9140,Op9140,Op9140,Op9140,Op9140,Op9140,Op9140,Op9140 ;@ 9f40
  .long Op9148,Op9148,Op9148,Op9148,Op9148,Op9148,Op9148,Op9148 ;@ 9f48
  .long Op9150,Op9150,Op9150,Op9150,Op9150,Op9150,Op9150,Op9150 ;@ 9f50
  .long Op9158,Op9158,Op9158,Op9158,Op9158,Op9158,Op9158,Op9158 ;@ 9f58
  .long Op9160,Op9160,Op9160,Op9160,Op9160,Op9160,Op9160,Op9160 ;@ 9f60
  .long Op9168,Op9168,Op9168,Op9168,Op9168,Op9168,Op9168,Op9168 ;@ 9f68
  .long Op9170,Op9170,Op9170,Op9170,Op9170,Op9170,Op9170,Op9170 ;@ 9f70
  .long Op9178,Op9179,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 9f78
  .long Op9180,Op9180,Op9180,Op9180,Op9180,Op9180,Op9180,Op9180 ;@ 9f80
  .long Op9188,Op9188,Op9188,Op9188,Op9188,Op9188,Op9188,Op9188 ;@ 9f88
  .long Op9190,Op9190,Op9190,Op9190,Op9190,Op9190,Op9190,Op9190 ;@ 9f90
  .long Op9198,Op9198,Op9198,Op9198,Op9198,Op9198,Op9198,Op9198 ;@ 9f98
  .long Op91a0,Op91a0,Op91a0,Op91a0,Op91a0,Op91a0,Op91a0,Op91a0 ;@ 9fa0
  .long Op91a8,Op91a8,Op91a8,Op91a8,Op91a8,Op91a8,Op91a8,Op91a8 ;@ 9fa8
  .long Op91b0,Op91b0,Op91b0,Op91b0,Op91b0,Op91b0,Op91b0,Op91b0 ;@ 9fb0
  .long Op91b8,Op91b9,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 9fb8
  .long Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0 ;@ 9fc0
  .long Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0,Op91c0 ;@ 9fc8
  .long Op91d0,Op91d0,Op91d0,Op91d0,Op91d0,Op91d0,Op91d0,Op91d0 ;@ 9fd0
  .long Op91d8,Op91d8,Op91d8,Op91d8,Op91d8,Op91d8,Op91d8,Op91d8 ;@ 9fd8
  .long Op91e0,Op91e0,Op91e0,Op91e0,Op91e0,Op91e0,Op91e0,Op91e0 ;@ 9fe0
  .long Op91e8,Op91e8,Op91e8,Op91e8,Op91e8,Op91e8,Op91e8,Op91e8 ;@ 9fe8
  .long Op91f0,Op91f0,Op91f0,Op91f0,Op91f0,Op91f0,Op91f0,Op91f0 ;@ 9ff0
  .long Op91f8,Op91f9,Op91fa,Op91fb,Op91fc,Op____,Op____,Op____ ;@ 9ff8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a000
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a008
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a010
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a018
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a020
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a028
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a030
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a038
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a040
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a048
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a050
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a058
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a060
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a068
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a070
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a078
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a080
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a088
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a090
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a098
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a0a0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a0a8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a0b0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a0b8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a0c0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a0c8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a0d0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a0d8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a0e0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a0e8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a0f0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a0f8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a100
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a108
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a110
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a118
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a120
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a128
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a130
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a138
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a140
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a148
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a150
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a158
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a160
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a168
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a170
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a178
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a180
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a188
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a190
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a198
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a1a0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a1a8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a1b0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a1b8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a1c0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a1c8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a1d0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a1d8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a1e0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a1e8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a1f0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a1f8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a200
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a208
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a210
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a218
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a220
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a228
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a230
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a238
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a240
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a248
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a250
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a258
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a260
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a268
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a270
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a278
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a280
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a288
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a290
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a298
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a2a0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a2a8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a2b0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a2b8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a2c0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a2c8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a2d0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a2d8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a2e0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a2e8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a2f0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a2f8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a300
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a308
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a310
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a318
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a320
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a328
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a330
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a338
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a340
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a348
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a350
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a358
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a360
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a368
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a370
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a378
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a380
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a388
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a390
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a398
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a3a0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a3a8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a3b0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a3b8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a3c0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a3c8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a3d0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a3d8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a3e0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a3e8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a3f0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a3f8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a400
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a408
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a410
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a418
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a420
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a428
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a430
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a438
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a440
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a448
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a450
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a458
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a460
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a468
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a470
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a478
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a480
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a488
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a490
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a498
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a4a0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a4a8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a4b0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a4b8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a4c0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a4c8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a4d0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a4d8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a4e0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a4e8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a4f0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a4f8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a500
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a508
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a510
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a518
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a520
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a528
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a530
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a538
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a540
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a548
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a550
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a558
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a560
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a568
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a570
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a578
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a580
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a588
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a590
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a598
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a5a0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a5a8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a5b0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a5b8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a5c0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a5c8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a5d0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a5d8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a5e0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a5e8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a5f0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a5f8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a600
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a608
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a610
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a618
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a620
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a628
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a630
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a638
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a640
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a648
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a650
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a658
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a660
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a668
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a670
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a678
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a680
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a688
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a690
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a698
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a6a0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a6a8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a6b0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a6b8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a6c0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a6c8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a6d0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a6d8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a6e0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a6e8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a6f0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a6f8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a700
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a708
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a710
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a718
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a720
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a728
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a730
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a738
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a740
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a748
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a750
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a758
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a760
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a768
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a770
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a778
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a780
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a788
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a790
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a798
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a7a0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a7a8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a7b0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a7b8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a7c0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a7c8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a7d0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a7d8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a7e0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a7e8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a7f0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a7f8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a800
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a808
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a810
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a818
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a820
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a828
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a830
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a838
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a840
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a848
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a850
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a858
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a860
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a868
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a870
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a878
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a880
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a888
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a890
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a898
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a8a0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a8a8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a8b0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a8b8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a8c0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a8c8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a8d0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a8d8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a8e0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a8e8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a8f0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a8f8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a900
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a908
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a910
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a918
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a920
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a928
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a930
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a938
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a940
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a948
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a950
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a958
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a960
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a968
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a970
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a978
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a980
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a988
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a990
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a998
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a9a0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a9a8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a9b0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a9b8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a9c0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a9c8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a9d0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a9d8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a9e0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a9e8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a9f0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a9f8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ aa00
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ aa08
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ aa10
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ aa18
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ aa20
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ aa28
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ aa30
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ aa38
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ aa40
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ aa48
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ aa50
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ aa58
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ aa60
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ aa68
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ aa70
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ aa78
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ aa80
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ aa88
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ aa90
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ aa98
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ aaa0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ aaa8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ aab0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ aab8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ aac0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ aac8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ aad0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ aad8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ aae0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ aae8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ aaf0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ aaf8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ab00
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ab08
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ab10
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ab18
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ab20
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ab28
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ab30
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ab38
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ab40
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ab48
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ab50
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ab58
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ab60
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ab68
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ab70
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ab78
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ab80
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ab88
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ab90
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ab98
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ aba0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ aba8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ abb0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ abb8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ abc0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ abc8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ abd0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ abd8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ abe0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ abe8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ abf0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ abf8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ac00
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ac08
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ac10
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ac18
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ac20
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ac28
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ac30
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ac38
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ac40
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ac48
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ac50
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ac58
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ac60
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ac68
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ac70
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ac78
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ac80
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ac88
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ac90
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ac98
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ aca0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ aca8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ acb0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ acb8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ acc0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ acc8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ acd0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ acd8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ace0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ace8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ acf0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ acf8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ad00
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ad08
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ad10
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ad18
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ad20
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ad28
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ad30
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ad38
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ad40
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ad48
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ad50
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ad58
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ad60
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ad68
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ad70
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ad78
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ad80
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ad88
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ad90
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ad98
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ada0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ada8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ adb0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ adb8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ adc0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ adc8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ add0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ add8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ade0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ade8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ adf0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ adf8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ae00
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ae08
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ae10
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ae18
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ae20
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ae28
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ae30
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ae38
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ae40
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ae48
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ae50
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ae58
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ae60
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ae68
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ae70
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ae78
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ae80
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ae88
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ae90
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ae98
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ aea0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ aea8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ aeb0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ aeb8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ aec0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ aec8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ aed0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ aed8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ aee0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ aee8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ aef0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ aef8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ af00
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ af08
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ af10
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ af18
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ af20
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ af28
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ af30
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ af38
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ af40
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ af48
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ af50
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ af58
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ af60
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ af68
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ af70
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ af78
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ af80
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ af88
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ af90
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ af98
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ afa0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ afa8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ afb0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ afb8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ afc0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ afc8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ afd0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ afd8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ afe0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ afe8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ aff0
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ aff8
  .long Opb000,Opb000,Opb000,Opb000,Opb000,Opb000,Opb000,Opb000 ;@ b000
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ b008
  .long Opb010,Opb010,Opb010,Opb010,Opb010,Opb010,Opb010,Opb010 ;@ b010
  .long Opb018,Opb018,Opb018,Opb018,Opb018,Opb018,Opb018,Opb01f ;@ b018
  .long Opb020,Opb020,Opb020,Opb020,Opb020,Opb020,Opb020,Opb027 ;@ b020
  .long Opb028,Opb028,Opb028,Opb028,Opb028,Opb028,Opb028,Opb028 ;@ b028
  .long Opb030,Opb030,Opb030,Opb030,Opb030,Opb030,Opb030,Opb030 ;@ b030
  .long Opb038,Opb039,Opb03a,Opb03b,Opb03c,Op____,Op____,Op____ ;@ b038
  .long Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040 ;@ b040
  .long Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040 ;@ b048
  .long Opb050,Opb050,Opb050,Opb050,Opb050,Opb050,Opb050,Opb050 ;@ b050
  .long Opb058,Opb058,Opb058,Opb058,Opb058,Opb058,Opb058,Opb058 ;@ b058
  .long Opb060,Opb060,Opb060,Opb060,Opb060,Opb060,Opb060,Opb060 ;@ b060
  .long Opb068,Opb068,Opb068,Opb068,Opb068,Opb068,Opb068,Opb068 ;@ b068
  .long Opb070,Opb070,Opb070,Opb070,Opb070,Opb070,Opb070,Opb070 ;@ b070
  .long Opb078,Opb079,Opb07a,Opb07b,Opb07c,Op____,Op____,Op____ ;@ b078
  .long Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080 ;@ b080
  .long Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080 ;@ b088
  .long Opb090,Opb090,Opb090,Opb090,Opb090,Opb090,Opb090,Opb090 ;@ b090
  .long Opb098,Opb098,Opb098,Opb098,Opb098,Opb098,Opb098,Opb098 ;@ b098
  .long Opb0a0,Opb0a0,Opb0a0,Opb0a0,Opb0a0,Opb0a0,Opb0a0,Opb0a0 ;@ b0a0
  .long Opb0a8,Opb0a8,Opb0a8,Opb0a8,Opb0a8,Opb0a8,Opb0a8,Opb0a8 ;@ b0a8
  .long Opb0b0,Opb0b0,Opb0b0,Opb0b0,Opb0b0,Opb0b0,Opb0b0,Opb0b0 ;@ b0b0
  .long Opb0b8,Opb0b9,Opb0ba,Opb0bb,Opb0bc,Op____,Op____,Op____ ;@ b0b8
  .long Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0 ;@ b0c0
  .long Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0 ;@ b0c8
  .long Opb0d0,Opb0d0,Opb0d0,Opb0d0,Opb0d0,Opb0d0,Opb0d0,Opb0d0 ;@ b0d0
  .long Opb0d8,Opb0d8,Opb0d8,Opb0d8,Opb0d8,Opb0d8,Opb0d8,Opb0d8 ;@ b0d8
  .long Opb0e0,Opb0e0,Opb0e0,Opb0e0,Opb0e0,Opb0e0,Opb0e0,Opb0e0 ;@ b0e0
  .long Opb0e8,Opb0e8,Opb0e8,Opb0e8,Opb0e8,Opb0e8,Opb0e8,Opb0e8 ;@ b0e8
  .long Opb0f0,Opb0f0,Opb0f0,Opb0f0,Opb0f0,Opb0f0,Opb0f0,Opb0f0 ;@ b0f0
  .long Opb0f8,Opb0f9,Opb0fa,Opb0fb,Opb0fc,Op____,Op____,Op____ ;@ b0f8
  .long Opb100,Opb100,Opb100,Opb100,Opb100,Opb100,Opb100,Opb100 ;@ b100
  .long Opb108,Opb108,Opb108,Opb108,Opb108,Opb108,Opb108,Opb10f ;@ b108
  .long Opb110,Opb110,Opb110,Opb110,Opb110,Opb110,Opb110,Opb110 ;@ b110
  .long Opb118,Opb118,Opb118,Opb118,Opb118,Opb118,Opb118,Opb11f ;@ b118
  .long Opb120,Opb120,Opb120,Opb120,Opb120,Opb120,Opb120,Opb127 ;@ b120
  .long Opb128,Opb128,Opb128,Opb128,Opb128,Opb128,Opb128,Opb128 ;@ b128
  .long Opb130,Opb130,Opb130,Opb130,Opb130,Opb130,Opb130,Opb130 ;@ b130
  .long Opb138,Opb139,Op____,Op____,Op____,Op____,Op____,Op____ ;@ b138
  .long Opb140,Opb140,Opb140,Opb140,Opb140,Opb140,Opb140,Opb140 ;@ b140
  .long Opb148,Opb148,Opb148,Opb148,Opb148,Opb148,Opb148,Opb148 ;@ b148
  .long Opb150,Opb150,Opb150,Opb150,Opb150,Opb150,Opb150,Opb150 ;@ b150
  .long Opb158,Opb158,Opb158,Opb158,Opb158,Opb158,Opb158,Opb158 ;@ b158
  .long Opb160,Opb160,Opb160,Opb160,Opb160,Opb160,Opb160,Opb160 ;@ b160
  .long Opb168,Opb168,Opb168,Opb168,Opb168,Opb168,Opb168,Opb168 ;@ b168
  .long Opb170,Opb170,Opb170,Opb170,Opb170,Opb170,Opb170,Opb170 ;@ b170
  .long Opb178,Opb179,Op____,Op____,Op____,Op____,Op____,Op____ ;@ b178
  .long Opb180,Opb180,Opb180,Opb180,Opb180,Opb180,Opb180,Opb180 ;@ b180
  .long Opb188,Opb188,Opb188,Opb188,Opb188,Opb188,Opb188,Opb188 ;@ b188
  .long Opb190,Opb190,Opb190,Opb190,Opb190,Opb190,Opb190,Opb190 ;@ b190
  .long Opb198,Opb198,Opb198,Opb198,Opb198,Opb198,Opb198,Opb198 ;@ b198
  .long Opb1a0,Opb1a0,Opb1a0,Opb1a0,Opb1a0,Opb1a0,Opb1a0,Opb1a0 ;@ b1a0
  .long Opb1a8,Opb1a8,Opb1a8,Opb1a8,Opb1a8,Opb1a8,Opb1a8,Opb1a8 ;@ b1a8
  .long Opb1b0,Opb1b0,Opb1b0,Opb1b0,Opb1b0,Opb1b0,Opb1b0,Opb1b0 ;@ b1b0
  .long Opb1b8,Opb1b9,Op____,Op____,Op____,Op____,Op____,Op____ ;@ b1b8
  .long Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0 ;@ b1c0
  .long Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0 ;@ b1c8
  .long Opb1d0,Opb1d0,Opb1d0,Opb1d0,Opb1d0,Opb1d0,Opb1d0,Opb1d0 ;@ b1d0
  .long Opb1d8,Opb1d8,Opb1d8,Opb1d8,Opb1d8,Opb1d8,Opb1d8,Opb1d8 ;@ b1d8
  .long Opb1e0,Opb1e0,Opb1e0,Opb1e0,Opb1e0,Opb1e0,Opb1e0,Opb1e0 ;@ b1e0
  .long Opb1e8,Opb1e8,Opb1e8,Opb1e8,Opb1e8,Opb1e8,Opb1e8,Opb1e8 ;@ b1e8
  .long Opb1f0,Opb1f0,Opb1f0,Opb1f0,Opb1f0,Opb1f0,Opb1f0,Opb1f0 ;@ b1f0
  .long Opb1f8,Opb1f9,Opb1fa,Opb1fb,Opb1fc,Op____,Op____,Op____ ;@ b1f8
  .long Opb000,Opb000,Opb000,Opb000,Opb000,Opb000,Opb000,Opb000 ;@ b200
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ b208
  .long Opb010,Opb010,Opb010,Opb010,Opb010,Opb010,Opb010,Opb010 ;@ b210
  .long Opb018,Opb018,Opb018,Opb018,Opb018,Opb018,Opb018,Opb01f ;@ b218
  .long Opb020,Opb020,Opb020,Opb020,Opb020,Opb020,Opb020,Opb027 ;@ b220
  .long Opb028,Opb028,Opb028,Opb028,Opb028,Opb028,Opb028,Opb028 ;@ b228
  .long Opb030,Opb030,Opb030,Opb030,Opb030,Opb030,Opb030,Opb030 ;@ b230
  .long Opb038,Opb039,Opb03a,Opb03b,Opb03c,Op____,Op____,Op____ ;@ b238
  .long Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040 ;@ b240
  .long Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040 ;@ b248
  .long Opb050,Opb050,Opb050,Opb050,Opb050,Opb050,Opb050,Opb050 ;@ b250
  .long Opb058,Opb058,Opb058,Opb058,Opb058,Opb058,Opb058,Opb058 ;@ b258
  .long Opb060,Opb060,Opb060,Opb060,Opb060,Opb060,Opb060,Opb060 ;@ b260
  .long Opb068,Opb068,Opb068,Opb068,Opb068,Opb068,Opb068,Opb068 ;@ b268
  .long Opb070,Opb070,Opb070,Opb070,Opb070,Opb070,Opb070,Opb070 ;@ b270
  .long Opb078,Opb079,Opb07a,Opb07b,Opb07c,Op____,Op____,Op____ ;@ b278
  .long Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080 ;@ b280
  .long Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080 ;@ b288
  .long Opb090,Opb090,Opb090,Opb090,Opb090,Opb090,Opb090,Opb090 ;@ b290
  .long Opb098,Opb098,Opb098,Opb098,Opb098,Opb098,Opb098,Opb098 ;@ b298
  .long Opb0a0,Opb0a0,Opb0a0,Opb0a0,Opb0a0,Opb0a0,Opb0a0,Opb0a0 ;@ b2a0
  .long Opb0a8,Opb0a8,Opb0a8,Opb0a8,Opb0a8,Opb0a8,Opb0a8,Opb0a8 ;@ b2a8
  .long Opb0b0,Opb0b0,Opb0b0,Opb0b0,Opb0b0,Opb0b0,Opb0b0,Opb0b0 ;@ b2b0
  .long Opb0b8,Opb0b9,Opb0ba,Opb0bb,Opb0bc,Op____,Op____,Op____ ;@ b2b8
  .long Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0 ;@ b2c0
  .long Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0 ;@ b2c8
  .long Opb0d0,Opb0d0,Opb0d0,Opb0d0,Opb0d0,Opb0d0,Opb0d0,Opb0d0 ;@ b2d0
  .long Opb0d8,Opb0d8,Opb0d8,Opb0d8,Opb0d8,Opb0d8,Opb0d8,Opb0d8 ;@ b2d8
  .long Opb0e0,Opb0e0,Opb0e0,Opb0e0,Opb0e0,Opb0e0,Opb0e0,Opb0e0 ;@ b2e0
  .long Opb0e8,Opb0e8,Opb0e8,Opb0e8,Opb0e8,Opb0e8,Opb0e8,Opb0e8 ;@ b2e8
  .long Opb0f0,Opb0f0,Opb0f0,Opb0f0,Opb0f0,Opb0f0,Opb0f0,Opb0f0 ;@ b2f0
  .long Opb0f8,Opb0f9,Opb0fa,Opb0fb,Opb0fc,Op____,Op____,Op____ ;@ b2f8
  .long Opb100,Opb100,Opb100,Opb100,Opb100,Opb100,Opb100,Opb100 ;@ b300
  .long Opb108,Opb108,Opb108,Opb108,Opb108,Opb108,Opb108,Opb10f ;@ b308
  .long Opb110,Opb110,Opb110,Opb110,Opb110,Opb110,Opb110,Opb110 ;@ b310
  .long Opb118,Opb118,Opb118,Opb118,Opb118,Opb118,Opb118,Opb11f ;@ b318
  .long Opb120,Opb120,Opb120,Opb120,Opb120,Opb120,Opb120,Opb127 ;@ b320
  .long Opb128,Opb128,Opb128,Opb128,Opb128,Opb128,Opb128,Opb128 ;@ b328
  .long Opb130,Opb130,Opb130,Opb130,Opb130,Opb130,Opb130,Opb130 ;@ b330
  .long Opb138,Opb139,Op____,Op____,Op____,Op____,Op____,Op____ ;@ b338
  .long Opb140,Opb140,Opb140,Opb140,Opb140,Opb140,Opb140,Opb140 ;@ b340
  .long Opb148,Opb148,Opb148,Opb148,Opb148,Opb148,Opb148,Opb148 ;@ b348
  .long Opb150,Opb150,Opb150,Opb150,Opb150,Opb150,Opb150,Opb150 ;@ b350
  .long Opb158,Opb158,Opb158,Opb158,Opb158,Opb158,Opb158,Opb158 ;@ b358
  .long Opb160,Opb160,Opb160,Opb160,Opb160,Opb160,Opb160,Opb160 ;@ b360
  .long Opb168,Opb168,Opb168,Opb168,Opb168,Opb168,Opb168,Opb168 ;@ b368
  .long Opb170,Opb170,Opb170,Opb170,Opb170,Opb170,Opb170,Opb170 ;@ b370
  .long Opb178,Opb179,Op____,Op____,Op____,Op____,Op____,Op____ ;@ b378
  .long Opb180,Opb180,Opb180,Opb180,Opb180,Opb180,Opb180,Opb180 ;@ b380
  .long Opb188,Opb188,Opb188,Opb188,Opb188,Opb188,Opb188,Opb188 ;@ b388
  .long Opb190,Opb190,Opb190,Opb190,Opb190,Opb190,Opb190,Opb190 ;@ b390
  .long Opb198,Opb198,Opb198,Opb198,Opb198,Opb198,Opb198,Opb198 ;@ b398
  .long Opb1a0,Opb1a0,Opb1a0,Opb1a0,Opb1a0,Opb1a0,Opb1a0,Opb1a0 ;@ b3a0
  .long Opb1a8,Opb1a8,Opb1a8,Opb1a8,Opb1a8,Opb1a8,Opb1a8,Opb1a8 ;@ b3a8
  .long Opb1b0,Opb1b0,Opb1b0,Opb1b0,Opb1b0,Opb1b0,Opb1b0,Opb1b0 ;@ b3b0
  .long Opb1b8,Opb1b9,Op____,Op____,Op____,Op____,Op____,Op____ ;@ b3b8
  .long Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0 ;@ b3c0
  .long Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0 ;@ b3c8
  .long Opb1d0,Opb1d0,Opb1d0,Opb1d0,Opb1d0,Opb1d0,Opb1d0,Opb1d0 ;@ b3d0
  .long Opb1d8,Opb1d8,Opb1d8,Opb1d8,Opb1d8,Opb1d8,Opb1d8,Opb1d8 ;@ b3d8
  .long Opb1e0,Opb1e0,Opb1e0,Opb1e0,Opb1e0,Opb1e0,Opb1e0,Opb1e0 ;@ b3e0
  .long Opb1e8,Opb1e8,Opb1e8,Opb1e8,Opb1e8,Opb1e8,Opb1e8,Opb1e8 ;@ b3e8
  .long Opb1f0,Opb1f0,Opb1f0,Opb1f0,Opb1f0,Opb1f0,Opb1f0,Opb1f0 ;@ b3f0
  .long Opb1f8,Opb1f9,Opb1fa,Opb1fb,Opb1fc,Op____,Op____,Op____ ;@ b3f8
  .long Opb000,Opb000,Opb000,Opb000,Opb000,Opb000,Opb000,Opb000 ;@ b400
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ b408
  .long Opb010,Opb010,Opb010,Opb010,Opb010,Opb010,Opb010,Opb010 ;@ b410
  .long Opb018,Opb018,Opb018,Opb018,Opb018,Opb018,Opb018,Opb01f ;@ b418
  .long Opb020,Opb020,Opb020,Opb020,Opb020,Opb020,Opb020,Opb027 ;@ b420
  .long Opb028,Opb028,Opb028,Opb028,Opb028,Opb028,Opb028,Opb028 ;@ b428
  .long Opb030,Opb030,Opb030,Opb030,Opb030,Opb030,Opb030,Opb030 ;@ b430
  .long Opb038,Opb039,Opb03a,Opb03b,Opb03c,Op____,Op____,Op____ ;@ b438
  .long Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040 ;@ b440
  .long Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040 ;@ b448
  .long Opb050,Opb050,Opb050,Opb050,Opb050,Opb050,Opb050,Opb050 ;@ b450
  .long Opb058,Opb058,Opb058,Opb058,Opb058,Opb058,Opb058,Opb058 ;@ b458
  .long Opb060,Opb060,Opb060,Opb060,Opb060,Opb060,Opb060,Opb060 ;@ b460
  .long Opb068,Opb068,Opb068,Opb068,Opb068,Opb068,Opb068,Opb068 ;@ b468
  .long Opb070,Opb070,Opb070,Opb070,Opb070,Opb070,Opb070,Opb070 ;@ b470
  .long Opb078,Opb079,Opb07a,Opb07b,Opb07c,Op____,Op____,Op____ ;@ b478
  .long Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080 ;@ b480
  .long Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080 ;@ b488
  .long Opb090,Opb090,Opb090,Opb090,Opb090,Opb090,Opb090,Opb090 ;@ b490
  .long Opb098,Opb098,Opb098,Opb098,Opb098,Opb098,Opb098,Opb098 ;@ b498
  .long Opb0a0,Opb0a0,Opb0a0,Opb0a0,Opb0a0,Opb0a0,Opb0a0,Opb0a0 ;@ b4a0
  .long Opb0a8,Opb0a8,Opb0a8,Opb0a8,Opb0a8,Opb0a8,Opb0a8,Opb0a8 ;@ b4a8
  .long Opb0b0,Opb0b0,Opb0b0,Opb0b0,Opb0b0,Opb0b0,Opb0b0,Opb0b0 ;@ b4b0
  .long Opb0b8,Opb0b9,Opb0ba,Opb0bb,Opb0bc,Op____,Op____,Op____ ;@ b4b8
  .long Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0 ;@ b4c0
  .long Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0 ;@ b4c8
  .long Opb0d0,Opb0d0,Opb0d0,Opb0d0,Opb0d0,Opb0d0,Opb0d0,Opb0d0 ;@ b4d0
  .long Opb0d8,Opb0d8,Opb0d8,Opb0d8,Opb0d8,Opb0d8,Opb0d8,Opb0d8 ;@ b4d8
  .long Opb0e0,Opb0e0,Opb0e0,Opb0e0,Opb0e0,Opb0e0,Opb0e0,Opb0e0 ;@ b4e0
  .long Opb0e8,Opb0e8,Opb0e8,Opb0e8,Opb0e8,Opb0e8,Opb0e8,Opb0e8 ;@ b4e8
  .long Opb0f0,Opb0f0,Opb0f0,Opb0f0,Opb0f0,Opb0f0,Opb0f0,Opb0f0 ;@ b4f0
  .long Opb0f8,Opb0f9,Opb0fa,Opb0fb,Opb0fc,Op____,Op____,Op____ ;@ b4f8
  .long Opb100,Opb100,Opb100,Opb100,Opb100,Opb100,Opb100,Opb100 ;@ b500
  .long Opb108,Opb108,Opb108,Opb108,Opb108,Opb108,Opb108,Opb10f ;@ b508
  .long Opb110,Opb110,Opb110,Opb110,Opb110,Opb110,Opb110,Opb110 ;@ b510
  .long Opb118,Opb118,Opb118,Opb118,Opb118,Opb118,Opb118,Opb11f ;@ b518
  .long Opb120,Opb120,Opb120,Opb120,Opb120,Opb120,Opb120,Opb127 ;@ b520
  .long Opb128,Opb128,Opb128,Opb128,Opb128,Opb128,Opb128,Opb128 ;@ b528
  .long Opb130,Opb130,Opb130,Opb130,Opb130,Opb130,Opb130,Opb130 ;@ b530
  .long Opb138,Opb139,Op____,Op____,Op____,Op____,Op____,Op____ ;@ b538
  .long Opb140,Opb140,Opb140,Opb140,Opb140,Opb140,Opb140,Opb140 ;@ b540
  .long Opb148,Opb148,Opb148,Opb148,Opb148,Opb148,Opb148,Opb148 ;@ b548
  .long Opb150,Opb150,Opb150,Opb150,Opb150,Opb150,Opb150,Opb150 ;@ b550
  .long Opb158,Opb158,Opb158,Opb158,Opb158,Opb158,Opb158,Opb158 ;@ b558
  .long Opb160,Opb160,Opb160,Opb160,Opb160,Opb160,Opb160,Opb160 ;@ b560
  .long Opb168,Opb168,Opb168,Opb168,Opb168,Opb168,Opb168,Opb168 ;@ b568
  .long Opb170,Opb170,Opb170,Opb170,Opb170,Opb170,Opb170,Opb170 ;@ b570
  .long Opb178,Opb179,Op____,Op____,Op____,Op____,Op____,Op____ ;@ b578
  .long Opb180,Opb180,Opb180,Opb180,Opb180,Opb180,Opb180,Opb180 ;@ b580
  .long Opb188,Opb188,Opb188,Opb188,Opb188,Opb188,Opb188,Opb188 ;@ b588
  .long Opb190,Opb190,Opb190,Opb190,Opb190,Opb190,Opb190,Opb190 ;@ b590
  .long Opb198,Opb198,Opb198,Opb198,Opb198,Opb198,Opb198,Opb198 ;@ b598
  .long Opb1a0,Opb1a0,Opb1a0,Opb1a0,Opb1a0,Opb1a0,Opb1a0,Opb1a0 ;@ b5a0
  .long Opb1a8,Opb1a8,Opb1a8,Opb1a8,Opb1a8,Opb1a8,Opb1a8,Opb1a8 ;@ b5a8
  .long Opb1b0,Opb1b0,Opb1b0,Opb1b0,Opb1b0,Opb1b0,Opb1b0,Opb1b0 ;@ b5b0
  .long Opb1b8,Opb1b9,Op____,Op____,Op____,Op____,Op____,Op____ ;@ b5b8
  .long Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0 ;@ b5c0
  .long Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0 ;@ b5c8
  .long Opb1d0,Opb1d0,Opb1d0,Opb1d0,Opb1d0,Opb1d0,Opb1d0,Opb1d0 ;@ b5d0
  .long Opb1d8,Opb1d8,Opb1d8,Opb1d8,Opb1d8,Opb1d8,Opb1d8,Opb1d8 ;@ b5d8
  .long Opb1e0,Opb1e0,Opb1e0,Opb1e0,Opb1e0,Opb1e0,Opb1e0,Opb1e0 ;@ b5e0
  .long Opb1e8,Opb1e8,Opb1e8,Opb1e8,Opb1e8,Opb1e8,Opb1e8,Opb1e8 ;@ b5e8
  .long Opb1f0,Opb1f0,Opb1f0,Opb1f0,Opb1f0,Opb1f0,Opb1f0,Opb1f0 ;@ b5f0
  .long Opb1f8,Opb1f9,Opb1fa,Opb1fb,Opb1fc,Op____,Op____,Op____ ;@ b5f8
  .long Opb000,Opb000,Opb000,Opb000,Opb000,Opb000,Opb000,Opb000 ;@ b600
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ b608
  .long Opb010,Opb010,Opb010,Opb010,Opb010,Opb010,Opb010,Opb010 ;@ b610
  .long Opb018,Opb018,Opb018,Opb018,Opb018,Opb018,Opb018,Opb01f ;@ b618
  .long Opb020,Opb020,Opb020,Opb020,Opb020,Opb020,Opb020,Opb027 ;@ b620
  .long Opb028,Opb028,Opb028,Opb028,Opb028,Opb028,Opb028,Opb028 ;@ b628
  .long Opb030,Opb030,Opb030,Opb030,Opb030,Opb030,Opb030,Opb030 ;@ b630
  .long Opb038,Opb039,Opb03a,Opb03b,Opb03c,Op____,Op____,Op____ ;@ b638
  .long Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040 ;@ b640
  .long Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040 ;@ b648
  .long Opb050,Opb050,Opb050,Opb050,Opb050,Opb050,Opb050,Opb050 ;@ b650
  .long Opb058,Opb058,Opb058,Opb058,Opb058,Opb058,Opb058,Opb058 ;@ b658
  .long Opb060,Opb060,Opb060,Opb060,Opb060,Opb060,Opb060,Opb060 ;@ b660
  .long Opb068,Opb068,Opb068,Opb068,Opb068,Opb068,Opb068,Opb068 ;@ b668
  .long Opb070,Opb070,Opb070,Opb070,Opb070,Opb070,Opb070,Opb070 ;@ b670
  .long Opb078,Opb079,Opb07a,Opb07b,Opb07c,Op____,Op____,Op____ ;@ b678
  .long Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080 ;@ b680
  .long Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080 ;@ b688
  .long Opb090,Opb090,Opb090,Opb090,Opb090,Opb090,Opb090,Opb090 ;@ b690
  .long Opb098,Opb098,Opb098,Opb098,Opb098,Opb098,Opb098,Opb098 ;@ b698
  .long Opb0a0,Opb0a0,Opb0a0,Opb0a0,Opb0a0,Opb0a0,Opb0a0,Opb0a0 ;@ b6a0
  .long Opb0a8,Opb0a8,Opb0a8,Opb0a8,Opb0a8,Opb0a8,Opb0a8,Opb0a8 ;@ b6a8
  .long Opb0b0,Opb0b0,Opb0b0,Opb0b0,Opb0b0,Opb0b0,Opb0b0,Opb0b0 ;@ b6b0
  .long Opb0b8,Opb0b9,Opb0ba,Opb0bb,Opb0bc,Op____,Op____,Op____ ;@ b6b8
  .long Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0 ;@ b6c0
  .long Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0 ;@ b6c8
  .long Opb0d0,Opb0d0,Opb0d0,Opb0d0,Opb0d0,Opb0d0,Opb0d0,Opb0d0 ;@ b6d0
  .long Opb0d8,Opb0d8,Opb0d8,Opb0d8,Opb0d8,Opb0d8,Opb0d8,Opb0d8 ;@ b6d8
  .long Opb0e0,Opb0e0,Opb0e0,Opb0e0,Opb0e0,Opb0e0,Opb0e0,Opb0e0 ;@ b6e0
  .long Opb0e8,Opb0e8,Opb0e8,Opb0e8,Opb0e8,Opb0e8,Opb0e8,Opb0e8 ;@ b6e8
  .long Opb0f0,Opb0f0,Opb0f0,Opb0f0,Opb0f0,Opb0f0,Opb0f0,Opb0f0 ;@ b6f0
  .long Opb0f8,Opb0f9,Opb0fa,Opb0fb,Opb0fc,Op____,Op____,Op____ ;@ b6f8
  .long Opb100,Opb100,Opb100,Opb100,Opb100,Opb100,Opb100,Opb100 ;@ b700
  .long Opb108,Opb108,Opb108,Opb108,Opb108,Opb108,Opb108,Opb10f ;@ b708
  .long Opb110,Opb110,Opb110,Opb110,Opb110,Opb110,Opb110,Opb110 ;@ b710
  .long Opb118,Opb118,Opb118,Opb118,Opb118,Opb118,Opb118,Opb11f ;@ b718
  .long Opb120,Opb120,Opb120,Opb120,Opb120,Opb120,Opb120,Opb127 ;@ b720
  .long Opb128,Opb128,Opb128,Opb128,Opb128,Opb128,Opb128,Opb128 ;@ b728
  .long Opb130,Opb130,Opb130,Opb130,Opb130,Opb130,Opb130,Opb130 ;@ b730
  .long Opb138,Opb139,Op____,Op____,Op____,Op____,Op____,Op____ ;@ b738
  .long Opb140,Opb140,Opb140,Opb140,Opb140,Opb140,Opb140,Opb140 ;@ b740
  .long Opb148,Opb148,Opb148,Opb148,Opb148,Opb148,Opb148,Opb148 ;@ b748
  .long Opb150,Opb150,Opb150,Opb150,Opb150,Opb150,Opb150,Opb150 ;@ b750
  .long Opb158,Opb158,Opb158,Opb158,Opb158,Opb158,Opb158,Opb158 ;@ b758
  .long Opb160,Opb160,Opb160,Opb160,Opb160,Opb160,Opb160,Opb160 ;@ b760
  .long Opb168,Opb168,Opb168,Opb168,Opb168,Opb168,Opb168,Opb168 ;@ b768
  .long Opb170,Opb170,Opb170,Opb170,Opb170,Opb170,Opb170,Opb170 ;@ b770
  .long Opb178,Opb179,Op____,Op____,Op____,Op____,Op____,Op____ ;@ b778
  .long Opb180,Opb180,Opb180,Opb180,Opb180,Opb180,Opb180,Opb180 ;@ b780
  .long Opb188,Opb188,Opb188,Opb188,Opb188,Opb188,Opb188,Opb188 ;@ b788
  .long Opb190,Opb190,Opb190,Opb190,Opb190,Opb190,Opb190,Opb190 ;@ b790
  .long Opb198,Opb198,Opb198,Opb198,Opb198,Opb198,Opb198,Opb198 ;@ b798
  .long Opb1a0,Opb1a0,Opb1a0,Opb1a0,Opb1a0,Opb1a0,Opb1a0,Opb1a0 ;@ b7a0
  .long Opb1a8,Opb1a8,Opb1a8,Opb1a8,Opb1a8,Opb1a8,Opb1a8,Opb1a8 ;@ b7a8
  .long Opb1b0,Opb1b0,Opb1b0,Opb1b0,Opb1b0,Opb1b0,Opb1b0,Opb1b0 ;@ b7b0
  .long Opb1b8,Opb1b9,Op____,Op____,Op____,Op____,Op____,Op____ ;@ b7b8
  .long Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0 ;@ b7c0
  .long Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0 ;@ b7c8
  .long Opb1d0,Opb1d0,Opb1d0,Opb1d0,Opb1d0,Opb1d0,Opb1d0,Opb1d0 ;@ b7d0
  .long Opb1d8,Opb1d8,Opb1d8,Opb1d8,Opb1d8,Opb1d8,Opb1d8,Opb1d8 ;@ b7d8
  .long Opb1e0,Opb1e0,Opb1e0,Opb1e0,Opb1e0,Opb1e0,Opb1e0,Opb1e0 ;@ b7e0
  .long Opb1e8,Opb1e8,Opb1e8,Opb1e8,Opb1e8,Opb1e8,Opb1e8,Opb1e8 ;@ b7e8
  .long Opb1f0,Opb1f0,Opb1f0,Opb1f0,Opb1f0,Opb1f0,Opb1f0,Opb1f0 ;@ b7f0
  .long Opb1f8,Opb1f9,Opb1fa,Opb1fb,Opb1fc,Op____,Op____,Op____ ;@ b7f8
  .long Opb000,Opb000,Opb000,Opb000,Opb000,Opb000,Opb000,Opb000 ;@ b800
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ b808
  .long Opb010,Opb010,Opb010,Opb010,Opb010,Opb010,Opb010,Opb010 ;@ b810
  .long Opb018,Opb018,Opb018,Opb018,Opb018,Opb018,Opb018,Opb01f ;@ b818
  .long Opb020,Opb020,Opb020,Opb020,Opb020,Opb020,Opb020,Opb027 ;@ b820
  .long Opb028,Opb028,Opb028,Opb028,Opb028,Opb028,Opb028,Opb028 ;@ b828
  .long Opb030,Opb030,Opb030,Opb030,Opb030,Opb030,Opb030,Opb030 ;@ b830
  .long Opb038,Opb039,Opb03a,Opb03b,Opb03c,Op____,Op____,Op____ ;@ b838
  .long Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040 ;@ b840
  .long Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040 ;@ b848
  .long Opb050,Opb050,Opb050,Opb050,Opb050,Opb050,Opb050,Opb050 ;@ b850
  .long Opb058,Opb058,Opb058,Opb058,Opb058,Opb058,Opb058,Opb058 ;@ b858
  .long Opb060,Opb060,Opb060,Opb060,Opb060,Opb060,Opb060,Opb060 ;@ b860
  .long Opb068,Opb068,Opb068,Opb068,Opb068,Opb068,Opb068,Opb068 ;@ b868
  .long Opb070,Opb070,Opb070,Opb070,Opb070,Opb070,Opb070,Opb070 ;@ b870
  .long Opb078,Opb079,Opb07a,Opb07b,Opb07c,Op____,Op____,Op____ ;@ b878
  .long Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080 ;@ b880
  .long Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080 ;@ b888
  .long Opb090,Opb090,Opb090,Opb090,Opb090,Opb090,Opb090,Opb090 ;@ b890
  .long Opb098,Opb098,Opb098,Opb098,Opb098,Opb098,Opb098,Opb098 ;@ b898
  .long Opb0a0,Opb0a0,Opb0a0,Opb0a0,Opb0a0,Opb0a0,Opb0a0,Opb0a0 ;@ b8a0
  .long Opb0a8,Opb0a8,Opb0a8,Opb0a8,Opb0a8,Opb0a8,Opb0a8,Opb0a8 ;@ b8a8
  .long Opb0b0,Opb0b0,Opb0b0,Opb0b0,Opb0b0,Opb0b0,Opb0b0,Opb0b0 ;@ b8b0
  .long Opb0b8,Opb0b9,Opb0ba,Opb0bb,Opb0bc,Op____,Op____,Op____ ;@ b8b8
  .long Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0 ;@ b8c0
  .long Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0 ;@ b8c8
  .long Opb0d0,Opb0d0,Opb0d0,Opb0d0,Opb0d0,Opb0d0,Opb0d0,Opb0d0 ;@ b8d0
  .long Opb0d8,Opb0d8,Opb0d8,Opb0d8,Opb0d8,Opb0d8,Opb0d8,Opb0d8 ;@ b8d8
  .long Opb0e0,Opb0e0,Opb0e0,Opb0e0,Opb0e0,Opb0e0,Opb0e0,Opb0e0 ;@ b8e0
  .long Opb0e8,Opb0e8,Opb0e8,Opb0e8,Opb0e8,Opb0e8,Opb0e8,Opb0e8 ;@ b8e8
  .long Opb0f0,Opb0f0,Opb0f0,Opb0f0,Opb0f0,Opb0f0,Opb0f0,Opb0f0 ;@ b8f0
  .long Opb0f8,Opb0f9,Opb0fa,Opb0fb,Opb0fc,Op____,Op____,Op____ ;@ b8f8
  .long Opb100,Opb100,Opb100,Opb100,Opb100,Opb100,Opb100,Opb100 ;@ b900
  .long Opb108,Opb108,Opb108,Opb108,Opb108,Opb108,Opb108,Opb10f ;@ b908
  .long Opb110,Opb110,Opb110,Opb110,Opb110,Opb110,Opb110,Opb110 ;@ b910
  .long Opb118,Opb118,Opb118,Opb118,Opb118,Opb118,Opb118,Opb11f ;@ b918
  .long Opb120,Opb120,Opb120,Opb120,Opb120,Opb120,Opb120,Opb127 ;@ b920
  .long Opb128,Opb128,Opb128,Opb128,Opb128,Opb128,Opb128,Opb128 ;@ b928
  .long Opb130,Opb130,Opb130,Opb130,Opb130,Opb130,Opb130,Opb130 ;@ b930
  .long Opb138,Opb139,Op____,Op____,Op____,Op____,Op____,Op____ ;@ b938
  .long Opb140,Opb140,Opb140,Opb140,Opb140,Opb140,Opb140,Opb140 ;@ b940
  .long Opb148,Opb148,Opb148,Opb148,Opb148,Opb148,Opb148,Opb148 ;@ b948
  .long Opb150,Opb150,Opb150,Opb150,Opb150,Opb150,Opb150,Opb150 ;@ b950
  .long Opb158,Opb158,Opb158,Opb158,Opb158,Opb158,Opb158,Opb158 ;@ b958
  .long Opb160,Opb160,Opb160,Opb160,Opb160,Opb160,Opb160,Opb160 ;@ b960
  .long Opb168,Opb168,Opb168,Opb168,Opb168,Opb168,Opb168,Opb168 ;@ b968
  .long Opb170,Opb170,Opb170,Opb170,Opb170,Opb170,Opb170,Opb170 ;@ b970
  .long Opb178,Opb179,Op____,Op____,Op____,Op____,Op____,Op____ ;@ b978
  .long Opb180,Opb180,Opb180,Opb180,Opb180,Opb180,Opb180,Opb180 ;@ b980
  .long Opb188,Opb188,Opb188,Opb188,Opb188,Opb188,Opb188,Opb188 ;@ b988
  .long Opb190,Opb190,Opb190,Opb190,Opb190,Opb190,Opb190,Opb190 ;@ b990
  .long Opb198,Opb198,Opb198,Opb198,Opb198,Opb198,Opb198,Opb198 ;@ b998
  .long Opb1a0,Opb1a0,Opb1a0,Opb1a0,Opb1a0,Opb1a0,Opb1a0,Opb1a0 ;@ b9a0
  .long Opb1a8,Opb1a8,Opb1a8,Opb1a8,Opb1a8,Opb1a8,Opb1a8,Opb1a8 ;@ b9a8
  .long Opb1b0,Opb1b0,Opb1b0,Opb1b0,Opb1b0,Opb1b0,Opb1b0,Opb1b0 ;@ b9b0
  .long Opb1b8,Opb1b9,Op____,Op____,Op____,Op____,Op____,Op____ ;@ b9b8
  .long Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0 ;@ b9c0
  .long Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0 ;@ b9c8
  .long Opb1d0,Opb1d0,Opb1d0,Opb1d0,Opb1d0,Opb1d0,Opb1d0,Opb1d0 ;@ b9d0
  .long Opb1d8,Opb1d8,Opb1d8,Opb1d8,Opb1d8,Opb1d8,Opb1d8,Opb1d8 ;@ b9d8
  .long Opb1e0,Opb1e0,Opb1e0,Opb1e0,Opb1e0,Opb1e0,Opb1e0,Opb1e0 ;@ b9e0
  .long Opb1e8,Opb1e8,Opb1e8,Opb1e8,Opb1e8,Opb1e8,Opb1e8,Opb1e8 ;@ b9e8
  .long Opb1f0,Opb1f0,Opb1f0,Opb1f0,Opb1f0,Opb1f0,Opb1f0,Opb1f0 ;@ b9f0
  .long Opb1f8,Opb1f9,Opb1fa,Opb1fb,Opb1fc,Op____,Op____,Op____ ;@ b9f8
  .long Opb000,Opb000,Opb000,Opb000,Opb000,Opb000,Opb000,Opb000 ;@ ba00
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ ba08
  .long Opb010,Opb010,Opb010,Opb010,Opb010,Opb010,Opb010,Opb010 ;@ ba10
  .long Opb018,Opb018,Opb018,Opb018,Opb018,Opb018,Opb018,Opb01f ;@ ba18
  .long Opb020,Opb020,Opb020,Opb020,Opb020,Opb020,Opb020,Opb027 ;@ ba20
  .long Opb028,Opb028,Opb028,Opb028,Opb028,Opb028,Opb028,Opb028 ;@ ba28
  .long Opb030,Opb030,Opb030,Opb030,Opb030,Opb030,Opb030,Opb030 ;@ ba30
  .long Opb038,Opb039,Opb03a,Opb03b,Opb03c,Op____,Op____,Op____ ;@ ba38
  .long Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040 ;@ ba40
  .long Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040 ;@ ba48
  .long Opb050,Opb050,Opb050,Opb050,Opb050,Opb050,Opb050,Opb050 ;@ ba50
  .long Opb058,Opb058,Opb058,Opb058,Opb058,Opb058,Opb058,Opb058 ;@ ba58
  .long Opb060,Opb060,Opb060,Opb060,Opb060,Opb060,Opb060,Opb060 ;@ ba60
  .long Opb068,Opb068,Opb068,Opb068,Opb068,Opb068,Opb068,Opb068 ;@ ba68
  .long Opb070,Opb070,Opb070,Opb070,Opb070,Opb070,Opb070,Opb070 ;@ ba70
  .long Opb078,Opb079,Opb07a,Opb07b,Opb07c,Op____,Op____,Op____ ;@ ba78
  .long Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080 ;@ ba80
  .long Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080 ;@ ba88
  .long Opb090,Opb090,Opb090,Opb090,Opb090,Opb090,Opb090,Opb090 ;@ ba90
  .long Opb098,Opb098,Opb098,Opb098,Opb098,Opb098,Opb098,Opb098 ;@ ba98
  .long Opb0a0,Opb0a0,Opb0a0,Opb0a0,Opb0a0,Opb0a0,Opb0a0,Opb0a0 ;@ baa0
  .long Opb0a8,Opb0a8,Opb0a8,Opb0a8,Opb0a8,Opb0a8,Opb0a8,Opb0a8 ;@ baa8
  .long Opb0b0,Opb0b0,Opb0b0,Opb0b0,Opb0b0,Opb0b0,Opb0b0,Opb0b0 ;@ bab0
  .long Opb0b8,Opb0b9,Opb0ba,Opb0bb,Opb0bc,Op____,Op____,Op____ ;@ bab8
  .long Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0 ;@ bac0
  .long Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0 ;@ bac8
  .long Opb0d0,Opb0d0,Opb0d0,Opb0d0,Opb0d0,Opb0d0,Opb0d0,Opb0d0 ;@ bad0
  .long Opb0d8,Opb0d8,Opb0d8,Opb0d8,Opb0d8,Opb0d8,Opb0d8,Opb0d8 ;@ bad8
  .long Opb0e0,Opb0e0,Opb0e0,Opb0e0,Opb0e0,Opb0e0,Opb0e0,Opb0e0 ;@ bae0
  .long Opb0e8,Opb0e8,Opb0e8,Opb0e8,Opb0e8,Opb0e8,Opb0e8,Opb0e8 ;@ bae8
  .long Opb0f0,Opb0f0,Opb0f0,Opb0f0,Opb0f0,Opb0f0,Opb0f0,Opb0f0 ;@ baf0
  .long Opb0f8,Opb0f9,Opb0fa,Opb0fb,Opb0fc,Op____,Op____,Op____ ;@ baf8
  .long Opb100,Opb100,Opb100,Opb100,Opb100,Opb100,Opb100,Opb100 ;@ bb00
  .long Opb108,Opb108,Opb108,Opb108,Opb108,Opb108,Opb108,Opb10f ;@ bb08
  .long Opb110,Opb110,Opb110,Opb110,Opb110,Opb110,Opb110,Opb110 ;@ bb10
  .long Opb118,Opb118,Opb118,Opb118,Opb118,Opb118,Opb118,Opb11f ;@ bb18
  .long Opb120,Opb120,Opb120,Opb120,Opb120,Opb120,Opb120,Opb127 ;@ bb20
  .long Opb128,Opb128,Opb128,Opb128,Opb128,Opb128,Opb128,Opb128 ;@ bb28
  .long Opb130,Opb130,Opb130,Opb130,Opb130,Opb130,Opb130,Opb130 ;@ bb30
  .long Opb138,Opb139,Op____,Op____,Op____,Op____,Op____,Op____ ;@ bb38
  .long Opb140,Opb140,Opb140,Opb140,Opb140,Opb140,Opb140,Opb140 ;@ bb40
  .long Opb148,Opb148,Opb148,Opb148,Opb148,Opb148,Opb148,Opb148 ;@ bb48
  .long Opb150,Opb150,Opb150,Opb150,Opb150,Opb150,Opb150,Opb150 ;@ bb50
  .long Opb158,Opb158,Opb158,Opb158,Opb158,Opb158,Opb158,Opb158 ;@ bb58
  .long Opb160,Opb160,Opb160,Opb160,Opb160,Opb160,Opb160,Opb160 ;@ bb60
  .long Opb168,Opb168,Opb168,Opb168,Opb168,Opb168,Opb168,Opb168 ;@ bb68
  .long Opb170,Opb170,Opb170,Opb170,Opb170,Opb170,Opb170,Opb170 ;@ bb70
  .long Opb178,Opb179,Op____,Op____,Op____,Op____,Op____,Op____ ;@ bb78
  .long Opb180,Opb180,Opb180,Opb180,Opb180,Opb180,Opb180,Opb180 ;@ bb80
  .long Opb188,Opb188,Opb188,Opb188,Opb188,Opb188,Opb188,Opb188 ;@ bb88
  .long Opb190,Opb190,Opb190,Opb190,Opb190,Opb190,Opb190,Opb190 ;@ bb90
  .long Opb198,Opb198,Opb198,Opb198,Opb198,Opb198,Opb198,Opb198 ;@ bb98
  .long Opb1a0,Opb1a0,Opb1a0,Opb1a0,Opb1a0,Opb1a0,Opb1a0,Opb1a0 ;@ bba0
  .long Opb1a8,Opb1a8,Opb1a8,Opb1a8,Opb1a8,Opb1a8,Opb1a8,Opb1a8 ;@ bba8
  .long Opb1b0,Opb1b0,Opb1b0,Opb1b0,Opb1b0,Opb1b0,Opb1b0,Opb1b0 ;@ bbb0
  .long Opb1b8,Opb1b9,Op____,Op____,Op____,Op____,Op____,Op____ ;@ bbb8
  .long Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0 ;@ bbc0
  .long Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0 ;@ bbc8
  .long Opb1d0,Opb1d0,Opb1d0,Opb1d0,Opb1d0,Opb1d0,Opb1d0,Opb1d0 ;@ bbd0
  .long Opb1d8,Opb1d8,Opb1d8,Opb1d8,Opb1d8,Opb1d8,Opb1d8,Opb1d8 ;@ bbd8
  .long Opb1e0,Opb1e0,Opb1e0,Opb1e0,Opb1e0,Opb1e0,Opb1e0,Opb1e0 ;@ bbe0
  .long Opb1e8,Opb1e8,Opb1e8,Opb1e8,Opb1e8,Opb1e8,Opb1e8,Opb1e8 ;@ bbe8
  .long Opb1f0,Opb1f0,Opb1f0,Opb1f0,Opb1f0,Opb1f0,Opb1f0,Opb1f0 ;@ bbf0
  .long Opb1f8,Opb1f9,Opb1fa,Opb1fb,Opb1fc,Op____,Op____,Op____ ;@ bbf8
  .long Opb000,Opb000,Opb000,Opb000,Opb000,Opb000,Opb000,Opb000 ;@ bc00
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ bc08
  .long Opb010,Opb010,Opb010,Opb010,Opb010,Opb010,Opb010,Opb010 ;@ bc10
  .long Opb018,Opb018,Opb018,Opb018,Opb018,Opb018,Opb018,Opb01f ;@ bc18
  .long Opb020,Opb020,Opb020,Opb020,Opb020,Opb020,Opb020,Opb027 ;@ bc20
  .long Opb028,Opb028,Opb028,Opb028,Opb028,Opb028,Opb028,Opb028 ;@ bc28
  .long Opb030,Opb030,Opb030,Opb030,Opb030,Opb030,Opb030,Opb030 ;@ bc30
  .long Opb038,Opb039,Opb03a,Opb03b,Opb03c,Op____,Op____,Op____ ;@ bc38
  .long Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040 ;@ bc40
  .long Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040 ;@ bc48
  .long Opb050,Opb050,Opb050,Opb050,Opb050,Opb050,Opb050,Opb050 ;@ bc50
  .long Opb058,Opb058,Opb058,Opb058,Opb058,Opb058,Opb058,Opb058 ;@ bc58
  .long Opb060,Opb060,Opb060,Opb060,Opb060,Opb060,Opb060,Opb060 ;@ bc60
  .long Opb068,Opb068,Opb068,Opb068,Opb068,Opb068,Opb068,Opb068 ;@ bc68
  .long Opb070,Opb070,Opb070,Opb070,Opb070,Opb070,Opb070,Opb070 ;@ bc70
  .long Opb078,Opb079,Opb07a,Opb07b,Opb07c,Op____,Op____,Op____ ;@ bc78
  .long Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080 ;@ bc80
  .long Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080 ;@ bc88
  .long Opb090,Opb090,Opb090,Opb090,Opb090,Opb090,Opb090,Opb090 ;@ bc90
  .long Opb098,Opb098,Opb098,Opb098,Opb098,Opb098,Opb098,Opb098 ;@ bc98
  .long Opb0a0,Opb0a0,Opb0a0,Opb0a0,Opb0a0,Opb0a0,Opb0a0,Opb0a0 ;@ bca0
  .long Opb0a8,Opb0a8,Opb0a8,Opb0a8,Opb0a8,Opb0a8,Opb0a8,Opb0a8 ;@ bca8
  .long Opb0b0,Opb0b0,Opb0b0,Opb0b0,Opb0b0,Opb0b0,Opb0b0,Opb0b0 ;@ bcb0
  .long Opb0b8,Opb0b9,Opb0ba,Opb0bb,Opb0bc,Op____,Op____,Op____ ;@ bcb8
  .long Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0 ;@ bcc0
  .long Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0 ;@ bcc8
  .long Opb0d0,Opb0d0,Opb0d0,Opb0d0,Opb0d0,Opb0d0,Opb0d0,Opb0d0 ;@ bcd0
  .long Opb0d8,Opb0d8,Opb0d8,Opb0d8,Opb0d8,Opb0d8,Opb0d8,Opb0d8 ;@ bcd8
  .long Opb0e0,Opb0e0,Opb0e0,Opb0e0,Opb0e0,Opb0e0,Opb0e0,Opb0e0 ;@ bce0
  .long Opb0e8,Opb0e8,Opb0e8,Opb0e8,Opb0e8,Opb0e8,Opb0e8,Opb0e8 ;@ bce8
  .long Opb0f0,Opb0f0,Opb0f0,Opb0f0,Opb0f0,Opb0f0,Opb0f0,Opb0f0 ;@ bcf0
  .long Opb0f8,Opb0f9,Opb0fa,Opb0fb,Opb0fc,Op____,Op____,Op____ ;@ bcf8
  .long Opb100,Opb100,Opb100,Opb100,Opb100,Opb100,Opb100,Opb100 ;@ bd00
  .long Opb108,Opb108,Opb108,Opb108,Opb108,Opb108,Opb108,Opb10f ;@ bd08
  .long Opb110,Opb110,Opb110,Opb110,Opb110,Opb110,Opb110,Opb110 ;@ bd10
  .long Opb118,Opb118,Opb118,Opb118,Opb118,Opb118,Opb118,Opb11f ;@ bd18
  .long Opb120,Opb120,Opb120,Opb120,Opb120,Opb120,Opb120,Opb127 ;@ bd20
  .long Opb128,Opb128,Opb128,Opb128,Opb128,Opb128,Opb128,Opb128 ;@ bd28
  .long Opb130,Opb130,Opb130,Opb130,Opb130,Opb130,Opb130,Opb130 ;@ bd30
  .long Opb138,Opb139,Op____,Op____,Op____,Op____,Op____,Op____ ;@ bd38
  .long Opb140,Opb140,Opb140,Opb140,Opb140,Opb140,Opb140,Opb140 ;@ bd40
  .long Opb148,Opb148,Opb148,Opb148,Opb148,Opb148,Opb148,Opb148 ;@ bd48
  .long Opb150,Opb150,Opb150,Opb150,Opb150,Opb150,Opb150,Opb150 ;@ bd50
  .long Opb158,Opb158,Opb158,Opb158,Opb158,Opb158,Opb158,Opb158 ;@ bd58
  .long Opb160,Opb160,Opb160,Opb160,Opb160,Opb160,Opb160,Opb160 ;@ bd60
  .long Opb168,Opb168,Opb168,Opb168,Opb168,Opb168,Opb168,Opb168 ;@ bd68
  .long Opb170,Opb170,Opb170,Opb170,Opb170,Opb170,Opb170,Opb170 ;@ bd70
  .long Opb178,Opb179,Op____,Op____,Op____,Op____,Op____,Op____ ;@ bd78
  .long Opb180,Opb180,Opb180,Opb180,Opb180,Opb180,Opb180,Opb180 ;@ bd80
  .long Opb188,Opb188,Opb188,Opb188,Opb188,Opb188,Opb188,Opb188 ;@ bd88
  .long Opb190,Opb190,Opb190,Opb190,Opb190,Opb190,Opb190,Opb190 ;@ bd90
  .long Opb198,Opb198,Opb198,Opb198,Opb198,Opb198,Opb198,Opb198 ;@ bd98
  .long Opb1a0,Opb1a0,Opb1a0,Opb1a0,Opb1a0,Opb1a0,Opb1a0,Opb1a0 ;@ bda0
  .long Opb1a8,Opb1a8,Opb1a8,Opb1a8,Opb1a8,Opb1a8,Opb1a8,Opb1a8 ;@ bda8
  .long Opb1b0,Opb1b0,Opb1b0,Opb1b0,Opb1b0,Opb1b0,Opb1b0,Opb1b0 ;@ bdb0
  .long Opb1b8,Opb1b9,Op____,Op____,Op____,Op____,Op____,Op____ ;@ bdb8
  .long Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0 ;@ bdc0
  .long Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0 ;@ bdc8
  .long Opb1d0,Opb1d0,Opb1d0,Opb1d0,Opb1d0,Opb1d0,Opb1d0,Opb1d0 ;@ bdd0
  .long Opb1d8,Opb1d8,Opb1d8,Opb1d8,Opb1d8,Opb1d8,Opb1d8,Opb1d8 ;@ bdd8
  .long Opb1e0,Opb1e0,Opb1e0,Opb1e0,Opb1e0,Opb1e0,Opb1e0,Opb1e0 ;@ bde0
  .long Opb1e8,Opb1e8,Opb1e8,Opb1e8,Opb1e8,Opb1e8,Opb1e8,Opb1e8 ;@ bde8
  .long Opb1f0,Opb1f0,Opb1f0,Opb1f0,Opb1f0,Opb1f0,Opb1f0,Opb1f0 ;@ bdf0
  .long Opb1f8,Opb1f9,Opb1fa,Opb1fb,Opb1fc,Op____,Op____,Op____ ;@ bdf8
  .long Opb000,Opb000,Opb000,Opb000,Opb000,Opb000,Opb000,Opb000 ;@ be00
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ be08
  .long Opb010,Opb010,Opb010,Opb010,Opb010,Opb010,Opb010,Opb010 ;@ be10
  .long Opb018,Opb018,Opb018,Opb018,Opb018,Opb018,Opb018,Opb01f ;@ be18
  .long Opb020,Opb020,Opb020,Opb020,Opb020,Opb020,Opb020,Opb027 ;@ be20
  .long Opb028,Opb028,Opb028,Opb028,Opb028,Opb028,Opb028,Opb028 ;@ be28
  .long Opb030,Opb030,Opb030,Opb030,Opb030,Opb030,Opb030,Opb030 ;@ be30
  .long Opb038,Opb039,Opb03a,Opb03b,Opb03c,Op____,Op____,Op____ ;@ be38
  .long Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040 ;@ be40
  .long Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040,Opb040 ;@ be48
  .long Opb050,Opb050,Opb050,Opb050,Opb050,Opb050,Opb050,Opb050 ;@ be50
  .long Opb058,Opb058,Opb058,Opb058,Opb058,Opb058,Opb058,Opb058 ;@ be58
  .long Opb060,Opb060,Opb060,Opb060,Opb060,Opb060,Opb060,Opb060 ;@ be60
  .long Opb068,Opb068,Opb068,Opb068,Opb068,Opb068,Opb068,Opb068 ;@ be68
  .long Opb070,Opb070,Opb070,Opb070,Opb070,Opb070,Opb070,Opb070 ;@ be70
  .long Opb078,Opb079,Opb07a,Opb07b,Opb07c,Op____,Op____,Op____ ;@ be78
  .long Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080 ;@ be80
  .long Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080,Opb080 ;@ be88
  .long Opb090,Opb090,Opb090,Opb090,Opb090,Opb090,Opb090,Opb090 ;@ be90
  .long Opb098,Opb098,Opb098,Opb098,Opb098,Opb098,Opb098,Opb098 ;@ be98
  .long Opb0a0,Opb0a0,Opb0a0,Opb0a0,Opb0a0,Opb0a0,Opb0a0,Opb0a0 ;@ bea0
  .long Opb0a8,Opb0a8,Opb0a8,Opb0a8,Opb0a8,Opb0a8,Opb0a8,Opb0a8 ;@ bea8
  .long Opb0b0,Opb0b0,Opb0b0,Opb0b0,Opb0b0,Opb0b0,Opb0b0,Opb0b0 ;@ beb0
  .long Opb0b8,Opb0b9,Opb0ba,Opb0bb,Opb0bc,Op____,Op____,Op____ ;@ beb8
  .long Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0 ;@ bec0
  .long Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0,Opb0c0 ;@ bec8
  .long Opb0d0,Opb0d0,Opb0d0,Opb0d0,Opb0d0,Opb0d0,Opb0d0,Opb0d0 ;@ bed0
  .long Opb0d8,Opb0d8,Opb0d8,Opb0d8,Opb0d8,Opb0d8,Opb0d8,Opb0d8 ;@ bed8
  .long Opb0e0,Opb0e0,Opb0e0,Opb0e0,Opb0e0,Opb0e0,Opb0e0,Opb0e0 ;@ bee0
  .long Opb0e8,Opb0e8,Opb0e8,Opb0e8,Opb0e8,Opb0e8,Opb0e8,Opb0e8 ;@ bee8
  .long Opb0f0,Opb0f0,Opb0f0,Opb0f0,Opb0f0,Opb0f0,Opb0f0,Opb0f0 ;@ bef0
  .long Opb0f8,Opb0f9,Opb0fa,Opb0fb,Opb0fc,Op____,Op____,Op____ ;@ bef8
  .long Opb100,Opb100,Opb100,Opb100,Opb100,Opb100,Opb100,Opb100 ;@ bf00
  .long Opbf08,Opbf08,Opbf08,Opbf08,Opbf08,Opbf08,Opbf08,Opbf0f ;@ bf08
  .long Opb110,Opb110,Opb110,Opb110,Opb110,Opb110,Opb110,Opb110 ;@ bf10
  .long Opb118,Opb118,Opb118,Opb118,Opb118,Opb118,Opb118,Opb11f ;@ bf18
  .long Opb120,Opb120,Opb120,Opb120,Opb120,Opb120,Opb120,Opb127 ;@ bf20
  .long Opb128,Opb128,Opb128,Opb128,Opb128,Opb128,Opb128,Opb128 ;@ bf28
  .long Opb130,Opb130,Opb130,Opb130,Opb130,Opb130,Opb130,Opb130 ;@ bf30
  .long Opb138,Opb139,Op____,Op____,Op____,Op____,Op____,Op____ ;@ bf38
  .long Opb140,Opb140,Opb140,Opb140,Opb140,Opb140,Opb140,Opb140 ;@ bf40
  .long Opb148,Opb148,Opb148,Opb148,Opb148,Opb148,Opb148,Opb148 ;@ bf48
  .long Opb150,Opb150,Opb150,Opb150,Opb150,Opb150,Opb150,Opb150 ;@ bf50
  .long Opb158,Opb158,Opb158,Opb158,Opb158,Opb158,Opb158,Opb158 ;@ bf58
  .long Opb160,Opb160,Opb160,Opb160,Opb160,Opb160,Opb160,Opb160 ;@ bf60
  .long Opb168,Opb168,Opb168,Opb168,Opb168,Opb168,Opb168,Opb168 ;@ bf68
  .long Opb170,Opb170,Opb170,Opb170,Opb170,Opb170,Opb170,Opb170 ;@ bf70
  .long Opb178,Opb179,Op____,Op____,Op____,Op____,Op____,Op____ ;@ bf78
  .long Opb180,Opb180,Opb180,Opb180,Opb180,Opb180,Opb180,Opb180 ;@ bf80
  .long Opb188,Opb188,Opb188,Opb188,Opb188,Opb188,Opb188,Opb188 ;@ bf88
  .long Opb190,Opb190,Opb190,Opb190,Opb190,Opb190,Opb190,Opb190 ;@ bf90
  .long Opb198,Opb198,Opb198,Opb198,Opb198,Opb198,Opb198,Opb198 ;@ bf98
  .long Opb1a0,Opb1a0,Opb1a0,Opb1a0,Opb1a0,Opb1a0,Opb1a0,Opb1a0 ;@ bfa0
  .long Opb1a8,Opb1a8,Opb1a8,Opb1a8,Opb1a8,Opb1a8,Opb1a8,Opb1a8 ;@ bfa8
  .long Opb1b0,Opb1b0,Opb1b0,Opb1b0,Opb1b0,Opb1b0,Opb1b0,Opb1b0 ;@ bfb0
  .long Opb1b8,Opb1b9,Op____,Op____,Op____,Op____,Op____,Op____ ;@ bfb8
  .long Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0 ;@ bfc0
  .long Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0,Opb1c0 ;@ bfc8
  .long Opb1d0,Opb1d0,Opb1d0,Opb1d0,Opb1d0,Opb1d0,Opb1d0,Opb1d0 ;@ bfd0
  .long Opb1d8,Opb1d8,Opb1d8,Opb1d8,Opb1d8,Opb1d8,Opb1d8,Opb1d8 ;@ bfd8
  .long Opb1e0,Opb1e0,Opb1e0,Opb1e0,Opb1e0,Opb1e0,Opb1e0,Opb1e0 ;@ bfe0
  .long Opb1e8,Opb1e8,Opb1e8,Opb1e8,Opb1e8,Opb1e8,Opb1e8,Opb1e8 ;@ bfe8
  .long Opb1f0,Opb1f0,Opb1f0,Opb1f0,Opb1f0,Opb1f0,Opb1f0,Opb1f0 ;@ bff0
  .long Opb1f8,Opb1f9,Opb1fa,Opb1fb,Opb1fc,Op____,Op____,Op____ ;@ bff8
  .long Opc000,Opc000,Opc000,Opc000,Opc000,Opc000,Opc000,Opc000 ;@ c000
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ c008
  .long Opc010,Opc010,Opc010,Opc010,Opc010,Opc010,Opc010,Opc010 ;@ c010
  .long Opc018,Opc018,Opc018,Opc018,Opc018,Opc018,Opc018,Opc01f ;@ c018
  .long Opc020,Opc020,Opc020,Opc020,Opc020,Opc020,Opc020,Opc027 ;@ c020
  .long Opc028,Opc028,Opc028,Opc028,Opc028,Opc028,Opc028,Opc028 ;@ c028
  .long Opc030,Opc030,Opc030,Opc030,Opc030,Opc030,Opc030,Opc030 ;@ c030
  .long Opc038,Opc039,Opc03a,Opc03b,Opc03c,Op____,Op____,Op____ ;@ c038
  .long Opc040,Opc040,Opc040,Opc040,Opc040,Opc040,Opc040,Opc040 ;@ c040
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ c048
  .long Opc050,Opc050,Opc050,Opc050,Opc050,Opc050,Opc050,Opc050 ;@ c050
  .long Opc058,Opc058,Opc058,Opc058,Opc058,Opc058,Opc058,Opc058 ;@ c058
  .long Opc060,Opc060,Opc060,Opc060,Opc060,Opc060,Opc060,Opc060 ;@ c060
  .long Opc068,Opc068,Opc068,Opc068,Opc068,Opc068,Opc068,Opc068 ;@ c068
  .long Opc070,Opc070,Opc070,Opc070,Opc070,Opc070,Opc070,Opc070 ;@ c070
  .long Opc078,Opc079,Opc07a,Opc07b,Opc07c,Op____,Op____,Op____ ;@ c078
  .long Opc080,Opc080,Opc080,Opc080,Opc080,Opc080,Opc080,Opc080 ;@ c080
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ c088
  .long Opc090,Opc090,Opc090,Opc090,Opc090,Opc090,Opc090,Opc090 ;@ c090
  .long Opc098,Opc098,Opc098,Opc098,Opc098,Opc098,Opc098,Opc098 ;@ c098
  .long Opc0a0,Opc0a0,Opc0a0,Opc0a0,Opc0a0,Opc0a0,Opc0a0,Opc0a0 ;@ c0a0
  .long Opc0a8,Opc0a8,Opc0a8,Opc0a8,Opc0a8,Opc0a8,Opc0a8,Opc0a8 ;@ c0a8
  .long Opc0b0,Opc0b0,Opc0b0,Opc0b0,Opc0b0,Opc0b0,Opc0b0,Opc0b0 ;@ c0b0
  .long Opc0b8,Opc0b9,Opc0ba,Opc0bb,Opc0bc,Op____,Op____,Op____ ;@ c0b8
  .long Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0 ;@ c0c0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ c0c8
  .long Opc0d0,Opc0d0,Opc0d0,Opc0d0,Opc0d0,Opc0d0,Opc0d0,Opc0d0 ;@ c0d0
  .long Opc0d8,Opc0d8,Opc0d8,Opc0d8,Opc0d8,Opc0d8,Opc0d8,Opc0d8 ;@ c0d8
  .long Opc0e0,Opc0e0,Opc0e0,Opc0e0,Opc0e0,Opc0e0,Opc0e0,Opc0e0 ;@ c0e0
  .long Opc0e8,Opc0e8,Opc0e8,Opc0e8,Opc0e8,Opc0e8,Opc0e8,Opc0e8 ;@ c0e8
  .long Opc0f0,Opc0f0,Opc0f0,Opc0f0,Opc0f0,Opc0f0,Opc0f0,Opc0f0 ;@ c0f0
  .long Opc0f8,Opc0f9,Opc0fa,Opc0fb,Opc0fc,Op____,Op____,Op____ ;@ c0f8
  .long Opc100,Opc100,Opc100,Opc100,Opc100,Opc100,Opc100,Opc100 ;@ c100
  .long Opc108,Opc108,Opc108,Opc108,Opc108,Opc108,Opc108,Opc10f ;@ c108
  .long Opc110,Opc110,Opc110,Opc110,Opc110,Opc110,Opc110,Opc110 ;@ c110
  .long Opc118,Opc118,Opc118,Opc118,Opc118,Opc118,Opc118,Opc11f ;@ c118
  .long Opc120,Opc120,Opc120,Opc120,Opc120,Opc120,Opc120,Opc127 ;@ c120
  .long Opc128,Opc128,Opc128,Opc128,Opc128,Opc128,Opc128,Opc128 ;@ c128
  .long Opc130,Opc130,Opc130,Opc130,Opc130,Opc130,Opc130,Opc130 ;@ c130
  .long Opc138,Opc139,Op____,Op____,Op____,Op____,Op____,Op____ ;@ c138
  .long Opc140,Opc140,Opc140,Opc140,Opc140,Opc140,Opc140,Opc140 ;@ c140
  .long Opc148,Opc148,Opc148,Opc148,Opc148,Opc148,Opc148,Opc148 ;@ c148
  .long Opc150,Opc150,Opc150,Opc150,Opc150,Opc150,Opc150,Opc150 ;@ c150
  .long Opc158,Opc158,Opc158,Opc158,Opc158,Opc158,Opc158,Opc158 ;@ c158
  .long Opc160,Opc160,Opc160,Opc160,Opc160,Opc160,Opc160,Opc160 ;@ c160
  .long Opc168,Opc168,Opc168,Opc168,Opc168,Opc168,Opc168,Opc168 ;@ c168
  .long Opc170,Opc170,Opc170,Opc170,Opc170,Opc170,Opc170,Opc170 ;@ c170
  .long Opc178,Opc179,Op____,Op____,Op____,Op____,Op____,Op____ ;@ c178
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ c180
  .long Opc188,Opc188,Opc188,Opc188,Opc188,Opc188,Opc188,Opc188 ;@ c188
  .long Opc190,Opc190,Opc190,Opc190,Opc190,Opc190,Opc190,Opc190 ;@ c190
  .long Opc198,Opc198,Opc198,Opc198,Opc198,Opc198,Opc198,Opc198 ;@ c198
  .long Opc1a0,Opc1a0,Opc1a0,Opc1a0,Opc1a0,Opc1a0,Opc1a0,Opc1a0 ;@ c1a0
  .long Opc1a8,Opc1a8,Opc1a8,Opc1a8,Opc1a8,Opc1a8,Opc1a8,Opc1a8 ;@ c1a8
  .long Opc1b0,Opc1b0,Opc1b0,Opc1b0,Opc1b0,Opc1b0,Opc1b0,Opc1b0 ;@ c1b0
  .long Opc1b8,Opc1b9,Op____,Op____,Op____,Op____,Op____,Op____ ;@ c1b8
  .long Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0 ;@ c1c0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ c1c8
  .long Opc1d0,Opc1d0,Opc1d0,Opc1d0,Opc1d0,Opc1d0,Opc1d0,Opc1d0 ;@ c1d0
  .long Opc1d8,Opc1d8,Opc1d8,Opc1d8,Opc1d8,Opc1d8,Opc1d8,Opc1d8 ;@ c1d8
  .long Opc1e0,Opc1e0,Opc1e0,Opc1e0,Opc1e0,Opc1e0,Opc1e0,Opc1e0 ;@ c1e0
  .long Opc1e8,Opc1e8,Opc1e8,Opc1e8,Opc1e8,Opc1e8,Opc1e8,Opc1e8 ;@ c1e8
  .long Opc1f0,Opc1f0,Opc1f0,Opc1f0,Opc1f0,Opc1f0,Opc1f0,Opc1f0 ;@ c1f0
  .long Opc1f8,Opc1f9,Opc1fa,Opc1fb,Opc1fc,Op____,Op____,Op____ ;@ c1f8
  .long Opc000,Opc000,Opc000,Opc000,Opc000,Opc000,Opc000,Opc000 ;@ c200
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ c208
  .long Opc010,Opc010,Opc010,Opc010,Opc010,Opc010,Opc010,Opc010 ;@ c210
  .long Opc018,Opc018,Opc018,Opc018,Opc018,Opc018,Opc018,Opc01f ;@ c218
  .long Opc020,Opc020,Opc020,Opc020,Opc020,Opc020,Opc020,Opc027 ;@ c220
  .long Opc028,Opc028,Opc028,Opc028,Opc028,Opc028,Opc028,Opc028 ;@ c228
  .long Opc030,Opc030,Opc030,Opc030,Opc030,Opc030,Opc030,Opc030 ;@ c230
  .long Opc038,Opc039,Opc03a,Opc03b,Opc03c,Op____,Op____,Op____ ;@ c238
  .long Opc040,Opc040,Opc040,Opc040,Opc040,Opc040,Opc040,Opc040 ;@ c240
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ c248
  .long Opc050,Opc050,Opc050,Opc050,Opc050,Opc050,Opc050,Opc050 ;@ c250
  .long Opc058,Opc058,Opc058,Opc058,Opc058,Opc058,Opc058,Opc058 ;@ c258
  .long Opc060,Opc060,Opc060,Opc060,Opc060,Opc060,Opc060,Opc060 ;@ c260
  .long Opc068,Opc068,Opc068,Opc068,Opc068,Opc068,Opc068,Opc068 ;@ c268
  .long Opc070,Opc070,Opc070,Opc070,Opc070,Opc070,Opc070,Opc070 ;@ c270
  .long Opc078,Opc079,Opc07a,Opc07b,Opc07c,Op____,Op____,Op____ ;@ c278
  .long Opc080,Opc080,Opc080,Opc080,Opc080,Opc080,Opc080,Opc080 ;@ c280
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ c288
  .long Opc090,Opc090,Opc090,Opc090,Opc090,Opc090,Opc090,Opc090 ;@ c290
  .long Opc098,Opc098,Opc098,Opc098,Opc098,Opc098,Opc098,Opc098 ;@ c298
  .long Opc0a0,Opc0a0,Opc0a0,Opc0a0,Opc0a0,Opc0a0,Opc0a0,Opc0a0 ;@ c2a0
  .long Opc0a8,Opc0a8,Opc0a8,Opc0a8,Opc0a8,Opc0a8,Opc0a8,Opc0a8 ;@ c2a8
  .long Opc0b0,Opc0b0,Opc0b0,Opc0b0,Opc0b0,Opc0b0,Opc0b0,Opc0b0 ;@ c2b0
  .long Opc0b8,Opc0b9,Opc0ba,Opc0bb,Opc0bc,Op____,Op____,Op____ ;@ c2b8
  .long Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0 ;@ c2c0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ c2c8
  .long Opc0d0,Opc0d0,Opc0d0,Opc0d0,Opc0d0,Opc0d0,Opc0d0,Opc0d0 ;@ c2d0
  .long Opc0d8,Opc0d8,Opc0d8,Opc0d8,Opc0d8,Opc0d8,Opc0d8,Opc0d8 ;@ c2d8
  .long Opc0e0,Opc0e0,Opc0e0,Opc0e0,Opc0e0,Opc0e0,Opc0e0,Opc0e0 ;@ c2e0
  .long Opc0e8,Opc0e8,Opc0e8,Opc0e8,Opc0e8,Opc0e8,Opc0e8,Opc0e8 ;@ c2e8
  .long Opc0f0,Opc0f0,Opc0f0,Opc0f0,Opc0f0,Opc0f0,Opc0f0,Opc0f0 ;@ c2f0
  .long Opc0f8,Opc0f9,Opc0fa,Opc0fb,Opc0fc,Op____,Op____,Op____ ;@ c2f8
  .long Opc100,Opc100,Opc100,Opc100,Opc100,Opc100,Opc100,Opc100 ;@ c300
  .long Opc108,Opc108,Opc108,Opc108,Opc108,Opc108,Opc108,Opc10f ;@ c308
  .long Opc110,Opc110,Opc110,Opc110,Opc110,Opc110,Opc110,Opc110 ;@ c310
  .long Opc118,Opc118,Opc118,Opc118,Opc118,Opc118,Opc118,Opc11f ;@ c318
  .long Opc120,Opc120,Opc120,Opc120,Opc120,Opc120,Opc120,Opc127 ;@ c320
  .long Opc128,Opc128,Opc128,Opc128,Opc128,Opc128,Opc128,Opc128 ;@ c328
  .long Opc130,Opc130,Opc130,Opc130,Opc130,Opc130,Opc130,Opc130 ;@ c330
  .long Opc138,Opc139,Op____,Op____,Op____,Op____,Op____,Op____ ;@ c338
  .long Opc140,Opc140,Opc140,Opc140,Opc140,Opc140,Opc140,Opc140 ;@ c340
  .long Opc148,Opc148,Opc148,Opc148,Opc148,Opc148,Opc148,Opc148 ;@ c348
  .long Opc150,Opc150,Opc150,Opc150,Opc150,Opc150,Opc150,Opc150 ;@ c350
  .long Opc158,Opc158,Opc158,Opc158,Opc158,Opc158,Opc158,Opc158 ;@ c358
  .long Opc160,Opc160,Opc160,Opc160,Opc160,Opc160,Opc160,Opc160 ;@ c360
  .long Opc168,Opc168,Opc168,Opc168,Opc168,Opc168,Opc168,Opc168 ;@ c368
  .long Opc170,Opc170,Opc170,Opc170,Opc170,Opc170,Opc170,Opc170 ;@ c370
  .long Opc178,Opc179,Op____,Op____,Op____,Op____,Op____,Op____ ;@ c378
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ c380
  .long Opc188,Opc188,Opc188,Opc188,Opc188,Opc188,Opc188,Opc188 ;@ c388
  .long Opc190,Opc190,Opc190,Opc190,Opc190,Opc190,Opc190,Opc190 ;@ c390
  .long Opc198,Opc198,Opc198,Opc198,Opc198,Opc198,Opc198,Opc198 ;@ c398
  .long Opc1a0,Opc1a0,Opc1a0,Opc1a0,Opc1a0,Opc1a0,Opc1a0,Opc1a0 ;@ c3a0
  .long Opc1a8,Opc1a8,Opc1a8,Opc1a8,Opc1a8,Opc1a8,Opc1a8,Opc1a8 ;@ c3a8
  .long Opc1b0,Opc1b0,Opc1b0,Opc1b0,Opc1b0,Opc1b0,Opc1b0,Opc1b0 ;@ c3b0
  .long Opc1b8,Opc1b9,Op____,Op____,Op____,Op____,Op____,Op____ ;@ c3b8
  .long Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0 ;@ c3c0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ c3c8
  .long Opc1d0,Opc1d0,Opc1d0,Opc1d0,Opc1d0,Opc1d0,Opc1d0,Opc1d0 ;@ c3d0
  .long Opc1d8,Opc1d8,Opc1d8,Opc1d8,Opc1d8,Opc1d8,Opc1d8,Opc1d8 ;@ c3d8
  .long Opc1e0,Opc1e0,Opc1e0,Opc1e0,Opc1e0,Opc1e0,Opc1e0,Opc1e0 ;@ c3e0
  .long Opc1e8,Opc1e8,Opc1e8,Opc1e8,Opc1e8,Opc1e8,Opc1e8,Opc1e8 ;@ c3e8
  .long Opc1f0,Opc1f0,Opc1f0,Opc1f0,Opc1f0,Opc1f0,Opc1f0,Opc1f0 ;@ c3f0
  .long Opc1f8,Opc1f9,Opc1fa,Opc1fb,Opc1fc,Op____,Op____,Op____ ;@ c3f8
  .long Opc000,Opc000,Opc000,Opc000,Opc000,Opc000,Opc000,Opc000 ;@ c400
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ c408
  .long Opc010,Opc010,Opc010,Opc010,Opc010,Opc010,Opc010,Opc010 ;@ c410
  .long Opc018,Opc018,Opc018,Opc018,Opc018,Opc018,Opc018,Opc01f ;@ c418
  .long Opc020,Opc020,Opc020,Opc020,Opc020,Opc020,Opc020,Opc027 ;@ c420
  .long Opc028,Opc028,Opc028,Opc028,Opc028,Opc028,Opc028,Opc028 ;@ c428
  .long Opc030,Opc030,Opc030,Opc030,Opc030,Opc030,Opc030,Opc030 ;@ c430
  .long Opc038,Opc039,Opc03a,Opc03b,Opc03c,Op____,Op____,Op____ ;@ c438
  .long Opc040,Opc040,Opc040,Opc040,Opc040,Opc040,Opc040,Opc040 ;@ c440
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ c448
  .long Opc050,Opc050,Opc050,Opc050,Opc050,Opc050,Opc050,Opc050 ;@ c450
  .long Opc058,Opc058,Opc058,Opc058,Opc058,Opc058,Opc058,Opc058 ;@ c458
  .long Opc060,Opc060,Opc060,Opc060,Opc060,Opc060,Opc060,Opc060 ;@ c460
  .long Opc068,Opc068,Opc068,Opc068,Opc068,Opc068,Opc068,Opc068 ;@ c468
  .long Opc070,Opc070,Opc070,Opc070,Opc070,Opc070,Opc070,Opc070 ;@ c470
  .long Opc078,Opc079,Opc07a,Opc07b,Opc07c,Op____,Op____,Op____ ;@ c478
  .long Opc080,Opc080,Opc080,Opc080,Opc080,Opc080,Opc080,Opc080 ;@ c480
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ c488
  .long Opc090,Opc090,Opc090,Opc090,Opc090,Opc090,Opc090,Opc090 ;@ c490
  .long Opc098,Opc098,Opc098,Opc098,Opc098,Opc098,Opc098,Opc098 ;@ c498
  .long Opc0a0,Opc0a0,Opc0a0,Opc0a0,Opc0a0,Opc0a0,Opc0a0,Opc0a0 ;@ c4a0
  .long Opc0a8,Opc0a8,Opc0a8,Opc0a8,Opc0a8,Opc0a8,Opc0a8,Opc0a8 ;@ c4a8
  .long Opc0b0,Opc0b0,Opc0b0,Opc0b0,Opc0b0,Opc0b0,Opc0b0,Opc0b0 ;@ c4b0
  .long Opc0b8,Opc0b9,Opc0ba,Opc0bb,Opc0bc,Op____,Op____,Op____ ;@ c4b8
  .long Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0 ;@ c4c0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ c4c8
  .long Opc0d0,Opc0d0,Opc0d0,Opc0d0,Opc0d0,Opc0d0,Opc0d0,Opc0d0 ;@ c4d0
  .long Opc0d8,Opc0d8,Opc0d8,Opc0d8,Opc0d8,Opc0d8,Opc0d8,Opc0d8 ;@ c4d8
  .long Opc0e0,Opc0e0,Opc0e0,Opc0e0,Opc0e0,Opc0e0,Opc0e0,Opc0e0 ;@ c4e0
  .long Opc0e8,Opc0e8,Opc0e8,Opc0e8,Opc0e8,Opc0e8,Opc0e8,Opc0e8 ;@ c4e8
  .long Opc0f0,Opc0f0,Opc0f0,Opc0f0,Opc0f0,Opc0f0,Opc0f0,Opc0f0 ;@ c4f0
  .long Opc0f8,Opc0f9,Opc0fa,Opc0fb,Opc0fc,Op____,Op____,Op____ ;@ c4f8
  .long Opc100,Opc100,Opc100,Opc100,Opc100,Opc100,Opc100,Opc100 ;@ c500
  .long Opc108,Opc108,Opc108,Opc108,Opc108,Opc108,Opc108,Opc10f ;@ c508
  .long Opc110,Opc110,Opc110,Opc110,Opc110,Opc110,Opc110,Opc110 ;@ c510
  .long Opc118,Opc118,Opc118,Opc118,Opc118,Opc118,Opc118,Opc11f ;@ c518
  .long Opc120,Opc120,Opc120,Opc120,Opc120,Opc120,Opc120,Opc127 ;@ c520
  .long Opc128,Opc128,Opc128,Opc128,Opc128,Opc128,Opc128,Opc128 ;@ c528
  .long Opc130,Opc130,Opc130,Opc130,Opc130,Opc130,Opc130,Opc130 ;@ c530
  .long Opc138,Opc139,Op____,Op____,Op____,Op____,Op____,Op____ ;@ c538
  .long Opc140,Opc140,Opc140,Opc140,Opc140,Opc140,Opc140,Opc140 ;@ c540
  .long Opc148,Opc148,Opc148,Opc148,Opc148,Opc148,Opc148,Opc148 ;@ c548
  .long Opc150,Opc150,Opc150,Opc150,Opc150,Opc150,Opc150,Opc150 ;@ c550
  .long Opc158,Opc158,Opc158,Opc158,Opc158,Opc158,Opc158,Opc158 ;@ c558
  .long Opc160,Opc160,Opc160,Opc160,Opc160,Opc160,Opc160,Opc160 ;@ c560
  .long Opc168,Opc168,Opc168,Opc168,Opc168,Opc168,Opc168,Opc168 ;@ c568
  .long Opc170,Opc170,Opc170,Opc170,Opc170,Opc170,Opc170,Opc170 ;@ c570
  .long Opc178,Opc179,Op____,Op____,Op____,Op____,Op____,Op____ ;@ c578
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ c580
  .long Opc188,Opc188,Opc188,Opc188,Opc188,Opc188,Opc188,Opc188 ;@ c588
  .long Opc190,Opc190,Opc190,Opc190,Opc190,Opc190,Opc190,Opc190 ;@ c590
  .long Opc198,Opc198,Opc198,Opc198,Opc198,Opc198,Opc198,Opc198 ;@ c598
  .long Opc1a0,Opc1a0,Opc1a0,Opc1a0,Opc1a0,Opc1a0,Opc1a0,Opc1a0 ;@ c5a0
  .long Opc1a8,Opc1a8,Opc1a8,Opc1a8,Opc1a8,Opc1a8,Opc1a8,Opc1a8 ;@ c5a8
  .long Opc1b0,Opc1b0,Opc1b0,Opc1b0,Opc1b0,Opc1b0,Opc1b0,Opc1b0 ;@ c5b0
  .long Opc1b8,Opc1b9,Op____,Op____,Op____,Op____,Op____,Op____ ;@ c5b8
  .long Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0 ;@ c5c0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ c5c8
  .long Opc1d0,Opc1d0,Opc1d0,Opc1d0,Opc1d0,Opc1d0,Opc1d0,Opc1d0 ;@ c5d0
  .long Opc1d8,Opc1d8,Opc1d8,Opc1d8,Opc1d8,Opc1d8,Opc1d8,Opc1d8 ;@ c5d8
  .long Opc1e0,Opc1e0,Opc1e0,Opc1e0,Opc1e0,Opc1e0,Opc1e0,Opc1e0 ;@ c5e0
  .long Opc1e8,Opc1e8,Opc1e8,Opc1e8,Opc1e8,Opc1e8,Opc1e8,Opc1e8 ;@ c5e8
  .long Opc1f0,Opc1f0,Opc1f0,Opc1f0,Opc1f0,Opc1f0,Opc1f0,Opc1f0 ;@ c5f0
  .long Opc1f8,Opc1f9,Opc1fa,Opc1fb,Opc1fc,Op____,Op____,Op____ ;@ c5f8
  .long Opc000,Opc000,Opc000,Opc000,Opc000,Opc000,Opc000,Opc000 ;@ c600
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ c608
  .long Opc010,Opc010,Opc010,Opc010,Opc010,Opc010,Opc010,Opc010 ;@ c610
  .long Opc018,Opc018,Opc018,Opc018,Opc018,Opc018,Opc018,Opc01f ;@ c618
  .long Opc020,Opc020,Opc020,Opc020,Opc020,Opc020,Opc020,Opc027 ;@ c620
  .long Opc028,Opc028,Opc028,Opc028,Opc028,Opc028,Opc028,Opc028 ;@ c628
  .long Opc030,Opc030,Opc030,Opc030,Opc030,Opc030,Opc030,Opc030 ;@ c630
  .long Opc038,Opc039,Opc03a,Opc03b,Opc03c,Op____,Op____,Op____ ;@ c638
  .long Opc040,Opc040,Opc040,Opc040,Opc040,Opc040,Opc040,Opc040 ;@ c640
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ c648
  .long Opc050,Opc050,Opc050,Opc050,Opc050,Opc050,Opc050,Opc050 ;@ c650
  .long Opc058,Opc058,Opc058,Opc058,Opc058,Opc058,Opc058,Opc058 ;@ c658
  .long Opc060,Opc060,Opc060,Opc060,Opc060,Opc060,Opc060,Opc060 ;@ c660
  .long Opc068,Opc068,Opc068,Opc068,Opc068,Opc068,Opc068,Opc068 ;@ c668
  .long Opc070,Opc070,Opc070,Opc070,Opc070,Opc070,Opc070,Opc070 ;@ c670
  .long Opc078,Opc079,Opc07a,Opc07b,Opc07c,Op____,Op____,Op____ ;@ c678
  .long Opc080,Opc080,Opc080,Opc080,Opc080,Opc080,Opc080,Opc080 ;@ c680
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ c688
  .long Opc090,Opc090,Opc090,Opc090,Opc090,Opc090,Opc090,Opc090 ;@ c690
  .long Opc098,Opc098,Opc098,Opc098,Opc098,Opc098,Opc098,Opc098 ;@ c698
  .long Opc0a0,Opc0a0,Opc0a0,Opc0a0,Opc0a0,Opc0a0,Opc0a0,Opc0a0 ;@ c6a0
  .long Opc0a8,Opc0a8,Opc0a8,Opc0a8,Opc0a8,Opc0a8,Opc0a8,Opc0a8 ;@ c6a8
  .long Opc0b0,Opc0b0,Opc0b0,Opc0b0,Opc0b0,Opc0b0,Opc0b0,Opc0b0 ;@ c6b0
  .long Opc0b8,Opc0b9,Opc0ba,Opc0bb,Opc0bc,Op____,Op____,Op____ ;@ c6b8
  .long Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0 ;@ c6c0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ c6c8
  .long Opc0d0,Opc0d0,Opc0d0,Opc0d0,Opc0d0,Opc0d0,Opc0d0,Opc0d0 ;@ c6d0
  .long Opc0d8,Opc0d8,Opc0d8,Opc0d8,Opc0d8,Opc0d8,Opc0d8,Opc0d8 ;@ c6d8
  .long Opc0e0,Opc0e0,Opc0e0,Opc0e0,Opc0e0,Opc0e0,Opc0e0,Opc0e0 ;@ c6e0
  .long Opc0e8,Opc0e8,Opc0e8,Opc0e8,Opc0e8,Opc0e8,Opc0e8,Opc0e8 ;@ c6e8
  .long Opc0f0,Opc0f0,Opc0f0,Opc0f0,Opc0f0,Opc0f0,Opc0f0,Opc0f0 ;@ c6f0
  .long Opc0f8,Opc0f9,Opc0fa,Opc0fb,Opc0fc,Op____,Op____,Op____ ;@ c6f8
  .long Opc100,Opc100,Opc100,Opc100,Opc100,Opc100,Opc100,Opc100 ;@ c700
  .long Opc108,Opc108,Opc108,Opc108,Opc108,Opc108,Opc108,Opc10f ;@ c708
  .long Opc110,Opc110,Opc110,Opc110,Opc110,Opc110,Opc110,Opc110 ;@ c710
  .long Opc118,Opc118,Opc118,Opc118,Opc118,Opc118,Opc118,Opc11f ;@ c718
  .long Opc120,Opc120,Opc120,Opc120,Opc120,Opc120,Opc120,Opc127 ;@ c720
  .long Opc128,Opc128,Opc128,Opc128,Opc128,Opc128,Opc128,Opc128 ;@ c728
  .long Opc130,Opc130,Opc130,Opc130,Opc130,Opc130,Opc130,Opc130 ;@ c730
  .long Opc138,Opc139,Op____,Op____,Op____,Op____,Op____,Op____ ;@ c738
  .long Opc140,Opc140,Opc140,Opc140,Opc140,Opc140,Opc140,Opc140 ;@ c740
  .long Opc148,Opc148,Opc148,Opc148,Opc148,Opc148,Opc148,Opc148 ;@ c748
  .long Opc150,Opc150,Opc150,Opc150,Opc150,Opc150,Opc150,Opc150 ;@ c750
  .long Opc158,Opc158,Opc158,Opc158,Opc158,Opc158,Opc158,Opc158 ;@ c758
  .long Opc160,Opc160,Opc160,Opc160,Opc160,Opc160,Opc160,Opc160 ;@ c760
  .long Opc168,Opc168,Opc168,Opc168,Opc168,Opc168,Opc168,Opc168 ;@ c768
  .long Opc170,Opc170,Opc170,Opc170,Opc170,Opc170,Opc170,Opc170 ;@ c770
  .long Opc178,Opc179,Op____,Op____,Op____,Op____,Op____,Op____ ;@ c778
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ c780
  .long Opc188,Opc188,Opc188,Opc188,Opc188,Opc188,Opc188,Opc188 ;@ c788
  .long Opc190,Opc190,Opc190,Opc190,Opc190,Opc190,Opc190,Opc190 ;@ c790
  .long Opc198,Opc198,Opc198,Opc198,Opc198,Opc198,Opc198,Opc198 ;@ c798
  .long Opc1a0,Opc1a0,Opc1a0,Opc1a0,Opc1a0,Opc1a0,Opc1a0,Opc1a0 ;@ c7a0
  .long Opc1a8,Opc1a8,Opc1a8,Opc1a8,Opc1a8,Opc1a8,Opc1a8,Opc1a8 ;@ c7a8
  .long Opc1b0,Opc1b0,Opc1b0,Opc1b0,Opc1b0,Opc1b0,Opc1b0,Opc1b0 ;@ c7b0
  .long Opc1b8,Opc1b9,Op____,Op____,Op____,Op____,Op____,Op____ ;@ c7b8
  .long Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0 ;@ c7c0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ c7c8
  .long Opc1d0,Opc1d0,Opc1d0,Opc1d0,Opc1d0,Opc1d0,Opc1d0,Opc1d0 ;@ c7d0
  .long Opc1d8,Opc1d8,Opc1d8,Opc1d8,Opc1d8,Opc1d8,Opc1d8,Opc1d8 ;@ c7d8
  .long Opc1e0,Opc1e0,Opc1e0,Opc1e0,Opc1e0,Opc1e0,Opc1e0,Opc1e0 ;@ c7e0
  .long Opc1e8,Opc1e8,Opc1e8,Opc1e8,Opc1e8,Opc1e8,Opc1e8,Opc1e8 ;@ c7e8
  .long Opc1f0,Opc1f0,Opc1f0,Opc1f0,Opc1f0,Opc1f0,Opc1f0,Opc1f0 ;@ c7f0
  .long Opc1f8,Opc1f9,Opc1fa,Opc1fb,Opc1fc,Op____,Op____,Op____ ;@ c7f8
  .long Opc000,Opc000,Opc000,Opc000,Opc000,Opc000,Opc000,Opc000 ;@ c800
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ c808
  .long Opc010,Opc010,Opc010,Opc010,Opc010,Opc010,Opc010,Opc010 ;@ c810
  .long Opc018,Opc018,Opc018,Opc018,Opc018,Opc018,Opc018,Opc01f ;@ c818
  .long Opc020,Opc020,Opc020,Opc020,Opc020,Opc020,Opc020,Opc027 ;@ c820
  .long Opc028,Opc028,Opc028,Opc028,Opc028,Opc028,Opc028,Opc028 ;@ c828
  .long Opc030,Opc030,Opc030,Opc030,Opc030,Opc030,Opc030,Opc030 ;@ c830
  .long Opc038,Opc039,Opc03a,Opc03b,Opc03c,Op____,Op____,Op____ ;@ c838
  .long Opc040,Opc040,Opc040,Opc040,Opc040,Opc040,Opc040,Opc040 ;@ c840
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ c848
  .long Opc050,Opc050,Opc050,Opc050,Opc050,Opc050,Opc050,Opc050 ;@ c850
  .long Opc058,Opc058,Opc058,Opc058,Opc058,Opc058,Opc058,Opc058 ;@ c858
  .long Opc060,Opc060,Opc060,Opc060,Opc060,Opc060,Opc060,Opc060 ;@ c860
  .long Opc068,Opc068,Opc068,Opc068,Opc068,Opc068,Opc068,Opc068 ;@ c868
  .long Opc070,Opc070,Opc070,Opc070,Opc070,Opc070,Opc070,Opc070 ;@ c870
  .long Opc078,Opc079,Opc07a,Opc07b,Opc07c,Op____,Op____,Op____ ;@ c878
  .long Opc080,Opc080,Opc080,Opc080,Opc080,Opc080,Opc080,Opc080 ;@ c880
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ c888
  .long Opc090,Opc090,Opc090,Opc090,Opc090,Opc090,Opc090,Opc090 ;@ c890
  .long Opc098,Opc098,Opc098,Opc098,Opc098,Opc098,Opc098,Opc098 ;@ c898
  .long Opc0a0,Opc0a0,Opc0a0,Opc0a0,Opc0a0,Opc0a0,Opc0a0,Opc0a0 ;@ c8a0
  .long Opc0a8,Opc0a8,Opc0a8,Opc0a8,Opc0a8,Opc0a8,Opc0a8,Opc0a8 ;@ c8a8
  .long Opc0b0,Opc0b0,Opc0b0,Opc0b0,Opc0b0,Opc0b0,Opc0b0,Opc0b0 ;@ c8b0
  .long Opc0b8,Opc0b9,Opc0ba,Opc0bb,Opc0bc,Op____,Op____,Op____ ;@ c8b8
  .long Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0 ;@ c8c0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ c8c8
  .long Opc0d0,Opc0d0,Opc0d0,Opc0d0,Opc0d0,Opc0d0,Opc0d0,Opc0d0 ;@ c8d0
  .long Opc0d8,Opc0d8,Opc0d8,Opc0d8,Opc0d8,Opc0d8,Opc0d8,Opc0d8 ;@ c8d8
  .long Opc0e0,Opc0e0,Opc0e0,Opc0e0,Opc0e0,Opc0e0,Opc0e0,Opc0e0 ;@ c8e0
  .long Opc0e8,Opc0e8,Opc0e8,Opc0e8,Opc0e8,Opc0e8,Opc0e8,Opc0e8 ;@ c8e8
  .long Opc0f0,Opc0f0,Opc0f0,Opc0f0,Opc0f0,Opc0f0,Opc0f0,Opc0f0 ;@ c8f0
  .long Opc0f8,Opc0f9,Opc0fa,Opc0fb,Opc0fc,Op____,Op____,Op____ ;@ c8f8
  .long Opc100,Opc100,Opc100,Opc100,Opc100,Opc100,Opc100,Opc100 ;@ c900
  .long Opc108,Opc108,Opc108,Opc108,Opc108,Opc108,Opc108,Opc10f ;@ c908
  .long Opc110,Opc110,Opc110,Opc110,Opc110,Opc110,Opc110,Opc110 ;@ c910
  .long Opc118,Opc118,Opc118,Opc118,Opc118,Opc118,Opc118,Opc11f ;@ c918
  .long Opc120,Opc120,Opc120,Opc120,Opc120,Opc120,Opc120,Opc127 ;@ c920
  .long Opc128,Opc128,Opc128,Opc128,Opc128,Opc128,Opc128,Opc128 ;@ c928
  .long Opc130,Opc130,Opc130,Opc130,Opc130,Opc130,Opc130,Opc130 ;@ c930
  .long Opc138,Opc139,Op____,Op____,Op____,Op____,Op____,Op____ ;@ c938
  .long Opc140,Opc140,Opc140,Opc140,Opc140,Opc140,Opc140,Opc140 ;@ c940
  .long Opc148,Opc148,Opc148,Opc148,Opc148,Opc148,Opc148,Opc148 ;@ c948
  .long Opc150,Opc150,Opc150,Opc150,Opc150,Opc150,Opc150,Opc150 ;@ c950
  .long Opc158,Opc158,Opc158,Opc158,Opc158,Opc158,Opc158,Opc158 ;@ c958
  .long Opc160,Opc160,Opc160,Opc160,Opc160,Opc160,Opc160,Opc160 ;@ c960
  .long Opc168,Opc168,Opc168,Opc168,Opc168,Opc168,Opc168,Opc168 ;@ c968
  .long Opc170,Opc170,Opc170,Opc170,Opc170,Opc170,Opc170,Opc170 ;@ c970
  .long Opc178,Opc179,Op____,Op____,Op____,Op____,Op____,Op____ ;@ c978
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ c980
  .long Opc188,Opc188,Opc188,Opc188,Opc188,Opc188,Opc188,Opc188 ;@ c988
  .long Opc190,Opc190,Opc190,Opc190,Opc190,Opc190,Opc190,Opc190 ;@ c990
  .long Opc198,Opc198,Opc198,Opc198,Opc198,Opc198,Opc198,Opc198 ;@ c998
  .long Opc1a0,Opc1a0,Opc1a0,Opc1a0,Opc1a0,Opc1a0,Opc1a0,Opc1a0 ;@ c9a0
  .long Opc1a8,Opc1a8,Opc1a8,Opc1a8,Opc1a8,Opc1a8,Opc1a8,Opc1a8 ;@ c9a8
  .long Opc1b0,Opc1b0,Opc1b0,Opc1b0,Opc1b0,Opc1b0,Opc1b0,Opc1b0 ;@ c9b0
  .long Opc1b8,Opc1b9,Op____,Op____,Op____,Op____,Op____,Op____ ;@ c9b8
  .long Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0 ;@ c9c0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ c9c8
  .long Opc1d0,Opc1d0,Opc1d0,Opc1d0,Opc1d0,Opc1d0,Opc1d0,Opc1d0 ;@ c9d0
  .long Opc1d8,Opc1d8,Opc1d8,Opc1d8,Opc1d8,Opc1d8,Opc1d8,Opc1d8 ;@ c9d8
  .long Opc1e0,Opc1e0,Opc1e0,Opc1e0,Opc1e0,Opc1e0,Opc1e0,Opc1e0 ;@ c9e0
  .long Opc1e8,Opc1e8,Opc1e8,Opc1e8,Opc1e8,Opc1e8,Opc1e8,Opc1e8 ;@ c9e8
  .long Opc1f0,Opc1f0,Opc1f0,Opc1f0,Opc1f0,Opc1f0,Opc1f0,Opc1f0 ;@ c9f0
  .long Opc1f8,Opc1f9,Opc1fa,Opc1fb,Opc1fc,Op____,Op____,Op____ ;@ c9f8
  .long Opc000,Opc000,Opc000,Opc000,Opc000,Opc000,Opc000,Opc000 ;@ ca00
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ ca08
  .long Opc010,Opc010,Opc010,Opc010,Opc010,Opc010,Opc010,Opc010 ;@ ca10
  .long Opc018,Opc018,Opc018,Opc018,Opc018,Opc018,Opc018,Opc01f ;@ ca18
  .long Opc020,Opc020,Opc020,Opc020,Opc020,Opc020,Opc020,Opc027 ;@ ca20
  .long Opc028,Opc028,Opc028,Opc028,Opc028,Opc028,Opc028,Opc028 ;@ ca28
  .long Opc030,Opc030,Opc030,Opc030,Opc030,Opc030,Opc030,Opc030 ;@ ca30
  .long Opc038,Opc039,Opc03a,Opc03b,Opc03c,Op____,Op____,Op____ ;@ ca38
  .long Opc040,Opc040,Opc040,Opc040,Opc040,Opc040,Opc040,Opc040 ;@ ca40
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ ca48
  .long Opc050,Opc050,Opc050,Opc050,Opc050,Opc050,Opc050,Opc050 ;@ ca50
  .long Opc058,Opc058,Opc058,Opc058,Opc058,Opc058,Opc058,Opc058 ;@ ca58
  .long Opc060,Opc060,Opc060,Opc060,Opc060,Opc060,Opc060,Opc060 ;@ ca60
  .long Opc068,Opc068,Opc068,Opc068,Opc068,Opc068,Opc068,Opc068 ;@ ca68
  .long Opc070,Opc070,Opc070,Opc070,Opc070,Opc070,Opc070,Opc070 ;@ ca70
  .long Opc078,Opc079,Opc07a,Opc07b,Opc07c,Op____,Op____,Op____ ;@ ca78
  .long Opc080,Opc080,Opc080,Opc080,Opc080,Opc080,Opc080,Opc080 ;@ ca80
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ ca88
  .long Opc090,Opc090,Opc090,Opc090,Opc090,Opc090,Opc090,Opc090 ;@ ca90
  .long Opc098,Opc098,Opc098,Opc098,Opc098,Opc098,Opc098,Opc098 ;@ ca98
  .long Opc0a0,Opc0a0,Opc0a0,Opc0a0,Opc0a0,Opc0a0,Opc0a0,Opc0a0 ;@ caa0
  .long Opc0a8,Opc0a8,Opc0a8,Opc0a8,Opc0a8,Opc0a8,Opc0a8,Opc0a8 ;@ caa8
  .long Opc0b0,Opc0b0,Opc0b0,Opc0b0,Opc0b0,Opc0b0,Opc0b0,Opc0b0 ;@ cab0
  .long Opc0b8,Opc0b9,Opc0ba,Opc0bb,Opc0bc,Op____,Op____,Op____ ;@ cab8
  .long Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0 ;@ cac0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ cac8
  .long Opc0d0,Opc0d0,Opc0d0,Opc0d0,Opc0d0,Opc0d0,Opc0d0,Opc0d0 ;@ cad0
  .long Opc0d8,Opc0d8,Opc0d8,Opc0d8,Opc0d8,Opc0d8,Opc0d8,Opc0d8 ;@ cad8
  .long Opc0e0,Opc0e0,Opc0e0,Opc0e0,Opc0e0,Opc0e0,Opc0e0,Opc0e0 ;@ cae0
  .long Opc0e8,Opc0e8,Opc0e8,Opc0e8,Opc0e8,Opc0e8,Opc0e8,Opc0e8 ;@ cae8
  .long Opc0f0,Opc0f0,Opc0f0,Opc0f0,Opc0f0,Opc0f0,Opc0f0,Opc0f0 ;@ caf0
  .long Opc0f8,Opc0f9,Opc0fa,Opc0fb,Opc0fc,Op____,Op____,Op____ ;@ caf8
  .long Opc100,Opc100,Opc100,Opc100,Opc100,Opc100,Opc100,Opc100 ;@ cb00
  .long Opc108,Opc108,Opc108,Opc108,Opc108,Opc108,Opc108,Opc10f ;@ cb08
  .long Opc110,Opc110,Opc110,Opc110,Opc110,Opc110,Opc110,Opc110 ;@ cb10
  .long Opc118,Opc118,Opc118,Opc118,Opc118,Opc118,Opc118,Opc11f ;@ cb18
  .long Opc120,Opc120,Opc120,Opc120,Opc120,Opc120,Opc120,Opc127 ;@ cb20
  .long Opc128,Opc128,Opc128,Opc128,Opc128,Opc128,Opc128,Opc128 ;@ cb28
  .long Opc130,Opc130,Opc130,Opc130,Opc130,Opc130,Opc130,Opc130 ;@ cb30
  .long Opc138,Opc139,Op____,Op____,Op____,Op____,Op____,Op____ ;@ cb38
  .long Opc140,Opc140,Opc140,Opc140,Opc140,Opc140,Opc140,Opc140 ;@ cb40
  .long Opc148,Opc148,Opc148,Opc148,Opc148,Opc148,Opc148,Opc148 ;@ cb48
  .long Opc150,Opc150,Opc150,Opc150,Opc150,Opc150,Opc150,Opc150 ;@ cb50
  .long Opc158,Opc158,Opc158,Opc158,Opc158,Opc158,Opc158,Opc158 ;@ cb58
  .long Opc160,Opc160,Opc160,Opc160,Opc160,Opc160,Opc160,Opc160 ;@ cb60
  .long Opc168,Opc168,Opc168,Opc168,Opc168,Opc168,Opc168,Opc168 ;@ cb68
  .long Opc170,Opc170,Opc170,Opc170,Opc170,Opc170,Opc170,Opc170 ;@ cb70
  .long Opc178,Opc179,Op____,Op____,Op____,Op____,Op____,Op____ ;@ cb78
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ cb80
  .long Opc188,Opc188,Opc188,Opc188,Opc188,Opc188,Opc188,Opc188 ;@ cb88
  .long Opc190,Opc190,Opc190,Opc190,Opc190,Opc190,Opc190,Opc190 ;@ cb90
  .long Opc198,Opc198,Opc198,Opc198,Opc198,Opc198,Opc198,Opc198 ;@ cb98
  .long Opc1a0,Opc1a0,Opc1a0,Opc1a0,Opc1a0,Opc1a0,Opc1a0,Opc1a0 ;@ cba0
  .long Opc1a8,Opc1a8,Opc1a8,Opc1a8,Opc1a8,Opc1a8,Opc1a8,Opc1a8 ;@ cba8
  .long Opc1b0,Opc1b0,Opc1b0,Opc1b0,Opc1b0,Opc1b0,Opc1b0,Opc1b0 ;@ cbb0
  .long Opc1b8,Opc1b9,Op____,Op____,Op____,Op____,Op____,Op____ ;@ cbb8
  .long Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0 ;@ cbc0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ cbc8
  .long Opc1d0,Opc1d0,Opc1d0,Opc1d0,Opc1d0,Opc1d0,Opc1d0,Opc1d0 ;@ cbd0
  .long Opc1d8,Opc1d8,Opc1d8,Opc1d8,Opc1d8,Opc1d8,Opc1d8,Opc1d8 ;@ cbd8
  .long Opc1e0,Opc1e0,Opc1e0,Opc1e0,Opc1e0,Opc1e0,Opc1e0,Opc1e0 ;@ cbe0
  .long Opc1e8,Opc1e8,Opc1e8,Opc1e8,Opc1e8,Opc1e8,Opc1e8,Opc1e8 ;@ cbe8
  .long Opc1f0,Opc1f0,Opc1f0,Opc1f0,Opc1f0,Opc1f0,Opc1f0,Opc1f0 ;@ cbf0
  .long Opc1f8,Opc1f9,Opc1fa,Opc1fb,Opc1fc,Op____,Op____,Op____ ;@ cbf8
  .long Opc000,Opc000,Opc000,Opc000,Opc000,Opc000,Opc000,Opc000 ;@ cc00
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ cc08
  .long Opc010,Opc010,Opc010,Opc010,Opc010,Opc010,Opc010,Opc010 ;@ cc10
  .long Opc018,Opc018,Opc018,Opc018,Opc018,Opc018,Opc018,Opc01f ;@ cc18
  .long Opc020,Opc020,Opc020,Opc020,Opc020,Opc020,Opc020,Opc027 ;@ cc20
  .long Opc028,Opc028,Opc028,Opc028,Opc028,Opc028,Opc028,Opc028 ;@ cc28
  .long Opc030,Opc030,Opc030,Opc030,Opc030,Opc030,Opc030,Opc030 ;@ cc30
  .long Opc038,Opc039,Opc03a,Opc03b,Opc03c,Op____,Op____,Op____ ;@ cc38
  .long Opc040,Opc040,Opc040,Opc040,Opc040,Opc040,Opc040,Opc040 ;@ cc40
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ cc48
  .long Opc050,Opc050,Opc050,Opc050,Opc050,Opc050,Opc050,Opc050 ;@ cc50
  .long Opc058,Opc058,Opc058,Opc058,Opc058,Opc058,Opc058,Opc058 ;@ cc58
  .long Opc060,Opc060,Opc060,Opc060,Opc060,Opc060,Opc060,Opc060 ;@ cc60
  .long Opc068,Opc068,Opc068,Opc068,Opc068,Opc068,Opc068,Opc068 ;@ cc68
  .long Opc070,Opc070,Opc070,Opc070,Opc070,Opc070,Opc070,Opc070 ;@ cc70
  .long Opc078,Opc079,Opc07a,Opc07b,Opc07c,Op____,Op____,Op____ ;@ cc78
  .long Opc080,Opc080,Opc080,Opc080,Opc080,Opc080,Opc080,Opc080 ;@ cc80
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ cc88
  .long Opc090,Opc090,Opc090,Opc090,Opc090,Opc090,Opc090,Opc090 ;@ cc90
  .long Opc098,Opc098,Opc098,Opc098,Opc098,Opc098,Opc098,Opc098 ;@ cc98
  .long Opc0a0,Opc0a0,Opc0a0,Opc0a0,Opc0a0,Opc0a0,Opc0a0,Opc0a0 ;@ cca0
  .long Opc0a8,Opc0a8,Opc0a8,Opc0a8,Opc0a8,Opc0a8,Opc0a8,Opc0a8 ;@ cca8
  .long Opc0b0,Opc0b0,Opc0b0,Opc0b0,Opc0b0,Opc0b0,Opc0b0,Opc0b0 ;@ ccb0
  .long Opc0b8,Opc0b9,Opc0ba,Opc0bb,Opc0bc,Op____,Op____,Op____ ;@ ccb8
  .long Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0 ;@ ccc0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ ccc8
  .long Opc0d0,Opc0d0,Opc0d0,Opc0d0,Opc0d0,Opc0d0,Opc0d0,Opc0d0 ;@ ccd0
  .long Opc0d8,Opc0d8,Opc0d8,Opc0d8,Opc0d8,Opc0d8,Opc0d8,Opc0d8 ;@ ccd8
  .long Opc0e0,Opc0e0,Opc0e0,Opc0e0,Opc0e0,Opc0e0,Opc0e0,Opc0e0 ;@ cce0
  .long Opc0e8,Opc0e8,Opc0e8,Opc0e8,Opc0e8,Opc0e8,Opc0e8,Opc0e8 ;@ cce8
  .long Opc0f0,Opc0f0,Opc0f0,Opc0f0,Opc0f0,Opc0f0,Opc0f0,Opc0f0 ;@ ccf0
  .long Opc0f8,Opc0f9,Opc0fa,Opc0fb,Opc0fc,Op____,Op____,Op____ ;@ ccf8
  .long Opc100,Opc100,Opc100,Opc100,Opc100,Opc100,Opc100,Opc100 ;@ cd00
  .long Opc108,Opc108,Opc108,Opc108,Opc108,Opc108,Opc108,Opc10f ;@ cd08
  .long Opc110,Opc110,Opc110,Opc110,Opc110,Opc110,Opc110,Opc110 ;@ cd10
  .long Opc118,Opc118,Opc118,Opc118,Opc118,Opc118,Opc118,Opc11f ;@ cd18
  .long Opc120,Opc120,Opc120,Opc120,Opc120,Opc120,Opc120,Opc127 ;@ cd20
  .long Opc128,Opc128,Opc128,Opc128,Opc128,Opc128,Opc128,Opc128 ;@ cd28
  .long Opc130,Opc130,Opc130,Opc130,Opc130,Opc130,Opc130,Opc130 ;@ cd30
  .long Opc138,Opc139,Op____,Op____,Op____,Op____,Op____,Op____ ;@ cd38
  .long Opc140,Opc140,Opc140,Opc140,Opc140,Opc140,Opc140,Opc140 ;@ cd40
  .long Opc148,Opc148,Opc148,Opc148,Opc148,Opc148,Opc148,Opc148 ;@ cd48
  .long Opc150,Opc150,Opc150,Opc150,Opc150,Opc150,Opc150,Opc150 ;@ cd50
  .long Opc158,Opc158,Opc158,Opc158,Opc158,Opc158,Opc158,Opc158 ;@ cd58
  .long Opc160,Opc160,Opc160,Opc160,Opc160,Opc160,Opc160,Opc160 ;@ cd60
  .long Opc168,Opc168,Opc168,Opc168,Opc168,Opc168,Opc168,Opc168 ;@ cd68
  .long Opc170,Opc170,Opc170,Opc170,Opc170,Opc170,Opc170,Opc170 ;@ cd70
  .long Opc178,Opc179,Op____,Op____,Op____,Op____,Op____,Op____ ;@ cd78
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ cd80
  .long Opc188,Opc188,Opc188,Opc188,Opc188,Opc188,Opc188,Opc188 ;@ cd88
  .long Opc190,Opc190,Opc190,Opc190,Opc190,Opc190,Opc190,Opc190 ;@ cd90
  .long Opc198,Opc198,Opc198,Opc198,Opc198,Opc198,Opc198,Opc198 ;@ cd98
  .long Opc1a0,Opc1a0,Opc1a0,Opc1a0,Opc1a0,Opc1a0,Opc1a0,Opc1a0 ;@ cda0
  .long Opc1a8,Opc1a8,Opc1a8,Opc1a8,Opc1a8,Opc1a8,Opc1a8,Opc1a8 ;@ cda8
  .long Opc1b0,Opc1b0,Opc1b0,Opc1b0,Opc1b0,Opc1b0,Opc1b0,Opc1b0 ;@ cdb0
  .long Opc1b8,Opc1b9,Op____,Op____,Op____,Op____,Op____,Op____ ;@ cdb8
  .long Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0 ;@ cdc0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ cdc8
  .long Opc1d0,Opc1d0,Opc1d0,Opc1d0,Opc1d0,Opc1d0,Opc1d0,Opc1d0 ;@ cdd0
  .long Opc1d8,Opc1d8,Opc1d8,Opc1d8,Opc1d8,Opc1d8,Opc1d8,Opc1d8 ;@ cdd8
  .long Opc1e0,Opc1e0,Opc1e0,Opc1e0,Opc1e0,Opc1e0,Opc1e0,Opc1e0 ;@ cde0
  .long Opc1e8,Opc1e8,Opc1e8,Opc1e8,Opc1e8,Opc1e8,Opc1e8,Opc1e8 ;@ cde8
  .long Opc1f0,Opc1f0,Opc1f0,Opc1f0,Opc1f0,Opc1f0,Opc1f0,Opc1f0 ;@ cdf0
  .long Opc1f8,Opc1f9,Opc1fa,Opc1fb,Opc1fc,Op____,Op____,Op____ ;@ cdf8
  .long Opc000,Opc000,Opc000,Opc000,Opc000,Opc000,Opc000,Opc000 ;@ ce00
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ ce08
  .long Opc010,Opc010,Opc010,Opc010,Opc010,Opc010,Opc010,Opc010 ;@ ce10
  .long Opc018,Opc018,Opc018,Opc018,Opc018,Opc018,Opc018,Opc01f ;@ ce18
  .long Opc020,Opc020,Opc020,Opc020,Opc020,Opc020,Opc020,Opc027 ;@ ce20
  .long Opc028,Opc028,Opc028,Opc028,Opc028,Opc028,Opc028,Opc028 ;@ ce28
  .long Opc030,Opc030,Opc030,Opc030,Opc030,Opc030,Opc030,Opc030 ;@ ce30
  .long Opc038,Opc039,Opc03a,Opc03b,Opc03c,Op____,Op____,Op____ ;@ ce38
  .long Opc040,Opc040,Opc040,Opc040,Opc040,Opc040,Opc040,Opc040 ;@ ce40
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ ce48
  .long Opc050,Opc050,Opc050,Opc050,Opc050,Opc050,Opc050,Opc050 ;@ ce50
  .long Opc058,Opc058,Opc058,Opc058,Opc058,Opc058,Opc058,Opc058 ;@ ce58
  .long Opc060,Opc060,Opc060,Opc060,Opc060,Opc060,Opc060,Opc060 ;@ ce60
  .long Opc068,Opc068,Opc068,Opc068,Opc068,Opc068,Opc068,Opc068 ;@ ce68
  .long Opc070,Opc070,Opc070,Opc070,Opc070,Opc070,Opc070,Opc070 ;@ ce70
  .long Opc078,Opc079,Opc07a,Opc07b,Opc07c,Op____,Op____,Op____ ;@ ce78
  .long Opc080,Opc080,Opc080,Opc080,Opc080,Opc080,Opc080,Opc080 ;@ ce80
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ ce88
  .long Opc090,Opc090,Opc090,Opc090,Opc090,Opc090,Opc090,Opc090 ;@ ce90
  .long Opc098,Opc098,Opc098,Opc098,Opc098,Opc098,Opc098,Opc098 ;@ ce98
  .long Opc0a0,Opc0a0,Opc0a0,Opc0a0,Opc0a0,Opc0a0,Opc0a0,Opc0a0 ;@ cea0
  .long Opc0a8,Opc0a8,Opc0a8,Opc0a8,Opc0a8,Opc0a8,Opc0a8,Opc0a8 ;@ cea8
  .long Opc0b0,Opc0b0,Opc0b0,Opc0b0,Opc0b0,Opc0b0,Opc0b0,Opc0b0 ;@ ceb0
  .long Opc0b8,Opc0b9,Opc0ba,Opc0bb,Opc0bc,Op____,Op____,Op____ ;@ ceb8
  .long Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0,Opc0c0 ;@ cec0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ cec8
  .long Opc0d0,Opc0d0,Opc0d0,Opc0d0,Opc0d0,Opc0d0,Opc0d0,Opc0d0 ;@ ced0
  .long Opc0d8,Opc0d8,Opc0d8,Opc0d8,Opc0d8,Opc0d8,Opc0d8,Opc0d8 ;@ ced8
  .long Opc0e0,Opc0e0,Opc0e0,Opc0e0,Opc0e0,Opc0e0,Opc0e0,Opc0e0 ;@ cee0
  .long Opc0e8,Opc0e8,Opc0e8,Opc0e8,Opc0e8,Opc0e8,Opc0e8,Opc0e8 ;@ cee8
  .long Opc0f0,Opc0f0,Opc0f0,Opc0f0,Opc0f0,Opc0f0,Opc0f0,Opc0f0 ;@ cef0
  .long Opc0f8,Opc0f9,Opc0fa,Opc0fb,Opc0fc,Op____,Op____,Op____ ;@ cef8
  .long Opc100,Opc100,Opc100,Opc100,Opc100,Opc100,Opc100,Opc100 ;@ cf00
  .long Opcf08,Opcf08,Opcf08,Opcf08,Opcf08,Opcf08,Opcf08,Opcf0f ;@ cf08
  .long Opc110,Opc110,Opc110,Opc110,Opc110,Opc110,Opc110,Opc110 ;@ cf10
  .long Opc118,Opc118,Opc118,Opc118,Opc118,Opc118,Opc118,Opc11f ;@ cf18
  .long Opc120,Opc120,Opc120,Opc120,Opc120,Opc120,Opc120,Opc127 ;@ cf20
  .long Opc128,Opc128,Opc128,Opc128,Opc128,Opc128,Opc128,Opc128 ;@ cf28
  .long Opc130,Opc130,Opc130,Opc130,Opc130,Opc130,Opc130,Opc130 ;@ cf30
  .long Opc138,Opc139,Op____,Op____,Op____,Op____,Op____,Op____ ;@ cf38
  .long Opc140,Opc140,Opc140,Opc140,Opc140,Opc140,Opc140,Opc140 ;@ cf40
  .long Opc148,Opc148,Opc148,Opc148,Opc148,Opc148,Opc148,Opc148 ;@ cf48
  .long Opc150,Opc150,Opc150,Opc150,Opc150,Opc150,Opc150,Opc150 ;@ cf50
  .long Opc158,Opc158,Opc158,Opc158,Opc158,Opc158,Opc158,Opc158 ;@ cf58
  .long Opc160,Opc160,Opc160,Opc160,Opc160,Opc160,Opc160,Opc160 ;@ cf60
  .long Opc168,Opc168,Opc168,Opc168,Opc168,Opc168,Opc168,Opc168 ;@ cf68
  .long Opc170,Opc170,Opc170,Opc170,Opc170,Opc170,Opc170,Opc170 ;@ cf70
  .long Opc178,Opc179,Op____,Op____,Op____,Op____,Op____,Op____ ;@ cf78
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ cf80
  .long Opc188,Opc188,Opc188,Opc188,Opc188,Opc188,Opc188,Opc188 ;@ cf88
  .long Opc190,Opc190,Opc190,Opc190,Opc190,Opc190,Opc190,Opc190 ;@ cf90
  .long Opc198,Opc198,Opc198,Opc198,Opc198,Opc198,Opc198,Opc198 ;@ cf98
  .long Opc1a0,Opc1a0,Opc1a0,Opc1a0,Opc1a0,Opc1a0,Opc1a0,Opc1a0 ;@ cfa0
  .long Opc1a8,Opc1a8,Opc1a8,Opc1a8,Opc1a8,Opc1a8,Opc1a8,Opc1a8 ;@ cfa8
  .long Opc1b0,Opc1b0,Opc1b0,Opc1b0,Opc1b0,Opc1b0,Opc1b0,Opc1b0 ;@ cfb0
  .long Opc1b8,Opc1b9,Op____,Op____,Op____,Op____,Op____,Op____ ;@ cfb8
  .long Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0,Opc1c0 ;@ cfc0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ cfc8
  .long Opc1d0,Opc1d0,Opc1d0,Opc1d0,Opc1d0,Opc1d0,Opc1d0,Opc1d0 ;@ cfd0
  .long Opc1d8,Opc1d8,Opc1d8,Opc1d8,Opc1d8,Opc1d8,Opc1d8,Opc1d8 ;@ cfd8
  .long Opc1e0,Opc1e0,Opc1e0,Opc1e0,Opc1e0,Opc1e0,Opc1e0,Opc1e0 ;@ cfe0
  .long Opc1e8,Opc1e8,Opc1e8,Opc1e8,Opc1e8,Opc1e8,Opc1e8,Opc1e8 ;@ cfe8
  .long Opc1f0,Opc1f0,Opc1f0,Opc1f0,Opc1f0,Opc1f0,Opc1f0,Opc1f0 ;@ cff0
  .long Opc1f8,Opc1f9,Opc1fa,Opc1fb,Opc1fc,Op____,Op____,Op____ ;@ cff8
  .long Opd000,Opd000,Opd000,Opd000,Opd000,Opd000,Opd000,Opd000 ;@ d000
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ d008
  .long Opd010,Opd010,Opd010,Opd010,Opd010,Opd010,Opd010,Opd010 ;@ d010
  .long Opd018,Opd018,Opd018,Opd018,Opd018,Opd018,Opd018,Opd01f ;@ d018
  .long Opd020,Opd020,Opd020,Opd020,Opd020,Opd020,Opd020,Opd027 ;@ d020
  .long Opd028,Opd028,Opd028,Opd028,Opd028,Opd028,Opd028,Opd028 ;@ d028
  .long Opd030,Opd030,Opd030,Opd030,Opd030,Opd030,Opd030,Opd030 ;@ d030
  .long Opd038,Opd039,Opd03a,Opd03b,Opd03c,Op____,Op____,Op____ ;@ d038
  .long Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040 ;@ d040
  .long Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040 ;@ d048
  .long Opd050,Opd050,Opd050,Opd050,Opd050,Opd050,Opd050,Opd050 ;@ d050
  .long Opd058,Opd058,Opd058,Opd058,Opd058,Opd058,Opd058,Opd058 ;@ d058
  .long Opd060,Opd060,Opd060,Opd060,Opd060,Opd060,Opd060,Opd060 ;@ d060
  .long Opd068,Opd068,Opd068,Opd068,Opd068,Opd068,Opd068,Opd068 ;@ d068
  .long Opd070,Opd070,Opd070,Opd070,Opd070,Opd070,Opd070,Opd070 ;@ d070
  .long Opd078,Opd079,Opd07a,Opd07b,Opd07c,Op____,Op____,Op____ ;@ d078
  .long Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080 ;@ d080
  .long Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080 ;@ d088
  .long Opd090,Opd090,Opd090,Opd090,Opd090,Opd090,Opd090,Opd090 ;@ d090
  .long Opd098,Opd098,Opd098,Opd098,Opd098,Opd098,Opd098,Opd098 ;@ d098
  .long Opd0a0,Opd0a0,Opd0a0,Opd0a0,Opd0a0,Opd0a0,Opd0a0,Opd0a0 ;@ d0a0
  .long Opd0a8,Opd0a8,Opd0a8,Opd0a8,Opd0a8,Opd0a8,Opd0a8,Opd0a8 ;@ d0a8
  .long Opd0b0,Opd0b0,Opd0b0,Opd0b0,Opd0b0,Opd0b0,Opd0b0,Opd0b0 ;@ d0b0
  .long Opd0b8,Opd0b9,Opd0ba,Opd0bb,Opd0bc,Op____,Op____,Op____ ;@ d0b8
  .long Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0 ;@ d0c0
  .long Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0 ;@ d0c8
  .long Opd0d0,Opd0d0,Opd0d0,Opd0d0,Opd0d0,Opd0d0,Opd0d0,Opd0d0 ;@ d0d0
  .long Opd0d8,Opd0d8,Opd0d8,Opd0d8,Opd0d8,Opd0d8,Opd0d8,Opd0d8 ;@ d0d8
  .long Opd0e0,Opd0e0,Opd0e0,Opd0e0,Opd0e0,Opd0e0,Opd0e0,Opd0e0 ;@ d0e0
  .long Opd0e8,Opd0e8,Opd0e8,Opd0e8,Opd0e8,Opd0e8,Opd0e8,Opd0e8 ;@ d0e8
  .long Opd0f0,Opd0f0,Opd0f0,Opd0f0,Opd0f0,Opd0f0,Opd0f0,Opd0f0 ;@ d0f0
  .long Opd0f8,Opd0f9,Opd0fa,Opd0fb,Opd0fc,Op____,Op____,Op____ ;@ d0f8
  .long Opd100,Opd100,Opd100,Opd100,Opd100,Opd100,Opd100,Opd100 ;@ d100
  .long Opd108,Opd108,Opd108,Opd108,Opd108,Opd108,Opd108,Opd10f ;@ d108
  .long Opd110,Opd110,Opd110,Opd110,Opd110,Opd110,Opd110,Opd110 ;@ d110
  .long Opd118,Opd118,Opd118,Opd118,Opd118,Opd118,Opd118,Opd11f ;@ d118
  .long Opd120,Opd120,Opd120,Opd120,Opd120,Opd120,Opd120,Opd127 ;@ d120
  .long Opd128,Opd128,Opd128,Opd128,Opd128,Opd128,Opd128,Opd128 ;@ d128
  .long Opd130,Opd130,Opd130,Opd130,Opd130,Opd130,Opd130,Opd130 ;@ d130
  .long Opd138,Opd139,Op____,Op____,Op____,Op____,Op____,Op____ ;@ d138
  .long Opd140,Opd140,Opd140,Opd140,Opd140,Opd140,Opd140,Opd140 ;@ d140
  .long Opd148,Opd148,Opd148,Opd148,Opd148,Opd148,Opd148,Opd148 ;@ d148
  .long Opd150,Opd150,Opd150,Opd150,Opd150,Opd150,Opd150,Opd150 ;@ d150
  .long Opd158,Opd158,Opd158,Opd158,Opd158,Opd158,Opd158,Opd158 ;@ d158
  .long Opd160,Opd160,Opd160,Opd160,Opd160,Opd160,Opd160,Opd160 ;@ d160
  .long Opd168,Opd168,Opd168,Opd168,Opd168,Opd168,Opd168,Opd168 ;@ d168
  .long Opd170,Opd170,Opd170,Opd170,Opd170,Opd170,Opd170,Opd170 ;@ d170
  .long Opd178,Opd179,Op____,Op____,Op____,Op____,Op____,Op____ ;@ d178
  .long Opd180,Opd180,Opd180,Opd180,Opd180,Opd180,Opd180,Opd180 ;@ d180
  .long Opd188,Opd188,Opd188,Opd188,Opd188,Opd188,Opd188,Opd188 ;@ d188
  .long Opd190,Opd190,Opd190,Opd190,Opd190,Opd190,Opd190,Opd190 ;@ d190
  .long Opd198,Opd198,Opd198,Opd198,Opd198,Opd198,Opd198,Opd198 ;@ d198
  .long Opd1a0,Opd1a0,Opd1a0,Opd1a0,Opd1a0,Opd1a0,Opd1a0,Opd1a0 ;@ d1a0
  .long Opd1a8,Opd1a8,Opd1a8,Opd1a8,Opd1a8,Opd1a8,Opd1a8,Opd1a8 ;@ d1a8
  .long Opd1b0,Opd1b0,Opd1b0,Opd1b0,Opd1b0,Opd1b0,Opd1b0,Opd1b0 ;@ d1b0
  .long Opd1b8,Opd1b9,Op____,Op____,Op____,Op____,Op____,Op____ ;@ d1b8
  .long Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0 ;@ d1c0
  .long Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0 ;@ d1c8
  .long Opd1d0,Opd1d0,Opd1d0,Opd1d0,Opd1d0,Opd1d0,Opd1d0,Opd1d0 ;@ d1d0
  .long Opd1d8,Opd1d8,Opd1d8,Opd1d8,Opd1d8,Opd1d8,Opd1d8,Opd1d8 ;@ d1d8
  .long Opd1e0,Opd1e0,Opd1e0,Opd1e0,Opd1e0,Opd1e0,Opd1e0,Opd1e0 ;@ d1e0
  .long Opd1e8,Opd1e8,Opd1e8,Opd1e8,Opd1e8,Opd1e8,Opd1e8,Opd1e8 ;@ d1e8
  .long Opd1f0,Opd1f0,Opd1f0,Opd1f0,Opd1f0,Opd1f0,Opd1f0,Opd1f0 ;@ d1f0
  .long Opd1f8,Opd1f9,Opd1fa,Opd1fb,Opd1fc,Op____,Op____,Op____ ;@ d1f8
  .long Opd000,Opd000,Opd000,Opd000,Opd000,Opd000,Opd000,Opd000 ;@ d200
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ d208
  .long Opd010,Opd010,Opd010,Opd010,Opd010,Opd010,Opd010,Opd010 ;@ d210
  .long Opd018,Opd018,Opd018,Opd018,Opd018,Opd018,Opd018,Opd01f ;@ d218
  .long Opd020,Opd020,Opd020,Opd020,Opd020,Opd020,Opd020,Opd027 ;@ d220
  .long Opd028,Opd028,Opd028,Opd028,Opd028,Opd028,Opd028,Opd028 ;@ d228
  .long Opd030,Opd030,Opd030,Opd030,Opd030,Opd030,Opd030,Opd030 ;@ d230
  .long Opd038,Opd039,Opd03a,Opd03b,Opd03c,Op____,Op____,Op____ ;@ d238
  .long Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040 ;@ d240
  .long Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040 ;@ d248
  .long Opd050,Opd050,Opd050,Opd050,Opd050,Opd050,Opd050,Opd050 ;@ d250
  .long Opd058,Opd058,Opd058,Opd058,Opd058,Opd058,Opd058,Opd058 ;@ d258
  .long Opd060,Opd060,Opd060,Opd060,Opd060,Opd060,Opd060,Opd060 ;@ d260
  .long Opd068,Opd068,Opd068,Opd068,Opd068,Opd068,Opd068,Opd068 ;@ d268
  .long Opd070,Opd070,Opd070,Opd070,Opd070,Opd070,Opd070,Opd070 ;@ d270
  .long Opd078,Opd079,Opd07a,Opd07b,Opd07c,Op____,Op____,Op____ ;@ d278
  .long Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080 ;@ d280
  .long Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080 ;@ d288
  .long Opd090,Opd090,Opd090,Opd090,Opd090,Opd090,Opd090,Opd090 ;@ d290
  .long Opd098,Opd098,Opd098,Opd098,Opd098,Opd098,Opd098,Opd098 ;@ d298
  .long Opd0a0,Opd0a0,Opd0a0,Opd0a0,Opd0a0,Opd0a0,Opd0a0,Opd0a0 ;@ d2a0
  .long Opd0a8,Opd0a8,Opd0a8,Opd0a8,Opd0a8,Opd0a8,Opd0a8,Opd0a8 ;@ d2a8
  .long Opd0b0,Opd0b0,Opd0b0,Opd0b0,Opd0b0,Opd0b0,Opd0b0,Opd0b0 ;@ d2b0
  .long Opd0b8,Opd0b9,Opd0ba,Opd0bb,Opd0bc,Op____,Op____,Op____ ;@ d2b8
  .long Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0 ;@ d2c0
  .long Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0 ;@ d2c8
  .long Opd0d0,Opd0d0,Opd0d0,Opd0d0,Opd0d0,Opd0d0,Opd0d0,Opd0d0 ;@ d2d0
  .long Opd0d8,Opd0d8,Opd0d8,Opd0d8,Opd0d8,Opd0d8,Opd0d8,Opd0d8 ;@ d2d8
  .long Opd0e0,Opd0e0,Opd0e0,Opd0e0,Opd0e0,Opd0e0,Opd0e0,Opd0e0 ;@ d2e0
  .long Opd0e8,Opd0e8,Opd0e8,Opd0e8,Opd0e8,Opd0e8,Opd0e8,Opd0e8 ;@ d2e8
  .long Opd0f0,Opd0f0,Opd0f0,Opd0f0,Opd0f0,Opd0f0,Opd0f0,Opd0f0 ;@ d2f0
  .long Opd0f8,Opd0f9,Opd0fa,Opd0fb,Opd0fc,Op____,Op____,Op____ ;@ d2f8
  .long Opd100,Opd100,Opd100,Opd100,Opd100,Opd100,Opd100,Opd100 ;@ d300
  .long Opd108,Opd108,Opd108,Opd108,Opd108,Opd108,Opd108,Opd10f ;@ d308
  .long Opd110,Opd110,Opd110,Opd110,Opd110,Opd110,Opd110,Opd110 ;@ d310
  .long Opd118,Opd118,Opd118,Opd118,Opd118,Opd118,Opd118,Opd11f ;@ d318
  .long Opd120,Opd120,Opd120,Opd120,Opd120,Opd120,Opd120,Opd127 ;@ d320
  .long Opd128,Opd128,Opd128,Opd128,Opd128,Opd128,Opd128,Opd128 ;@ d328
  .long Opd130,Opd130,Opd130,Opd130,Opd130,Opd130,Opd130,Opd130 ;@ d330
  .long Opd138,Opd139,Op____,Op____,Op____,Op____,Op____,Op____ ;@ d338
  .long Opd140,Opd140,Opd140,Opd140,Opd140,Opd140,Opd140,Opd140 ;@ d340
  .long Opd148,Opd148,Opd148,Opd148,Opd148,Opd148,Opd148,Opd148 ;@ d348
  .long Opd150,Opd150,Opd150,Opd150,Opd150,Opd150,Opd150,Opd150 ;@ d350
  .long Opd158,Opd158,Opd158,Opd158,Opd158,Opd158,Opd158,Opd158 ;@ d358
  .long Opd160,Opd160,Opd160,Opd160,Opd160,Opd160,Opd160,Opd160 ;@ d360
  .long Opd168,Opd168,Opd168,Opd168,Opd168,Opd168,Opd168,Opd168 ;@ d368
  .long Opd170,Opd170,Opd170,Opd170,Opd170,Opd170,Opd170,Opd170 ;@ d370
  .long Opd178,Opd179,Op____,Op____,Op____,Op____,Op____,Op____ ;@ d378
  .long Opd180,Opd180,Opd180,Opd180,Opd180,Opd180,Opd180,Opd180 ;@ d380
  .long Opd188,Opd188,Opd188,Opd188,Opd188,Opd188,Opd188,Opd188 ;@ d388
  .long Opd190,Opd190,Opd190,Opd190,Opd190,Opd190,Opd190,Opd190 ;@ d390
  .long Opd198,Opd198,Opd198,Opd198,Opd198,Opd198,Opd198,Opd198 ;@ d398
  .long Opd1a0,Opd1a0,Opd1a0,Opd1a0,Opd1a0,Opd1a0,Opd1a0,Opd1a0 ;@ d3a0
  .long Opd1a8,Opd1a8,Opd1a8,Opd1a8,Opd1a8,Opd1a8,Opd1a8,Opd1a8 ;@ d3a8
  .long Opd1b0,Opd1b0,Opd1b0,Opd1b0,Opd1b0,Opd1b0,Opd1b0,Opd1b0 ;@ d3b0
  .long Opd1b8,Opd1b9,Op____,Op____,Op____,Op____,Op____,Op____ ;@ d3b8
  .long Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0 ;@ d3c0
  .long Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0 ;@ d3c8
  .long Opd1d0,Opd1d0,Opd1d0,Opd1d0,Opd1d0,Opd1d0,Opd1d0,Opd1d0 ;@ d3d0
  .long Opd1d8,Opd1d8,Opd1d8,Opd1d8,Opd1d8,Opd1d8,Opd1d8,Opd1d8 ;@ d3d8
  .long Opd1e0,Opd1e0,Opd1e0,Opd1e0,Opd1e0,Opd1e0,Opd1e0,Opd1e0 ;@ d3e0
  .long Opd1e8,Opd1e8,Opd1e8,Opd1e8,Opd1e8,Opd1e8,Opd1e8,Opd1e8 ;@ d3e8
  .long Opd1f0,Opd1f0,Opd1f0,Opd1f0,Opd1f0,Opd1f0,Opd1f0,Opd1f0 ;@ d3f0
  .long Opd1f8,Opd1f9,Opd1fa,Opd1fb,Opd1fc,Op____,Op____,Op____ ;@ d3f8
  .long Opd000,Opd000,Opd000,Opd000,Opd000,Opd000,Opd000,Opd000 ;@ d400
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ d408
  .long Opd010,Opd010,Opd010,Opd010,Opd010,Opd010,Opd010,Opd010 ;@ d410
  .long Opd018,Opd018,Opd018,Opd018,Opd018,Opd018,Opd018,Opd01f ;@ d418
  .long Opd020,Opd020,Opd020,Opd020,Opd020,Opd020,Opd020,Opd027 ;@ d420
  .long Opd028,Opd028,Opd028,Opd028,Opd028,Opd028,Opd028,Opd028 ;@ d428
  .long Opd030,Opd030,Opd030,Opd030,Opd030,Opd030,Opd030,Opd030 ;@ d430
  .long Opd038,Opd039,Opd03a,Opd03b,Opd03c,Op____,Op____,Op____ ;@ d438
  .long Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040 ;@ d440
  .long Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040 ;@ d448
  .long Opd050,Opd050,Opd050,Opd050,Opd050,Opd050,Opd050,Opd050 ;@ d450
  .long Opd058,Opd058,Opd058,Opd058,Opd058,Opd058,Opd058,Opd058 ;@ d458
  .long Opd060,Opd060,Opd060,Opd060,Opd060,Opd060,Opd060,Opd060 ;@ d460
  .long Opd068,Opd068,Opd068,Opd068,Opd068,Opd068,Opd068,Opd068 ;@ d468
  .long Opd070,Opd070,Opd070,Opd070,Opd070,Opd070,Opd070,Opd070 ;@ d470
  .long Opd078,Opd079,Opd07a,Opd07b,Opd07c,Op____,Op____,Op____ ;@ d478
  .long Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080 ;@ d480
  .long Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080 ;@ d488
  .long Opd090,Opd090,Opd090,Opd090,Opd090,Opd090,Opd090,Opd090 ;@ d490
  .long Opd098,Opd098,Opd098,Opd098,Opd098,Opd098,Opd098,Opd098 ;@ d498
  .long Opd0a0,Opd0a0,Opd0a0,Opd0a0,Opd0a0,Opd0a0,Opd0a0,Opd0a0 ;@ d4a0
  .long Opd0a8,Opd0a8,Opd0a8,Opd0a8,Opd0a8,Opd0a8,Opd0a8,Opd0a8 ;@ d4a8
  .long Opd0b0,Opd0b0,Opd0b0,Opd0b0,Opd0b0,Opd0b0,Opd0b0,Opd0b0 ;@ d4b0
  .long Opd0b8,Opd0b9,Opd0ba,Opd0bb,Opd0bc,Op____,Op____,Op____ ;@ d4b8
  .long Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0 ;@ d4c0
  .long Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0 ;@ d4c8
  .long Opd0d0,Opd0d0,Opd0d0,Opd0d0,Opd0d0,Opd0d0,Opd0d0,Opd0d0 ;@ d4d0
  .long Opd0d8,Opd0d8,Opd0d8,Opd0d8,Opd0d8,Opd0d8,Opd0d8,Opd0d8 ;@ d4d8
  .long Opd0e0,Opd0e0,Opd0e0,Opd0e0,Opd0e0,Opd0e0,Opd0e0,Opd0e0 ;@ d4e0
  .long Opd0e8,Opd0e8,Opd0e8,Opd0e8,Opd0e8,Opd0e8,Opd0e8,Opd0e8 ;@ d4e8
  .long Opd0f0,Opd0f0,Opd0f0,Opd0f0,Opd0f0,Opd0f0,Opd0f0,Opd0f0 ;@ d4f0
  .long Opd0f8,Opd0f9,Opd0fa,Opd0fb,Opd0fc,Op____,Op____,Op____ ;@ d4f8
  .long Opd100,Opd100,Opd100,Opd100,Opd100,Opd100,Opd100,Opd100 ;@ d500
  .long Opd108,Opd108,Opd108,Opd108,Opd108,Opd108,Opd108,Opd10f ;@ d508
  .long Opd110,Opd110,Opd110,Opd110,Opd110,Opd110,Opd110,Opd110 ;@ d510
  .long Opd118,Opd118,Opd118,Opd118,Opd118,Opd118,Opd118,Opd11f ;@ d518
  .long Opd120,Opd120,Opd120,Opd120,Opd120,Opd120,Opd120,Opd127 ;@ d520
  .long Opd128,Opd128,Opd128,Opd128,Opd128,Opd128,Opd128,Opd128 ;@ d528
  .long Opd130,Opd130,Opd130,Opd130,Opd130,Opd130,Opd130,Opd130 ;@ d530
  .long Opd138,Opd139,Op____,Op____,Op____,Op____,Op____,Op____ ;@ d538
  .long Opd140,Opd140,Opd140,Opd140,Opd140,Opd140,Opd140,Opd140 ;@ d540
  .long Opd148,Opd148,Opd148,Opd148,Opd148,Opd148,Opd148,Opd148 ;@ d548
  .long Opd150,Opd150,Opd150,Opd150,Opd150,Opd150,Opd150,Opd150 ;@ d550
  .long Opd158,Opd158,Opd158,Opd158,Opd158,Opd158,Opd158,Opd158 ;@ d558
  .long Opd160,Opd160,Opd160,Opd160,Opd160,Opd160,Opd160,Opd160 ;@ d560
  .long Opd168,Opd168,Opd168,Opd168,Opd168,Opd168,Opd168,Opd168 ;@ d568
  .long Opd170,Opd170,Opd170,Opd170,Opd170,Opd170,Opd170,Opd170 ;@ d570
  .long Opd178,Opd179,Op____,Op____,Op____,Op____,Op____,Op____ ;@ d578
  .long Opd180,Opd180,Opd180,Opd180,Opd180,Opd180,Opd180,Opd180 ;@ d580
  .long Opd188,Opd188,Opd188,Opd188,Opd188,Opd188,Opd188,Opd188 ;@ d588
  .long Opd190,Opd190,Opd190,Opd190,Opd190,Opd190,Opd190,Opd190 ;@ d590
  .long Opd198,Opd198,Opd198,Opd198,Opd198,Opd198,Opd198,Opd198 ;@ d598
  .long Opd1a0,Opd1a0,Opd1a0,Opd1a0,Opd1a0,Opd1a0,Opd1a0,Opd1a0 ;@ d5a0
  .long Opd1a8,Opd1a8,Opd1a8,Opd1a8,Opd1a8,Opd1a8,Opd1a8,Opd1a8 ;@ d5a8
  .long Opd1b0,Opd1b0,Opd1b0,Opd1b0,Opd1b0,Opd1b0,Opd1b0,Opd1b0 ;@ d5b0
  .long Opd1b8,Opd1b9,Op____,Op____,Op____,Op____,Op____,Op____ ;@ d5b8
  .long Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0 ;@ d5c0
  .long Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0 ;@ d5c8
  .long Opd1d0,Opd1d0,Opd1d0,Opd1d0,Opd1d0,Opd1d0,Opd1d0,Opd1d0 ;@ d5d0
  .long Opd1d8,Opd1d8,Opd1d8,Opd1d8,Opd1d8,Opd1d8,Opd1d8,Opd1d8 ;@ d5d8
  .long Opd1e0,Opd1e0,Opd1e0,Opd1e0,Opd1e0,Opd1e0,Opd1e0,Opd1e0 ;@ d5e0
  .long Opd1e8,Opd1e8,Opd1e8,Opd1e8,Opd1e8,Opd1e8,Opd1e8,Opd1e8 ;@ d5e8
  .long Opd1f0,Opd1f0,Opd1f0,Opd1f0,Opd1f0,Opd1f0,Opd1f0,Opd1f0 ;@ d5f0
  .long Opd1f8,Opd1f9,Opd1fa,Opd1fb,Opd1fc,Op____,Op____,Op____ ;@ d5f8
  .long Opd000,Opd000,Opd000,Opd000,Opd000,Opd000,Opd000,Opd000 ;@ d600
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ d608
  .long Opd010,Opd010,Opd010,Opd010,Opd010,Opd010,Opd010,Opd010 ;@ d610
  .long Opd018,Opd018,Opd018,Opd018,Opd018,Opd018,Opd018,Opd01f ;@ d618
  .long Opd020,Opd020,Opd020,Opd020,Opd020,Opd020,Opd020,Opd027 ;@ d620
  .long Opd028,Opd028,Opd028,Opd028,Opd028,Opd028,Opd028,Opd028 ;@ d628
  .long Opd030,Opd030,Opd030,Opd030,Opd030,Opd030,Opd030,Opd030 ;@ d630
  .long Opd038,Opd039,Opd03a,Opd03b,Opd03c,Op____,Op____,Op____ ;@ d638
  .long Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040 ;@ d640
  .long Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040 ;@ d648
  .long Opd050,Opd050,Opd050,Opd050,Opd050,Opd050,Opd050,Opd050 ;@ d650
  .long Opd058,Opd058,Opd058,Opd058,Opd058,Opd058,Opd058,Opd058 ;@ d658
  .long Opd060,Opd060,Opd060,Opd060,Opd060,Opd060,Opd060,Opd060 ;@ d660
  .long Opd068,Opd068,Opd068,Opd068,Opd068,Opd068,Opd068,Opd068 ;@ d668
  .long Opd070,Opd070,Opd070,Opd070,Opd070,Opd070,Opd070,Opd070 ;@ d670
  .long Opd078,Opd079,Opd07a,Opd07b,Opd07c,Op____,Op____,Op____ ;@ d678
  .long Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080 ;@ d680
  .long Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080 ;@ d688
  .long Opd090,Opd090,Opd090,Opd090,Opd090,Opd090,Opd090,Opd090 ;@ d690
  .long Opd098,Opd098,Opd098,Opd098,Opd098,Opd098,Opd098,Opd098 ;@ d698
  .long Opd0a0,Opd0a0,Opd0a0,Opd0a0,Opd0a0,Opd0a0,Opd0a0,Opd0a0 ;@ d6a0
  .long Opd0a8,Opd0a8,Opd0a8,Opd0a8,Opd0a8,Opd0a8,Opd0a8,Opd0a8 ;@ d6a8
  .long Opd0b0,Opd0b0,Opd0b0,Opd0b0,Opd0b0,Opd0b0,Opd0b0,Opd0b0 ;@ d6b0
  .long Opd0b8,Opd0b9,Opd0ba,Opd0bb,Opd0bc,Op____,Op____,Op____ ;@ d6b8
  .long Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0 ;@ d6c0
  .long Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0 ;@ d6c8
  .long Opd0d0,Opd0d0,Opd0d0,Opd0d0,Opd0d0,Opd0d0,Opd0d0,Opd0d0 ;@ d6d0
  .long Opd0d8,Opd0d8,Opd0d8,Opd0d8,Opd0d8,Opd0d8,Opd0d8,Opd0d8 ;@ d6d8
  .long Opd0e0,Opd0e0,Opd0e0,Opd0e0,Opd0e0,Opd0e0,Opd0e0,Opd0e0 ;@ d6e0
  .long Opd0e8,Opd0e8,Opd0e8,Opd0e8,Opd0e8,Opd0e8,Opd0e8,Opd0e8 ;@ d6e8
  .long Opd0f0,Opd0f0,Opd0f0,Opd0f0,Opd0f0,Opd0f0,Opd0f0,Opd0f0 ;@ d6f0
  .long Opd0f8,Opd0f9,Opd0fa,Opd0fb,Opd0fc,Op____,Op____,Op____ ;@ d6f8
  .long Opd100,Opd100,Opd100,Opd100,Opd100,Opd100,Opd100,Opd100 ;@ d700
  .long Opd108,Opd108,Opd108,Opd108,Opd108,Opd108,Opd108,Opd10f ;@ d708
  .long Opd110,Opd110,Opd110,Opd110,Opd110,Opd110,Opd110,Opd110 ;@ d710
  .long Opd118,Opd118,Opd118,Opd118,Opd118,Opd118,Opd118,Opd11f ;@ d718
  .long Opd120,Opd120,Opd120,Opd120,Opd120,Opd120,Opd120,Opd127 ;@ d720
  .long Opd128,Opd128,Opd128,Opd128,Opd128,Opd128,Opd128,Opd128 ;@ d728
  .long Opd130,Opd130,Opd130,Opd130,Opd130,Opd130,Opd130,Opd130 ;@ d730
  .long Opd138,Opd139,Op____,Op____,Op____,Op____,Op____,Op____ ;@ d738
  .long Opd140,Opd140,Opd140,Opd140,Opd140,Opd140,Opd140,Opd140 ;@ d740
  .long Opd148,Opd148,Opd148,Opd148,Opd148,Opd148,Opd148,Opd148 ;@ d748
  .long Opd150,Opd150,Opd150,Opd150,Opd150,Opd150,Opd150,Opd150 ;@ d750
  .long Opd158,Opd158,Opd158,Opd158,Opd158,Opd158,Opd158,Opd158 ;@ d758
  .long Opd160,Opd160,Opd160,Opd160,Opd160,Opd160,Opd160,Opd160 ;@ d760
  .long Opd168,Opd168,Opd168,Opd168,Opd168,Opd168,Opd168,Opd168 ;@ d768
  .long Opd170,Opd170,Opd170,Opd170,Opd170,Opd170,Opd170,Opd170 ;@ d770
  .long Opd178,Opd179,Op____,Op____,Op____,Op____,Op____,Op____ ;@ d778
  .long Opd180,Opd180,Opd180,Opd180,Opd180,Opd180,Opd180,Opd180 ;@ d780
  .long Opd188,Opd188,Opd188,Opd188,Opd188,Opd188,Opd188,Opd188 ;@ d788
  .long Opd190,Opd190,Opd190,Opd190,Opd190,Opd190,Opd190,Opd190 ;@ d790
  .long Opd198,Opd198,Opd198,Opd198,Opd198,Opd198,Opd198,Opd198 ;@ d798
  .long Opd1a0,Opd1a0,Opd1a0,Opd1a0,Opd1a0,Opd1a0,Opd1a0,Opd1a0 ;@ d7a0
  .long Opd1a8,Opd1a8,Opd1a8,Opd1a8,Opd1a8,Opd1a8,Opd1a8,Opd1a8 ;@ d7a8
  .long Opd1b0,Opd1b0,Opd1b0,Opd1b0,Opd1b0,Opd1b0,Opd1b0,Opd1b0 ;@ d7b0
  .long Opd1b8,Opd1b9,Op____,Op____,Op____,Op____,Op____,Op____ ;@ d7b8
  .long Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0 ;@ d7c0
  .long Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0 ;@ d7c8
  .long Opd1d0,Opd1d0,Opd1d0,Opd1d0,Opd1d0,Opd1d0,Opd1d0,Opd1d0 ;@ d7d0
  .long Opd1d8,Opd1d8,Opd1d8,Opd1d8,Opd1d8,Opd1d8,Opd1d8,Opd1d8 ;@ d7d8
  .long Opd1e0,Opd1e0,Opd1e0,Opd1e0,Opd1e0,Opd1e0,Opd1e0,Opd1e0 ;@ d7e0
  .long Opd1e8,Opd1e8,Opd1e8,Opd1e8,Opd1e8,Opd1e8,Opd1e8,Opd1e8 ;@ d7e8
  .long Opd1f0,Opd1f0,Opd1f0,Opd1f0,Opd1f0,Opd1f0,Opd1f0,Opd1f0 ;@ d7f0
  .long Opd1f8,Opd1f9,Opd1fa,Opd1fb,Opd1fc,Op____,Op____,Op____ ;@ d7f8
  .long Opd000,Opd000,Opd000,Opd000,Opd000,Opd000,Opd000,Opd000 ;@ d800
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ d808
  .long Opd010,Opd010,Opd010,Opd010,Opd010,Opd010,Opd010,Opd010 ;@ d810
  .long Opd018,Opd018,Opd018,Opd018,Opd018,Opd018,Opd018,Opd01f ;@ d818
  .long Opd020,Opd020,Opd020,Opd020,Opd020,Opd020,Opd020,Opd027 ;@ d820
  .long Opd028,Opd028,Opd028,Opd028,Opd028,Opd028,Opd028,Opd028 ;@ d828
  .long Opd030,Opd030,Opd030,Opd030,Opd030,Opd030,Opd030,Opd030 ;@ d830
  .long Opd038,Opd039,Opd03a,Opd03b,Opd03c,Op____,Op____,Op____ ;@ d838
  .long Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040 ;@ d840
  .long Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040 ;@ d848
  .long Opd050,Opd050,Opd050,Opd050,Opd050,Opd050,Opd050,Opd050 ;@ d850
  .long Opd058,Opd058,Opd058,Opd058,Opd058,Opd058,Opd058,Opd058 ;@ d858
  .long Opd060,Opd060,Opd060,Opd060,Opd060,Opd060,Opd060,Opd060 ;@ d860
  .long Opd068,Opd068,Opd068,Opd068,Opd068,Opd068,Opd068,Opd068 ;@ d868
  .long Opd070,Opd070,Opd070,Opd070,Opd070,Opd070,Opd070,Opd070 ;@ d870
  .long Opd078,Opd079,Opd07a,Opd07b,Opd07c,Op____,Op____,Op____ ;@ d878
  .long Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080 ;@ d880
  .long Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080 ;@ d888
  .long Opd090,Opd090,Opd090,Opd090,Opd090,Opd090,Opd090,Opd090 ;@ d890
  .long Opd098,Opd098,Opd098,Opd098,Opd098,Opd098,Opd098,Opd098 ;@ d898
  .long Opd0a0,Opd0a0,Opd0a0,Opd0a0,Opd0a0,Opd0a0,Opd0a0,Opd0a0 ;@ d8a0
  .long Opd0a8,Opd0a8,Opd0a8,Opd0a8,Opd0a8,Opd0a8,Opd0a8,Opd0a8 ;@ d8a8
  .long Opd0b0,Opd0b0,Opd0b0,Opd0b0,Opd0b0,Opd0b0,Opd0b0,Opd0b0 ;@ d8b0
  .long Opd0b8,Opd0b9,Opd0ba,Opd0bb,Opd0bc,Op____,Op____,Op____ ;@ d8b8
  .long Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0 ;@ d8c0
  .long Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0 ;@ d8c8
  .long Opd0d0,Opd0d0,Opd0d0,Opd0d0,Opd0d0,Opd0d0,Opd0d0,Opd0d0 ;@ d8d0
  .long Opd0d8,Opd0d8,Opd0d8,Opd0d8,Opd0d8,Opd0d8,Opd0d8,Opd0d8 ;@ d8d8
  .long Opd0e0,Opd0e0,Opd0e0,Opd0e0,Opd0e0,Opd0e0,Opd0e0,Opd0e0 ;@ d8e0
  .long Opd0e8,Opd0e8,Opd0e8,Opd0e8,Opd0e8,Opd0e8,Opd0e8,Opd0e8 ;@ d8e8
  .long Opd0f0,Opd0f0,Opd0f0,Opd0f0,Opd0f0,Opd0f0,Opd0f0,Opd0f0 ;@ d8f0
  .long Opd0f8,Opd0f9,Opd0fa,Opd0fb,Opd0fc,Op____,Op____,Op____ ;@ d8f8
  .long Opd100,Opd100,Opd100,Opd100,Opd100,Opd100,Opd100,Opd100 ;@ d900
  .long Opd108,Opd108,Opd108,Opd108,Opd108,Opd108,Opd108,Opd10f ;@ d908
  .long Opd110,Opd110,Opd110,Opd110,Opd110,Opd110,Opd110,Opd110 ;@ d910
  .long Opd118,Opd118,Opd118,Opd118,Opd118,Opd118,Opd118,Opd11f ;@ d918
  .long Opd120,Opd120,Opd120,Opd120,Opd120,Opd120,Opd120,Opd127 ;@ d920
  .long Opd128,Opd128,Opd128,Opd128,Opd128,Opd128,Opd128,Opd128 ;@ d928
  .long Opd130,Opd130,Opd130,Opd130,Opd130,Opd130,Opd130,Opd130 ;@ d930
  .long Opd138,Opd139,Op____,Op____,Op____,Op____,Op____,Op____ ;@ d938
  .long Opd140,Opd140,Opd140,Opd140,Opd140,Opd140,Opd140,Opd140 ;@ d940
  .long Opd148,Opd148,Opd148,Opd148,Opd148,Opd148,Opd148,Opd148 ;@ d948
  .long Opd150,Opd150,Opd150,Opd150,Opd150,Opd150,Opd150,Opd150 ;@ d950
  .long Opd158,Opd158,Opd158,Opd158,Opd158,Opd158,Opd158,Opd158 ;@ d958
  .long Opd160,Opd160,Opd160,Opd160,Opd160,Opd160,Opd160,Opd160 ;@ d960
  .long Opd168,Opd168,Opd168,Opd168,Opd168,Opd168,Opd168,Opd168 ;@ d968
  .long Opd170,Opd170,Opd170,Opd170,Opd170,Opd170,Opd170,Opd170 ;@ d970
  .long Opd178,Opd179,Op____,Op____,Op____,Op____,Op____,Op____ ;@ d978
  .long Opd180,Opd180,Opd180,Opd180,Opd180,Opd180,Opd180,Opd180 ;@ d980
  .long Opd188,Opd188,Opd188,Opd188,Opd188,Opd188,Opd188,Opd188 ;@ d988
  .long Opd190,Opd190,Opd190,Opd190,Opd190,Opd190,Opd190,Opd190 ;@ d990
  .long Opd198,Opd198,Opd198,Opd198,Opd198,Opd198,Opd198,Opd198 ;@ d998
  .long Opd1a0,Opd1a0,Opd1a0,Opd1a0,Opd1a0,Opd1a0,Opd1a0,Opd1a0 ;@ d9a0
  .long Opd1a8,Opd1a8,Opd1a8,Opd1a8,Opd1a8,Opd1a8,Opd1a8,Opd1a8 ;@ d9a8
  .long Opd1b0,Opd1b0,Opd1b0,Opd1b0,Opd1b0,Opd1b0,Opd1b0,Opd1b0 ;@ d9b0
  .long Opd1b8,Opd1b9,Op____,Op____,Op____,Op____,Op____,Op____ ;@ d9b8
  .long Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0 ;@ d9c0
  .long Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0 ;@ d9c8
  .long Opd1d0,Opd1d0,Opd1d0,Opd1d0,Opd1d0,Opd1d0,Opd1d0,Opd1d0 ;@ d9d0
  .long Opd1d8,Opd1d8,Opd1d8,Opd1d8,Opd1d8,Opd1d8,Opd1d8,Opd1d8 ;@ d9d8
  .long Opd1e0,Opd1e0,Opd1e0,Opd1e0,Opd1e0,Opd1e0,Opd1e0,Opd1e0 ;@ d9e0
  .long Opd1e8,Opd1e8,Opd1e8,Opd1e8,Opd1e8,Opd1e8,Opd1e8,Opd1e8 ;@ d9e8
  .long Opd1f0,Opd1f0,Opd1f0,Opd1f0,Opd1f0,Opd1f0,Opd1f0,Opd1f0 ;@ d9f0
  .long Opd1f8,Opd1f9,Opd1fa,Opd1fb,Opd1fc,Op____,Op____,Op____ ;@ d9f8
  .long Opd000,Opd000,Opd000,Opd000,Opd000,Opd000,Opd000,Opd000 ;@ da00
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ da08
  .long Opd010,Opd010,Opd010,Opd010,Opd010,Opd010,Opd010,Opd010 ;@ da10
  .long Opd018,Opd018,Opd018,Opd018,Opd018,Opd018,Opd018,Opd01f ;@ da18
  .long Opd020,Opd020,Opd020,Opd020,Opd020,Opd020,Opd020,Opd027 ;@ da20
  .long Opd028,Opd028,Opd028,Opd028,Opd028,Opd028,Opd028,Opd028 ;@ da28
  .long Opd030,Opd030,Opd030,Opd030,Opd030,Opd030,Opd030,Opd030 ;@ da30
  .long Opd038,Opd039,Opd03a,Opd03b,Opd03c,Op____,Op____,Op____ ;@ da38
  .long Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040 ;@ da40
  .long Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040 ;@ da48
  .long Opd050,Opd050,Opd050,Opd050,Opd050,Opd050,Opd050,Opd050 ;@ da50
  .long Opd058,Opd058,Opd058,Opd058,Opd058,Opd058,Opd058,Opd058 ;@ da58
  .long Opd060,Opd060,Opd060,Opd060,Opd060,Opd060,Opd060,Opd060 ;@ da60
  .long Opd068,Opd068,Opd068,Opd068,Opd068,Opd068,Opd068,Opd068 ;@ da68
  .long Opd070,Opd070,Opd070,Opd070,Opd070,Opd070,Opd070,Opd070 ;@ da70
  .long Opd078,Opd079,Opd07a,Opd07b,Opd07c,Op____,Op____,Op____ ;@ da78
  .long Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080 ;@ da80
  .long Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080 ;@ da88
  .long Opd090,Opd090,Opd090,Opd090,Opd090,Opd090,Opd090,Opd090 ;@ da90
  .long Opd098,Opd098,Opd098,Opd098,Opd098,Opd098,Opd098,Opd098 ;@ da98
  .long Opd0a0,Opd0a0,Opd0a0,Opd0a0,Opd0a0,Opd0a0,Opd0a0,Opd0a0 ;@ daa0
  .long Opd0a8,Opd0a8,Opd0a8,Opd0a8,Opd0a8,Opd0a8,Opd0a8,Opd0a8 ;@ daa8
  .long Opd0b0,Opd0b0,Opd0b0,Opd0b0,Opd0b0,Opd0b0,Opd0b0,Opd0b0 ;@ dab0
  .long Opd0b8,Opd0b9,Opd0ba,Opd0bb,Opd0bc,Op____,Op____,Op____ ;@ dab8
  .long Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0 ;@ dac0
  .long Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0 ;@ dac8
  .long Opd0d0,Opd0d0,Opd0d0,Opd0d0,Opd0d0,Opd0d0,Opd0d0,Opd0d0 ;@ dad0
  .long Opd0d8,Opd0d8,Opd0d8,Opd0d8,Opd0d8,Opd0d8,Opd0d8,Opd0d8 ;@ dad8
  .long Opd0e0,Opd0e0,Opd0e0,Opd0e0,Opd0e0,Opd0e0,Opd0e0,Opd0e0 ;@ dae0
  .long Opd0e8,Opd0e8,Opd0e8,Opd0e8,Opd0e8,Opd0e8,Opd0e8,Opd0e8 ;@ dae8
  .long Opd0f0,Opd0f0,Opd0f0,Opd0f0,Opd0f0,Opd0f0,Opd0f0,Opd0f0 ;@ daf0
  .long Opd0f8,Opd0f9,Opd0fa,Opd0fb,Opd0fc,Op____,Op____,Op____ ;@ daf8
  .long Opd100,Opd100,Opd100,Opd100,Opd100,Opd100,Opd100,Opd100 ;@ db00
  .long Opd108,Opd108,Opd108,Opd108,Opd108,Opd108,Opd108,Opd10f ;@ db08
  .long Opd110,Opd110,Opd110,Opd110,Opd110,Opd110,Opd110,Opd110 ;@ db10
  .long Opd118,Opd118,Opd118,Opd118,Opd118,Opd118,Opd118,Opd11f ;@ db18
  .long Opd120,Opd120,Opd120,Opd120,Opd120,Opd120,Opd120,Opd127 ;@ db20
  .long Opd128,Opd128,Opd128,Opd128,Opd128,Opd128,Opd128,Opd128 ;@ db28
  .long Opd130,Opd130,Opd130,Opd130,Opd130,Opd130,Opd130,Opd130 ;@ db30
  .long Opd138,Opd139,Op____,Op____,Op____,Op____,Op____,Op____ ;@ db38
  .long Opd140,Opd140,Opd140,Opd140,Opd140,Opd140,Opd140,Opd140 ;@ db40
  .long Opd148,Opd148,Opd148,Opd148,Opd148,Opd148,Opd148,Opd148 ;@ db48
  .long Opd150,Opd150,Opd150,Opd150,Opd150,Opd150,Opd150,Opd150 ;@ db50
  .long Opd158,Opd158,Opd158,Opd158,Opd158,Opd158,Opd158,Opd158 ;@ db58
  .long Opd160,Opd160,Opd160,Opd160,Opd160,Opd160,Opd160,Opd160 ;@ db60
  .long Opd168,Opd168,Opd168,Opd168,Opd168,Opd168,Opd168,Opd168 ;@ db68
  .long Opd170,Opd170,Opd170,Opd170,Opd170,Opd170,Opd170,Opd170 ;@ db70
  .long Opd178,Opd179,Op____,Op____,Op____,Op____,Op____,Op____ ;@ db78
  .long Opd180,Opd180,Opd180,Opd180,Opd180,Opd180,Opd180,Opd180 ;@ db80
  .long Opd188,Opd188,Opd188,Opd188,Opd188,Opd188,Opd188,Opd188 ;@ db88
  .long Opd190,Opd190,Opd190,Opd190,Opd190,Opd190,Opd190,Opd190 ;@ db90
  .long Opd198,Opd198,Opd198,Opd198,Opd198,Opd198,Opd198,Opd198 ;@ db98
  .long Opd1a0,Opd1a0,Opd1a0,Opd1a0,Opd1a0,Opd1a0,Opd1a0,Opd1a0 ;@ dba0
  .long Opd1a8,Opd1a8,Opd1a8,Opd1a8,Opd1a8,Opd1a8,Opd1a8,Opd1a8 ;@ dba8
  .long Opd1b0,Opd1b0,Opd1b0,Opd1b0,Opd1b0,Opd1b0,Opd1b0,Opd1b0 ;@ dbb0
  .long Opd1b8,Opd1b9,Op____,Op____,Op____,Op____,Op____,Op____ ;@ dbb8
  .long Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0 ;@ dbc0
  .long Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0 ;@ dbc8
  .long Opd1d0,Opd1d0,Opd1d0,Opd1d0,Opd1d0,Opd1d0,Opd1d0,Opd1d0 ;@ dbd0
  .long Opd1d8,Opd1d8,Opd1d8,Opd1d8,Opd1d8,Opd1d8,Opd1d8,Opd1d8 ;@ dbd8
  .long Opd1e0,Opd1e0,Opd1e0,Opd1e0,Opd1e0,Opd1e0,Opd1e0,Opd1e0 ;@ dbe0
  .long Opd1e8,Opd1e8,Opd1e8,Opd1e8,Opd1e8,Opd1e8,Opd1e8,Opd1e8 ;@ dbe8
  .long Opd1f0,Opd1f0,Opd1f0,Opd1f0,Opd1f0,Opd1f0,Opd1f0,Opd1f0 ;@ dbf0
  .long Opd1f8,Opd1f9,Opd1fa,Opd1fb,Opd1fc,Op____,Op____,Op____ ;@ dbf8
  .long Opd000,Opd000,Opd000,Opd000,Opd000,Opd000,Opd000,Opd000 ;@ dc00
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ dc08
  .long Opd010,Opd010,Opd010,Opd010,Opd010,Opd010,Opd010,Opd010 ;@ dc10
  .long Opd018,Opd018,Opd018,Opd018,Opd018,Opd018,Opd018,Opd01f ;@ dc18
  .long Opd020,Opd020,Opd020,Opd020,Opd020,Opd020,Opd020,Opd027 ;@ dc20
  .long Opd028,Opd028,Opd028,Opd028,Opd028,Opd028,Opd028,Opd028 ;@ dc28
  .long Opd030,Opd030,Opd030,Opd030,Opd030,Opd030,Opd030,Opd030 ;@ dc30
  .long Opd038,Opd039,Opd03a,Opd03b,Opd03c,Op____,Op____,Op____ ;@ dc38
  .long Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040 ;@ dc40
  .long Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040 ;@ dc48
  .long Opd050,Opd050,Opd050,Opd050,Opd050,Opd050,Opd050,Opd050 ;@ dc50
  .long Opd058,Opd058,Opd058,Opd058,Opd058,Opd058,Opd058,Opd058 ;@ dc58
  .long Opd060,Opd060,Opd060,Opd060,Opd060,Opd060,Opd060,Opd060 ;@ dc60
  .long Opd068,Opd068,Opd068,Opd068,Opd068,Opd068,Opd068,Opd068 ;@ dc68
  .long Opd070,Opd070,Opd070,Opd070,Opd070,Opd070,Opd070,Opd070 ;@ dc70
  .long Opd078,Opd079,Opd07a,Opd07b,Opd07c,Op____,Op____,Op____ ;@ dc78
  .long Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080 ;@ dc80
  .long Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080 ;@ dc88
  .long Opd090,Opd090,Opd090,Opd090,Opd090,Opd090,Opd090,Opd090 ;@ dc90
  .long Opd098,Opd098,Opd098,Opd098,Opd098,Opd098,Opd098,Opd098 ;@ dc98
  .long Opd0a0,Opd0a0,Opd0a0,Opd0a0,Opd0a0,Opd0a0,Opd0a0,Opd0a0 ;@ dca0
  .long Opd0a8,Opd0a8,Opd0a8,Opd0a8,Opd0a8,Opd0a8,Opd0a8,Opd0a8 ;@ dca8
  .long Opd0b0,Opd0b0,Opd0b0,Opd0b0,Opd0b0,Opd0b0,Opd0b0,Opd0b0 ;@ dcb0
  .long Opd0b8,Opd0b9,Opd0ba,Opd0bb,Opd0bc,Op____,Op____,Op____ ;@ dcb8
  .long Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0 ;@ dcc0
  .long Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0 ;@ dcc8
  .long Opd0d0,Opd0d0,Opd0d0,Opd0d0,Opd0d0,Opd0d0,Opd0d0,Opd0d0 ;@ dcd0
  .long Opd0d8,Opd0d8,Opd0d8,Opd0d8,Opd0d8,Opd0d8,Opd0d8,Opd0d8 ;@ dcd8
  .long Opd0e0,Opd0e0,Opd0e0,Opd0e0,Opd0e0,Opd0e0,Opd0e0,Opd0e0 ;@ dce0
  .long Opd0e8,Opd0e8,Opd0e8,Opd0e8,Opd0e8,Opd0e8,Opd0e8,Opd0e8 ;@ dce8
  .long Opd0f0,Opd0f0,Opd0f0,Opd0f0,Opd0f0,Opd0f0,Opd0f0,Opd0f0 ;@ dcf0
  .long Opd0f8,Opd0f9,Opd0fa,Opd0fb,Opd0fc,Op____,Op____,Op____ ;@ dcf8
  .long Opd100,Opd100,Opd100,Opd100,Opd100,Opd100,Opd100,Opd100 ;@ dd00
  .long Opd108,Opd108,Opd108,Opd108,Opd108,Opd108,Opd108,Opd10f ;@ dd08
  .long Opd110,Opd110,Opd110,Opd110,Opd110,Opd110,Opd110,Opd110 ;@ dd10
  .long Opd118,Opd118,Opd118,Opd118,Opd118,Opd118,Opd118,Opd11f ;@ dd18
  .long Opd120,Opd120,Opd120,Opd120,Opd120,Opd120,Opd120,Opd127 ;@ dd20
  .long Opd128,Opd128,Opd128,Opd128,Opd128,Opd128,Opd128,Opd128 ;@ dd28
  .long Opd130,Opd130,Opd130,Opd130,Opd130,Opd130,Opd130,Opd130 ;@ dd30
  .long Opd138,Opd139,Op____,Op____,Op____,Op____,Op____,Op____ ;@ dd38
  .long Opd140,Opd140,Opd140,Opd140,Opd140,Opd140,Opd140,Opd140 ;@ dd40
  .long Opd148,Opd148,Opd148,Opd148,Opd148,Opd148,Opd148,Opd148 ;@ dd48
  .long Opd150,Opd150,Opd150,Opd150,Opd150,Opd150,Opd150,Opd150 ;@ dd50
  .long Opd158,Opd158,Opd158,Opd158,Opd158,Opd158,Opd158,Opd158 ;@ dd58
  .long Opd160,Opd160,Opd160,Opd160,Opd160,Opd160,Opd160,Opd160 ;@ dd60
  .long Opd168,Opd168,Opd168,Opd168,Opd168,Opd168,Opd168,Opd168 ;@ dd68
  .long Opd170,Opd170,Opd170,Opd170,Opd170,Opd170,Opd170,Opd170 ;@ dd70
  .long Opd178,Opd179,Op____,Op____,Op____,Op____,Op____,Op____ ;@ dd78
  .long Opd180,Opd180,Opd180,Opd180,Opd180,Opd180,Opd180,Opd180 ;@ dd80
  .long Opd188,Opd188,Opd188,Opd188,Opd188,Opd188,Opd188,Opd188 ;@ dd88
  .long Opd190,Opd190,Opd190,Opd190,Opd190,Opd190,Opd190,Opd190 ;@ dd90
  .long Opd198,Opd198,Opd198,Opd198,Opd198,Opd198,Opd198,Opd198 ;@ dd98
  .long Opd1a0,Opd1a0,Opd1a0,Opd1a0,Opd1a0,Opd1a0,Opd1a0,Opd1a0 ;@ dda0
  .long Opd1a8,Opd1a8,Opd1a8,Opd1a8,Opd1a8,Opd1a8,Opd1a8,Opd1a8 ;@ dda8
  .long Opd1b0,Opd1b0,Opd1b0,Opd1b0,Opd1b0,Opd1b0,Opd1b0,Opd1b0 ;@ ddb0
  .long Opd1b8,Opd1b9,Op____,Op____,Op____,Op____,Op____,Op____ ;@ ddb8
  .long Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0 ;@ ddc0
  .long Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0 ;@ ddc8
  .long Opd1d0,Opd1d0,Opd1d0,Opd1d0,Opd1d0,Opd1d0,Opd1d0,Opd1d0 ;@ ddd0
  .long Opd1d8,Opd1d8,Opd1d8,Opd1d8,Opd1d8,Opd1d8,Opd1d8,Opd1d8 ;@ ddd8
  .long Opd1e0,Opd1e0,Opd1e0,Opd1e0,Opd1e0,Opd1e0,Opd1e0,Opd1e0 ;@ dde0
  .long Opd1e8,Opd1e8,Opd1e8,Opd1e8,Opd1e8,Opd1e8,Opd1e8,Opd1e8 ;@ dde8
  .long Opd1f0,Opd1f0,Opd1f0,Opd1f0,Opd1f0,Opd1f0,Opd1f0,Opd1f0 ;@ ddf0
  .long Opd1f8,Opd1f9,Opd1fa,Opd1fb,Opd1fc,Op____,Op____,Op____ ;@ ddf8
  .long Opd000,Opd000,Opd000,Opd000,Opd000,Opd000,Opd000,Opd000 ;@ de00
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ de08
  .long Opd010,Opd010,Opd010,Opd010,Opd010,Opd010,Opd010,Opd010 ;@ de10
  .long Opd018,Opd018,Opd018,Opd018,Opd018,Opd018,Opd018,Opd01f ;@ de18
  .long Opd020,Opd020,Opd020,Opd020,Opd020,Opd020,Opd020,Opd027 ;@ de20
  .long Opd028,Opd028,Opd028,Opd028,Opd028,Opd028,Opd028,Opd028 ;@ de28
  .long Opd030,Opd030,Opd030,Opd030,Opd030,Opd030,Opd030,Opd030 ;@ de30
  .long Opd038,Opd039,Opd03a,Opd03b,Opd03c,Op____,Op____,Op____ ;@ de38
  .long Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040 ;@ de40
  .long Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040,Opd040 ;@ de48
  .long Opd050,Opd050,Opd050,Opd050,Opd050,Opd050,Opd050,Opd050 ;@ de50
  .long Opd058,Opd058,Opd058,Opd058,Opd058,Opd058,Opd058,Opd058 ;@ de58
  .long Opd060,Opd060,Opd060,Opd060,Opd060,Opd060,Opd060,Opd060 ;@ de60
  .long Opd068,Opd068,Opd068,Opd068,Opd068,Opd068,Opd068,Opd068 ;@ de68
  .long Opd070,Opd070,Opd070,Opd070,Opd070,Opd070,Opd070,Opd070 ;@ de70
  .long Opd078,Opd079,Opd07a,Opd07b,Opd07c,Op____,Op____,Op____ ;@ de78
  .long Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080 ;@ de80
  .long Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080,Opd080 ;@ de88
  .long Opd090,Opd090,Opd090,Opd090,Opd090,Opd090,Opd090,Opd090 ;@ de90
  .long Opd098,Opd098,Opd098,Opd098,Opd098,Opd098,Opd098,Opd098 ;@ de98
  .long Opd0a0,Opd0a0,Opd0a0,Opd0a0,Opd0a0,Opd0a0,Opd0a0,Opd0a0 ;@ dea0
  .long Opd0a8,Opd0a8,Opd0a8,Opd0a8,Opd0a8,Opd0a8,Opd0a8,Opd0a8 ;@ dea8
  .long Opd0b0,Opd0b0,Opd0b0,Opd0b0,Opd0b0,Opd0b0,Opd0b0,Opd0b0 ;@ deb0
  .long Opd0b8,Opd0b9,Opd0ba,Opd0bb,Opd0bc,Op____,Op____,Op____ ;@ deb8
  .long Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0 ;@ dec0
  .long Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0,Opd0c0 ;@ dec8
  .long Opd0d0,Opd0d0,Opd0d0,Opd0d0,Opd0d0,Opd0d0,Opd0d0,Opd0d0 ;@ ded0
  .long Opd0d8,Opd0d8,Opd0d8,Opd0d8,Opd0d8,Opd0d8,Opd0d8,Opd0d8 ;@ ded8
  .long Opd0e0,Opd0e0,Opd0e0,Opd0e0,Opd0e0,Opd0e0,Opd0e0,Opd0e0 ;@ dee0
  .long Opd0e8,Opd0e8,Opd0e8,Opd0e8,Opd0e8,Opd0e8,Opd0e8,Opd0e8 ;@ dee8
  .long Opd0f0,Opd0f0,Opd0f0,Opd0f0,Opd0f0,Opd0f0,Opd0f0,Opd0f0 ;@ def0
  .long Opd0f8,Opd0f9,Opd0fa,Opd0fb,Opd0fc,Op____,Op____,Op____ ;@ def8
  .long Opd100,Opd100,Opd100,Opd100,Opd100,Opd100,Opd100,Opd100 ;@ df00
  .long Opdf08,Opdf08,Opdf08,Opdf08,Opdf08,Opdf08,Opdf08,Opdf0f ;@ df08
  .long Opd110,Opd110,Opd110,Opd110,Opd110,Opd110,Opd110,Opd110 ;@ df10
  .long Opd118,Opd118,Opd118,Opd118,Opd118,Opd118,Opd118,Opd11f ;@ df18
  .long Opd120,Opd120,Opd120,Opd120,Opd120,Opd120,Opd120,Opd127 ;@ df20
  .long Opd128,Opd128,Opd128,Opd128,Opd128,Opd128,Opd128,Opd128 ;@ df28
  .long Opd130,Opd130,Opd130,Opd130,Opd130,Opd130,Opd130,Opd130 ;@ df30
  .long Opd138,Opd139,Op____,Op____,Op____,Op____,Op____,Op____ ;@ df38
  .long Opd140,Opd140,Opd140,Opd140,Opd140,Opd140,Opd140,Opd140 ;@ df40
  .long Opd148,Opd148,Opd148,Opd148,Opd148,Opd148,Opd148,Opd148 ;@ df48
  .long Opd150,Opd150,Opd150,Opd150,Opd150,Opd150,Opd150,Opd150 ;@ df50
  .long Opd158,Opd158,Opd158,Opd158,Opd158,Opd158,Opd158,Opd158 ;@ df58
  .long Opd160,Opd160,Opd160,Opd160,Opd160,Opd160,Opd160,Opd160 ;@ df60
  .long Opd168,Opd168,Opd168,Opd168,Opd168,Opd168,Opd168,Opd168 ;@ df68
  .long Opd170,Opd170,Opd170,Opd170,Opd170,Opd170,Opd170,Opd170 ;@ df70
  .long Opd178,Opd179,Op____,Op____,Op____,Op____,Op____,Op____ ;@ df78
  .long Opd180,Opd180,Opd180,Opd180,Opd180,Opd180,Opd180,Opd180 ;@ df80
  .long Opd188,Opd188,Opd188,Opd188,Opd188,Opd188,Opd188,Opd188 ;@ df88
  .long Opd190,Opd190,Opd190,Opd190,Opd190,Opd190,Opd190,Opd190 ;@ df90
  .long Opd198,Opd198,Opd198,Opd198,Opd198,Opd198,Opd198,Opd198 ;@ df98
  .long Opd1a0,Opd1a0,Opd1a0,Opd1a0,Opd1a0,Opd1a0,Opd1a0,Opd1a0 ;@ dfa0
  .long Opd1a8,Opd1a8,Opd1a8,Opd1a8,Opd1a8,Opd1a8,Opd1a8,Opd1a8 ;@ dfa8
  .long Opd1b0,Opd1b0,Opd1b0,Opd1b0,Opd1b0,Opd1b0,Opd1b0,Opd1b0 ;@ dfb0
  .long Opd1b8,Opd1b9,Op____,Op____,Op____,Op____,Op____,Op____ ;@ dfb8
  .long Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0 ;@ dfc0
  .long Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0,Opd1c0 ;@ dfc8
  .long Opd1d0,Opd1d0,Opd1d0,Opd1d0,Opd1d0,Opd1d0,Opd1d0,Opd1d0 ;@ dfd0
  .long Opd1d8,Opd1d8,Opd1d8,Opd1d8,Opd1d8,Opd1d8,Opd1d8,Opd1d8 ;@ dfd8
  .long Opd1e0,Opd1e0,Opd1e0,Opd1e0,Opd1e0,Opd1e0,Opd1e0,Opd1e0 ;@ dfe0
  .long Opd1e8,Opd1e8,Opd1e8,Opd1e8,Opd1e8,Opd1e8,Opd1e8,Opd1e8 ;@ dfe8
  .long Opd1f0,Opd1f0,Opd1f0,Opd1f0,Opd1f0,Opd1f0,Opd1f0,Opd1f0 ;@ dff0
  .long Opd1f8,Opd1f9,Opd1fa,Opd1fb,Opd1fc,Op____,Op____,Op____ ;@ dff8
  .long Ope000,Ope000,Ope000,Ope000,Ope000,Ope000,Ope000,Ope000 ;@ e000
  .long Ope008,Ope008,Ope008,Ope008,Ope008,Ope008,Ope008,Ope008 ;@ e008
  .long Ope010,Ope010,Ope010,Ope010,Ope010,Ope010,Ope010,Ope010 ;@ e010
  .long Ope018,Ope018,Ope018,Ope018,Ope018,Ope018,Ope018,Ope018 ;@ e018
  .long Ope020,Ope020,Ope020,Ope020,Ope020,Ope020,Ope020,Ope020 ;@ e020
  .long Ope028,Ope028,Ope028,Ope028,Ope028,Ope028,Ope028,Ope028 ;@ e028
  .long Ope030,Ope030,Ope030,Ope030,Ope030,Ope030,Ope030,Ope030 ;@ e030
  .long Ope038,Ope038,Ope038,Ope038,Ope038,Ope038,Ope038,Ope038 ;@ e038
  .long Ope040,Ope040,Ope040,Ope040,Ope040,Ope040,Ope040,Ope040 ;@ e040
  .long Ope048,Ope048,Ope048,Ope048,Ope048,Ope048,Ope048,Ope048 ;@ e048
  .long Ope050,Ope050,Ope050,Ope050,Ope050,Ope050,Ope050,Ope050 ;@ e050
  .long Ope058,Ope058,Ope058,Ope058,Ope058,Ope058,Ope058,Ope058 ;@ e058
  .long Ope060,Ope060,Ope060,Ope060,Ope060,Ope060,Ope060,Ope060 ;@ e060
  .long Ope068,Ope068,Ope068,Ope068,Ope068,Ope068,Ope068,Ope068 ;@ e068
  .long Ope070,Ope070,Ope070,Ope070,Ope070,Ope070,Ope070,Ope070 ;@ e070
  .long Ope078,Ope078,Ope078,Ope078,Ope078,Ope078,Ope078,Ope078 ;@ e078
  .long Ope080,Ope080,Ope080,Ope080,Ope080,Ope080,Ope080,Ope080 ;@ e080
  .long Ope088,Ope088,Ope088,Ope088,Ope088,Ope088,Ope088,Ope088 ;@ e088
  .long Ope090,Ope090,Ope090,Ope090,Ope090,Ope090,Ope090,Ope090 ;@ e090
  .long Ope098,Ope098,Ope098,Ope098,Ope098,Ope098,Ope098,Ope098 ;@ e098
  .long Ope0a0,Ope0a0,Ope0a0,Ope0a0,Ope0a0,Ope0a0,Ope0a0,Ope0a0 ;@ e0a0
  .long Ope0a8,Ope0a8,Ope0a8,Ope0a8,Ope0a8,Ope0a8,Ope0a8,Ope0a8 ;@ e0a8
  .long Ope0b0,Ope0b0,Ope0b0,Ope0b0,Ope0b0,Ope0b0,Ope0b0,Ope0b0 ;@ e0b0
  .long Ope0b8,Ope0b8,Ope0b8,Ope0b8,Ope0b8,Ope0b8,Ope0b8,Ope0b8 ;@ e0b8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ e0c0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ e0c8
  .long Ope0d0,Ope0d0,Ope0d0,Ope0d0,Ope0d0,Ope0d0,Ope0d0,Ope0d0 ;@ e0d0
  .long Ope0d8,Ope0d8,Ope0d8,Ope0d8,Ope0d8,Ope0d8,Ope0d8,Ope0d8 ;@ e0d8
  .long Ope0e0,Ope0e0,Ope0e0,Ope0e0,Ope0e0,Ope0e0,Ope0e0,Ope0e0 ;@ e0e0
  .long Ope0e8,Ope0e8,Ope0e8,Ope0e8,Ope0e8,Ope0e8,Ope0e8,Ope0e8 ;@ e0e8
  .long Ope0f0,Ope0f0,Ope0f0,Ope0f0,Ope0f0,Ope0f0,Ope0f0,Ope0f0 ;@ e0f0
  .long Ope0f8,Ope0f9,Op____,Op____,Op____,Op____,Op____,Op____ ;@ e0f8
  .long Ope100,Ope100,Ope100,Ope100,Ope100,Ope100,Ope100,Ope100 ;@ e100
  .long Ope108,Ope108,Ope108,Ope108,Ope108,Ope108,Ope108,Ope108 ;@ e108
  .long Ope110,Ope110,Ope110,Ope110,Ope110,Ope110,Ope110,Ope110 ;@ e110
  .long Ope118,Ope118,Ope118,Ope118,Ope118,Ope118,Ope118,Ope118 ;@ e118
  .long Ope120,Ope120,Ope120,Ope120,Ope120,Ope120,Ope120,Ope120 ;@ e120
  .long Ope128,Ope128,Ope128,Ope128,Ope128,Ope128,Ope128,Ope128 ;@ e128
  .long Ope130,Ope130,Ope130,Ope130,Ope130,Ope130,Ope130,Ope130 ;@ e130
  .long Ope138,Ope138,Ope138,Ope138,Ope138,Ope138,Ope138,Ope138 ;@ e138
  .long Ope140,Ope140,Ope140,Ope140,Ope140,Ope140,Ope140,Ope140 ;@ e140
  .long Ope148,Ope148,Ope148,Ope148,Ope148,Ope148,Ope148,Ope148 ;@ e148
  .long Ope150,Ope150,Ope150,Ope150,Ope150,Ope150,Ope150,Ope150 ;@ e150
  .long Ope158,Ope158,Ope158,Ope158,Ope158,Ope158,Ope158,Ope158 ;@ e158
  .long Ope160,Ope160,Ope160,Ope160,Ope160,Ope160,Ope160,Ope160 ;@ e160
  .long Ope168,Ope168,Ope168,Ope168,Ope168,Ope168,Ope168,Ope168 ;@ e168
  .long Ope170,Ope170,Ope170,Ope170,Ope170,Ope170,Ope170,Ope170 ;@ e170
  .long Ope178,Ope178,Ope178,Ope178,Ope178,Ope178,Ope178,Ope178 ;@ e178
  .long Ope180,Ope180,Ope180,Ope180,Ope180,Ope180,Ope180,Ope180 ;@ e180
  .long Ope188,Ope188,Ope188,Ope188,Ope188,Ope188,Ope188,Ope188 ;@ e188
  .long Ope190,Ope190,Ope190,Ope190,Ope190,Ope190,Ope190,Ope190 ;@ e190
  .long Ope198,Ope198,Ope198,Ope198,Ope198,Ope198,Ope198,Ope198 ;@ e198
  .long Ope1a0,Ope1a0,Ope1a0,Ope1a0,Ope1a0,Ope1a0,Ope1a0,Ope1a0 ;@ e1a0
  .long Ope1a8,Ope1a8,Ope1a8,Ope1a8,Ope1a8,Ope1a8,Ope1a8,Ope1a8 ;@ e1a8
  .long Ope1b0,Ope1b0,Ope1b0,Ope1b0,Ope1b0,Ope1b0,Ope1b0,Ope1b0 ;@ e1b0
  .long Ope1b8,Ope1b8,Ope1b8,Ope1b8,Ope1b8,Ope1b8,Ope1b8,Ope1b8 ;@ e1b8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ e1c0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ e1c8
  .long Ope1d0,Ope1d0,Ope1d0,Ope1d0,Ope1d0,Ope1d0,Ope1d0,Ope1d0 ;@ e1d0
  .long Ope1d8,Ope1d8,Ope1d8,Ope1d8,Ope1d8,Ope1d8,Ope1d8,Ope1d8 ;@ e1d8
  .long Ope1e0,Ope1e0,Ope1e0,Ope1e0,Ope1e0,Ope1e0,Ope1e0,Ope1e0 ;@ e1e0
  .long Ope1e8,Ope1e8,Ope1e8,Ope1e8,Ope1e8,Ope1e8,Ope1e8,Ope1e8 ;@ e1e8
  .long Ope1f0,Ope1f0,Ope1f0,Ope1f0,Ope1f0,Ope1f0,Ope1f0,Ope1f0 ;@ e1f0
  .long Ope1f8,Ope1f9,Op____,Op____,Op____,Op____,Op____,Op____ ;@ e1f8
  .long Opee00,Opee00,Opee00,Opee00,Opee00,Opee00,Opee00,Opee00 ;@ e200
  .long Opee08,Opee08,Opee08,Opee08,Opee08,Opee08,Opee08,Opee08 ;@ e208
  .long Ope210,Ope210,Ope210,Ope210,Ope210,Ope210,Ope210,Ope210 ;@ e210
  .long Opee18,Opee18,Opee18,Opee18,Opee18,Opee18,Opee18,Opee18 ;@ e218
  .long Ope020,Ope020,Ope020,Ope020,Ope020,Ope020,Ope020,Ope020 ;@ e220
  .long Ope028,Ope028,Ope028,Ope028,Ope028,Ope028,Ope028,Ope028 ;@ e228
  .long Ope030,Ope030,Ope030,Ope030,Ope030,Ope030,Ope030,Ope030 ;@ e230
  .long Ope038,Ope038,Ope038,Ope038,Ope038,Ope038,Ope038,Ope038 ;@ e238
  .long Opee40,Opee40,Opee40,Opee40,Opee40,Opee40,Opee40,Opee40 ;@ e240
  .long Opee48,Opee48,Opee48,Opee48,Opee48,Opee48,Opee48,Opee48 ;@ e248
  .long Ope250,Ope250,Ope250,Ope250,Ope250,Ope250,Ope250,Ope250 ;@ e250
  .long Opee58,Opee58,Opee58,Opee58,Opee58,Opee58,Opee58,Opee58 ;@ e258
  .long Ope060,Ope060,Ope060,Ope060,Ope060,Ope060,Ope060,Ope060 ;@ e260
  .long Ope068,Ope068,Ope068,Ope068,Ope068,Ope068,Ope068,Ope068 ;@ e268
  .long Ope070,Ope070,Ope070,Ope070,Ope070,Ope070,Ope070,Ope070 ;@ e270
  .long Ope078,Ope078,Ope078,Ope078,Ope078,Ope078,Ope078,Ope078 ;@ e278
  .long Opee80,Opee80,Opee80,Opee80,Opee80,Opee80,Opee80,Opee80 ;@ e280
  .long Opee88,Opee88,Opee88,Opee88,Opee88,Opee88,Opee88,Opee88 ;@ e288
  .long Ope290,Ope290,Ope290,Ope290,Ope290,Ope290,Ope290,Ope290 ;@ e290
  .long Opee98,Opee98,Opee98,Opee98,Opee98,Opee98,Opee98,Opee98 ;@ e298
  .long Ope0a0,Ope0a0,Ope0a0,Ope0a0,Ope0a0,Ope0a0,Ope0a0,Ope0a0 ;@ e2a0
  .long Ope0a8,Ope0a8,Ope0a8,Ope0a8,Ope0a8,Ope0a8,Ope0a8,Ope0a8 ;@ e2a8
  .long Ope0b0,Ope0b0,Ope0b0,Ope0b0,Ope0b0,Ope0b0,Ope0b0,Ope0b0 ;@ e2b0
  .long Ope0b8,Ope0b8,Ope0b8,Ope0b8,Ope0b8,Ope0b8,Ope0b8,Ope0b8 ;@ e2b8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ e2c0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ e2c8
  .long Ope2d0,Ope2d0,Ope2d0,Ope2d0,Ope2d0,Ope2d0,Ope2d0,Ope2d0 ;@ e2d0
  .long Ope2d8,Ope2d8,Ope2d8,Ope2d8,Ope2d8,Ope2d8,Ope2d8,Ope2d8 ;@ e2d8
  .long Ope2e0,Ope2e0,Ope2e0,Ope2e0,Ope2e0,Ope2e0,Ope2e0,Ope2e0 ;@ e2e0
  .long Ope2e8,Ope2e8,Ope2e8,Ope2e8,Ope2e8,Ope2e8,Ope2e8,Ope2e8 ;@ e2e8
  .long Ope2f0,Ope2f0,Ope2f0,Ope2f0,Ope2f0,Ope2f0,Ope2f0,Ope2f0 ;@ e2f0
  .long Ope2f8,Ope2f9,Op____,Op____,Op____,Op____,Op____,Op____ ;@ e2f8
  .long Opef00,Opef00,Opef00,Opef00,Opef00,Opef00,Opef00,Opef00 ;@ e300
  .long Opef08,Opef08,Opef08,Opef08,Opef08,Opef08,Opef08,Opef08 ;@ e308
  .long Ope310,Ope310,Ope310,Ope310,Ope310,Ope310,Ope310,Ope310 ;@ e310
  .long Opef18,Opef18,Opef18,Opef18,Opef18,Opef18,Opef18,Opef18 ;@ e318
  .long Ope120,Ope120,Ope120,Ope120,Ope120,Ope120,Ope120,Ope120 ;@ e320
  .long Ope128,Ope128,Ope128,Ope128,Ope128,Ope128,Ope128,Ope128 ;@ e328
  .long Ope130,Ope130,Ope130,Ope130,Ope130,Ope130,Ope130,Ope130 ;@ e330
  .long Ope138,Ope138,Ope138,Ope138,Ope138,Ope138,Ope138,Ope138 ;@ e338
  .long Opef40,Opef40,Opef40,Opef40,Opef40,Opef40,Opef40,Opef40 ;@ e340
  .long Opef48,Opef48,Opef48,Opef48,Opef48,Opef48,Opef48,Opef48 ;@ e348
  .long Ope350,Ope350,Ope350,Ope350,Ope350,Ope350,Ope350,Ope350 ;@ e350
  .long Opef58,Opef58,Opef58,Opef58,Opef58,Opef58,Opef58,Opef58 ;@ e358
  .long Ope160,Ope160,Ope160,Ope160,Ope160,Ope160,Ope160,Ope160 ;@ e360
  .long Ope168,Ope168,Ope168,Ope168,Ope168,Ope168,Ope168,Ope168 ;@ e368
  .long Ope170,Ope170,Ope170,Ope170,Ope170,Ope170,Ope170,Ope170 ;@ e370
  .long Ope178,Ope178,Ope178,Ope178,Ope178,Ope178,Ope178,Ope178 ;@ e378
  .long Opef80,Opef80,Opef80,Opef80,Opef80,Opef80,Opef80,Opef80 ;@ e380
  .long Opef88,Opef88,Opef88,Opef88,Opef88,Opef88,Opef88,Opef88 ;@ e388
  .long Ope390,Ope390,Ope390,Ope390,Ope390,Ope390,Ope390,Ope390 ;@ e390
  .long Opef98,Opef98,Opef98,Opef98,Opef98,Opef98,Opef98,Opef98 ;@ e398
  .long Ope1a0,Ope1a0,Ope1a0,Ope1a0,Ope1a0,Ope1a0,Ope1a0,Ope1a0 ;@ e3a0
  .long Ope1a8,Ope1a8,Ope1a8,Ope1a8,Ope1a8,Ope1a8,Ope1a8,Ope1a8 ;@ e3a8
  .long Ope1b0,Ope1b0,Ope1b0,Ope1b0,Ope1b0,Ope1b0,Ope1b0,Ope1b0 ;@ e3b0
  .long Ope1b8,Ope1b8,Ope1b8,Ope1b8,Ope1b8,Ope1b8,Ope1b8,Ope1b8 ;@ e3b8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ e3c0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ e3c8
  .long Ope3d0,Ope3d0,Ope3d0,Ope3d0,Ope3d0,Ope3d0,Ope3d0,Ope3d0 ;@ e3d0
  .long Ope3d8,Ope3d8,Ope3d8,Ope3d8,Ope3d8,Ope3d8,Ope3d8,Ope3d8 ;@ e3d8
  .long Ope3e0,Ope3e0,Ope3e0,Ope3e0,Ope3e0,Ope3e0,Ope3e0,Ope3e0 ;@ e3e0
  .long Ope3e8,Ope3e8,Ope3e8,Ope3e8,Ope3e8,Ope3e8,Ope3e8,Ope3e8 ;@ e3e8
  .long Ope3f0,Ope3f0,Ope3f0,Ope3f0,Ope3f0,Ope3f0,Ope3f0,Ope3f0 ;@ e3f0
  .long Ope3f8,Ope3f9,Op____,Op____,Op____,Op____,Op____,Op____ ;@ e3f8
  .long Opee00,Opee00,Opee00,Opee00,Opee00,Opee00,Opee00,Opee00 ;@ e400
  .long Opee08,Opee08,Opee08,Opee08,Opee08,Opee08,Opee08,Opee08 ;@ e408
  .long Opee10,Opee10,Opee10,Opee10,Opee10,Opee10,Opee10,Opee10 ;@ e410
  .long Opee18,Opee18,Opee18,Opee18,Opee18,Opee18,Opee18,Opee18 ;@ e418
  .long Ope020,Ope020,Ope020,Ope020,Ope020,Ope020,Ope020,Ope020 ;@ e420
  .long Ope028,Ope028,Ope028,Ope028,Ope028,Ope028,Ope028,Ope028 ;@ e428
  .long Ope030,Ope030,Ope030,Ope030,Ope030,Ope030,Ope030,Ope030 ;@ e430
  .long Ope038,Ope038,Ope038,Ope038,Ope038,Ope038,Ope038,Ope038 ;@ e438
  .long Opee40,Opee40,Opee40,Opee40,Opee40,Opee40,Opee40,Opee40 ;@ e440
  .long Opee48,Opee48,Opee48,Opee48,Opee48,Opee48,Opee48,Opee48 ;@ e448
  .long Opee50,Opee50,Opee50,Opee50,Opee50,Opee50,Opee50,Opee50 ;@ e450
  .long Opee58,Opee58,Opee58,Opee58,Opee58,Opee58,Opee58,Opee58 ;@ e458
  .long Ope060,Ope060,Ope060,Ope060,Ope060,Ope060,Ope060,Ope060 ;@ e460
  .long Ope068,Ope068,Ope068,Ope068,Ope068,Ope068,Ope068,Ope068 ;@ e468
  .long Ope070,Ope070,Ope070,Ope070,Ope070,Ope070,Ope070,Ope070 ;@ e470
  .long Ope078,Ope078,Ope078,Ope078,Ope078,Ope078,Ope078,Ope078 ;@ e478
  .long Opee80,Opee80,Opee80,Opee80,Opee80,Opee80,Opee80,Opee80 ;@ e480
  .long Opee88,Opee88,Opee88,Opee88,Opee88,Opee88,Opee88,Opee88 ;@ e488
  .long Opee90,Opee90,Opee90,Opee90,Opee90,Opee90,Opee90,Opee90 ;@ e490
  .long Opee98,Opee98,Opee98,Opee98,Opee98,Opee98,Opee98,Opee98 ;@ e498
  .long Ope0a0,Ope0a0,Ope0a0,Ope0a0,Ope0a0,Ope0a0,Ope0a0,Ope0a0 ;@ e4a0
  .long Ope0a8,Ope0a8,Ope0a8,Ope0a8,Ope0a8,Ope0a8,Ope0a8,Ope0a8 ;@ e4a8
  .long Ope0b0,Ope0b0,Ope0b0,Ope0b0,Ope0b0,Ope0b0,Ope0b0,Ope0b0 ;@ e4b0
  .long Ope0b8,Ope0b8,Ope0b8,Ope0b8,Ope0b8,Ope0b8,Ope0b8,Ope0b8 ;@ e4b8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ e4c0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ e4c8
  .long Ope4d0,Ope4d0,Ope4d0,Ope4d0,Ope4d0,Ope4d0,Ope4d0,Ope4d0 ;@ e4d0
  .long Ope4d8,Ope4d8,Ope4d8,Ope4d8,Ope4d8,Ope4d8,Ope4d8,Ope4d8 ;@ e4d8
  .long Ope4e0,Ope4e0,Ope4e0,Ope4e0,Ope4e0,Ope4e0,Ope4e0,Ope4e0 ;@ e4e0
  .long Ope4e8,Ope4e8,Ope4e8,Ope4e8,Ope4e8,Ope4e8,Ope4e8,Ope4e8 ;@ e4e8
  .long Ope4f0,Ope4f0,Ope4f0,Ope4f0,Ope4f0,Ope4f0,Ope4f0,Ope4f0 ;@ e4f0
  .long Ope4f8,Ope4f9,Op____,Op____,Op____,Op____,Op____,Op____ ;@ e4f8
  .long Opef00,Opef00,Opef00,Opef00,Opef00,Opef00,Opef00,Opef00 ;@ e500
  .long Opef08,Opef08,Opef08,Opef08,Opef08,Opef08,Opef08,Opef08 ;@ e508
  .long Opef10,Opef10,Opef10,Opef10,Opef10,Opef10,Opef10,Opef10 ;@ e510
  .long Opef18,Opef18,Opef18,Opef18,Opef18,Opef18,Opef18,Opef18 ;@ e518
  .long Ope120,Ope120,Ope120,Ope120,Ope120,Ope120,Ope120,Ope120 ;@ e520
  .long Ope128,Ope128,Ope128,Ope128,Ope128,Ope128,Ope128,Ope128 ;@ e528
  .long Ope130,Ope130,Ope130,Ope130,Ope130,Ope130,Ope130,Ope130 ;@ e530
  .long Ope138,Ope138,Ope138,Ope138,Ope138,Ope138,Ope138,Ope138 ;@ e538
  .long Opef40,Opef40,Opef40,Opef40,Opef40,Opef40,Opef40,Opef40 ;@ e540
  .long Opef48,Opef48,Opef48,Opef48,Opef48,Opef48,Opef48,Opef48 ;@ e548
  .long Opef50,Opef50,Opef50,Opef50,Opef50,Opef50,Opef50,Opef50 ;@ e550
  .long Opef58,Opef58,Opef58,Opef58,Opef58,Opef58,Opef58,Opef58 ;@ e558
  .long Ope160,Ope160,Ope160,Ope160,Ope160,Ope160,Ope160,Ope160 ;@ e560
  .long Ope168,Ope168,Ope168,Ope168,Ope168,Ope168,Ope168,Ope168 ;@ e568
  .long Ope170,Ope170,Ope170,Ope170,Ope170,Ope170,Ope170,Ope170 ;@ e570
  .long Ope178,Ope178,Ope178,Ope178,Ope178,Ope178,Ope178,Ope178 ;@ e578
  .long Opef80,Opef80,Opef80,Opef80,Opef80,Opef80,Opef80,Opef80 ;@ e580
  .long Opef88,Opef88,Opef88,Opef88,Opef88,Opef88,Opef88,Opef88 ;@ e588
  .long Opef90,Opef90,Opef90,Opef90,Opef90,Opef90,Opef90,Opef90 ;@ e590
  .long Opef98,Opef98,Opef98,Opef98,Opef98,Opef98,Opef98,Opef98 ;@ e598
  .long Ope1a0,Ope1a0,Ope1a0,Ope1a0,Ope1a0,Ope1a0,Ope1a0,Ope1a0 ;@ e5a0
  .long Ope1a8,Ope1a8,Ope1a8,Ope1a8,Ope1a8,Ope1a8,Ope1a8,Ope1a8 ;@ e5a8
  .long Ope1b0,Ope1b0,Ope1b0,Ope1b0,Ope1b0,Ope1b0,Ope1b0,Ope1b0 ;@ e5b0
  .long Ope1b8,Ope1b8,Ope1b8,Ope1b8,Ope1b8,Ope1b8,Ope1b8,Ope1b8 ;@ e5b8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ e5c0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ e5c8
  .long Ope5d0,Ope5d0,Ope5d0,Ope5d0,Ope5d0,Ope5d0,Ope5d0,Ope5d0 ;@ e5d0
  .long Ope5d8,Ope5d8,Ope5d8,Ope5d8,Ope5d8,Ope5d8,Ope5d8,Ope5d8 ;@ e5d8
  .long Ope5e0,Ope5e0,Ope5e0,Ope5e0,Ope5e0,Ope5e0,Ope5e0,Ope5e0 ;@ e5e0
  .long Ope5e8,Ope5e8,Ope5e8,Ope5e8,Ope5e8,Ope5e8,Ope5e8,Ope5e8 ;@ e5e8
  .long Ope5f0,Ope5f0,Ope5f0,Ope5f0,Ope5f0,Ope5f0,Ope5f0,Ope5f0 ;@ e5f0
  .long Ope5f8,Ope5f9,Op____,Op____,Op____,Op____,Op____,Op____ ;@ e5f8
  .long Opee00,Opee00,Opee00,Opee00,Opee00,Opee00,Opee00,Opee00 ;@ e600
  .long Opee08,Opee08,Opee08,Opee08,Opee08,Opee08,Opee08,Opee08 ;@ e608
  .long Opee10,Opee10,Opee10,Opee10,Opee10,Opee10,Opee10,Opee10 ;@ e610
  .long Opee18,Opee18,Opee18,Opee18,Opee18,Opee18,Opee18,Opee18 ;@ e618
  .long Ope020,Ope020,Ope020,Ope020,Ope020,Ope020,Ope020,Ope020 ;@ e620
  .long Ope028,Ope028,Ope028,Ope028,Ope028,Ope028,Ope028,Ope028 ;@ e628
  .long Ope030,Ope030,Ope030,Ope030,Ope030,Ope030,Ope030,Ope030 ;@ e630
  .long Ope038,Ope038,Ope038,Ope038,Ope038,Ope038,Ope038,Ope038 ;@ e638
  .long Opee40,Opee40,Opee40,Opee40,Opee40,Opee40,Opee40,Opee40 ;@ e640
  .long Opee48,Opee48,Opee48,Opee48,Opee48,Opee48,Opee48,Opee48 ;@ e648
  .long Opee50,Opee50,Opee50,Opee50,Opee50,Opee50,Opee50,Opee50 ;@ e650
  .long Opee58,Opee58,Opee58,Opee58,Opee58,Opee58,Opee58,Opee58 ;@ e658
  .long Ope060,Ope060,Ope060,Ope060,Ope060,Ope060,Ope060,Ope060 ;@ e660
  .long Ope068,Ope068,Ope068,Ope068,Ope068,Ope068,Ope068,Ope068 ;@ e668
  .long Ope070,Ope070,Ope070,Ope070,Ope070,Ope070,Ope070,Ope070 ;@ e670
  .long Ope078,Ope078,Ope078,Ope078,Ope078,Ope078,Ope078,Ope078 ;@ e678
  .long Opee80,Opee80,Opee80,Opee80,Opee80,Opee80,Opee80,Opee80 ;@ e680
  .long Opee88,Opee88,Opee88,Opee88,Opee88,Opee88,Opee88,Opee88 ;@ e688
  .long Opee90,Opee90,Opee90,Opee90,Opee90,Opee90,Opee90,Opee90 ;@ e690
  .long Opee98,Opee98,Opee98,Opee98,Opee98,Opee98,Opee98,Opee98 ;@ e698
  .long Ope0a0,Ope0a0,Ope0a0,Ope0a0,Ope0a0,Ope0a0,Ope0a0,Ope0a0 ;@ e6a0
  .long Ope0a8,Ope0a8,Ope0a8,Ope0a8,Ope0a8,Ope0a8,Ope0a8,Ope0a8 ;@ e6a8
  .long Ope0b0,Ope0b0,Ope0b0,Ope0b0,Ope0b0,Ope0b0,Ope0b0,Ope0b0 ;@ e6b0
  .long Ope0b8,Ope0b8,Ope0b8,Ope0b8,Ope0b8,Ope0b8,Ope0b8,Ope0b8 ;@ e6b8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ e6c0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ e6c8
  .long Ope6d0,Ope6d0,Ope6d0,Ope6d0,Ope6d0,Ope6d0,Ope6d0,Ope6d0 ;@ e6d0
  .long Ope6d8,Ope6d8,Ope6d8,Ope6d8,Ope6d8,Ope6d8,Ope6d8,Ope6d8 ;@ e6d8
  .long Ope6e0,Ope6e0,Ope6e0,Ope6e0,Ope6e0,Ope6e0,Ope6e0,Ope6e0 ;@ e6e0
  .long Ope6e8,Ope6e8,Ope6e8,Ope6e8,Ope6e8,Ope6e8,Ope6e8,Ope6e8 ;@ e6e8
  .long Ope6f0,Ope6f0,Ope6f0,Ope6f0,Ope6f0,Ope6f0,Ope6f0,Ope6f0 ;@ e6f0
  .long Ope6f8,Ope6f9,Op____,Op____,Op____,Op____,Op____,Op____ ;@ e6f8
  .long Opef00,Opef00,Opef00,Opef00,Opef00,Opef00,Opef00,Opef00 ;@ e700
  .long Opef08,Opef08,Opef08,Opef08,Opef08,Opef08,Opef08,Opef08 ;@ e708
  .long Opef10,Opef10,Opef10,Opef10,Opef10,Opef10,Opef10,Opef10 ;@ e710
  .long Opef18,Opef18,Opef18,Opef18,Opef18,Opef18,Opef18,Opef18 ;@ e718
  .long Ope120,Ope120,Ope120,Ope120,Ope120,Ope120,Ope120,Ope120 ;@ e720
  .long Ope128,Ope128,Ope128,Ope128,Ope128,Ope128,Ope128,Ope128 ;@ e728
  .long Ope130,Ope130,Ope130,Ope130,Ope130,Ope130,Ope130,Ope130 ;@ e730
  .long Ope138,Ope138,Ope138,Ope138,Ope138,Ope138,Ope138,Ope138 ;@ e738
  .long Opef40,Opef40,Opef40,Opef40,Opef40,Opef40,Opef40,Opef40 ;@ e740
  .long Opef48,Opef48,Opef48,Opef48,Opef48,Opef48,Opef48,Opef48 ;@ e748
  .long Opef50,Opef50,Opef50,Opef50,Opef50,Opef50,Opef50,Opef50 ;@ e750
  .long Opef58,Opef58,Opef58,Opef58,Opef58,Opef58,Opef58,Opef58 ;@ e758
  .long Ope160,Ope160,Ope160,Ope160,Ope160,Ope160,Ope160,Ope160 ;@ e760
  .long Ope168,Ope168,Ope168,Ope168,Ope168,Ope168,Ope168,Ope168 ;@ e768
  .long Ope170,Ope170,Ope170,Ope170,Ope170,Ope170,Ope170,Ope170 ;@ e770
  .long Ope178,Ope178,Ope178,Ope178,Ope178,Ope178,Ope178,Ope178 ;@ e778
  .long Opef80,Opef80,Opef80,Opef80,Opef80,Opef80,Opef80,Opef80 ;@ e780
  .long Opef88,Opef88,Opef88,Opef88,Opef88,Opef88,Opef88,Opef88 ;@ e788
  .long Opef90,Opef90,Opef90,Opef90,Opef90,Opef90,Opef90,Opef90 ;@ e790
  .long Opef98,Opef98,Opef98,Opef98,Opef98,Opef98,Opef98,Opef98 ;@ e798
  .long Ope1a0,Ope1a0,Ope1a0,Ope1a0,Ope1a0,Ope1a0,Ope1a0,Ope1a0 ;@ e7a0
  .long Ope1a8,Ope1a8,Ope1a8,Ope1a8,Ope1a8,Ope1a8,Ope1a8,Ope1a8 ;@ e7a8
  .long Ope1b0,Ope1b0,Ope1b0,Ope1b0,Ope1b0,Ope1b0,Ope1b0,Ope1b0 ;@ e7b0
  .long Ope1b8,Ope1b8,Ope1b8,Ope1b8,Ope1b8,Ope1b8,Ope1b8,Ope1b8 ;@ e7b8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ e7c0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ e7c8
  .long Ope7d0,Ope7d0,Ope7d0,Ope7d0,Ope7d0,Ope7d0,Ope7d0,Ope7d0 ;@ e7d0
  .long Ope7d8,Ope7d8,Ope7d8,Ope7d8,Ope7d8,Ope7d8,Ope7d8,Ope7d8 ;@ e7d8
  .long Ope7e0,Ope7e0,Ope7e0,Ope7e0,Ope7e0,Ope7e0,Ope7e0,Ope7e0 ;@ e7e0
  .long Ope7e8,Ope7e8,Ope7e8,Ope7e8,Ope7e8,Ope7e8,Ope7e8,Ope7e8 ;@ e7e8
  .long Ope7f0,Ope7f0,Ope7f0,Ope7f0,Ope7f0,Ope7f0,Ope7f0,Ope7f0 ;@ e7f0
  .long Ope7f8,Ope7f9,Op____,Op____,Op____,Op____,Op____,Op____ ;@ e7f8
  .long Opee00,Opee00,Opee00,Opee00,Opee00,Opee00,Opee00,Opee00 ;@ e800
  .long Opee08,Opee08,Opee08,Opee08,Opee08,Opee08,Opee08,Opee08 ;@ e808
  .long Opee10,Opee10,Opee10,Opee10,Opee10,Opee10,Opee10,Opee10 ;@ e810
  .long Opee18,Opee18,Opee18,Opee18,Opee18,Opee18,Opee18,Opee18 ;@ e818
  .long Ope020,Ope020,Ope020,Ope020,Ope020,Ope020,Ope020,Ope020 ;@ e820
  .long Ope028,Ope028,Ope028,Ope028,Ope028,Ope028,Ope028,Ope028 ;@ e828
  .long Ope030,Ope030,Ope030,Ope030,Ope030,Ope030,Ope030,Ope030 ;@ e830
  .long Ope038,Ope038,Ope038,Ope038,Ope038,Ope038,Ope038,Ope038 ;@ e838
  .long Opee40,Opee40,Opee40,Opee40,Opee40,Opee40,Opee40,Opee40 ;@ e840
  .long Opee48,Opee48,Opee48,Opee48,Opee48,Opee48,Opee48,Opee48 ;@ e848
  .long Opee50,Opee50,Opee50,Opee50,Opee50,Opee50,Opee50,Opee50 ;@ e850
  .long Opee58,Opee58,Opee58,Opee58,Opee58,Opee58,Opee58,Opee58 ;@ e858
  .long Ope060,Ope060,Ope060,Ope060,Ope060,Ope060,Ope060,Ope060 ;@ e860
  .long Ope068,Ope068,Ope068,Ope068,Ope068,Ope068,Ope068,Ope068 ;@ e868
  .long Ope070,Ope070,Ope070,Ope070,Ope070,Ope070,Ope070,Ope070 ;@ e870
  .long Ope078,Ope078,Ope078,Ope078,Ope078,Ope078,Ope078,Ope078 ;@ e878
  .long Opee80,Opee80,Opee80,Opee80,Opee80,Opee80,Opee80,Opee80 ;@ e880
  .long Opee88,Opee88,Opee88,Opee88,Opee88,Opee88,Opee88,Opee88 ;@ e888
  .long Opee90,Opee90,Opee90,Opee90,Opee90,Opee90,Opee90,Opee90 ;@ e890
  .long Opee98,Opee98,Opee98,Opee98,Opee98,Opee98,Opee98,Opee98 ;@ e898
  .long Ope0a0,Ope0a0,Ope0a0,Ope0a0,Ope0a0,Ope0a0,Ope0a0,Ope0a0 ;@ e8a0
  .long Ope0a8,Ope0a8,Ope0a8,Ope0a8,Ope0a8,Ope0a8,Ope0a8,Ope0a8 ;@ e8a8
  .long Ope0b0,Ope0b0,Ope0b0,Ope0b0,Ope0b0,Ope0b0,Ope0b0,Ope0b0 ;@ e8b0
  .long Ope0b8,Ope0b8,Ope0b8,Ope0b8,Ope0b8,Ope0b8,Ope0b8,Ope0b8 ;@ e8b8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ e8c0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ e8c8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ e8d0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ e8d8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ e8e0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ e8e8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ e8f0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ e8f8
  .long Opef00,Opef00,Opef00,Opef00,Opef00,Opef00,Opef00,Opef00 ;@ e900
  .long Opef08,Opef08,Opef08,Opef08,Opef08,Opef08,Opef08,Opef08 ;@ e908
  .long Opef10,Opef10,Opef10,Opef10,Opef10,Opef10,Opef10,Opef10 ;@ e910
  .long Opef18,Opef18,Opef18,Opef18,Opef18,Opef18,Opef18,Opef18 ;@ e918
  .long Ope120,Ope120,Ope120,Ope120,Ope120,Ope120,Ope120,Ope120 ;@ e920
  .long Ope128,Ope128,Ope128,Ope128,Ope128,Ope128,Ope128,Ope128 ;@ e928
  .long Ope130,Ope130,Ope130,Ope130,Ope130,Ope130,Ope130,Ope130 ;@ e930
  .long Ope138,Ope138,Ope138,Ope138,Ope138,Ope138,Ope138,Ope138 ;@ e938
  .long Opef40,Opef40,Opef40,Opef40,Opef40,Opef40,Opef40,Opef40 ;@ e940
  .long Opef48,Opef48,Opef48,Opef48,Opef48,Opef48,Opef48,Opef48 ;@ e948
  .long Opef50,Opef50,Opef50,Opef50,Opef50,Opef50,Opef50,Opef50 ;@ e950
  .long Opef58,Opef58,Opef58,Opef58,Opef58,Opef58,Opef58,Opef58 ;@ e958
  .long Ope160,Ope160,Ope160,Ope160,Ope160,Ope160,Ope160,Ope160 ;@ e960
  .long Ope168,Ope168,Ope168,Ope168,Ope168,Ope168,Ope168,Ope168 ;@ e968
  .long Ope170,Ope170,Ope170,Ope170,Ope170,Ope170,Ope170,Ope170 ;@ e970
  .long Ope178,Ope178,Ope178,Ope178,Ope178,Ope178,Ope178,Ope178 ;@ e978
  .long Opef80,Opef80,Opef80,Opef80,Opef80,Opef80,Opef80,Opef80 ;@ e980
  .long Opef88,Opef88,Opef88,Opef88,Opef88,Opef88,Opef88,Opef88 ;@ e988
  .long Opef90,Opef90,Opef90,Opef90,Opef90,Opef90,Opef90,Opef90 ;@ e990
  .long Opef98,Opef98,Opef98,Opef98,Opef98,Opef98,Opef98,Opef98 ;@ e998
  .long Ope1a0,Ope1a0,Ope1a0,Ope1a0,Ope1a0,Ope1a0,Ope1a0,Ope1a0 ;@ e9a0
  .long Ope1a8,Ope1a8,Ope1a8,Ope1a8,Ope1a8,Ope1a8,Ope1a8,Ope1a8 ;@ e9a8
  .long Ope1b0,Ope1b0,Ope1b0,Ope1b0,Ope1b0,Ope1b0,Ope1b0,Ope1b0 ;@ e9b0
  .long Ope1b8,Ope1b8,Ope1b8,Ope1b8,Ope1b8,Ope1b8,Ope1b8,Ope1b8 ;@ e9b8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ e9c0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ e9c8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ e9d0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ e9d8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ e9e0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ e9e8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ e9f0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ e9f8
  .long Opee00,Opee00,Opee00,Opee00,Opee00,Opee00,Opee00,Opee00 ;@ ea00
  .long Opee08,Opee08,Opee08,Opee08,Opee08,Opee08,Opee08,Opee08 ;@ ea08
  .long Opee10,Opee10,Opee10,Opee10,Opee10,Opee10,Opee10,Opee10 ;@ ea10
  .long Opee18,Opee18,Opee18,Opee18,Opee18,Opee18,Opee18,Opee18 ;@ ea18
  .long Ope020,Ope020,Ope020,Ope020,Ope020,Ope020,Ope020,Ope020 ;@ ea20
  .long Ope028,Ope028,Ope028,Ope028,Ope028,Ope028,Ope028,Ope028 ;@ ea28
  .long Ope030,Ope030,Ope030,Ope030,Ope030,Ope030,Ope030,Ope030 ;@ ea30
  .long Ope038,Ope038,Ope038,Ope038,Ope038,Ope038,Ope038,Ope038 ;@ ea38
  .long Opee40,Opee40,Opee40,Opee40,Opee40,Opee40,Opee40,Opee40 ;@ ea40
  .long Opee48,Opee48,Opee48,Opee48,Opee48,Opee48,Opee48,Opee48 ;@ ea48
  .long Opee50,Opee50,Opee50,Opee50,Opee50,Opee50,Opee50,Opee50 ;@ ea50
  .long Opee58,Opee58,Opee58,Opee58,Opee58,Opee58,Opee58,Opee58 ;@ ea58
  .long Ope060,Ope060,Ope060,Ope060,Ope060,Ope060,Ope060,Ope060 ;@ ea60
  .long Ope068,Ope068,Ope068,Ope068,Ope068,Ope068,Ope068,Ope068 ;@ ea68
  .long Ope070,Ope070,Ope070,Ope070,Ope070,Ope070,Ope070,Ope070 ;@ ea70
  .long Ope078,Ope078,Ope078,Ope078,Ope078,Ope078,Ope078,Ope078 ;@ ea78
  .long Opee80,Opee80,Opee80,Opee80,Opee80,Opee80,Opee80,Opee80 ;@ ea80
  .long Opee88,Opee88,Opee88,Opee88,Opee88,Opee88,Opee88,Opee88 ;@ ea88
  .long Opee90,Opee90,Opee90,Opee90,Opee90,Opee90,Opee90,Opee90 ;@ ea90
  .long Opee98,Opee98,Opee98,Opee98,Opee98,Opee98,Opee98,Opee98 ;@ ea98
  .long Ope0a0,Ope0a0,Ope0a0,Ope0a0,Ope0a0,Ope0a0,Ope0a0,Ope0a0 ;@ eaa0
  .long Ope0a8,Ope0a8,Ope0a8,Ope0a8,Ope0a8,Ope0a8,Ope0a8,Ope0a8 ;@ eaa8
  .long Ope0b0,Ope0b0,Ope0b0,Ope0b0,Ope0b0,Ope0b0,Ope0b0,Ope0b0 ;@ eab0
  .long Ope0b8,Ope0b8,Ope0b8,Ope0b8,Ope0b8,Ope0b8,Ope0b8,Ope0b8 ;@ eab8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ eac0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ eac8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ ead0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ ead8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ eae0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ eae8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ eaf0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ eaf8
  .long Opef00,Opef00,Opef00,Opef00,Opef00,Opef00,Opef00,Opef00 ;@ eb00
  .long Opef08,Opef08,Opef08,Opef08,Opef08,Opef08,Opef08,Opef08 ;@ eb08
  .long Opef10,Opef10,Opef10,Opef10,Opef10,Opef10,Opef10,Opef10 ;@ eb10
  .long Opef18,Opef18,Opef18,Opef18,Opef18,Opef18,Opef18,Opef18 ;@ eb18
  .long Ope120,Ope120,Ope120,Ope120,Ope120,Ope120,Ope120,Ope120 ;@ eb20
  .long Ope128,Ope128,Ope128,Ope128,Ope128,Ope128,Ope128,Ope128 ;@ eb28
  .long Ope130,Ope130,Ope130,Ope130,Ope130,Ope130,Ope130,Ope130 ;@ eb30
  .long Ope138,Ope138,Ope138,Ope138,Ope138,Ope138,Ope138,Ope138 ;@ eb38
  .long Opef40,Opef40,Opef40,Opef40,Opef40,Opef40,Opef40,Opef40 ;@ eb40
  .long Opef48,Opef48,Opef48,Opef48,Opef48,Opef48,Opef48,Opef48 ;@ eb48
  .long Opef50,Opef50,Opef50,Opef50,Opef50,Opef50,Opef50,Opef50 ;@ eb50
  .long Opef58,Opef58,Opef58,Opef58,Opef58,Opef58,Opef58,Opef58 ;@ eb58
  .long Ope160,Ope160,Ope160,Ope160,Ope160,Ope160,Ope160,Ope160 ;@ eb60
  .long Ope168,Ope168,Ope168,Ope168,Ope168,Ope168,Ope168,Ope168 ;@ eb68
  .long Ope170,Ope170,Ope170,Ope170,Ope170,Ope170,Ope170,Ope170 ;@ eb70
  .long Ope178,Ope178,Ope178,Ope178,Ope178,Ope178,Ope178,Ope178 ;@ eb78
  .long Opef80,Opef80,Opef80,Opef80,Opef80,Opef80,Opef80,Opef80 ;@ eb80
  .long Opef88,Opef88,Opef88,Opef88,Opef88,Opef88,Opef88,Opef88 ;@ eb88
  .long Opef90,Opef90,Opef90,Opef90,Opef90,Opef90,Opef90,Opef90 ;@ eb90
  .long Opef98,Opef98,Opef98,Opef98,Opef98,Opef98,Opef98,Opef98 ;@ eb98
  .long Ope1a0,Ope1a0,Ope1a0,Ope1a0,Ope1a0,Ope1a0,Ope1a0,Ope1a0 ;@ eba0
  .long Ope1a8,Ope1a8,Ope1a8,Ope1a8,Ope1a8,Ope1a8,Ope1a8,Ope1a8 ;@ eba8
  .long Ope1b0,Ope1b0,Ope1b0,Ope1b0,Ope1b0,Ope1b0,Ope1b0,Ope1b0 ;@ ebb0
  .long Ope1b8,Ope1b8,Ope1b8,Ope1b8,Ope1b8,Ope1b8,Ope1b8,Ope1b8 ;@ ebb8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ ebc0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ ebc8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ ebd0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ ebd8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ ebe0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ ebe8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ ebf0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ ebf8
  .long Opee00,Opee00,Opee00,Opee00,Opee00,Opee00,Opee00,Opee00 ;@ ec00
  .long Opee08,Opee08,Opee08,Opee08,Opee08,Opee08,Opee08,Opee08 ;@ ec08
  .long Opee10,Opee10,Opee10,Opee10,Opee10,Opee10,Opee10,Opee10 ;@ ec10
  .long Opee18,Opee18,Opee18,Opee18,Opee18,Opee18,Opee18,Opee18 ;@ ec18
  .long Ope020,Ope020,Ope020,Ope020,Ope020,Ope020,Ope020,Ope020 ;@ ec20
  .long Ope028,Ope028,Ope028,Ope028,Ope028,Ope028,Ope028,Ope028 ;@ ec28
  .long Ope030,Ope030,Ope030,Ope030,Ope030,Ope030,Ope030,Ope030 ;@ ec30
  .long Ope038,Ope038,Ope038,Ope038,Ope038,Ope038,Ope038,Ope038 ;@ ec38
  .long Opee40,Opee40,Opee40,Opee40,Opee40,Opee40,Opee40,Opee40 ;@ ec40
  .long Opee48,Opee48,Opee48,Opee48,Opee48,Opee48,Opee48,Opee48 ;@ ec48
  .long Opee50,Opee50,Opee50,Opee50,Opee50,Opee50,Opee50,Opee50 ;@ ec50
  .long Opee58,Opee58,Opee58,Opee58,Opee58,Opee58,Opee58,Opee58 ;@ ec58
  .long Ope060,Ope060,Ope060,Ope060,Ope060,Ope060,Ope060,Ope060 ;@ ec60
  .long Ope068,Ope068,Ope068,Ope068,Ope068,Ope068,Ope068,Ope068 ;@ ec68
  .long Ope070,Ope070,Ope070,Ope070,Ope070,Ope070,Ope070,Ope070 ;@ ec70
  .long Ope078,Ope078,Ope078,Ope078,Ope078,Ope078,Ope078,Ope078 ;@ ec78
  .long Opee80,Opee80,Opee80,Opee80,Opee80,Opee80,Opee80,Opee80 ;@ ec80
  .long Opee88,Opee88,Opee88,Opee88,Opee88,Opee88,Opee88,Opee88 ;@ ec88
  .long Opee90,Opee90,Opee90,Opee90,Opee90,Opee90,Opee90,Opee90 ;@ ec90
  .long Opee98,Opee98,Opee98,Opee98,Opee98,Opee98,Opee98,Opee98 ;@ ec98
  .long Ope0a0,Ope0a0,Ope0a0,Ope0a0,Ope0a0,Ope0a0,Ope0a0,Ope0a0 ;@ eca0
  .long Ope0a8,Ope0a8,Ope0a8,Ope0a8,Ope0a8,Ope0a8,Ope0a8,Ope0a8 ;@ eca8
  .long Ope0b0,Ope0b0,Ope0b0,Ope0b0,Ope0b0,Ope0b0,Ope0b0,Ope0b0 ;@ ecb0
  .long Ope0b8,Ope0b8,Ope0b8,Ope0b8,Ope0b8,Ope0b8,Ope0b8,Ope0b8 ;@ ecb8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ ecc0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ ecc8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ ecd0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ ecd8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ ece0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ ece8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ ecf0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ ecf8
  .long Opef00,Opef00,Opef00,Opef00,Opef00,Opef00,Opef00,Opef00 ;@ ed00
  .long Opef08,Opef08,Opef08,Opef08,Opef08,Opef08,Opef08,Opef08 ;@ ed08
  .long Opef10,Opef10,Opef10,Opef10,Opef10,Opef10,Opef10,Opef10 ;@ ed10
  .long Opef18,Opef18,Opef18,Opef18,Opef18,Opef18,Opef18,Opef18 ;@ ed18
  .long Ope120,Ope120,Ope120,Ope120,Ope120,Ope120,Ope120,Ope120 ;@ ed20
  .long Ope128,Ope128,Ope128,Ope128,Ope128,Ope128,Ope128,Ope128 ;@ ed28
  .long Ope130,Ope130,Ope130,Ope130,Ope130,Ope130,Ope130,Ope130 ;@ ed30
  .long Ope138,Ope138,Ope138,Ope138,Ope138,Ope138,Ope138,Ope138 ;@ ed38
  .long Opef40,Opef40,Opef40,Opef40,Opef40,Opef40,Opef40,Opef40 ;@ ed40
  .long Opef48,Opef48,Opef48,Opef48,Opef48,Opef48,Opef48,Opef48 ;@ ed48
  .long Opef50,Opef50,Opef50,Opef50,Opef50,Opef50,Opef50,Opef50 ;@ ed50
  .long Opef58,Opef58,Opef58,Opef58,Opef58,Opef58,Opef58,Opef58 ;@ ed58
  .long Ope160,Ope160,Ope160,Ope160,Ope160,Ope160,Ope160,Ope160 ;@ ed60
  .long Ope168,Ope168,Ope168,Ope168,Ope168,Ope168,Ope168,Ope168 ;@ ed68
  .long Ope170,Ope170,Ope170,Ope170,Ope170,Ope170,Ope170,Ope170 ;@ ed70
  .long Ope178,Ope178,Ope178,Ope178,Ope178,Ope178,Ope178,Ope178 ;@ ed78
  .long Opef80,Opef80,Opef80,Opef80,Opef80,Opef80,Opef80,Opef80 ;@ ed80
  .long Opef88,Opef88,Opef88,Opef88,Opef88,Opef88,Opef88,Opef88 ;@ ed88
  .long Opef90,Opef90,Opef90,Opef90,Opef90,Opef90,Opef90,Opef90 ;@ ed90
  .long Opef98,Opef98,Opef98,Opef98,Opef98,Opef98,Opef98,Opef98 ;@ ed98
  .long Ope1a0,Ope1a0,Ope1a0,Ope1a0,Ope1a0,Ope1a0,Ope1a0,Ope1a0 ;@ eda0
  .long Ope1a8,Ope1a8,Ope1a8,Ope1a8,Ope1a8,Ope1a8,Ope1a8,Ope1a8 ;@ eda8
  .long Ope1b0,Ope1b0,Ope1b0,Ope1b0,Ope1b0,Ope1b0,Ope1b0,Ope1b0 ;@ edb0
  .long Ope1b8,Ope1b8,Ope1b8,Ope1b8,Ope1b8,Ope1b8,Ope1b8,Ope1b8 ;@ edb8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ edc0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ edc8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ edd0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ edd8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ ede0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ ede8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ edf0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ edf8
  .long Opee00,Opee00,Opee00,Opee00,Opee00,Opee00,Opee00,Opee00 ;@ ee00
  .long Opee08,Opee08,Opee08,Opee08,Opee08,Opee08,Opee08,Opee08 ;@ ee08
  .long Opee10,Opee10,Opee10,Opee10,Opee10,Opee10,Opee10,Opee10 ;@ ee10
  .long Opee18,Opee18,Opee18,Opee18,Opee18,Opee18,Opee18,Opee18 ;@ ee18
  .long Ope020,Ope020,Ope020,Ope020,Ope020,Ope020,Ope020,Ope020 ;@ ee20
  .long Ope028,Ope028,Ope028,Ope028,Ope028,Ope028,Ope028,Ope028 ;@ ee28
  .long Ope030,Ope030,Ope030,Ope030,Ope030,Ope030,Ope030,Ope030 ;@ ee30
  .long Ope038,Ope038,Ope038,Ope038,Ope038,Ope038,Ope038,Ope038 ;@ ee38
  .long Opee40,Opee40,Opee40,Opee40,Opee40,Opee40,Opee40,Opee40 ;@ ee40
  .long Opee48,Opee48,Opee48,Opee48,Opee48,Opee48,Opee48,Opee48 ;@ ee48
  .long Opee50,Opee50,Opee50,Opee50,Opee50,Opee50,Opee50,Opee50 ;@ ee50
  .long Opee58,Opee58,Opee58,Opee58,Opee58,Opee58,Opee58,Opee58 ;@ ee58
  .long Ope060,Ope060,Ope060,Ope060,Ope060,Ope060,Ope060,Ope060 ;@ ee60
  .long Ope068,Ope068,Ope068,Ope068,Ope068,Ope068,Ope068,Ope068 ;@ ee68
  .long Ope070,Ope070,Ope070,Ope070,Ope070,Ope070,Ope070,Ope070 ;@ ee70
  .long Ope078,Ope078,Ope078,Ope078,Ope078,Ope078,Ope078,Ope078 ;@ ee78
  .long Opee80,Opee80,Opee80,Opee80,Opee80,Opee80,Opee80,Opee80 ;@ ee80
  .long Opee88,Opee88,Opee88,Opee88,Opee88,Opee88,Opee88,Opee88 ;@ ee88
  .long Opee90,Opee90,Opee90,Opee90,Opee90,Opee90,Opee90,Opee90 ;@ ee90
  .long Opee98,Opee98,Opee98,Opee98,Opee98,Opee98,Opee98,Opee98 ;@ ee98
  .long Ope0a0,Ope0a0,Ope0a0,Ope0a0,Ope0a0,Ope0a0,Ope0a0,Ope0a0 ;@ eea0
  .long Ope0a8,Ope0a8,Ope0a8,Ope0a8,Ope0a8,Ope0a8,Ope0a8,Ope0a8 ;@ eea8
  .long Ope0b0,Ope0b0,Ope0b0,Ope0b0,Ope0b0,Ope0b0,Ope0b0,Ope0b0 ;@ eeb0
  .long Ope0b8,Ope0b8,Ope0b8,Ope0b8,Ope0b8,Ope0b8,Ope0b8,Ope0b8 ;@ eeb8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ eec0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ eec8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ eed0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ eed8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ eee0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ eee8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ eef0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ eef8
  .long Opef00,Opef00,Opef00,Opef00,Opef00,Opef00,Opef00,Opef00 ;@ ef00
  .long Opef08,Opef08,Opef08,Opef08,Opef08,Opef08,Opef08,Opef08 ;@ ef08
  .long Opef10,Opef10,Opef10,Opef10,Opef10,Opef10,Opef10,Opef10 ;@ ef10
  .long Opef18,Opef18,Opef18,Opef18,Opef18,Opef18,Opef18,Opef18 ;@ ef18
  .long Ope120,Ope120,Ope120,Ope120,Ope120,Ope120,Ope120,Ope120 ;@ ef20
  .long Ope128,Ope128,Ope128,Ope128,Ope128,Ope128,Ope128,Ope128 ;@ ef28
  .long Ope130,Ope130,Ope130,Ope130,Ope130,Ope130,Ope130,Ope130 ;@ ef30
  .long Ope138,Ope138,Ope138,Ope138,Ope138,Ope138,Ope138,Ope138 ;@ ef38
  .long Opef40,Opef40,Opef40,Opef40,Opef40,Opef40,Opef40,Opef40 ;@ ef40
  .long Opef48,Opef48,Opef48,Opef48,Opef48,Opef48,Opef48,Opef48 ;@ ef48
  .long Opef50,Opef50,Opef50,Opef50,Opef50,Opef50,Opef50,Opef50 ;@ ef50
  .long Opef58,Opef58,Opef58,Opef58,Opef58,Opef58,Opef58,Opef58 ;@ ef58
  .long Ope160,Ope160,Ope160,Ope160,Ope160,Ope160,Ope160,Ope160 ;@ ef60
  .long Ope168,Ope168,Ope168,Ope168,Ope168,Ope168,Ope168,Ope168 ;@ ef68
  .long Ope170,Ope170,Ope170,Ope170,Ope170,Ope170,Ope170,Ope170 ;@ ef70
  .long Ope178,Ope178,Ope178,Ope178,Ope178,Ope178,Ope178,Ope178 ;@ ef78
  .long Opef80,Opef80,Opef80,Opef80,Opef80,Opef80,Opef80,Opef80 ;@ ef80
  .long Opef88,Opef88,Opef88,Opef88,Opef88,Opef88,Opef88,Opef88 ;@ ef88
  .long Opef90,Opef90,Opef90,Opef90,Opef90,Opef90,Opef90,Opef90 ;@ ef90
  .long Opef98,Opef98,Opef98,Opef98,Opef98,Opef98,Opef98,Opef98 ;@ ef98
  .long Ope1a0,Ope1a0,Ope1a0,Ope1a0,Ope1a0,Ope1a0,Ope1a0,Ope1a0 ;@ efa0
  .long Ope1a8,Ope1a8,Ope1a8,Ope1a8,Ope1a8,Ope1a8,Ope1a8,Ope1a8 ;@ efa8
  .long Ope1b0,Ope1b0,Ope1b0,Ope1b0,Ope1b0,Ope1b0,Ope1b0,Ope1b0 ;@ efb0
  .long Ope1b8,Ope1b8,Ope1b8,Ope1b8,Ope1b8,Ope1b8,Ope1b8,Ope1b8 ;@ efb8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ efc0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ efc8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ efd0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ efd8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ efe0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ efe8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ eff0
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ eff8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f000
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f008
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f010
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f018
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f020
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f028
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f030
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f038
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f040
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f048
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f050
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f058
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f060
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f068
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f070
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f078
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f080
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f088
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f090
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f098
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f0a0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f0a8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f0b0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f0b8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f0c0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f0c8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f0d0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f0d8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f0e0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f0e8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f0f0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f0f8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f100
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f108
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f110
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f118
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f120
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f128
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f130
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f138
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f140
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f148
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f150
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f158
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f160
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f168
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f170
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f178
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f180
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f188
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f190
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f198
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f1a0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f1a8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f1b0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f1b8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f1c0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f1c8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f1d0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f1d8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f1e0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f1e8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f1f0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f1f8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f200
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f208
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f210
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f218
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f220
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f228
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f230
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f238
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f240
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f248
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f250
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f258
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f260
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f268
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f270
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f278
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f280
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f288
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f290
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f298
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f2a0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f2a8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f2b0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f2b8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f2c0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f2c8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f2d0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f2d8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f2e0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f2e8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f2f0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f2f8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f300
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f308
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f310
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f318
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f320
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f328
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f330
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f338
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f340
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f348
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f350
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f358
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f360
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f368
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f370
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f378
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f380
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f388
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f390
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f398
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f3a0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f3a8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f3b0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f3b8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f3c0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f3c8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f3d0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f3d8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f3e0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f3e8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f3f0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f3f8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f400
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f408
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f410
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f418
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f420
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f428
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f430
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f438
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f440
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f448
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f450
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f458
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f460
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f468
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f470
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f478
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f480
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f488
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f490
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f498
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f4a0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f4a8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f4b0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f4b8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f4c0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f4c8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f4d0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f4d8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f4e0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f4e8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f4f0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f4f8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f500
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f508
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f510
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f518
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f520
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f528
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f530
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f538
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f540
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f548
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f550
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f558
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f560
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f568
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f570
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f578
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f580
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f588
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f590
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f598
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f5a0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f5a8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f5b0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f5b8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f5c0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f5c8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f5d0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f5d8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f5e0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f5e8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f5f0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f5f8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f600
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f608
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f610
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f618
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f620
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f628
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f630
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f638
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f640
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f648
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f650
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f658
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f660
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f668
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f670
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f678
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f680
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f688
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f690
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f698
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f6a0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f6a8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f6b0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f6b8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f6c0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f6c8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f6d0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f6d8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f6e0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f6e8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f6f0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f6f8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f700
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f708
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f710
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f718
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f720
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f728
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f730
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f738
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f740
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f748
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f750
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f758
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f760
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f768
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f770
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f778
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f780
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f788
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f790
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f798
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f7a0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f7a8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f7b0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f7b8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f7c0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f7c8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f7d0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f7d8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f7e0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f7e8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f7f0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f7f8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f800
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f808
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f810
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f818
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f820
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f828
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f830
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f838
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f840
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f848
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f850
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f858
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f860
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f868
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f870
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f878
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f880
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f888
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f890
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f898
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f8a0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f8a8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f8b0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f8b8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f8c0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f8c8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f8d0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f8d8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f8e0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f8e8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f8f0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f8f8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f900
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f908
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f910
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f918
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f920
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f928
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f930
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f938
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f940
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f948
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f950
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f958
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f960
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f968
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f970
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f978
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f980
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f988
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f990
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f998
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f9a0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f9a8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f9b0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f9b8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f9c0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f9c8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f9d0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f9d8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f9e0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f9e8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f9f0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f9f8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fa00
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fa08
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fa10
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fa18
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fa20
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fa28
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fa30
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fa38
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fa40
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fa48
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fa50
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fa58
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fa60
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fa68
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fa70
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fa78
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fa80
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fa88
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fa90
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fa98
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ faa0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ faa8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fab0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fab8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fac0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fac8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fad0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fad8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fae0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fae8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ faf0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ faf8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fb00
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fb08
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fb10
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fb18
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fb20
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fb28
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fb30
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fb38
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fb40
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fb48
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fb50
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fb58
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fb60
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fb68
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fb70
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fb78
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fb80
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fb88
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fb90
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fb98
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fba0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fba8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fbb0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fbb8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fbc0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fbc8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fbd0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fbd8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fbe0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fbe8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fbf0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fbf8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fc00
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fc08
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fc10
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fc18
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fc20
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fc28
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fc30
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fc38
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fc40
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fc48
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fc50
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fc58
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fc60
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fc68
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fc70
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fc78
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fc80
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fc88
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fc90
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fc98
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fca0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fca8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fcb0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fcb8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fcc0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fcc8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fcd0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fcd8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fce0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fce8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fcf0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fcf8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fd00
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fd08
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fd10
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fd18
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fd20
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fd28
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fd30
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fd38
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fd40
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fd48
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fd50
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fd58
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fd60
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fd68
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fd70
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fd78
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fd80
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fd88
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fd90
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fd98
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fda0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fda8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fdb0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fdb8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fdc0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fdc8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fdd0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fdd8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fde0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fde8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fdf0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fdf8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fe00
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fe08
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fe10
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fe18
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fe20
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fe28
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fe30
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fe38
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fe40
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fe48
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fe50
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fe58
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fe60
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fe68
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fe70
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fe78
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fe80
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fe88
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fe90
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fe98
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fea0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fea8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ feb0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ feb8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fec0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fec8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fed0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fed8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fee0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fee8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fef0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fef8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ ff00
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ ff08
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ ff10
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ ff18
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ ff20
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ ff28
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ ff30
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ ff38
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ ff40
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ ff48
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ ff50
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ ff58
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ ff60
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ ff68
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ ff70
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ ff78
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ ff80
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ ff88
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ ff90
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ ff98
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ ffa0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ ffa8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ ffb0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ ffb8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ ffc0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ ffc8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ ffd0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ ffd8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ ffe0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ ffe8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fff0
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl
;@ notaz: we don't want to crash if we run into those 2 missing opcodes
;@ so we leave this pattern to patch it later
  .long 0x78563412
  .long 0x56341290


;@ vim:filetype=armasm
